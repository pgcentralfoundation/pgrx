use crate as pg_sys;
#[cfg(any(
    feature = "pg12",
    feature = "pg13",
    feature = "pg14",
    feature = "pg15",
    feature = "pg16"
))]
use crate::NullableDatum;
use crate::{Datum, Oid, PgNode};
#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") { 7 - (index % 8) } else { index % 8 };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") { 7 - (index % 8) } else { index % 8 };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index =
                    if cfg!(target_endian = "big") { bit_width as usize - 1 - i } else { i };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") { bit_width as usize - 1 - i } else { i };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const PG_DIAG_SEVERITY: u8 = 83u8;
pub const PG_DIAG_SEVERITY_NONLOCALIZED: u8 = 86u8;
pub const PG_DIAG_SQLSTATE: u8 = 67u8;
pub const PG_DIAG_MESSAGE_PRIMARY: u8 = 77u8;
pub const PG_DIAG_MESSAGE_DETAIL: u8 = 68u8;
pub const PG_DIAG_MESSAGE_HINT: u8 = 72u8;
pub const PG_DIAG_STATEMENT_POSITION: u8 = 80u8;
pub const PG_DIAG_INTERNAL_POSITION: u8 = 112u8;
pub const PG_DIAG_INTERNAL_QUERY: u8 = 113u8;
pub const PG_DIAG_CONTEXT: u8 = 87u8;
pub const PG_DIAG_SCHEMA_NAME: u8 = 115u8;
pub const PG_DIAG_TABLE_NAME: u8 = 116u8;
pub const PG_DIAG_COLUMN_NAME: u8 = 99u8;
pub const PG_DIAG_DATATYPE_NAME: u8 = 100u8;
pub const PG_DIAG_CONSTRAINT_NAME: u8 = 110u8;
pub const PG_DIAG_SOURCE_FILE: u8 = 70u8;
pub const PG_DIAG_SOURCE_LINE: u8 = 76u8;
pub const PG_DIAG_SOURCE_FUNCTION: u8 = 82u8;
pub const ALIGNOF_DOUBLE: u32 = 8;
pub const ALIGNOF_INT: u32 = 4;
pub const ALIGNOF_LONG: u32 = 8;
pub const ALIGNOF_PG_INT128_TYPE: u32 = 16;
pub const ALIGNOF_SHORT: u32 = 2;
pub const BLCKSZ: u32 = 8192;
pub const CONFIGURE_ARGS : & [u8 ; 205] = b" '--prefix=/home/zombodb/.pgrx/16.0/pgrx-install' '--with-pgport=28816' '--enable-debug' '--enable-cassert' 'CPPFLAGS= -DMEMORY_CONTEXT_CHECKING=1 -DCLOBBER_FREED_MEMORY=1 -DRANDOMIZE_ALLOCATED_MEMORY=1 '\0" ;
pub const DEF_PGPORT: u32 = 28816;
pub const DEF_PGPORT_STR: &[u8; 6] = b"28816\0";
pub const DLSUFFIX: &[u8; 4] = b".so\0";
pub const ENABLE_THREAD_SAFETY: u32 = 1;
pub const HAVE_APPEND_HISTORY: u32 = 1;
pub const HAVE_ATOMICS: u32 = 1;
pub const HAVE_BACKTRACE_SYMBOLS: u32 = 1;
pub const HAVE_COMPUTED_GOTO: u32 = 1;
pub const HAVE_DECL_FDATASYNC: u32 = 1;
pub const HAVE_DECL_F_FULLFSYNC: u32 = 0;
pub const HAVE_DECL_POSIX_FADVISE: u32 = 1;
pub const HAVE_DECL_PREADV: u32 = 1;
pub const HAVE_DECL_PWRITEV: u32 = 1;
pub const HAVE_DECL_STRLCAT: u32 = 0;
pub const HAVE_DECL_STRLCPY: u32 = 0;
pub const HAVE_DECL_STRNLEN: u32 = 1;
pub const HAVE_EXECINFO_H: u32 = 1;
pub const HAVE_EXPLICIT_BZERO: u32 = 1;
pub const HAVE_FSEEKO: u32 = 1;
pub const HAVE_GCC__ATOMIC_INT32_CAS: u32 = 1;
pub const HAVE_GCC__ATOMIC_INT64_CAS: u32 = 1;
pub const HAVE_GCC__SYNC_CHAR_TAS: u32 = 1;
pub const HAVE_GCC__SYNC_INT32_CAS: u32 = 1;
pub const HAVE_GCC__SYNC_INT32_TAS: u32 = 1;
pub const HAVE_GCC__SYNC_INT64_CAS: u32 = 1;
pub const HAVE_GETIFADDRS: u32 = 1;
pub const HAVE_GETOPT: u32 = 1;
pub const HAVE_GETOPT_H: u32 = 1;
pub const HAVE_GETOPT_LONG: u32 = 1;
pub const HAVE_HISTORY_TRUNCATE_FILE: u32 = 1;
pub const HAVE_IFADDRS_H: u32 = 1;
pub const HAVE_INET_ATON: u32 = 1;
pub const HAVE_INET_PTON: u32 = 1;
pub const HAVE_INTTYPES_H: u32 = 1;
pub const HAVE_INT_OPTERR: u32 = 1;
pub const HAVE_INT_TIMEZONE: u32 = 1;
pub const HAVE_LANGINFO_H: u32 = 1;
pub const HAVE_LIBM: u32 = 1;
pub const HAVE_LIBREADLINE: u32 = 1;
pub const HAVE_LIBZ: u32 = 1;
pub const HAVE_LOCALE_T: u32 = 1;
pub const HAVE_LONG_INT_64: u32 = 1;
pub const HAVE_MEMORY_H: u32 = 1;
pub const HAVE_MKDTEMP: u32 = 1;
pub const HAVE_POSIX_FADVISE: u32 = 1;
pub const HAVE_POSIX_FALLOCATE: u32 = 1;
pub const HAVE_PPOLL: u32 = 1;
pub const HAVE_PTHREAD: u32 = 1;
pub const HAVE_PTHREAD_BARRIER_WAIT: u32 = 1;
pub const HAVE_PTHREAD_PRIO_INHERIT: u32 = 1;
pub const HAVE_READLINE_HISTORY_H: u32 = 1;
pub const HAVE_READLINE_READLINE_H: u32 = 1;
pub const HAVE_RL_COMPLETION_MATCHES: u32 = 1;
pub const HAVE_RL_COMPLETION_SUPPRESS_QUOTE: u32 = 1;
pub const HAVE_RL_FILENAME_COMPLETION_FUNCTION: u32 = 1;
pub const HAVE_RL_FILENAME_QUOTE_CHARACTERS: u32 = 1;
pub const HAVE_RL_FILENAME_QUOTING_FUNCTION: u32 = 1;
pub const HAVE_RL_RESET_SCREEN_SIZE: u32 = 1;
pub const HAVE_RL_VARIABLE_BIND: u32 = 1;
pub const HAVE_SOCKLEN_T: u32 = 1;
pub const HAVE_SPINLOCKS: u32 = 1;
pub const HAVE_STDBOOL_H: u32 = 1;
pub const HAVE_STDINT_H: u32 = 1;
pub const HAVE_STDLIB_H: u32 = 1;
pub const HAVE_STRCHRNUL: u32 = 1;
pub const HAVE_STRERROR_R: u32 = 1;
pub const HAVE_STRINGS_H: u32 = 1;
pub const HAVE_STRING_H: u32 = 1;
pub const HAVE_STRNLEN: u32 = 1;
pub const HAVE_STRSIGNAL: u32 = 1;
pub const HAVE_STRUCT_OPTION: u32 = 1;
pub const HAVE_STRUCT_TM_TM_ZONE: u32 = 1;
pub const HAVE_SYNCFS: u32 = 1;
pub const HAVE_SYNC_FILE_RANGE: u32 = 1;
pub const HAVE_SYSLOG: u32 = 1;
pub const HAVE_SYS_EPOLL_H: u32 = 1;
pub const HAVE_SYS_PERSONALITY_H: u32 = 1;
pub const HAVE_SYS_PRCTL_H: u32 = 1;
pub const HAVE_SYS_SIGNALFD_H: u32 = 1;
pub const HAVE_SYS_STAT_H: u32 = 1;
pub const HAVE_SYS_TYPES_H: u32 = 1;
pub const HAVE_TERMIOS_H: u32 = 1;
pub const HAVE_TYPEOF: u32 = 1;
pub const HAVE_UNISTD_H: u32 = 1;
pub const HAVE_USELOCALE: u32 = 1;
pub const HAVE_VISIBILITY_ATTRIBUTE: u32 = 1;
pub const HAVE_X86_64_POPCNTQ: u32 = 1;
pub const HAVE__BOOL: u32 = 1;
pub const HAVE__BUILTIN_BSWAP16: u32 = 1;
pub const HAVE__BUILTIN_BSWAP32: u32 = 1;
pub const HAVE__BUILTIN_BSWAP64: u32 = 1;
pub const HAVE__BUILTIN_CLZ: u32 = 1;
pub const HAVE__BUILTIN_CONSTANT_P: u32 = 1;
pub const HAVE__BUILTIN_CTZ: u32 = 1;
pub const HAVE__BUILTIN_FRAME_ADDRESS: u32 = 1;
pub const HAVE__BUILTIN_OP_OVERFLOW: u32 = 1;
pub const HAVE__BUILTIN_POPCOUNT: u32 = 1;
pub const HAVE__BUILTIN_TYPES_COMPATIBLE_P: u32 = 1;
pub const HAVE__BUILTIN_UNREACHABLE: u32 = 1;
pub const HAVE__GET_CPUID: u32 = 1;
pub const HAVE__STATIC_ASSERT: u32 = 1;
pub const INT64_MODIFIER: &[u8; 2] = b"l\0";
pub const MAXIMUM_ALIGNOF: u32 = 8;
pub const MEMSET_LOOP_LIMIT: u32 = 1024;
pub const PACKAGE_BUGREPORT: &[u8; 32] = b"pgsql-bugs@lists.postgresql.org\0";
pub const PACKAGE_NAME: &[u8; 11] = b"PostgreSQL\0";
pub const PACKAGE_STRING: &[u8; 16] = b"PostgreSQL 16.0\0";
pub const PACKAGE_TARNAME: &[u8; 11] = b"postgresql\0";
pub const PACKAGE_URL: &[u8; 28] = b"https://www.postgresql.org/\0";
pub const PACKAGE_VERSION: &[u8; 5] = b"16.0\0";
pub const PG_KRB_SRVNAM: &[u8; 9] = b"postgres\0";
pub const PG_MAJORVERSION: &[u8; 3] = b"16\0";
pub const PG_MAJORVERSION_NUM: u32 = 16;
pub const PG_MINORVERSION_NUM: u32 = 0;
pub const PG_USE_STDBOOL: u32 = 1;
pub const PG_VERSION: &[u8; 5] = b"16.0\0";
pub const PG_VERSION_NUM: u32 = 160000;
pub const PG_VERSION_STR : & [u8 ; 102] = b"PostgreSQL 16.0 on x86_64-pc-linux-gnu, compiled by gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0, 64-bit\0" ;
pub const RELSEG_SIZE: u32 = 131072;
pub const SIZEOF_BOOL: u32 = 1;
pub const SIZEOF_LONG: u32 = 8;
pub const SIZEOF_OFF_T: u32 = 8;
pub const SIZEOF_SIZE_T: u32 = 8;
pub const SIZEOF_VOID_P: u32 = 8;
pub const STDC_HEADERS: u32 = 1;
pub const USE_ASSERT_CHECKING: u32 = 1;
pub const USE_ICU: u32 = 1;
pub const USE_SSE42_CRC32C_WITH_RUNTIME_CHECK: u32 = 1;
pub const USE_SYSV_SHARED_MEMORY: u32 = 1;
pub const USE_UNNAMED_POSIX_SEMAPHORES: u32 = 1;
pub const XLOG_BLCKSZ: u32 = 8192;
pub const DEFAULT_XLOG_SEG_SIZE: u32 = 16777216;
pub const NAMEDATALEN: u32 = 64;
pub const FUNC_MAX_ARGS: u32 = 100;
pub const FMGR_ABI_EXTRA: &[u8; 11] = b"PostgreSQL\0";
pub const INDEX_MAX_KEYS: u32 = 32;
pub const PARTITION_MAX_KEYS: u32 = 32;
pub const USE_FLOAT8_BYVAL: u32 = 1;
pub const NUM_SPINLOCK_SEMAPHORES: u32 = 128;
pub const NUM_ATOMICS_SEMAPHORES: u32 = 64;
pub const MAXPGPATH: u32 = 1024;
pub const BITS_PER_BYTE: u32 = 8;
pub const ALIGNOF_BUFFER: u32 = 32;
pub const DEFAULT_BACKEND_FLUSH_AFTER: u32 = 0;
pub const DEFAULT_BGWRITER_FLUSH_AFTER: u32 = 64;
pub const DEFAULT_CHECKPOINT_FLUSH_AFTER: u32 = 32;
pub const WRITEBACK_MAX_PENDING_FLUSHES: u32 = 256;
pub const DEFAULT_PGSOCKET_DIR: &[u8; 5] = b"/tmp\0";
pub const DEFAULT_EVENT_SOURCE: &[u8; 11] = b"PostgreSQL\0";
pub const PG_CACHE_LINE_SIZE: u32 = 128;
pub const PG_IO_ALIGN_SIZE: u32 = 4096;
pub const TRACE_SORT: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const _LOCALE_H: u32 = 1;
pub const _BITS_LOCALE_H: u32 = 1;
pub const __LC_CTYPE: u32 = 0;
pub const __LC_NUMERIC: u32 = 1;
pub const __LC_TIME: u32 = 2;
pub const __LC_COLLATE: u32 = 3;
pub const __LC_MONETARY: u32 = 4;
pub const __LC_MESSAGES: u32 = 5;
pub const __LC_ALL: u32 = 6;
pub const __LC_PAPER: u32 = 7;
pub const __LC_NAME: u32 = 8;
pub const __LC_ADDRESS: u32 = 9;
pub const __LC_TELEPHONE: u32 = 10;
pub const __LC_MEASUREMENT: u32 = 11;
pub const __LC_IDENTIFICATION: u32 = 12;
pub const LC_CTYPE: u32 = 0;
pub const LC_NUMERIC: u32 = 1;
pub const LC_TIME: u32 = 2;
pub const LC_COLLATE: u32 = 3;
pub const LC_MONETARY: u32 = 4;
pub const LC_MESSAGES: u32 = 5;
pub const LC_ALL: u32 = 6;
pub const LC_PAPER: u32 = 7;
pub const LC_NAME: u32 = 8;
pub const LC_ADDRESS: u32 = 9;
pub const LC_TELEPHONE: u32 = 10;
pub const LC_MEASUREMENT: u32 = 11;
pub const LC_IDENTIFICATION: u32 = 12;
pub const LC_CTYPE_MASK: u32 = 1;
pub const LC_NUMERIC_MASK: u32 = 2;
pub const LC_TIME_MASK: u32 = 4;
pub const LC_COLLATE_MASK: u32 = 8;
pub const LC_MONETARY_MASK: u32 = 16;
pub const LC_MESSAGES_MASK: u32 = 32;
pub const LC_PAPER_MASK: u32 = 128;
pub const LC_NAME_MASK: u32 = 256;
pub const LC_ADDRESS_MASK: u32 = 512;
pub const LC_TELEPHONE_MASK: u32 = 1024;
pub const LC_MEASUREMENT_MASK: u32 = 2048;
pub const LC_IDENTIFICATION_MASK: u32 = 4096;
pub const LC_ALL_MASK: u32 = 8127;
pub const HAVE_PG_ATTRIBUTE_NORETURN: u32 = 1;
pub const HAVE_PRAGMA_GCC_SYSTEM_HEADER: u32 = 1;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const INT64_FORMAT: &[u8; 4] = b"%ld\0";
pub const UINT64_FORMAT: &[u8; 4] = b"%lu\0";
pub const HAVE_INT128: u32 = 1;
pub const PG_INT8_MIN: i32 = -128;
pub const PG_INT8_MAX: u32 = 127;
pub const PG_UINT8_MAX: u32 = 255;
pub const PG_INT16_MIN: i32 = -32768;
pub const PG_INT16_MAX: u32 = 32767;
pub const PG_UINT16_MAX: u32 = 65535;
pub const PG_INT32_MIN: i32 = -2147483648;
pub const PG_INT32_MAX: u32 = 2147483647;
pub const PG_UINT32_MAX: u32 = 4294967295;
pub const FLOAT8PASSBYVAL: u32 = 1;
pub const HIGHBIT: u32 = 128;
pub const ESCAPE_STRING_SYNTAX: u8 = 69u8;
pub const STATUS_OK: u32 = 0;
pub const STATUS_ERROR: i32 = -1;
pub const STATUS_EOF: i32 = -2;
pub const PG_BINARY: u32 = 0;
pub const PG_BINARY_A: &[u8; 2] = b"a\0";
pub const PG_BINARY_R: &[u8; 2] = b"r\0";
pub const PG_BINARY_W: &[u8; 2] = b"w\0";
pub const _CTYPE_H: u32 = 1;
pub const PGINVALID_SOCKET: i32 = -1;
pub const PG_BACKEND_VERSIONSTR: &[u8; 28] = b"postgres (PostgreSQL) 16.0\n\0";
pub const EXE: &[u8; 1] = b"\0";
pub const DEVNULL: &[u8; 10] = b"/dev/null\0";
pub const USE_REPL_SNPRINTF: u32 = 1;
pub const PG_STRERROR_R_BUFLEN: u32 = 256;
pub const PG_IOLBF: u32 = 1;
pub const _MATH_H: u32 = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const __FP_LOGB0_IS_MIN: u32 = 1;
pub const __FP_LOGBNAN_IS_MIN: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARING_FLOATN: u32 = 0;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const HAVE_GETRLIMIT: u32 = 1;
pub const HAVE_POLL: u32 = 1;
pub const HAVE_POLL_H: u32 = 1;
pub const HAVE_READLINK: u32 = 1;
pub const HAVE_SETSID: u32 = 1;
pub const HAVE_SHM_OPEN: u32 = 1;
pub const HAVE_SYMLINK: u32 = 1;
pub const _SETJMP_H: u32 = 1;
pub const _BITS_SETJMP_H: u32 = 1;
pub const __jmp_buf_tag_defined: u32 = 1;
pub const DEBUG5: u32 = 10;
pub const DEBUG4: u32 = 11;
pub const DEBUG3: u32 = 12;
pub const DEBUG2: u32 = 13;
pub const DEBUG1: u32 = 14;
pub const LOG: u32 = 15;
pub const LOG_SERVER_ONLY: u32 = 16;
pub const COMMERROR: u32 = 16;
pub const INFO: u32 = 17;
pub const NOTICE: u32 = 18;
pub const WARNING: u32 = 19;
pub const PGWARNING: u32 = 19;
pub const WARNING_CLIENT_ONLY: u32 = 20;
pub const ERROR: u32 = 21;
pub const PGERROR: u32 = 21;
pub const FATAL: u32 = 22;
pub const PANIC: u32 = 23;
pub const LOG_DESTINATION_STDERR: u32 = 1;
pub const LOG_DESTINATION_SYSLOG: u32 = 2;
pub const LOG_DESTINATION_EVENTLOG: u32 = 4;
pub const LOG_DESTINATION_CSVLOG: u32 = 8;
pub const LOG_DESTINATION_JSONLOG: u32 = 16;
pub const MCXT_ALLOC_HUGE: u32 = 1;
pub const MCXT_ALLOC_NO_OOM: u32 = 2;
pub const MCXT_ALLOC_ZERO: u32 = 4;
pub const FIELDNO_NULLABLE_DATUM_DATUM: u32 = 0;
pub const FIELDNO_NULLABLE_DATUM_ISNULL: u32 = 1;
pub const SIZEOF_DATUM: u32 = 8;
pub const InvalidAttrNumber: u32 = 0;
pub const MaxAttrNumber: u32 = 32767;
pub const AttributeRelationId: Oid = Oid(1249);
pub const AttributeRelation_Rowtype_Id: u32 = 75;
pub const AttributeRelidNameIndexId: u32 = 2658;
pub const AttributeRelidNumIndexId: u32 = 2659;
pub const Anum_pg_attribute_attrelid: u32 = 1;
pub const Anum_pg_attribute_attname: u32 = 2;
pub const Anum_pg_attribute_atttypid: u32 = 3;
pub const Anum_pg_attribute_attlen: u32 = 4;
pub const Anum_pg_attribute_attnum: u32 = 5;
pub const Anum_pg_attribute_attcacheoff: u32 = 6;
pub const Anum_pg_attribute_atttypmod: u32 = 7;
pub const Anum_pg_attribute_attndims: u32 = 8;
pub const Anum_pg_attribute_attbyval: u32 = 9;
pub const Anum_pg_attribute_attalign: u32 = 10;
pub const Anum_pg_attribute_attstorage: u32 = 11;
pub const Anum_pg_attribute_attcompression: u32 = 12;
pub const Anum_pg_attribute_attnotnull: u32 = 13;
pub const Anum_pg_attribute_atthasdef: u32 = 14;
pub const Anum_pg_attribute_atthasmissing: u32 = 15;
pub const Anum_pg_attribute_attidentity: u32 = 16;
pub const Anum_pg_attribute_attgenerated: u32 = 17;
pub const Anum_pg_attribute_attisdropped: u32 = 18;
pub const Anum_pg_attribute_attislocal: u32 = 19;
pub const Anum_pg_attribute_attinhcount: u32 = 20;
pub const Anum_pg_attribute_attstattarget: u32 = 21;
pub const Anum_pg_attribute_attcollation: u32 = 22;
pub const Anum_pg_attribute_attacl: u32 = 23;
pub const Anum_pg_attribute_attoptions: u32 = 24;
pub const Anum_pg_attribute_attfdwoptions: u32 = 25;
pub const Anum_pg_attribute_attmissingval: u32 = 26;
pub const Natts_pg_attribute: u32 = 26;
pub const ATTRIBUTE_IDENTITY_ALWAYS: u8 = 97u8;
pub const ATTRIBUTE_IDENTITY_BY_DEFAULT: u8 = 100u8;
pub const ATTRIBUTE_GENERATED_STORED: u8 = 115u8;
pub const AGGSPLITOP_COMBINE: u32 = 1;
pub const AGGSPLITOP_SKIPFINAL: u32 = 2;
pub const AGGSPLITOP_SERIALIZE: u32 = 4;
pub const AGGSPLITOP_DESERIALIZE: u32 = 8;
pub const LP_UNUSED: u32 = 0;
pub const LP_NORMAL: u32 = 1;
pub const LP_REDIRECT: u32 = 2;
pub const LP_DEAD: u32 = 3;
pub const SpecTokenOffsetNumber: u32 = 65534;
pub const MovedPartitionsOffsetNumber: u32 = 65533;
pub const FIELDNO_HEAPTUPLEDATA_DATA: u32 = 3;
pub const _FCNTL_H: u32 = 1;
pub const __O_LARGEFILE: u32 = 0;
pub const F_GETLK64: u32 = 5;
pub const F_SETLK64: u32 = 6;
pub const F_SETLKW64: u32 = 7;
pub const O_ACCMODE: u32 = 3;
pub const O_RDONLY: u32 = 0;
pub const O_WRONLY: u32 = 1;
pub const O_RDWR: u32 = 2;
pub const O_CREAT: u32 = 64;
pub const O_EXCL: u32 = 128;
pub const O_NOCTTY: u32 = 256;
pub const O_TRUNC: u32 = 512;
pub const O_APPEND: u32 = 1024;
pub const O_NONBLOCK: u32 = 2048;
pub const O_NDELAY: u32 = 2048;
pub const O_SYNC: u32 = 1052672;
pub const O_FSYNC: u32 = 1052672;
pub const O_ASYNC: u32 = 8192;
pub const __O_DIRECTORY: u32 = 65536;
pub const __O_NOFOLLOW: u32 = 131072;
pub const __O_CLOEXEC: u32 = 524288;
pub const __O_DIRECT: u32 = 16384;
pub const __O_NOATIME: u32 = 262144;
pub const __O_PATH: u32 = 2097152;
pub const __O_DSYNC: u32 = 4096;
pub const __O_TMPFILE: u32 = 4259840;
pub const F_GETLK: u32 = 5;
pub const F_SETLK: u32 = 6;
pub const F_SETLKW: u32 = 7;
pub const O_DIRECTORY: u32 = 65536;
pub const O_NOFOLLOW: u32 = 131072;
pub const O_CLOEXEC: u32 = 524288;
pub const O_DSYNC: u32 = 4096;
pub const O_RSYNC: u32 = 1052672;
pub const F_DUPFD: u32 = 0;
pub const F_GETFD: u32 = 1;
pub const F_SETFD: u32 = 2;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const __F_SETOWN: u32 = 8;
pub const __F_GETOWN: u32 = 9;
pub const F_SETOWN: u32 = 8;
pub const F_GETOWN: u32 = 9;
pub const __F_SETSIG: u32 = 10;
pub const __F_GETSIG: u32 = 11;
pub const __F_SETOWN_EX: u32 = 15;
pub const __F_GETOWN_EX: u32 = 16;
pub const F_DUPFD_CLOEXEC: u32 = 1030;
pub const FD_CLOEXEC: u32 = 1;
pub const F_RDLCK: u32 = 0;
pub const F_WRLCK: u32 = 1;
pub const F_UNLCK: u32 = 2;
pub const F_EXLCK: u32 = 4;
pub const F_SHLCK: u32 = 8;
pub const LOCK_SH: u32 = 1;
pub const LOCK_EX: u32 = 2;
pub const LOCK_NB: u32 = 4;
pub const LOCK_UN: u32 = 8;
pub const FAPPEND: u32 = 1024;
pub const FFSYNC: u32 = 1052672;
pub const FASYNC: u32 = 8192;
pub const FNONBLOCK: u32 = 2048;
pub const FNDELAY: u32 = 2048;
pub const __POSIX_FADV_DONTNEED: u32 = 4;
pub const __POSIX_FADV_NOREUSE: u32 = 5;
pub const POSIX_FADV_NORMAL: u32 = 0;
pub const POSIX_FADV_RANDOM: u32 = 1;
pub const POSIX_FADV_SEQUENTIAL: u32 = 2;
pub const POSIX_FADV_WILLNEED: u32 = 3;
pub const POSIX_FADV_DONTNEED: u32 = 4;
pub const POSIX_FADV_NOREUSE: u32 = 5;
pub const AT_FDCWD: i32 = -100;
pub const AT_SYMLINK_NOFOLLOW: u32 = 256;
pub const AT_REMOVEDIR: u32 = 512;
pub const AT_SYMLINK_FOLLOW: u32 = 1024;
pub const AT_EACCESS: u32 = 512;
pub const _BITS_STAT_H: u32 = 1;
pub const _BITS_STRUCT_STAT_H: u32 = 1;
pub const __S_IFMT: u32 = 61440;
pub const __S_IFDIR: u32 = 16384;
pub const __S_IFCHR: u32 = 8192;
pub const __S_IFBLK: u32 = 24576;
pub const __S_IFREG: u32 = 32768;
pub const __S_IFIFO: u32 = 4096;
pub const __S_IFLNK: u32 = 40960;
pub const __S_IFSOCK: u32 = 49152;
pub const __S_ISUID: u32 = 2048;
pub const __S_ISGID: u32 = 1024;
pub const __S_ISVTX: u32 = 512;
pub const __S_IREAD: u32 = 256;
pub const __S_IWRITE: u32 = 128;
pub const __S_IEXEC: u32 = 64;
pub const UTIME_NOW: u32 = 1073741823;
pub const UTIME_OMIT: u32 = 1073741822;
pub const S_IFMT: u32 = 61440;
pub const S_IFDIR: u32 = 16384;
pub const S_IFCHR: u32 = 8192;
pub const S_IFBLK: u32 = 24576;
pub const S_IFREG: u32 = 32768;
pub const S_IFIFO: u32 = 4096;
pub const S_IFLNK: u32 = 40960;
pub const S_IFSOCK: u32 = 49152;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXU: u32 = 448;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXG: u32 = 56;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const S_IRWXO: u32 = 7;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const InvalidXLogRecPtr: u32 = 0;
pub const FirstGenbkiObjectId: u32 = 10000;
pub const FirstUnpinnedObjectId: u32 = 12000;
pub const FirstNormalObjectId: u32 = 16384;
pub const TypeRelationId: Oid = Oid(1247);
pub const TypeRelation_Rowtype_Id: u32 = 71;
pub const TypeOidIndexId: u32 = 2703;
pub const TypeNameNspIndexId: u32 = 2704;
pub const Anum_pg_type_oid: u32 = 1;
pub const Anum_pg_type_typname: u32 = 2;
pub const Anum_pg_type_typnamespace: u32 = 3;
pub const Anum_pg_type_typowner: u32 = 4;
pub const Anum_pg_type_typlen: u32 = 5;
pub const Anum_pg_type_typbyval: u32 = 6;
pub const Anum_pg_type_typtype: u32 = 7;
pub const Anum_pg_type_typcategory: u32 = 8;
pub const Anum_pg_type_typispreferred: u32 = 9;
pub const Anum_pg_type_typisdefined: u32 = 10;
pub const Anum_pg_type_typdelim: u32 = 11;
pub const Anum_pg_type_typrelid: u32 = 12;
pub const Anum_pg_type_typsubscript: u32 = 13;
pub const Anum_pg_type_typelem: u32 = 14;
pub const Anum_pg_type_typarray: u32 = 15;
pub const Anum_pg_type_typinput: u32 = 16;
pub const Anum_pg_type_typoutput: u32 = 17;
pub const Anum_pg_type_typreceive: u32 = 18;
pub const Anum_pg_type_typsend: u32 = 19;
pub const Anum_pg_type_typmodin: u32 = 20;
pub const Anum_pg_type_typmodout: u32 = 21;
pub const Anum_pg_type_typanalyze: u32 = 22;
pub const Anum_pg_type_typalign: u32 = 23;
pub const Anum_pg_type_typstorage: u32 = 24;
pub const Anum_pg_type_typnotnull: u32 = 25;
pub const Anum_pg_type_typbasetype: u32 = 26;
pub const Anum_pg_type_typtypmod: u32 = 27;
pub const Anum_pg_type_typndims: u32 = 28;
pub const Anum_pg_type_typcollation: u32 = 29;
pub const Anum_pg_type_typdefaultbin: u32 = 30;
pub const Anum_pg_type_typdefault: u32 = 31;
pub const Anum_pg_type_typacl: u32 = 32;
pub const Natts_pg_type: u32 = 32;
pub const TYPTYPE_BASE: u8 = 98u8;
pub const TYPTYPE_COMPOSITE: u8 = 99u8;
pub const TYPTYPE_DOMAIN: u8 = 100u8;
pub const TYPTYPE_ENUM: u8 = 101u8;
pub const TYPTYPE_MULTIRANGE: u8 = 109u8;
pub const TYPTYPE_PSEUDO: u8 = 112u8;
pub const TYPTYPE_RANGE: u8 = 114u8;
pub const TYPCATEGORY_INVALID: u8 = 0u8;
pub const TYPCATEGORY_ARRAY: u8 = 65u8;
pub const TYPCATEGORY_BOOLEAN: u8 = 66u8;
pub const TYPCATEGORY_COMPOSITE: u8 = 67u8;
pub const TYPCATEGORY_DATETIME: u8 = 68u8;
pub const TYPCATEGORY_ENUM: u8 = 69u8;
pub const TYPCATEGORY_GEOMETRIC: u8 = 71u8;
pub const TYPCATEGORY_NETWORK: u8 = 73u8;
pub const TYPCATEGORY_NUMERIC: u8 = 78u8;
pub const TYPCATEGORY_PSEUDOTYPE: u8 = 80u8;
pub const TYPCATEGORY_RANGE: u8 = 82u8;
pub const TYPCATEGORY_STRING: u8 = 83u8;
pub const TYPCATEGORY_TIMESPAN: u8 = 84u8;
pub const TYPCATEGORY_USER: u8 = 85u8;
pub const TYPCATEGORY_BITSTRING: u8 = 86u8;
pub const TYPCATEGORY_UNKNOWN: u8 = 88u8;
pub const TYPCATEGORY_INTERNAL: u8 = 90u8;
pub const TYPALIGN_CHAR: u8 = 99u8;
pub const TYPALIGN_SHORT: u8 = 115u8;
pub const TYPALIGN_INT: u8 = 105u8;
pub const TYPALIGN_DOUBLE: u8 = 100u8;
pub const TYPSTORAGE_PLAIN: u8 = 112u8;
pub const TYPSTORAGE_EXTERNAL: u8 = 101u8;
pub const TYPSTORAGE_EXTENDED: u8 = 120u8;
pub const TYPSTORAGE_MAIN: u8 = 109u8;
pub const BOOLOID: Oid = Oid(16);
pub const BYTEAOID: Oid = Oid(17);
pub const CHAROID: Oid = Oid(18);
pub const NAMEOID: Oid = Oid(19);
pub const INT8OID: Oid = Oid(20);
pub const INT2OID: Oid = Oid(21);
pub const INT2VECTOROID: Oid = Oid(22);
pub const INT4OID: Oid = Oid(23);
pub const REGPROCOID: Oid = Oid(24);
pub const TEXTOID: Oid = Oid(25);
pub const OIDOID: Oid = Oid(26);
pub const TIDOID: Oid = Oid(27);
pub const XIDOID: Oid = Oid(28);
pub const CIDOID: Oid = Oid(29);
pub const OIDVECTOROID: Oid = Oid(30);
pub const JSONOID: Oid = Oid(114);
pub const XMLOID: Oid = Oid(142);
pub const PG_NODE_TREEOID: Oid = Oid(194);
pub const PG_NDISTINCTOID: Oid = Oid(3361);
pub const PG_DEPENDENCIESOID: Oid = Oid(3402);
pub const PG_MCV_LISTOID: Oid = Oid(5017);
pub const PG_DDL_COMMANDOID: Oid = Oid(32);
pub const XID8OID: Oid = Oid(5069);
pub const POINTOID: Oid = Oid(600);
pub const LSEGOID: Oid = Oid(601);
pub const PATHOID: Oid = Oid(602);
pub const BOXOID: Oid = Oid(603);
pub const POLYGONOID: Oid = Oid(604);
pub const LINEOID: Oid = Oid(628);
pub const FLOAT4OID: Oid = Oid(700);
pub const FLOAT8OID: Oid = Oid(701);
pub const UNKNOWNOID: Oid = Oid(705);
pub const CIRCLEOID: Oid = Oid(718);
pub const MONEYOID: Oid = Oid(790);
pub const MACADDROID: Oid = Oid(829);
pub const INETOID: Oid = Oid(869);
pub const CIDROID: Oid = Oid(650);
pub const MACADDR8OID: Oid = Oid(774);
pub const ACLITEMOID: Oid = Oid(1033);
pub const BPCHAROID: Oid = Oid(1042);
pub const VARCHAROID: Oid = Oid(1043);
pub const DATEOID: Oid = Oid(1082);
pub const TIMEOID: Oid = Oid(1083);
pub const TIMESTAMPOID: Oid = Oid(1114);
pub const TIMESTAMPTZOID: Oid = Oid(1184);
pub const INTERVALOID: Oid = Oid(1186);
pub const TIMETZOID: Oid = Oid(1266);
pub const BITOID: Oid = Oid(1560);
pub const VARBITOID: Oid = Oid(1562);
pub const NUMERICOID: Oid = Oid(1700);
pub const REFCURSOROID: Oid = Oid(1790);
pub const REGPROCEDUREOID: Oid = Oid(2202);
pub const REGOPEROID: Oid = Oid(2203);
pub const REGOPERATOROID: Oid = Oid(2204);
pub const REGCLASSOID: Oid = Oid(2205);
pub const REGCOLLATIONOID: Oid = Oid(4191);
pub const REGTYPEOID: Oid = Oid(2206);
pub const REGROLEOID: Oid = Oid(4096);
pub const REGNAMESPACEOID: Oid = Oid(4089);
pub const UUIDOID: Oid = Oid(2950);
pub const PG_LSNOID: Oid = Oid(3220);
pub const TSVECTOROID: Oid = Oid(3614);
pub const GTSVECTOROID: Oid = Oid(3642);
pub const TSQUERYOID: Oid = Oid(3615);
pub const REGCONFIGOID: Oid = Oid(3734);
pub const REGDICTIONARYOID: Oid = Oid(3769);
pub const JSONBOID: Oid = Oid(3802);
pub const JSONPATHOID: Oid = Oid(4072);
pub const TXID_SNAPSHOTOID: Oid = Oid(2970);
pub const PG_SNAPSHOTOID: Oid = Oid(5038);
pub const INT4RANGEOID: Oid = Oid(3904);
pub const NUMRANGEOID: Oid = Oid(3906);
pub const TSRANGEOID: Oid = Oid(3908);
pub const TSTZRANGEOID: Oid = Oid(3910);
pub const DATERANGEOID: Oid = Oid(3912);
pub const INT8RANGEOID: Oid = Oid(3926);
pub const INT4MULTIRANGEOID: Oid = Oid(4451);
pub const NUMMULTIRANGEOID: Oid = Oid(4532);
pub const TSMULTIRANGEOID: Oid = Oid(4533);
pub const TSTZMULTIRANGEOID: Oid = Oid(4534);
pub const DATEMULTIRANGEOID: Oid = Oid(4535);
pub const INT8MULTIRANGEOID: Oid = Oid(4536);
pub const RECORDOID: Oid = Oid(2249);
pub const RECORDARRAYOID: Oid = Oid(2287);
pub const CSTRINGOID: Oid = Oid(2275);
pub const ANYOID: Oid = Oid(2276);
pub const ANYARRAYOID: Oid = Oid(2277);
pub const VOIDOID: Oid = Oid(2278);
pub const TRIGGEROID: Oid = Oid(2279);
pub const EVENT_TRIGGEROID: Oid = Oid(3838);
pub const LANGUAGE_HANDLEROID: Oid = Oid(2280);
pub const INTERNALOID: Oid = Oid(2281);
pub const ANYELEMENTOID: Oid = Oid(2283);
pub const ANYNONARRAYOID: Oid = Oid(2776);
pub const ANYENUMOID: Oid = Oid(3500);
pub const FDW_HANDLEROID: Oid = Oid(3115);
pub const INDEX_AM_HANDLEROID: Oid = Oid(325);
pub const TSM_HANDLEROID: Oid = Oid(3310);
pub const TABLE_AM_HANDLEROID: Oid = Oid(269);
pub const ANYRANGEOID: Oid = Oid(3831);
pub const ANYCOMPATIBLEOID: Oid = Oid(5077);
pub const ANYCOMPATIBLEARRAYOID: Oid = Oid(5078);
pub const ANYCOMPATIBLENONARRAYOID: Oid = Oid(5079);
pub const ANYCOMPATIBLERANGEOID: Oid = Oid(5080);
pub const ANYMULTIRANGEOID: Oid = Oid(4537);
pub const ANYCOMPATIBLEMULTIRANGEOID: Oid = Oid(4538);
pub const PG_BRIN_BLOOM_SUMMARYOID: Oid = Oid(4600);
pub const PG_BRIN_MINMAX_MULTI_SUMMARYOID: Oid = Oid(4601);
pub const BOOLARRAYOID: Oid = Oid(1000);
pub const BYTEAARRAYOID: Oid = Oid(1001);
pub const CHARARRAYOID: Oid = Oid(1002);
pub const NAMEARRAYOID: Oid = Oid(1003);
pub const INT8ARRAYOID: Oid = Oid(1016);
pub const INT2ARRAYOID: Oid = Oid(1005);
pub const INT2VECTORARRAYOID: Oid = Oid(1006);
pub const INT4ARRAYOID: Oid = Oid(1007);
pub const REGPROCARRAYOID: Oid = Oid(1008);
pub const TEXTARRAYOID: Oid = Oid(1009);
pub const OIDARRAYOID: Oid = Oid(1028);
pub const TIDARRAYOID: Oid = Oid(1010);
pub const XIDARRAYOID: Oid = Oid(1011);
pub const CIDARRAYOID: Oid = Oid(1012);
pub const OIDVECTORARRAYOID: Oid = Oid(1013);
pub const PG_TYPEARRAYOID: Oid = Oid(210);
pub const PG_ATTRIBUTEARRAYOID: Oid = Oid(270);
pub const PG_PROCARRAYOID: Oid = Oid(272);
pub const PG_CLASSARRAYOID: Oid = Oid(273);
pub const JSONARRAYOID: Oid = Oid(199);
pub const XMLARRAYOID: Oid = Oid(143);
pub const XID8ARRAYOID: Oid = Oid(271);
pub const POINTARRAYOID: Oid = Oid(1017);
pub const LSEGARRAYOID: Oid = Oid(1018);
pub const PATHARRAYOID: Oid = Oid(1019);
pub const BOXARRAYOID: Oid = Oid(1020);
pub const POLYGONARRAYOID: Oid = Oid(1027);
pub const LINEARRAYOID: Oid = Oid(629);
pub const FLOAT4ARRAYOID: Oid = Oid(1021);
pub const FLOAT8ARRAYOID: Oid = Oid(1022);
pub const CIRCLEARRAYOID: Oid = Oid(719);
pub const MONEYARRAYOID: Oid = Oid(791);
pub const MACADDRARRAYOID: Oid = Oid(1040);
pub const INETARRAYOID: Oid = Oid(1041);
pub const CIDRARRAYOID: Oid = Oid(651);
pub const MACADDR8ARRAYOID: Oid = Oid(775);
pub const ACLITEMARRAYOID: Oid = Oid(1034);
pub const BPCHARARRAYOID: Oid = Oid(1014);
pub const VARCHARARRAYOID: Oid = Oid(1015);
pub const DATEARRAYOID: Oid = Oid(1182);
pub const TIMEARRAYOID: Oid = Oid(1183);
pub const TIMESTAMPARRAYOID: Oid = Oid(1115);
pub const TIMESTAMPTZARRAYOID: Oid = Oid(1185);
pub const INTERVALARRAYOID: Oid = Oid(1187);
pub const TIMETZARRAYOID: Oid = Oid(1270);
pub const BITARRAYOID: Oid = Oid(1561);
pub const VARBITARRAYOID: Oid = Oid(1563);
pub const NUMERICARRAYOID: Oid = Oid(1231);
pub const REFCURSORARRAYOID: Oid = Oid(2201);
pub const REGPROCEDUREARRAYOID: Oid = Oid(2207);
pub const REGOPERARRAYOID: Oid = Oid(2208);
pub const REGOPERATORARRAYOID: Oid = Oid(2209);
pub const REGCLASSARRAYOID: Oid = Oid(2210);
pub const REGCOLLATIONARRAYOID: Oid = Oid(4192);
pub const REGTYPEARRAYOID: Oid = Oid(2211);
pub const REGROLEARRAYOID: Oid = Oid(4097);
pub const REGNAMESPACEARRAYOID: Oid = Oid(4090);
pub const UUIDARRAYOID: Oid = Oid(2951);
pub const PG_LSNARRAYOID: Oid = Oid(3221);
pub const TSVECTORARRAYOID: Oid = Oid(3643);
pub const GTSVECTORARRAYOID: Oid = Oid(3644);
pub const TSQUERYARRAYOID: Oid = Oid(3645);
pub const REGCONFIGARRAYOID: Oid = Oid(3735);
pub const REGDICTIONARYARRAYOID: Oid = Oid(3770);
pub const JSONBARRAYOID: Oid = Oid(3807);
pub const JSONPATHARRAYOID: Oid = Oid(4073);
pub const TXID_SNAPSHOTARRAYOID: Oid = Oid(2949);
pub const PG_SNAPSHOTARRAYOID: Oid = Oid(5039);
pub const INT4RANGEARRAYOID: Oid = Oid(3905);
pub const NUMRANGEARRAYOID: Oid = Oid(3907);
pub const TSRANGEARRAYOID: Oid = Oid(3909);
pub const TSTZRANGEARRAYOID: Oid = Oid(3911);
pub const DATERANGEARRAYOID: Oid = Oid(3913);
pub const INT8RANGEARRAYOID: Oid = Oid(3927);
pub const INT4MULTIRANGEARRAYOID: Oid = Oid(6150);
pub const NUMMULTIRANGEARRAYOID: Oid = Oid(6151);
pub const TSMULTIRANGEARRAYOID: Oid = Oid(6152);
pub const TSTZMULTIRANGEARRAYOID: Oid = Oid(6153);
pub const DATEMULTIRANGEARRAYOID: Oid = Oid(6155);
pub const INT8MULTIRANGEARRAYOID: Oid = Oid(6157);
pub const CSTRINGARRAYOID: Oid = Oid(1263);
pub const PD_HAS_FREE_LINES: u32 = 1;
pub const PD_PAGE_FULL: u32 = 2;
pub const PD_ALL_VISIBLE: u32 = 4;
pub const PD_VALID_FLAG_BITS: u32 = 7;
pub const PG_PAGE_LAYOUT_VERSION: u32 = 4;
pub const PG_DATA_CHECKSUM_VERSION: u32 = 1;
pub const PAI_OVERWRITE: u32 = 1;
pub const PAI_IS_HEAP: u32 = 2;
pub const PIV_LOG_WARNING: u32 = 1;
pub const PIV_REPORT_STAT: u32 = 2;
pub const VARLENA_EXTSIZE_BITS: u32 = 30;
pub const VARLENA_EXTSIZE_MASK: u32 = 1073741823;
pub const VARATT_SHORT_MAX: u32 = 127;
pub const MaxTupleAttributeNumber: u32 = 1664;
pub const MaxHeapAttributeNumber: u32 = 1600;
pub const FIELDNO_HEAPTUPLEHEADERDATA_INFOMASK2: u32 = 2;
pub const FIELDNO_HEAPTUPLEHEADERDATA_INFOMASK: u32 = 3;
pub const FIELDNO_HEAPTUPLEHEADERDATA_HOFF: u32 = 4;
pub const FIELDNO_HEAPTUPLEHEADERDATA_BITS: u32 = 5;
pub const HEAP_HASNULL: u32 = 1;
pub const HEAP_HASVARWIDTH: u32 = 2;
pub const HEAP_HASEXTERNAL: u32 = 4;
pub const HEAP_HASOID_OLD: u32 = 8;
pub const HEAP_XMAX_KEYSHR_LOCK: u32 = 16;
pub const HEAP_COMBOCID: u32 = 32;
pub const HEAP_XMAX_EXCL_LOCK: u32 = 64;
pub const HEAP_XMAX_LOCK_ONLY: u32 = 128;
pub const HEAP_XMAX_SHR_LOCK: u32 = 80;
pub const HEAP_LOCK_MASK: u32 = 80;
pub const HEAP_XMIN_COMMITTED: u32 = 256;
pub const HEAP_XMIN_INVALID: u32 = 512;
pub const HEAP_XMIN_FROZEN: u32 = 768;
pub const HEAP_XMAX_COMMITTED: u32 = 1024;
pub const HEAP_XMAX_INVALID: u32 = 2048;
pub const HEAP_XMAX_IS_MULTI: u32 = 4096;
pub const HEAP_UPDATED: u32 = 8192;
pub const HEAP_MOVED_OFF: u32 = 16384;
pub const HEAP_MOVED_IN: u32 = 32768;
pub const HEAP_MOVED: u32 = 49152;
pub const HEAP_XACT_MASK: u32 = 65520;
pub const HEAP_XMAX_BITS: u32 = 7376;
pub const HEAP_NATTS_MASK: u32 = 2047;
pub const HEAP_KEYS_UPDATED: u32 = 8192;
pub const HEAP_HOT_UPDATED: u32 = 16384;
pub const HEAP_ONLY_TUPLE: u32 = 32768;
pub const HEAP2_XACT_MASK: u32 = 57344;
pub const HEAP_TUPLE_HAS_MATCH: u32 = 32768;
pub const MaxAttrSize: u32 = 10485760;
pub const SelfItemPointerAttributeNumber: i32 = -1;
pub const MinTransactionIdAttributeNumber: i32 = -2;
pub const MinCommandIdAttributeNumber: i32 = -3;
pub const MaxTransactionIdAttributeNumber: i32 = -4;
pub const MaxCommandIdAttributeNumber: i32 = -5;
pub const TableOidAttributeNumber: i32 = -6;
pub const FirstLowInvalidHeapAttributeNumber: i32 = -7;
pub const InvalidBuffer: u32 = 0;
pub const TTS_FLAG_EMPTY: u32 = 2;
pub const TTS_FLAG_SHOULDFREE: u32 = 4;
pub const TTS_FLAG_SLOW: u32 = 8;
pub const TTS_FLAG_FIXED: u32 = 16;
pub const FIELDNO_TUPLETABLESLOT_FLAGS: u32 = 1;
pub const FIELDNO_TUPLETABLESLOT_NVALID: u32 = 2;
pub const FIELDNO_TUPLETABLESLOT_TUPLEDESCRIPTOR: u32 = 4;
pub const FIELDNO_TUPLETABLESLOT_VALUES: u32 = 5;
pub const FIELDNO_TUPLETABLESLOT_ISNULL: u32 = 6;
pub const FIELDNO_HEAPTUPLETABLESLOT_TUPLE: u32 = 1;
pub const FIELDNO_HEAPTUPLETABLESLOT_OFF: u32 = 2;
pub const FIELDNO_MINIMALTUPLETABLESLOT_TUPLE: u32 = 1;
pub const FIELDNO_MINIMALTUPLETABLESLOT_OFF: u32 = 4;
pub const BITS_PER_BITMAPWORD: u32 = 64;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const PG_INSTR_CLOCK: u32 = 1;
pub const FIELDNO_FUNCTIONCALLINFODATA_ISNULL: u32 = 4;
pub const FIELDNO_FUNCTIONCALLINFODATA_ARGS: u32 = 6;
pub const PG_MAGIC_FUNCTION_NAME_STRING: &[u8; 14] = b"Pg_magic_func\0";
pub const AGG_CONTEXT_AGGREGATE: u32 = 1;
pub const AGG_CONTEXT_WINDOW: u32 = 2;
pub const PARAM_FLAG_CONST: u32 = 1;
pub const BTLessStrategyNumber: u32 = 1;
pub const BTLessEqualStrategyNumber: u32 = 2;
pub const BTEqualStrategyNumber: u32 = 3;
pub const BTGreaterEqualStrategyNumber: u32 = 4;
pub const BTGreaterStrategyNumber: u32 = 5;
pub const BTMaxStrategyNumber: u32 = 5;
pub const HTEqualStrategyNumber: u32 = 1;
pub const HTMaxStrategyNumber: u32 = 1;
pub const RTLeftStrategyNumber: u32 = 1;
pub const RTOverLeftStrategyNumber: u32 = 2;
pub const RTOverlapStrategyNumber: u32 = 3;
pub const RTOverRightStrategyNumber: u32 = 4;
pub const RTRightStrategyNumber: u32 = 5;
pub const RTSameStrategyNumber: u32 = 6;
pub const RTContainsStrategyNumber: u32 = 7;
pub const RTContainedByStrategyNumber: u32 = 8;
pub const RTOverBelowStrategyNumber: u32 = 9;
pub const RTBelowStrategyNumber: u32 = 10;
pub const RTAboveStrategyNumber: u32 = 11;
pub const RTOverAboveStrategyNumber: u32 = 12;
pub const RTOldContainsStrategyNumber: u32 = 13;
pub const RTOldContainedByStrategyNumber: u32 = 14;
pub const RTKNNSearchStrategyNumber: u32 = 15;
pub const RTContainsElemStrategyNumber: u32 = 16;
pub const RTAdjacentStrategyNumber: u32 = 17;
pub const RTEqualStrategyNumber: u32 = 18;
pub const RTNotEqualStrategyNumber: u32 = 19;
pub const RTLessStrategyNumber: u32 = 20;
pub const RTLessEqualStrategyNumber: u32 = 21;
pub const RTGreaterStrategyNumber: u32 = 22;
pub const RTGreaterEqualStrategyNumber: u32 = 23;
pub const RTSubStrategyNumber: u32 = 24;
pub const RTSubEqualStrategyNumber: u32 = 25;
pub const RTSuperStrategyNumber: u32 = 26;
pub const RTSuperEqualStrategyNumber: u32 = 27;
pub const RTPrefixStrategyNumber: u32 = 28;
pub const RTOldBelowStrategyNumber: u32 = 29;
pub const RTOldAboveStrategyNumber: u32 = 30;
pub const RTMaxStrategyNumber: u32 = 30;
pub const CATALOG_VERSION_NO: u32 = 202307071;
pub const OIDCHARS: u32 = 10;
pub const FORKNAMECHARS: u32 = 4;
pub const INNER_VAR: i32 = -1;
pub const OUTER_VAR: i32 = -2;
pub const INDEX_VAR: i32 = -3;
pub const ROWID_VAR: i32 = -4;
pub const PRS2_OLD_VARNO: u32 = 1;
pub const PRS2_NEW_VARNO: u32 = 2;
pub const ACL_INSERT: u32 = 1;
pub const ACL_SELECT: u32 = 2;
pub const ACL_UPDATE: u32 = 4;
pub const ACL_DELETE: u32 = 8;
pub const ACL_TRUNCATE: u32 = 16;
pub const ACL_REFERENCES: u32 = 32;
pub const ACL_TRIGGER: u32 = 64;
pub const ACL_EXECUTE: u32 = 128;
pub const ACL_USAGE: u32 = 256;
pub const ACL_CREATE: u32 = 512;
pub const ACL_CREATE_TEMP: u32 = 1024;
pub const ACL_CONNECT: u32 = 2048;
pub const ACL_SET: u32 = 4096;
pub const ACL_ALTER_SYSTEM: u32 = 8192;
pub const N_ACL_RIGHTS: u32 = 14;
pub const ACL_NO_RIGHTS: u32 = 0;
pub const ACL_SELECT_FOR_UPDATE: u32 = 4;
pub const FRAMEOPTION_NONDEFAULT: u32 = 1;
pub const FRAMEOPTION_RANGE: u32 = 2;
pub const FRAMEOPTION_ROWS: u32 = 4;
pub const FRAMEOPTION_GROUPS: u32 = 8;
pub const FRAMEOPTION_BETWEEN: u32 = 16;
pub const FRAMEOPTION_START_UNBOUNDED_PRECEDING: u32 = 32;
pub const FRAMEOPTION_END_UNBOUNDED_PRECEDING: u32 = 64;
pub const FRAMEOPTION_START_UNBOUNDED_FOLLOWING: u32 = 128;
pub const FRAMEOPTION_END_UNBOUNDED_FOLLOWING: u32 = 256;
pub const FRAMEOPTION_START_CURRENT_ROW: u32 = 512;
pub const FRAMEOPTION_END_CURRENT_ROW: u32 = 1024;
pub const FRAMEOPTION_START_OFFSET_PRECEDING: u32 = 2048;
pub const FRAMEOPTION_END_OFFSET_PRECEDING: u32 = 4096;
pub const FRAMEOPTION_START_OFFSET_FOLLOWING: u32 = 8192;
pub const FRAMEOPTION_END_OFFSET_FOLLOWING: u32 = 16384;
pub const FRAMEOPTION_EXCLUDE_CURRENT_ROW: u32 = 32768;
pub const FRAMEOPTION_EXCLUDE_GROUP: u32 = 65536;
pub const FRAMEOPTION_EXCLUDE_TIES: u32 = 131072;
pub const FRAMEOPTION_START_OFFSET: u32 = 10240;
pub const FRAMEOPTION_END_OFFSET: u32 = 20480;
pub const FRAMEOPTION_EXCLUSION: u32 = 229376;
pub const FRAMEOPTION_DEFAULTS: u32 = 1058;
pub const FKCONSTR_ACTION_NOACTION: u8 = 97u8;
pub const FKCONSTR_ACTION_RESTRICT: u8 = 114u8;
pub const FKCONSTR_ACTION_CASCADE: u8 = 99u8;
pub const FKCONSTR_ACTION_SETNULL: u8 = 110u8;
pub const FKCONSTR_ACTION_SETDEFAULT: u8 = 100u8;
pub const FKCONSTR_MATCH_FULL: u8 = 102u8;
pub const FKCONSTR_MATCH_PARTIAL: u8 = 112u8;
pub const FKCONSTR_MATCH_SIMPLE: u8 = 115u8;
pub const OPCLASS_ITEM_OPERATOR: u32 = 1;
pub const OPCLASS_ITEM_FUNCTION: u32 = 2;
pub const OPCLASS_ITEM_STORAGETYPE: u32 = 3;
pub const CURSOR_OPT_BINARY: u32 = 1;
pub const CURSOR_OPT_SCROLL: u32 = 2;
pub const CURSOR_OPT_NO_SCROLL: u32 = 4;
pub const CURSOR_OPT_INSENSITIVE: u32 = 8;
pub const CURSOR_OPT_ASENSITIVE: u32 = 16;
pub const CURSOR_OPT_HOLD: u32 = 32;
pub const CURSOR_OPT_FAST_PLAN: u32 = 256;
pub const CURSOR_OPT_GENERIC_PLAN: u32 = 512;
pub const CURSOR_OPT_CUSTOM_PLAN: u32 = 1024;
pub const CURSOR_OPT_PARALLEL_OK: u32 = 2048;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const DSM_IMPL_POSIX: u32 = 1;
pub const DSM_IMPL_SYSV: u32 = 2;
pub const DSM_IMPL_WINDOWS: u32 = 3;
pub const DSM_IMPL_MMAP: u32 = 4;
pub const DEFAULT_DYNAMIC_SHARED_MEMORY_TYPE: u32 = 1;
pub const PG_DYNSHMEM_DIR: &[u8; 12] = b"pg_dynshmem\0";
pub const PG_DYNSHMEM_MMAP_FILE_PREFIX: &[u8; 6] = b"mmap.\0";
pub const DSM_CREATE_NULL_IF_MAXSEGMENTS: u32 = 1;
pub const SIZEOF_DSA_POINTER: u32 = 8;
pub const DSA_POINTER_FORMAT: &[u8; 7] = b"%016lx\0";
pub const DSA_ALLOC_HUGE: u32 = 1;
pub const DSA_ALLOC_NO_OOM: u32 = 2;
pub const DSA_ALLOC_ZERO: u32 = 4;
pub const DEFAULT_SPINS_PER_DELAY: u32 = 100;
pub const HASH_PARTITION: u32 = 1;
pub const HASH_SEGMENT: u32 = 2;
pub const HASH_DIRSIZE: u32 = 4;
pub const HASH_ELEM: u32 = 8;
pub const HASH_STRINGS: u32 = 16;
pub const HASH_BLOBS: u32 = 32;
pub const HASH_FUNCTION: u32 = 64;
pub const HASH_COMPARE: u32 = 128;
pub const HASH_KEYCOPY: u32 = 256;
pub const HASH_ALLOC: u32 = 512;
pub const HASH_CONTEXT: u32 = 1024;
pub const HASH_SHARED_MEM: u32 = 2048;
pub const HASH_ATTACH: u32 = 4096;
pub const HASH_FIXED_SIZE: u32 = 8192;
pub const NO_MAX_DSIZE: i32 = -1;
pub const _DIRENT_H: u32 = 1;
pub const _DIRENT_MATCHES_DIRENT64: u32 = 1;
pub const MAXNAMLEN: u32 = 255;
pub const IO_DIRECT_DATA: u32 = 1;
pub const IO_DIRECT_WAL: u32 = 2;
pub const IO_DIRECT_WAL_INIT: u32 = 4;
pub const PG_O_DIRECT: u32 = 0;
pub const PG_TEMP_FILES_DIR: &[u8; 10] = b"pgsql_tmp\0";
pub const PG_TEMP_FILE_PREFIX: &[u8; 10] = b"pgsql_tmp\0";
pub const SHARED_TUPLESTORE_SINGLE_PASS: u32 = 1;
pub const MAX_TIMESTAMP_PRECISION: u32 = 6;
pub const MAX_INTERVAL_PRECISION: u32 = 6;
pub const TS_PREC_INV: f64 = 1000000.0;
pub const DAYS_PER_YEAR: f64 = 365.25;
pub const MONTHS_PER_YEAR: u32 = 12;
pub const DAYS_PER_MONTH: u32 = 30;
pub const HOURS_PER_DAY: u32 = 24;
pub const SECS_PER_YEAR: u32 = 31557600;
pub const SECS_PER_DAY: u32 = 86400;
pub const SECS_PER_HOUR: u32 = 3600;
pub const SECS_PER_MINUTE: u32 = 60;
pub const MINS_PER_HOUR: u32 = 60;
pub const MAX_TZDISP_HOUR: u32 = 15;
pub const TZDISP_LIMIT: u32 = 57600;
pub const JULIAN_MINYEAR: i32 = -4713;
pub const JULIAN_MINMONTH: u32 = 11;
pub const JULIAN_MINDAY: u32 = 24;
pub const JULIAN_MAXYEAR: u32 = 5874898;
pub const JULIAN_MAXMONTH: u32 = 6;
pub const JULIAN_MAXDAY: u32 = 3;
pub const UNIX_EPOCH_JDATE: u32 = 2440588;
pub const POSTGRES_EPOCH_JDATE: u32 = 2451545;
pub const DATETIME_MIN_JULIAN: u32 = 0;
pub const DATE_END_JULIAN: u32 = 2147483494;
pub const TIMESTAMP_END_JULIAN: u32 = 109203528;
pub const RELCACHE_INIT_FILENAME: &[u8; 17] = b"pg_internal.init\0";
pub const INDEX_SIZE_MASK: u32 = 8191;
pub const INDEX_AM_RESERVED_BIT: u32 = 8192;
pub const INDEX_VAR_MASK: u32 = 16384;
pub const INDEX_NULL_MASK: u32 = 32768;
pub const NUM_TUPLESORTMETHODS: u32 = 4;
pub const TUPLESORT_NONE: u32 = 0;
pub const TUPLESORT_RANDOMACCESS: u32 = 1;
pub const TUPLESORT_ALLOWBOUNDED: u32 = 2;
pub const EEO_FLAG_IS_QUAL: u32 = 1;
pub const FIELDNO_EXPRSTATE_RESNULL: u32 = 2;
pub const FIELDNO_EXPRSTATE_RESVALUE: u32 = 3;
pub const FIELDNO_EXPRSTATE_RESULTSLOT: u32 = 4;
pub const FIELDNO_EXPRSTATE_PARENT: u32 = 11;
pub const FIELDNO_EXPRCONTEXT_SCANTUPLE: u32 = 1;
pub const FIELDNO_EXPRCONTEXT_INNERTUPLE: u32 = 2;
pub const FIELDNO_EXPRCONTEXT_OUTERTUPLE: u32 = 3;
pub const FIELDNO_EXPRCONTEXT_AGGVALUES: u32 = 8;
pub const FIELDNO_EXPRCONTEXT_AGGNULLS: u32 = 9;
pub const FIELDNO_EXPRCONTEXT_CASEDATUM: u32 = 10;
pub const FIELDNO_EXPRCONTEXT_CASENULL: u32 = 11;
pub const FIELDNO_EXPRCONTEXT_DOMAINDATUM: u32 = 12;
pub const FIELDNO_EXPRCONTEXT_DOMAINNULL: u32 = 13;
pub const TRY_POPCNT_FAST: u32 = 1;
pub const MERGE_INSERT: u32 = 1;
pub const MERGE_UPDATE: u32 = 2;
pub const MERGE_DELETE: u32 = 4;
pub const FIELDNO_AGGSTATE_CURAGGCONTEXT: u32 = 14;
pub const FIELDNO_AGGSTATE_CURPERTRANS: u32 = 16;
pub const FIELDNO_AGGSTATE_CURRENT_SET: u32 = 20;
pub const FIELDNO_AGGSTATE_ALL_PERGROUPS: u32 = 53;
pub const COMPLETION_TAG_BUFSIZE: u32 = 64;
pub const MaxAllocHugeSize: u32 = 0;
pub const InvalidAllocSize: i32 = -1;
pub const ALLOCSET_DEFAULT_MINSIZE: u32 = 0;
pub const ALLOCSET_DEFAULT_INITSIZE: u32 = 8192;
pub const ALLOCSET_DEFAULT_MAXSIZE: u32 = 8388608;
pub const ALLOCSET_SMALL_MINSIZE: u32 = 0;
pub const ALLOCSET_SMALL_INITSIZE: u32 = 1024;
pub const ALLOCSET_SMALL_MAXSIZE: u32 = 8192;
pub const ALLOCSET_SEPARATE_THRESHOLD: u32 = 8192;
pub const SLAB_DEFAULT_BLOCK_SIZE: u32 = 8192;
pub const SLAB_LARGE_BLOCK_SIZE: u32 = 8388608;
pub const EXEC_FLAG_EXPLAIN_ONLY: u32 = 1;
pub const EXEC_FLAG_EXPLAIN_GENERIC: u32 = 2;
pub const EXEC_FLAG_REWIND: u32 = 4;
pub const EXEC_FLAG_BACKWARD: u32 = 8;
pub const EXEC_FLAG_MARK: u32 = 16;
pub const EXEC_FLAG_SKIP_TRIGGERS: u32 = 32;
pub const EXEC_FLAG_WITH_NO_DATA: u32 = 64;
pub const MAT_SRF_USE_EXPECTED_DESC: u32 = 1;
pub const MAT_SRF_BLESS: u32 = 2;
pub const _BITS_SIGNUM_GENERIC_H: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGILL: u32 = 4;
pub const SIGABRT: u32 = 6;
pub const SIGFPE: u32 = 8;
pub const SIGSEGV: u32 = 11;
pub const SIGTERM: u32 = 15;
pub const SIGHUP: u32 = 1;
pub const SIGQUIT: u32 = 3;
pub const SIGTRAP: u32 = 5;
pub const SIGKILL: u32 = 9;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGIOT: u32 = 6;
pub const _BITS_SIGNUM_ARCH_H: u32 = 1;
pub const SIGSTKFLT: u32 = 16;
pub const SIGPWR: u32 = 30;
pub const SIGBUS: u32 = 7;
pub const SIGSYS: u32 = 31;
pub const SIGURG: u32 = 23;
pub const SIGSTOP: u32 = 19;
pub const SIGTSTP: u32 = 20;
pub const SIGCONT: u32 = 18;
pub const SIGCHLD: u32 = 17;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGPOLL: u32 = 29;
pub const SIGXFSZ: u32 = 25;
pub const SIGXCPU: u32 = 24;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGUSR1: u32 = 10;
pub const SIGUSR2: u32 = 12;
pub const SIGWINCH: u32 = 28;
pub const SIGIO: u32 = 29;
pub const SIGCLD: u32 = 17;
pub const __SIGRTMIN: u32 = 32;
pub const __SIGRTMAX: u32 = 64;
pub const _NSIG: u32 = 65;
pub const __sig_atomic_t_defined: u32 = 1;
pub const __siginfo_t_defined: u32 = 1;
pub const __SI_MAX_SIZE: u32 = 128;
pub const _BITS_SIGINFO_ARCH_H: u32 = 1;
pub const __SI_ERRNO_THEN_CODE: u32 = 1;
pub const __SI_HAVE_SIGSYS: u32 = 1;
pub const _BITS_SIGINFO_CONSTS_H: u32 = 1;
pub const __SI_ASYNCIO_AFTER_SIGIO: u32 = 1;
pub const __sigevent_t_defined: u32 = 1;
pub const __SIGEV_MAX_SIZE: u32 = 64;
pub const _BITS_SIGEVENT_CONSTS_H: u32 = 1;
pub const NSIG: u32 = 65;
pub const _BITS_SIGACTION_H: u32 = 1;
pub const SA_NOCLDSTOP: u32 = 1;
pub const SA_NOCLDWAIT: u32 = 2;
pub const SA_SIGINFO: u32 = 4;
pub const SA_ONSTACK: u32 = 134217728;
pub const SA_RESTART: u32 = 268435456;
pub const SA_NODEFER: u32 = 1073741824;
pub const SA_RESETHAND: u32 = 2147483648;
pub const SA_INTERRUPT: u32 = 536870912;
pub const SA_NOMASK: u32 = 1073741824;
pub const SA_ONESHOT: u32 = 2147483648;
pub const SA_STACK: u32 = 134217728;
pub const SIG_BLOCK: u32 = 0;
pub const SIG_UNBLOCK: u32 = 1;
pub const SIG_SETMASK: u32 = 2;
pub const _BITS_SIGCONTEXT_H: u32 = 1;
pub const FP_XSTATE_MAGIC1: u32 = 1179670611;
pub const FP_XSTATE_MAGIC2: u32 = 1179670597;
pub const __stack_t_defined: u32 = 1;
pub const _SYS_UCONTEXT_H: u32 = 1;
pub const __NGREG: u32 = 23;
pub const NGREG: u32 = 23;
pub const _BITS_SIGSTACK_H: u32 = 1;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const _BITS_SS_FLAGS_H: u32 = 1;
pub const __sigstack_defined: u32 = 1;
pub const _BITS_SIGTHREAD_H: u32 = 1;
pub const TZ_STRLEN_MAX: u32 = 255;
pub const InvalidPid: i32 = -1;
pub const USE_POSTGRES_DATES: u32 = 0;
pub const USE_ISO_DATES: u32 = 1;
pub const USE_SQL_DATES: u32 = 2;
pub const USE_GERMAN_DATES: u32 = 3;
pub const USE_XSD_DATES: u32 = 4;
pub const DATEORDER_YMD: u32 = 0;
pub const DATEORDER_DMY: u32 = 1;
pub const DATEORDER_MDY: u32 = 2;
pub const INTSTYLE_POSTGRES: u32 = 0;
pub const INTSTYLE_POSTGRES_VERBOSE: u32 = 1;
pub const INTSTYLE_SQL_STANDARD: u32 = 2;
pub const INTSTYLE_ISO_8601: u32 = 3;
pub const MAXTZLEN: u32 = 10;
pub const MIN_BAS_VAC_RING_SIZE_KB: u32 = 128;
pub const MAX_BAS_VAC_RING_SIZE_KB: u32 = 16777216;
pub const SECURITY_LOCAL_USERID_CHANGE: u32 = 1;
pub const SECURITY_RESTRICTED_OPERATION: u32 = 2;
pub const SECURITY_NOFORCE_RLS: u32 = 4;
pub const MIN_XFN_CHARS: u32 = 16;
pub const MAX_XFN_CHARS: u32 = 40;
pub const VALID_XFN_CHARS: &[u8; 40] = b"0123456789ABCDEF.history.backup.partial\0";
pub const PGSTAT_NUM_PROGRESS_PARAM: u32 = 20;
pub const _SYS_SOCKET_H: u32 = 1;
pub const __iovec_defined: u32 = 1;
pub const PF_UNSPEC: u32 = 0;
pub const PF_LOCAL: u32 = 1;
pub const PF_UNIX: u32 = 1;
pub const PF_FILE: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_AX25: u32 = 3;
pub const PF_IPX: u32 = 4;
pub const PF_APPLETALK: u32 = 5;
pub const PF_NETROM: u32 = 6;
pub const PF_BRIDGE: u32 = 7;
pub const PF_ATMPVC: u32 = 8;
pub const PF_X25: u32 = 9;
pub const PF_INET6: u32 = 10;
pub const PF_ROSE: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_NETBEUI: u32 = 13;
pub const PF_SECURITY: u32 = 14;
pub const PF_KEY: u32 = 15;
pub const PF_NETLINK: u32 = 16;
pub const PF_ROUTE: u32 = 16;
pub const PF_PACKET: u32 = 17;
pub const PF_ASH: u32 = 18;
pub const PF_ECONET: u32 = 19;
pub const PF_ATMSVC: u32 = 20;
pub const PF_RDS: u32 = 21;
pub const PF_SNA: u32 = 22;
pub const PF_IRDA: u32 = 23;
pub const PF_PPPOX: u32 = 24;
pub const PF_WANPIPE: u32 = 25;
pub const PF_LLC: u32 = 26;
pub const PF_IB: u32 = 27;
pub const PF_MPLS: u32 = 28;
pub const PF_CAN: u32 = 29;
pub const PF_TIPC: u32 = 30;
pub const PF_BLUETOOTH: u32 = 31;
pub const PF_IUCV: u32 = 32;
pub const PF_RXRPC: u32 = 33;
pub const PF_ISDN: u32 = 34;
pub const PF_PHONET: u32 = 35;
pub const PF_IEEE802154: u32 = 36;
pub const PF_CAIF: u32 = 37;
pub const PF_ALG: u32 = 38;
pub const PF_NFC: u32 = 39;
pub const PF_VSOCK: u32 = 40;
pub const PF_KCM: u32 = 41;
pub const PF_QIPCRTR: u32 = 42;
pub const PF_SMC: u32 = 43;
pub const PF_XDP: u32 = 44;
pub const PF_MCTP: u32 = 45;
pub const PF_MAX: u32 = 46;
pub const AF_UNSPEC: u32 = 0;
pub const AF_LOCAL: u32 = 1;
pub const AF_UNIX: u32 = 1;
pub const AF_FILE: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_AX25: u32 = 3;
pub const AF_IPX: u32 = 4;
pub const AF_APPLETALK: u32 = 5;
pub const AF_NETROM: u32 = 6;
pub const AF_BRIDGE: u32 = 7;
pub const AF_ATMPVC: u32 = 8;
pub const AF_X25: u32 = 9;
pub const AF_INET6: u32 = 10;
pub const AF_ROSE: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_NETBEUI: u32 = 13;
pub const AF_SECURITY: u32 = 14;
pub const AF_KEY: u32 = 15;
pub const AF_NETLINK: u32 = 16;
pub const AF_ROUTE: u32 = 16;
pub const AF_PACKET: u32 = 17;
pub const AF_ASH: u32 = 18;
pub const AF_ECONET: u32 = 19;
pub const AF_ATMSVC: u32 = 20;
pub const AF_RDS: u32 = 21;
pub const AF_SNA: u32 = 22;
pub const AF_IRDA: u32 = 23;
pub const AF_PPPOX: u32 = 24;
pub const AF_WANPIPE: u32 = 25;
pub const AF_LLC: u32 = 26;
pub const AF_IB: u32 = 27;
pub const AF_MPLS: u32 = 28;
pub const AF_CAN: u32 = 29;
pub const AF_TIPC: u32 = 30;
pub const AF_BLUETOOTH: u32 = 31;
pub const AF_IUCV: u32 = 32;
pub const AF_RXRPC: u32 = 33;
pub const AF_ISDN: u32 = 34;
pub const AF_PHONET: u32 = 35;
pub const AF_IEEE802154: u32 = 36;
pub const AF_CAIF: u32 = 37;
pub const AF_ALG: u32 = 38;
pub const AF_NFC: u32 = 39;
pub const AF_VSOCK: u32 = 40;
pub const AF_KCM: u32 = 41;
pub const AF_QIPCRTR: u32 = 42;
pub const AF_SMC: u32 = 43;
pub const AF_XDP: u32 = 44;
pub const AF_MCTP: u32 = 45;
pub const AF_MAX: u32 = 46;
pub const SOL_RAW: u32 = 255;
pub const SOL_DECNET: u32 = 261;
pub const SOL_X25: u32 = 262;
pub const SOL_PACKET: u32 = 263;
pub const SOL_ATM: u32 = 264;
pub const SOL_AAL: u32 = 265;
pub const SOL_IRDA: u32 = 266;
pub const SOL_NETBEUI: u32 = 267;
pub const SOL_LLC: u32 = 268;
pub const SOL_DCCP: u32 = 269;
pub const SOL_NETLINK: u32 = 270;
pub const SOL_TIPC: u32 = 271;
pub const SOL_RXRPC: u32 = 272;
pub const SOL_PPPOL2TP: u32 = 273;
pub const SOL_BLUETOOTH: u32 = 274;
pub const SOL_PNPIPE: u32 = 275;
pub const SOL_RDS: u32 = 276;
pub const SOL_IUCV: u32 = 277;
pub const SOL_CAIF: u32 = 278;
pub const SOL_ALG: u32 = 279;
pub const SOL_NFC: u32 = 280;
pub const SOL_KCM: u32 = 281;
pub const SOL_TLS: u32 = 282;
pub const SOL_XDP: u32 = 283;
pub const SOMAXCONN: u32 = 4096;
pub const _BITS_SOCKADDR_H: u32 = 1;
pub const _SS_SIZE: u32 = 128;
pub const __BITS_PER_LONG: u32 = 64;
pub const FIOSETOWN: u32 = 35073;
pub const SIOCSPGRP: u32 = 35074;
pub const FIOGETOWN: u32 = 35075;
pub const SIOCGPGRP: u32 = 35076;
pub const SIOCATMARK: u32 = 35077;
pub const SIOCGSTAMP_OLD: u32 = 35078;
pub const SIOCGSTAMPNS_OLD: u32 = 35079;
pub const SOL_SOCKET: u32 = 1;
pub const SO_DEBUG: u32 = 1;
pub const SO_REUSEADDR: u32 = 2;
pub const SO_TYPE: u32 = 3;
pub const SO_ERROR: u32 = 4;
pub const SO_DONTROUTE: u32 = 5;
pub const SO_BROADCAST: u32 = 6;
pub const SO_SNDBUF: u32 = 7;
pub const SO_RCVBUF: u32 = 8;
pub const SO_SNDBUFFORCE: u32 = 32;
pub const SO_RCVBUFFORCE: u32 = 33;
pub const SO_KEEPALIVE: u32 = 9;
pub const SO_OOBINLINE: u32 = 10;
pub const SO_NO_CHECK: u32 = 11;
pub const SO_PRIORITY: u32 = 12;
pub const SO_LINGER: u32 = 13;
pub const SO_BSDCOMPAT: u32 = 14;
pub const SO_REUSEPORT: u32 = 15;
pub const SO_PASSCRED: u32 = 16;
pub const SO_PEERCRED: u32 = 17;
pub const SO_RCVLOWAT: u32 = 18;
pub const SO_SNDLOWAT: u32 = 19;
pub const SO_RCVTIMEO_OLD: u32 = 20;
pub const SO_SNDTIMEO_OLD: u32 = 21;
pub const SO_SECURITY_AUTHENTICATION: u32 = 22;
pub const SO_SECURITY_ENCRYPTION_TRANSPORT: u32 = 23;
pub const SO_SECURITY_ENCRYPTION_NETWORK: u32 = 24;
pub const SO_BINDTODEVICE: u32 = 25;
pub const SO_ATTACH_FILTER: u32 = 26;
pub const SO_DETACH_FILTER: u32 = 27;
pub const SO_GET_FILTER: u32 = 26;
pub const SO_PEERNAME: u32 = 28;
pub const SO_ACCEPTCONN: u32 = 30;
pub const SO_PEERSEC: u32 = 31;
pub const SO_PASSSEC: u32 = 34;
pub const SO_MARK: u32 = 36;
pub const SO_PROTOCOL: u32 = 38;
pub const SO_DOMAIN: u32 = 39;
pub const SO_RXQ_OVFL: u32 = 40;
pub const SO_WIFI_STATUS: u32 = 41;
pub const SCM_WIFI_STATUS: u32 = 41;
pub const SO_PEEK_OFF: u32 = 42;
pub const SO_NOFCS: u32 = 43;
pub const SO_LOCK_FILTER: u32 = 44;
pub const SO_SELECT_ERR_QUEUE: u32 = 45;
pub const SO_BUSY_POLL: u32 = 46;
pub const SO_MAX_PACING_RATE: u32 = 47;
pub const SO_BPF_EXTENSIONS: u32 = 48;
pub const SO_INCOMING_CPU: u32 = 49;
pub const SO_ATTACH_BPF: u32 = 50;
pub const SO_DETACH_BPF: u32 = 27;
pub const SO_ATTACH_REUSEPORT_CBPF: u32 = 51;
pub const SO_ATTACH_REUSEPORT_EBPF: u32 = 52;
pub const SO_CNX_ADVICE: u32 = 53;
pub const SCM_TIMESTAMPING_OPT_STATS: u32 = 54;
pub const SO_MEMINFO: u32 = 55;
pub const SO_INCOMING_NAPI_ID: u32 = 56;
pub const SO_COOKIE: u32 = 57;
pub const SCM_TIMESTAMPING_PKTINFO: u32 = 58;
pub const SO_PEERGROUPS: u32 = 59;
pub const SO_ZEROCOPY: u32 = 60;
pub const SO_TXTIME: u32 = 61;
pub const SCM_TXTIME: u32 = 61;
pub const SO_BINDTOIFINDEX: u32 = 62;
pub const SO_TIMESTAMP_OLD: u32 = 29;
pub const SO_TIMESTAMPNS_OLD: u32 = 35;
pub const SO_TIMESTAMPING_OLD: u32 = 37;
pub const SO_TIMESTAMP_NEW: u32 = 63;
pub const SO_TIMESTAMPNS_NEW: u32 = 64;
pub const SO_TIMESTAMPING_NEW: u32 = 65;
pub const SO_RCVTIMEO_NEW: u32 = 66;
pub const SO_SNDTIMEO_NEW: u32 = 67;
pub const SO_DETACH_REUSEPORT_BPF: u32 = 68;
pub const SO_PREFER_BUSY_POLL: u32 = 69;
pub const SO_BUSY_POLL_BUDGET: u32 = 70;
pub const SO_NETNS_COOKIE: u32 = 71;
pub const SO_BUF_LOCK: u32 = 72;
pub const SO_TIMESTAMP: u32 = 29;
pub const SO_TIMESTAMPNS: u32 = 35;
pub const SO_TIMESTAMPING: u32 = 37;
pub const SO_RCVTIMEO: u32 = 20;
pub const SO_SNDTIMEO: u32 = 21;
pub const SCM_TIMESTAMP: u32 = 29;
pub const SCM_TIMESTAMPNS: u32 = 35;
pub const SCM_TIMESTAMPING: u32 = 37;
pub const __osockaddr_defined: u32 = 1;
pub const _SYS_UN_H: u32 = 1;
pub const _NETDB_H: u32 = 1;
pub const _NETINET_IN_H: u32 = 1;
pub const __USE_KERNEL_IPV6_DEFS: u32 = 0;
pub const IP_OPTIONS: u32 = 4;
pub const IP_HDRINCL: u32 = 3;
pub const IP_TOS: u32 = 1;
pub const IP_TTL: u32 = 2;
pub const IP_RECVOPTS: u32 = 6;
pub const IP_RETOPTS: u32 = 7;
pub const IP_MULTICAST_IF: u32 = 32;
pub const IP_MULTICAST_TTL: u32 = 33;
pub const IP_MULTICAST_LOOP: u32 = 34;
pub const IP_ADD_MEMBERSHIP: u32 = 35;
pub const IP_DROP_MEMBERSHIP: u32 = 36;
pub const IP_UNBLOCK_SOURCE: u32 = 37;
pub const IP_BLOCK_SOURCE: u32 = 38;
pub const IP_ADD_SOURCE_MEMBERSHIP: u32 = 39;
pub const IP_DROP_SOURCE_MEMBERSHIP: u32 = 40;
pub const IP_MSFILTER: u32 = 41;
pub const MCAST_JOIN_GROUP: u32 = 42;
pub const MCAST_BLOCK_SOURCE: u32 = 43;
pub const MCAST_UNBLOCK_SOURCE: u32 = 44;
pub const MCAST_LEAVE_GROUP: u32 = 45;
pub const MCAST_JOIN_SOURCE_GROUP: u32 = 46;
pub const MCAST_LEAVE_SOURCE_GROUP: u32 = 47;
pub const MCAST_MSFILTER: u32 = 48;
pub const IP_MULTICAST_ALL: u32 = 49;
pub const IP_UNICAST_IF: u32 = 50;
pub const MCAST_EXCLUDE: u32 = 0;
pub const MCAST_INCLUDE: u32 = 1;
pub const IP_ROUTER_ALERT: u32 = 5;
pub const IP_PKTINFO: u32 = 8;
pub const IP_PKTOPTIONS: u32 = 9;
pub const IP_PMTUDISC: u32 = 10;
pub const IP_MTU_DISCOVER: u32 = 10;
pub const IP_RECVERR: u32 = 11;
pub const IP_RECVTTL: u32 = 12;
pub const IP_RECVTOS: u32 = 13;
pub const IP_MTU: u32 = 14;
pub const IP_FREEBIND: u32 = 15;
pub const IP_IPSEC_POLICY: u32 = 16;
pub const IP_XFRM_POLICY: u32 = 17;
pub const IP_PASSSEC: u32 = 18;
pub const IP_TRANSPARENT: u32 = 19;
pub const IP_ORIGDSTADDR: u32 = 20;
pub const IP_RECVORIGDSTADDR: u32 = 20;
pub const IP_MINTTL: u32 = 21;
pub const IP_NODEFRAG: u32 = 22;
pub const IP_CHECKSUM: u32 = 23;
pub const IP_BIND_ADDRESS_NO_PORT: u32 = 24;
pub const IP_RECVFRAGSIZE: u32 = 25;
pub const IP_RECVERR_RFC4884: u32 = 26;
pub const IP_PMTUDISC_DONT: u32 = 0;
pub const IP_PMTUDISC_WANT: u32 = 1;
pub const IP_PMTUDISC_DO: u32 = 2;
pub const IP_PMTUDISC_PROBE: u32 = 3;
pub const IP_PMTUDISC_INTERFACE: u32 = 4;
pub const IP_PMTUDISC_OMIT: u32 = 5;
pub const SOL_IP: u32 = 0;
pub const IP_DEFAULT_MULTICAST_TTL: u32 = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IP_MAX_MEMBERSHIPS: u32 = 20;
pub const IPV6_ADDRFORM: u32 = 1;
pub const IPV6_2292PKTINFO: u32 = 2;
pub const IPV6_2292HOPOPTS: u32 = 3;
pub const IPV6_2292DSTOPTS: u32 = 4;
pub const IPV6_2292RTHDR: u32 = 5;
pub const IPV6_2292PKTOPTIONS: u32 = 6;
pub const IPV6_CHECKSUM: u32 = 7;
pub const IPV6_2292HOPLIMIT: u32 = 8;
pub const IPV6_NEXTHOP: u32 = 9;
pub const IPV6_AUTHHDR: u32 = 10;
pub const IPV6_UNICAST_HOPS: u32 = 16;
pub const IPV6_MULTICAST_IF: u32 = 17;
pub const IPV6_MULTICAST_HOPS: u32 = 18;
pub const IPV6_MULTICAST_LOOP: u32 = 19;
pub const IPV6_JOIN_GROUP: u32 = 20;
pub const IPV6_LEAVE_GROUP: u32 = 21;
pub const IPV6_ROUTER_ALERT: u32 = 22;
pub const IPV6_MTU_DISCOVER: u32 = 23;
pub const IPV6_MTU: u32 = 24;
pub const IPV6_RECVERR: u32 = 25;
pub const IPV6_V6ONLY: u32 = 26;
pub const IPV6_JOIN_ANYCAST: u32 = 27;
pub const IPV6_LEAVE_ANYCAST: u32 = 28;
pub const IPV6_MULTICAST_ALL: u32 = 29;
pub const IPV6_ROUTER_ALERT_ISOLATE: u32 = 30;
pub const IPV6_RECVERR_RFC4884: u32 = 31;
pub const IPV6_IPSEC_POLICY: u32 = 34;
pub const IPV6_XFRM_POLICY: u32 = 35;
pub const IPV6_HDRINCL: u32 = 36;
pub const IPV6_RECVPKTINFO: u32 = 49;
pub const IPV6_PKTINFO: u32 = 50;
pub const IPV6_RECVHOPLIMIT: u32 = 51;
pub const IPV6_HOPLIMIT: u32 = 52;
pub const IPV6_RECVHOPOPTS: u32 = 53;
pub const IPV6_HOPOPTS: u32 = 54;
pub const IPV6_RTHDRDSTOPTS: u32 = 55;
pub const IPV6_RECVRTHDR: u32 = 56;
pub const IPV6_RTHDR: u32 = 57;
pub const IPV6_RECVDSTOPTS: u32 = 58;
pub const IPV6_DSTOPTS: u32 = 59;
pub const IPV6_RECVPATHMTU: u32 = 60;
pub const IPV6_PATHMTU: u32 = 61;
pub const IPV6_DONTFRAG: u32 = 62;
pub const IPV6_RECVTCLASS: u32 = 66;
pub const IPV6_TCLASS: u32 = 67;
pub const IPV6_AUTOFLOWLABEL: u32 = 70;
pub const IPV6_ADDR_PREFERENCES: u32 = 72;
pub const IPV6_MINHOPCOUNT: u32 = 73;
pub const IPV6_ORIGDSTADDR: u32 = 74;
pub const IPV6_RECVORIGDSTADDR: u32 = 74;
pub const IPV6_TRANSPARENT: u32 = 75;
pub const IPV6_UNICAST_IF: u32 = 76;
pub const IPV6_RECVFRAGSIZE: u32 = 77;
pub const IPV6_FREEBIND: u32 = 78;
pub const IPV6_ADD_MEMBERSHIP: u32 = 20;
pub const IPV6_DROP_MEMBERSHIP: u32 = 21;
pub const IPV6_RXHOPOPTS: u32 = 54;
pub const IPV6_RXDSTOPTS: u32 = 59;
pub const IPV6_PMTUDISC_DONT: u32 = 0;
pub const IPV6_PMTUDISC_WANT: u32 = 1;
pub const IPV6_PMTUDISC_DO: u32 = 2;
pub const IPV6_PMTUDISC_PROBE: u32 = 3;
pub const IPV6_PMTUDISC_INTERFACE: u32 = 4;
pub const IPV6_PMTUDISC_OMIT: u32 = 5;
pub const SOL_IPV6: u32 = 41;
pub const SOL_ICMPV6: u32 = 58;
pub const IPV6_RTHDR_LOOSE: u32 = 0;
pub const IPV6_RTHDR_STRICT: u32 = 1;
pub const IPV6_RTHDR_TYPE_0: u32 = 0;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_LOOPBACKNET: u32 = 127;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const INET6_ADDRSTRLEN: u32 = 46;
pub const _RPC_NETDB_H: u32 = 1;
pub const _PATH_HEQUIV: &[u8; 17] = b"/etc/hosts.equiv\0";
pub const _PATH_HOSTS: &[u8; 11] = b"/etc/hosts\0";
pub const _PATH_NETWORKS: &[u8; 14] = b"/etc/networks\0";
pub const _PATH_NSSWITCH_CONF: &[u8; 19] = b"/etc/nsswitch.conf\0";
pub const _PATH_PROTOCOLS: &[u8; 15] = b"/etc/protocols\0";
pub const _PATH_SERVICES: &[u8; 14] = b"/etc/services\0";
pub const HOST_NOT_FOUND: u32 = 1;
pub const TRY_AGAIN: u32 = 2;
pub const NO_RECOVERY: u32 = 3;
pub const NO_DATA: u32 = 4;
pub const NETDB_INTERNAL: i32 = -1;
pub const NETDB_SUCCESS: u32 = 0;
pub const NO_ADDRESS: u32 = 4;
pub const AI_PASSIVE: u32 = 1;
pub const AI_CANONNAME: u32 = 2;
pub const AI_NUMERICHOST: u32 = 4;
pub const AI_V4MAPPED: u32 = 8;
pub const AI_ALL: u32 = 16;
pub const AI_ADDRCONFIG: u32 = 32;
pub const AI_NUMERICSERV: u32 = 1024;
pub const EAI_BADFLAGS: i32 = -1;
pub const EAI_NONAME: i32 = -2;
pub const EAI_AGAIN: i32 = -3;
pub const EAI_FAIL: i32 = -4;
pub const EAI_FAMILY: i32 = -6;
pub const EAI_SOCKTYPE: i32 = -7;
pub const EAI_SERVICE: i32 = -8;
pub const EAI_MEMORY: i32 = -10;
pub const EAI_SYSTEM: i32 = -11;
pub const EAI_OVERFLOW: i32 = -12;
pub const NI_MAXHOST: u32 = 1025;
pub const NI_MAXSERV: u32 = 32;
pub const NI_NUMERICHOST: u32 = 1;
pub const NI_NUMERICSERV: u32 = 2;
pub const NI_NOFQDN: u32 = 4;
pub const NI_NAMEREQD: u32 = 8;
pub const NI_DGRAM: u32 = 16;
pub const MAX_STARTUP_PACKET_LENGTH: u32 = 10000;
pub const AUTH_REQ_OK: u32 = 0;
pub const AUTH_REQ_KRB4: u32 = 1;
pub const AUTH_REQ_KRB5: u32 = 2;
pub const AUTH_REQ_PASSWORD: u32 = 3;
pub const AUTH_REQ_CRYPT: u32 = 4;
pub const AUTH_REQ_MD5: u32 = 5;
pub const AUTH_REQ_GSS: u32 = 7;
pub const AUTH_REQ_GSS_CONT: u32 = 8;
pub const AUTH_REQ_SSPI: u32 = 9;
pub const AUTH_REQ_SASL: u32 = 10;
pub const AUTH_REQ_SASL_CONT: u32 = 11;
pub const AUTH_REQ_SASL_FIN: u32 = 12;
pub const AUTH_REQ_MAX: u32 = 12;
pub const InvalidBackendId: i32 = -1;
pub const PG_WAIT_LWLOCK: u32 = 16777216;
pub const PG_WAIT_LOCK: u32 = 50331648;
pub const PG_WAIT_BUFFER_PIN: u32 = 67108864;
pub const PG_WAIT_ACTIVITY: u32 = 83886080;
pub const PG_WAIT_CLIENT: u32 = 100663296;
pub const PG_WAIT_EXTENSION: u32 = 117440512;
pub const PG_WAIT_IPC: u32 = 134217728;
pub const PG_WAIT_TIMEOUT: u32 = 150994944;
pub const PG_WAIT_IO: u32 = 167772160;
pub const PGSTAT_STAT_PERMANENT_DIRECTORY: &[u8; 8] = b"pg_stat\0";
pub const PGSTAT_STAT_PERMANENT_FILENAME: &[u8; 20] = b"pg_stat/pgstat.stat\0";
pub const PGSTAT_STAT_PERMANENT_TMPFILE: &[u8; 19] = b"pg_stat/pgstat.tmp\0";
pub const PG_STAT_TMP_DIR: &[u8; 12] = b"pg_stat_tmp\0";
pub const PGSTAT_FILE_FORMAT_ID: u32 = 27638956;
pub const SK_ISNULL: u32 = 1;
pub const SK_UNARY: u32 = 2;
pub const SK_ROW_HEADER: u32 = 4;
pub const SK_ROW_MEMBER: u32 = 8;
pub const SK_ROW_END: u32 = 16;
pub const SK_SEARCHARRAY: u32 = 32;
pub const SK_SEARCHNULL: u32 = 64;
pub const SK_SEARCHNOTNULL: u32 = 128;
pub const SK_ORDER_BY: u32 = 256;
pub const NoLock: u32 = 0;
pub const AccessShareLock: u32 = 1;
pub const RowShareLock: u32 = 2;
pub const RowExclusiveLock: u32 = 3;
pub const ShareUpdateExclusiveLock: u32 = 4;
pub const ShareLock: u32 = 5;
pub const ShareRowExclusiveLock: u32 = 6;
pub const ExclusiveLock: u32 = 7;
pub const AccessExclusiveLock: u32 = 8;
pub const MaxLockMode: u32 = 8;
pub const SYNC_METHOD_FSYNC: u32 = 0;
pub const SYNC_METHOD_FDATASYNC: u32 = 1;
pub const SYNC_METHOD_OPEN: u32 = 2;
pub const SYNC_METHOD_FSYNC_WRITETHROUGH: u32 = 3;
pub const SYNC_METHOD_OPEN_DSYNC: u32 = 4;
pub const CHECKPOINT_IS_SHUTDOWN: u32 = 1;
pub const CHECKPOINT_END_OF_RECOVERY: u32 = 2;
pub const CHECKPOINT_IMMEDIATE: u32 = 4;
pub const CHECKPOINT_FORCE: u32 = 8;
pub const CHECKPOINT_FLUSH_ALL: u32 = 16;
pub const CHECKPOINT_WAIT: u32 = 32;
pub const CHECKPOINT_REQUESTED: u32 = 64;
pub const CHECKPOINT_CAUSE_XLOG: u32 = 128;
pub const CHECKPOINT_CAUSE_TIME: u32 = 256;
pub const XLOG_INCLUDE_ORIGIN: u32 = 1;
pub const XLOG_MARK_UNIMPORTANT: u32 = 2;
pub const RECOVERY_SIGNAL_FILE: &[u8; 16] = b"recovery.signal\0";
pub const STANDBY_SIGNAL_FILE: &[u8; 15] = b"standby.signal\0";
pub const BACKUP_LABEL_FILE: &[u8; 13] = b"backup_label\0";
pub const BACKUP_LABEL_OLD: &[u8; 17] = b"backup_label.old\0";
pub const TABLESPACE_MAP: &[u8; 15] = b"tablespace_map\0";
pub const TABLESPACE_MAP_OLD: &[u8; 19] = b"tablespace_map.old\0";
pub const PROMOTE_SIGNAL_FILE: &[u8; 8] = b"promote\0";
pub const RM_MAX_ID: u32 = 255;
pub const RM_MIN_CUSTOM_ID: u32 = 128;
pub const RM_MAX_CUSTOM_ID: u32 = 255;
pub const RM_N_IDS: u32 = 256;
pub const RM_N_CUSTOM_IDS: u32 = 128;
pub const RM_EXPERIMENTAL_ID: u32 = 128;
pub const XLR_INFO_MASK: u32 = 15;
pub const XLR_RMGR_INFO_MASK: u32 = 240;
pub const XLogRecordMaxSize: u32 = 1069547520;
pub const XLR_SPECIAL_REL_UPDATE: u32 = 1;
pub const XLR_CHECK_CONSISTENCY: u32 = 2;
pub const BKPIMAGE_HAS_HOLE: u32 = 1;
pub const BKPIMAGE_APPLY: u32 = 2;
pub const BKPIMAGE_COMPRESS_PGLZ: u32 = 4;
pub const BKPIMAGE_COMPRESS_LZ4: u32 = 8;
pub const BKPIMAGE_COMPRESS_ZSTD: u32 = 16;
pub const BKPBLOCK_FORK_MASK: u32 = 15;
pub const BKPBLOCK_FLAG_MASK: u32 = 240;
pub const BKPBLOCK_HAS_IMAGE: u32 = 16;
pub const BKPBLOCK_HAS_DATA: u32 = 32;
pub const BKPBLOCK_WILL_INIT: u32 = 64;
pub const BKPBLOCK_SAME_REL: u32 = 128;
pub const XLR_MAX_BLOCK_ID: u32 = 32;
pub const XLR_BLOCK_ID_DATA_SHORT: u32 = 255;
pub const XLR_BLOCK_ID_DATA_LONG: u32 = 254;
pub const XLR_BLOCK_ID_ORIGIN: u32 = 253;
pub const XLR_BLOCK_ID_TOPLEVEL_XID: u32 = 252;
pub const XLOG_PAGE_MAGIC: u32 = 53523;
pub const XLP_FIRST_IS_CONTRECORD: u32 = 1;
pub const XLP_LONG_HEADER: u32 = 2;
pub const XLP_BKP_REMOVABLE: u32 = 4;
pub const XLP_FIRST_IS_OVERWRITE_CONTRECORD: u32 = 8;
pub const XLP_ALL_FLAGS: u32 = 15;
pub const WalSegMinSize: u32 = 1048576;
pub const WalSegMaxSize: u32 = 1073741824;
pub const DEFAULT_MIN_WAL_SEGS: u32 = 5;
pub const DEFAULT_MAX_WAL_SEGS: u32 = 64;
pub const XLOGDIR: &[u8; 7] = b"pg_wal\0";
pub const XLOG_CONTROL_FILE: &[u8; 18] = b"global/pg_control\0";
pub const MAXFNAMELEN: u32 = 64;
pub const XLOG_FNAME_LEN: u32 = 24;
pub const XLR_NORMAL_MAX_BLOCK_ID: u32 = 4;
pub const XLR_NORMAL_RDATAS: u32 = 20;
pub const REGBUF_FORCE_IMAGE: u32 = 1;
pub const REGBUF_NO_IMAGE: u32 = 2;
pub const REGBUF_WILL_INIT: u32 = 6;
pub const REGBUF_STANDARD: u32 = 8;
pub const REGBUF_KEEP_DATA: u32 = 16;
pub const RelationRelationId: Oid = Oid(1259);
pub const RelationRelation_Rowtype_Id: u32 = 83;
pub const ClassOidIndexId: u32 = 2662;
pub const ClassNameNspIndexId: u32 = 2663;
pub const ClassTblspcRelfilenodeIndexId: u32 = 3455;
pub const Anum_pg_class_oid: u32 = 1;
pub const Anum_pg_class_relname: u32 = 2;
pub const Anum_pg_class_relnamespace: u32 = 3;
pub const Anum_pg_class_reltype: u32 = 4;
pub const Anum_pg_class_reloftype: u32 = 5;
pub const Anum_pg_class_relowner: u32 = 6;
pub const Anum_pg_class_relam: u32 = 7;
pub const Anum_pg_class_relfilenode: u32 = 8;
pub const Anum_pg_class_reltablespace: u32 = 9;
pub const Anum_pg_class_relpages: u32 = 10;
pub const Anum_pg_class_reltuples: u32 = 11;
pub const Anum_pg_class_relallvisible: u32 = 12;
pub const Anum_pg_class_reltoastrelid: u32 = 13;
pub const Anum_pg_class_relhasindex: u32 = 14;
pub const Anum_pg_class_relisshared: u32 = 15;
pub const Anum_pg_class_relpersistence: u32 = 16;
pub const Anum_pg_class_relkind: u32 = 17;
pub const Anum_pg_class_relnatts: u32 = 18;
pub const Anum_pg_class_relchecks: u32 = 19;
pub const Anum_pg_class_relhasrules: u32 = 20;
pub const Anum_pg_class_relhastriggers: u32 = 21;
pub const Anum_pg_class_relhassubclass: u32 = 22;
pub const Anum_pg_class_relrowsecurity: u32 = 23;
pub const Anum_pg_class_relforcerowsecurity: u32 = 24;
pub const Anum_pg_class_relispopulated: u32 = 25;
pub const Anum_pg_class_relreplident: u32 = 26;
pub const Anum_pg_class_relispartition: u32 = 27;
pub const Anum_pg_class_relrewrite: u32 = 28;
pub const Anum_pg_class_relfrozenxid: u32 = 29;
pub const Anum_pg_class_relminmxid: u32 = 30;
pub const Anum_pg_class_relacl: u32 = 31;
pub const Anum_pg_class_reloptions: u32 = 32;
pub const Anum_pg_class_relpartbound: u32 = 33;
pub const Natts_pg_class: u32 = 33;
pub const RELKIND_RELATION: u8 = 114u8;
pub const RELKIND_INDEX: u8 = 105u8;
pub const RELKIND_SEQUENCE: u8 = 83u8;
pub const RELKIND_TOASTVALUE: u8 = 116u8;
pub const RELKIND_VIEW: u8 = 118u8;
pub const RELKIND_MATVIEW: u8 = 109u8;
pub const RELKIND_COMPOSITE_TYPE: u8 = 99u8;
pub const RELKIND_FOREIGN_TABLE: u8 = 102u8;
pub const RELKIND_PARTITIONED_TABLE: u8 = 112u8;
pub const RELKIND_PARTITIONED_INDEX: u8 = 73u8;
pub const RELPERSISTENCE_PERMANENT: u8 = 112u8;
pub const RELPERSISTENCE_UNLOGGED: u8 = 117u8;
pub const RELPERSISTENCE_TEMP: u8 = 116u8;
pub const REPLICA_IDENTITY_DEFAULT: u8 = 100u8;
pub const REPLICA_IDENTITY_NOTHING: u8 = 110u8;
pub const REPLICA_IDENTITY_FULL: u8 = 102u8;
pub const REPLICA_IDENTITY_INDEX: u8 = 105u8;
pub const IndexRelationId: Oid = Oid(2610);
pub const IndexIndrelidIndexId: u32 = 2678;
pub const IndexRelidIndexId: u32 = 2679;
pub const Anum_pg_index_indexrelid: u32 = 1;
pub const Anum_pg_index_indrelid: u32 = 2;
pub const Anum_pg_index_indnatts: u32 = 3;
pub const Anum_pg_index_indnkeyatts: u32 = 4;
pub const Anum_pg_index_indisunique: u32 = 5;
pub const Anum_pg_index_indnullsnotdistinct: u32 = 6;
pub const Anum_pg_index_indisprimary: u32 = 7;
pub const Anum_pg_index_indisexclusion: u32 = 8;
pub const Anum_pg_index_indimmediate: u32 = 9;
pub const Anum_pg_index_indisclustered: u32 = 10;
pub const Anum_pg_index_indisvalid: u32 = 11;
pub const Anum_pg_index_indcheckxmin: u32 = 12;
pub const Anum_pg_index_indisready: u32 = 13;
pub const Anum_pg_index_indislive: u32 = 14;
pub const Anum_pg_index_indisreplident: u32 = 15;
pub const Anum_pg_index_indkey: u32 = 16;
pub const Anum_pg_index_indcollation: u32 = 17;
pub const Anum_pg_index_indclass: u32 = 18;
pub const Anum_pg_index_indoption: u32 = 19;
pub const Anum_pg_index_indexprs: u32 = 20;
pub const Anum_pg_index_indpred: u32 = 21;
pub const Natts_pg_index: u32 = 21;
pub const INDOPTION_DESC: u32 = 1;
pub const INDOPTION_NULLS_FIRST: u32 = 2;
pub const PublicationRelationId: Oid = Oid(6104);
pub const PublicationObjectIndexId: u32 = 6110;
pub const PublicationNameIndexId: u32 = 6111;
pub const Anum_pg_publication_oid: u32 = 1;
pub const Anum_pg_publication_pubname: u32 = 2;
pub const Anum_pg_publication_pubowner: u32 = 3;
pub const Anum_pg_publication_puballtables: u32 = 4;
pub const Anum_pg_publication_pubinsert: u32 = 5;
pub const Anum_pg_publication_pubupdate: u32 = 6;
pub const Anum_pg_publication_pubdelete: u32 = 7;
pub const Anum_pg_publication_pubtruncate: u32 = 8;
pub const Anum_pg_publication_pubviaroot: u32 = 9;
pub const Natts_pg_publication: u32 = 9;
pub const HEAP_MIN_FILLFACTOR: u32 = 10;
pub const HEAP_DEFAULT_FILLFACTOR: u32 = 100;
pub const MAX_GENERIC_XLOG_PAGES: u32 = 4;
pub const GENERIC_XLOG_FULL_IMAGE: u32 = 1;
pub const GIN_COMPARE_PROC: u32 = 1;
pub const GIN_EXTRACTVALUE_PROC: u32 = 2;
pub const GIN_EXTRACTQUERY_PROC: u32 = 3;
pub const GIN_CONSISTENT_PROC: u32 = 4;
pub const GIN_COMPARE_PARTIAL_PROC: u32 = 5;
pub const GIN_TRICONSISTENT_PROC: u32 = 6;
pub const GIN_OPTIONS_PROC: u32 = 7;
pub const GINNProcs: u32 = 7;
pub const GIN_SEARCH_MODE_DEFAULT: u32 = 0;
pub const GIN_SEARCH_MODE_INCLUDE_EMPTY: u32 = 1;
pub const GIN_SEARCH_MODE_ALL: u32 = 2;
pub const GIN_SEARCH_MODE_EVERYTHING: u32 = 3;
pub const GIN_FALSE: u32 = 0;
pub const GIN_TRUE: u32 = 1;
pub const GIN_MAYBE: u32 = 2;
pub const GIST_CONSISTENT_PROC: u32 = 1;
pub const GIST_UNION_PROC: u32 = 2;
pub const GIST_COMPRESS_PROC: u32 = 3;
pub const GIST_DECOMPRESS_PROC: u32 = 4;
pub const GIST_PENALTY_PROC: u32 = 5;
pub const GIST_PICKSPLIT_PROC: u32 = 6;
pub const GIST_EQUAL_PROC: u32 = 7;
pub const GIST_DISTANCE_PROC: u32 = 8;
pub const GIST_FETCH_PROC: u32 = 9;
pub const GIST_OPTIONS_PROC: u32 = 10;
pub const GIST_SORTSUPPORT_PROC: u32 = 11;
pub const GISTNProcs: u32 = 11;
pub const F_LEAF: u32 = 1;
pub const F_DELETED: u32 = 2;
pub const F_TUPLES_DELETED: u32 = 4;
pub const F_FOLLOW_RIGHT: u32 = 8;
pub const F_HAS_GARBAGE: u32 = 16;
pub const GIST_PAGE_ID: u32 = 65409;
pub const SHAREDINVALCATALOG_ID: i32 = -1;
pub const SHAREDINVALRELCACHE_ID: i32 = -2;
pub const SHAREDINVALSMGR_ID: i32 = -3;
pub const SHAREDINVALRELMAP_ID: i32 = -4;
pub const SHAREDINVALSNAPSHOT_ID: i32 = -5;
pub const GIDSIZE: u32 = 200;
pub const XACT_READ_UNCOMMITTED: u32 = 0;
pub const XACT_READ_COMMITTED: u32 = 1;
pub const XACT_REPEATABLE_READ: u32 = 2;
pub const XACT_SERIALIZABLE: u32 = 3;
pub const XACT_FLAGS_ACCESSEDTEMPNAMESPACE: u32 = 1;
pub const XACT_FLAGS_ACQUIREDACCESSEXCLUSIVELOCK: u32 = 2;
pub const XACT_FLAGS_NEEDIMMEDIATECOMMIT: u32 = 4;
pub const XACT_FLAGS_PIPELINING: u32 = 8;
pub const XLOG_XACT_COMMIT: u32 = 0;
pub const XLOG_XACT_PREPARE: u32 = 16;
pub const XLOG_XACT_ABORT: u32 = 32;
pub const XLOG_XACT_COMMIT_PREPARED: u32 = 48;
pub const XLOG_XACT_ABORT_PREPARED: u32 = 64;
pub const XLOG_XACT_ASSIGNMENT: u32 = 80;
pub const XLOG_XACT_INVALIDATIONS: u32 = 96;
pub const XLOG_XACT_OPMASK: u32 = 112;
pub const XLOG_XACT_HAS_INFO: u32 = 128;
pub const XACT_XINFO_HAS_DBINFO: u32 = 1;
pub const XACT_XINFO_HAS_SUBXACTS: u32 = 2;
pub const XACT_XINFO_HAS_RELFILELOCATORS: u32 = 4;
pub const XACT_XINFO_HAS_INVALS: u32 = 8;
pub const XACT_XINFO_HAS_TWOPHASE: u32 = 16;
pub const XACT_XINFO_HAS_ORIGIN: u32 = 32;
pub const XACT_XINFO_HAS_AE_LOCKS: u32 = 64;
pub const XACT_XINFO_HAS_GID: u32 = 128;
pub const XACT_XINFO_HAS_DROPPED_STATS: u32 = 256;
pub const XACT_COMPLETION_APPLY_FEEDBACK: u32 = 536870912;
pub const XACT_COMPLETION_UPDATE_RELCACHE_FILE: u32 = 1073741824;
pub const XACT_COMPLETION_FORCE_SYNC_COMMIT: u32 = 2147483648;
pub const DEFAULT_TABLE_ACCESS_METHOD: &[u8; 5] = b"heap\0";
pub const TABLE_INSERT_SKIP_FSM: u32 = 2;
pub const TABLE_INSERT_FROZEN: u32 = 4;
pub const TABLE_INSERT_NO_LOGICAL: u32 = 8;
pub const TUPLE_LOCK_FLAG_LOCK_UPDATE_IN_PROGRESS: u32 = 1;
pub const TUPLE_LOCK_FLAG_FIND_LAST_VERSION: u32 = 2;
pub const SHMEM_INDEX_KEYSIZE: u32 = 48;
pub const SHMEM_INDEX_SIZE: u32 = 64;
pub const HEAP_INSERT_SKIP_FSM: u32 = 2;
pub const HEAP_INSERT_FROZEN: u32 = 4;
pub const HEAP_INSERT_NO_LOGICAL: u32 = 8;
pub const HEAP_INSERT_SPECULATIVE: u32 = 16;
pub const HEAP_FREEZE_CHECK_XMIN_COMMITTED: u32 = 1;
pub const HEAP_FREEZE_CHECK_XMAX_ABORTED: u32 = 2;
pub const LWLOCK_PADDED_SIZE: u32 = 128;
pub const NUM_INDIVIDUAL_LWLOCKS: u32 = 48;
pub const NUM_BUFFER_PARTITIONS: u32 = 128;
pub const LOG2_NUM_LOCK_PARTITIONS: u32 = 4;
pub const NUM_LOCK_PARTITIONS: u32 = 16;
pub const LOG2_NUM_PREDICATELOCK_PARTITIONS: u32 = 4;
pub const NUM_PREDICATELOCK_PARTITIONS: u32 = 16;
pub const BUFFER_MAPPING_LWLOCK_OFFSET: u32 = 48;
pub const LOCK_MANAGER_LWLOCK_OFFSET: u32 = 176;
pub const PREDICATELOCK_MANAGER_LWLOCK_OFFSET: u32 = 192;
pub const NUM_FIXED_LWLOCKS: u32 = 208;
pub const INTERVAL_FULL_RANGE: u32 = 32767;
pub const INTERVAL_RANGE_MASK: u32 = 32767;
pub const INTERVAL_FULL_PRECISION: u32 = 65535;
pub const INTERVAL_PRECISION_MASK: u32 = 65535;
pub const InvalidLocalTransactionId: u32 = 0;
pub const MAX_LOCKMODES: u32 = 10;
pub const DEFAULT_LOCKMETHOD: u32 = 1;
pub const USER_LOCKMETHOD: u32 = 2;
pub const PG_CONTROL_VERSION: u32 = 1300;
pub const MOCK_AUTH_NONCE_LEN: u32 = 32;
pub const XLOG_CHECKPOINT_SHUTDOWN: u32 = 0;
pub const XLOG_CHECKPOINT_ONLINE: u32 = 16;
pub const XLOG_NOOP: u32 = 32;
pub const XLOG_NEXTOID: Oid = Oid(48);
pub const XLOG_SWITCH: u32 = 64;
pub const XLOG_BACKUP_END: u32 = 80;
pub const XLOG_PARAMETER_CHANGE: u32 = 96;
pub const XLOG_RESTORE_POINT: u32 = 112;
pub const XLOG_FPW_CHANGE: u32 = 128;
pub const XLOG_END_OF_RECOVERY: u32 = 144;
pub const XLOG_FPI_FOR_HINT: u32 = 160;
pub const XLOG_FPI: u32 = 176;
pub const XLOG_OVERWRITE_CONTRECORD: u32 = 208;
pub const FLOATFORMAT_VALUE: f64 = 1234567.0;
pub const PG_CONTROL_MAX_SAFE_SIZE: u32 = 512;
pub const PG_CONTROL_FILE_SIZE: u32 = 8192;
pub const PERFORM_DELETION_INTERNAL: u32 = 1;
pub const PERFORM_DELETION_CONCURRENTLY: u32 = 2;
pub const PERFORM_DELETION_QUIETLY: u32 = 4;
pub const PERFORM_DELETION_SKIP_ORIGINAL: u32 = 8;
pub const PERFORM_DELETION_SKIP_EXTENSIONS: u32 = 16;
pub const PERFORM_DELETION_CONCURRENT_LOCK: u32 = 32;
pub const DEFAULT_INDEX_TYPE: &[u8; 6] = b"btree\0";
pub const REINDEXOPT_VERBOSE: u32 = 1;
pub const REINDEXOPT_REPORT_PROGRESS: u32 = 2;
pub const REINDEXOPT_MISSING_OK: u32 = 4;
pub const REINDEXOPT_CONCURRENTLY: u32 = 8;
pub const INDEX_CREATE_IS_PRIMARY: u32 = 1;
pub const INDEX_CREATE_ADD_CONSTRAINT: u32 = 2;
pub const INDEX_CREATE_SKIP_BUILD: u32 = 4;
pub const INDEX_CREATE_CONCURRENT: u32 = 8;
pub const INDEX_CREATE_IF_NOT_EXISTS: u32 = 16;
pub const INDEX_CREATE_PARTITIONED: u32 = 32;
pub const INDEX_CREATE_INVALID: u32 = 64;
pub const INDEX_CONSTR_CREATE_MARK_AS_PRIMARY: u32 = 1;
pub const INDEX_CONSTR_CREATE_DEFERRABLE: u32 = 2;
pub const INDEX_CONSTR_CREATE_INIT_DEFERRED: u32 = 4;
pub const INDEX_CONSTR_CREATE_UPDATE_INDEX: u32 = 8;
pub const INDEX_CONSTR_CREATE_REMOVE_OLD_DEPS: u32 = 16;
pub const REINDEX_REL_PROCESS_TOAST: u32 = 1;
pub const REINDEX_REL_SUPPRESS_INDEX_USE: u32 = 2;
pub const REINDEX_REL_CHECK_CONSTRAINTS: u32 = 4;
pub const REINDEX_REL_FORCE_INDEXES_UNLOGGED: u32 = 8;
pub const REINDEX_REL_FORCE_INDEXES_PERMANENT: u32 = 16;
pub const MAX_CATALOG_MULTI_INSERT_BYTES: u32 = 65535;
pub const AccessMethodRelationId: Oid = Oid(2601);
pub const AmNameIndexId: u32 = 2651;
pub const AmOidIndexId: u32 = 2652;
pub const Anum_pg_am_oid: u32 = 1;
pub const Anum_pg_am_amname: u32 = 2;
pub const Anum_pg_am_amhandler: u32 = 3;
pub const Anum_pg_am_amtype: u32 = 4;
pub const Natts_pg_am: u32 = 4;
pub const AMTYPE_INDEX: u8 = 105u8;
pub const AMTYPE_TABLE: u8 = 116u8;
pub const HEAP_TABLE_AM_OID: Oid = Oid(2);
pub const BTREE_AM_OID: Oid = Oid(403);
pub const HASH_AM_OID: Oid = Oid(405);
pub const GIST_AM_OID: Oid = Oid(783);
pub const GIN_AM_OID: Oid = Oid(2742);
pub const SPGIST_AM_OID: Oid = Oid(4000);
pub const BRIN_AM_OID: Oid = Oid(3580);
pub const AccessMethodOperatorRelationId: Oid = Oid(2602);
pub const AccessMethodStrategyIndexId: u32 = 2653;
pub const AccessMethodOperatorIndexId: u32 = 2654;
pub const AccessMethodOperatorOidIndexId: u32 = 2756;
pub const Anum_pg_amop_oid: u32 = 1;
pub const Anum_pg_amop_amopfamily: u32 = 2;
pub const Anum_pg_amop_amoplefttype: u32 = 3;
pub const Anum_pg_amop_amoprighttype: u32 = 4;
pub const Anum_pg_amop_amopstrategy: u32 = 5;
pub const Anum_pg_amop_amoppurpose: u32 = 6;
pub const Anum_pg_amop_amopopr: u32 = 7;
pub const Anum_pg_amop_amopmethod: u32 = 8;
pub const Anum_pg_amop_amopsortfamily: u32 = 9;
pub const Natts_pg_amop: u32 = 9;
pub const AMOP_SEARCH: u8 = 115u8;
pub const AMOP_ORDER: u8 = 111u8;
pub const AccessMethodProcedureRelationId: Oid = Oid(2603);
pub const AccessMethodProcedureIndexId: u32 = 2655;
pub const AccessMethodProcedureOidIndexId: u32 = 2757;
pub const Anum_pg_amproc_oid: u32 = 1;
pub const Anum_pg_amproc_amprocfamily: u32 = 2;
pub const Anum_pg_amproc_amproclefttype: u32 = 3;
pub const Anum_pg_amproc_amprocrighttype: u32 = 4;
pub const Anum_pg_amproc_amprocnum: u32 = 5;
pub const Anum_pg_amproc_amproc: u32 = 6;
pub const Natts_pg_amproc: u32 = 6;
pub const AuthIdRelationId: Oid = Oid(1260);
pub const AuthIdRelation_Rowtype_Id: u32 = 2842;
pub const PgAuthidToastTable: u32 = 4175;
pub const PgAuthidToastIndex: u32 = 4176;
pub const AuthIdRolnameIndexId: u32 = 2676;
pub const AuthIdOidIndexId: u32 = 2677;
pub const Anum_pg_authid_oid: u32 = 1;
pub const Anum_pg_authid_rolname: u32 = 2;
pub const Anum_pg_authid_rolsuper: u32 = 3;
pub const Anum_pg_authid_rolinherit: u32 = 4;
pub const Anum_pg_authid_rolcreaterole: u32 = 5;
pub const Anum_pg_authid_rolcreatedb: u32 = 6;
pub const Anum_pg_authid_rolcanlogin: u32 = 7;
pub const Anum_pg_authid_rolreplication: u32 = 8;
pub const Anum_pg_authid_rolbypassrls: u32 = 9;
pub const Anum_pg_authid_rolconnlimit: u32 = 10;
pub const Anum_pg_authid_rolpassword: u32 = 11;
pub const Anum_pg_authid_rolvaliduntil: u32 = 12;
pub const Natts_pg_authid: u32 = 12;
pub const BOOTSTRAP_SUPERUSERID: u32 = 10;
pub const ROLE_PG_DATABASE_OWNER: u32 = 6171;
pub const ROLE_PG_READ_ALL_DATA: u32 = 6181;
pub const ROLE_PG_WRITE_ALL_DATA: u32 = 6182;
pub const ROLE_PG_MONITOR: u32 = 3373;
pub const ROLE_PG_READ_ALL_SETTINGS: u32 = 3374;
pub const ROLE_PG_READ_ALL_STATS: u32 = 3375;
pub const ROLE_PG_STAT_SCAN_TABLES: u32 = 3377;
pub const ROLE_PG_READ_SERVER_FILES: u32 = 4569;
pub const ROLE_PG_WRITE_SERVER_FILES: u32 = 4570;
pub const ROLE_PG_EXECUTE_SERVER_PROGRAM: u32 = 4571;
pub const ROLE_PG_SIGNAL_BACKEND: u32 = 4200;
pub const ROLE_PG_CHECKPOINT: u32 = 4544;
pub const ROLE_PG_USE_RESERVED_CONNECTIONS: u32 = 4550;
pub const ROLE_PG_CREATE_SUBSCRIPTION: u32 = 6304;
pub const CollationRelationId: Oid = Oid(3456);
pub const CollationNameEncNspIndexId: u32 = 3164;
pub const CollationOidIndexId: u32 = 3085;
pub const Anum_pg_collation_oid: u32 = 1;
pub const Anum_pg_collation_collname: u32 = 2;
pub const Anum_pg_collation_collnamespace: u32 = 3;
pub const Anum_pg_collation_collowner: u32 = 4;
pub const Anum_pg_collation_collprovider: u32 = 5;
pub const Anum_pg_collation_collisdeterministic: u32 = 6;
pub const Anum_pg_collation_collencoding: u32 = 7;
pub const Anum_pg_collation_collcollate: u32 = 8;
pub const Anum_pg_collation_collctype: u32 = 9;
pub const Anum_pg_collation_colliculocale: u32 = 10;
pub const Anum_pg_collation_collicurules: u32 = 11;
pub const Anum_pg_collation_collversion: u32 = 12;
pub const Natts_pg_collation: u32 = 12;
pub const COLLPROVIDER_DEFAULT: u8 = 100u8;
pub const COLLPROVIDER_ICU: u8 = 105u8;
pub const COLLPROVIDER_LIBC: u8 = 99u8;
pub const DEFAULT_COLLATION_OID: Oid = Oid(100);
pub const C_COLLATION_OID: Oid = Oid(950);
pub const POSIX_COLLATION_OID: Oid = Oid(951);
pub const DatabaseRelationId: Oid = Oid(1262);
pub const DatabaseRelation_Rowtype_Id: u32 = 1248;
pub const PgDatabaseToastTable: u32 = 4177;
pub const PgDatabaseToastIndex: u32 = 4178;
pub const DatabaseNameIndexId: u32 = 2671;
pub const DatabaseOidIndexId: u32 = 2672;
pub const Template0DbOid: u32 = 4;
pub const PostgresDbOid: u32 = 5;
pub const Anum_pg_database_oid: u32 = 1;
pub const Anum_pg_database_datname: u32 = 2;
pub const Anum_pg_database_datdba: u32 = 3;
pub const Anum_pg_database_encoding: u32 = 4;
pub const Anum_pg_database_datlocprovider: u32 = 5;
pub const Anum_pg_database_datistemplate: u32 = 6;
pub const Anum_pg_database_datallowconn: u32 = 7;
pub const Anum_pg_database_datconnlimit: u32 = 8;
pub const Anum_pg_database_datfrozenxid: u32 = 9;
pub const Anum_pg_database_datminmxid: u32 = 10;
pub const Anum_pg_database_dattablespace: u32 = 11;
pub const Anum_pg_database_datcollate: u32 = 12;
pub const Anum_pg_database_datctype: u32 = 13;
pub const Anum_pg_database_daticulocale: u32 = 14;
pub const Anum_pg_database_daticurules: u32 = 15;
pub const Anum_pg_database_datcollversion: u32 = 16;
pub const Anum_pg_database_datacl: u32 = 17;
pub const Natts_pg_database: u32 = 17;
pub const Template1DbOid: u32 = 1;
pub const DATCONNLIMIT_UNLIMITED: i32 = -1;
pub const DATCONNLIMIT_INVALID_DB: i32 = -2;
pub const EnumRelationId: Oid = Oid(3501);
pub const EnumOidIndexId: u32 = 3502;
pub const EnumTypIdLabelIndexId: u32 = 3503;
pub const EnumTypIdSortOrderIndexId: u32 = 3534;
pub const Anum_pg_enum_oid: u32 = 1;
pub const Anum_pg_enum_enumtypid: u32 = 2;
pub const Anum_pg_enum_enumsortorder: u32 = 3;
pub const Anum_pg_enum_enumlabel: u32 = 4;
pub const Natts_pg_enum: u32 = 4;
pub const ExtensionRelationId: Oid = Oid(3079);
pub const ExtensionOidIndexId: u32 = 3080;
pub const ExtensionNameIndexId: u32 = 3081;
pub const Anum_pg_extension_oid: u32 = 1;
pub const Anum_pg_extension_extname: u32 = 2;
pub const Anum_pg_extension_extowner: u32 = 3;
pub const Anum_pg_extension_extnamespace: u32 = 4;
pub const Anum_pg_extension_extrelocatable: u32 = 5;
pub const Anum_pg_extension_extversion: u32 = 6;
pub const Anum_pg_extension_extconfig: u32 = 7;
pub const Anum_pg_extension_extcondition: u32 = 8;
pub const Natts_pg_extension: u32 = 8;
pub const ForeignDataWrapperRelationId: Oid = Oid(2328);
pub const ForeignDataWrapperOidIndexId: u32 = 112;
pub const ForeignDataWrapperNameIndexId: u32 = 548;
pub const Anum_pg_foreign_data_wrapper_oid: u32 = 1;
pub const Anum_pg_foreign_data_wrapper_fdwname: u32 = 2;
pub const Anum_pg_foreign_data_wrapper_fdwowner: u32 = 3;
pub const Anum_pg_foreign_data_wrapper_fdwhandler: u32 = 4;
pub const Anum_pg_foreign_data_wrapper_fdwvalidator: u32 = 5;
pub const Anum_pg_foreign_data_wrapper_fdwacl: u32 = 6;
pub const Anum_pg_foreign_data_wrapper_fdwoptions: u32 = 7;
pub const Natts_pg_foreign_data_wrapper: u32 = 7;
pub const ForeignServerRelationId: Oid = Oid(1417);
pub const ForeignServerOidIndexId: u32 = 113;
pub const ForeignServerNameIndexId: u32 = 549;
pub const Anum_pg_foreign_server_oid: u32 = 1;
pub const Anum_pg_foreign_server_srvname: u32 = 2;
pub const Anum_pg_foreign_server_srvowner: u32 = 3;
pub const Anum_pg_foreign_server_srvfdw: u32 = 4;
pub const Anum_pg_foreign_server_srvtype: u32 = 5;
pub const Anum_pg_foreign_server_srvversion: u32 = 6;
pub const Anum_pg_foreign_server_srvacl: u32 = 7;
pub const Anum_pg_foreign_server_srvoptions: u32 = 8;
pub const Natts_pg_foreign_server: u32 = 8;
pub const ForeignTableRelationId: Oid = Oid(3118);
pub const ForeignTableRelidIndexId: u32 = 3119;
pub const Anum_pg_foreign_table_ftrelid: u32 = 1;
pub const Anum_pg_foreign_table_ftserver: u32 = 2;
pub const Anum_pg_foreign_table_ftoptions: u32 = 3;
pub const Natts_pg_foreign_table: u32 = 3;
pub const OperatorRelationId: Oid = Oid(2617);
pub const OperatorOidIndexId: u32 = 2688;
pub const OperatorNameNspIndexId: u32 = 2689;
pub const Anum_pg_operator_oid: u32 = 1;
pub const Anum_pg_operator_oprname: u32 = 2;
pub const Anum_pg_operator_oprnamespace: u32 = 3;
pub const Anum_pg_operator_oprowner: u32 = 4;
pub const Anum_pg_operator_oprkind: u32 = 5;
pub const Anum_pg_operator_oprcanmerge: u32 = 6;
pub const Anum_pg_operator_oprcanhash: u32 = 7;
pub const Anum_pg_operator_oprleft: u32 = 8;
pub const Anum_pg_operator_oprright: u32 = 9;
pub const Anum_pg_operator_oprresult: u32 = 10;
pub const Anum_pg_operator_oprcom: u32 = 11;
pub const Anum_pg_operator_oprnegate: u32 = 12;
pub const Anum_pg_operator_oprcode: u32 = 13;
pub const Anum_pg_operator_oprrest: u32 = 14;
pub const Anum_pg_operator_oprjoin: u32 = 15;
pub const Natts_pg_operator: u32 = 15;
pub const BooleanNotEqualOperator: u32 = 85;
pub const BooleanEqualOperator: u32 = 91;
pub const Int4EqualOperator: u32 = 96;
pub const Int4LessOperator: u32 = 97;
pub const TextEqualOperator: u32 = 98;
pub const TextPrefixOperator: u32 = 3877;
pub const NameEqualTextOperator: u32 = 254;
pub const NameLessTextOperator: u32 = 255;
pub const NameGreaterEqualTextOperator: u32 = 257;
pub const TIDEqualOperator: u32 = 387;
pub const TIDLessOperator: u32 = 2799;
pub const TIDGreaterOperator: u32 = 2800;
pub const TIDLessEqOperator: u32 = 2801;
pub const TIDGreaterEqOperator: u32 = 2802;
pub const Int8LessOperator: u32 = 412;
pub const OID_NAME_REGEXEQ_OP: u32 = 639;
pub const OID_TEXT_REGEXEQ_OP: u32 = 641;
pub const TextLessOperator: u32 = 664;
pub const TextGreaterEqualOperator: u32 = 667;
pub const Float8LessOperator: u32 = 672;
pub const BpcharEqualOperator: u32 = 1054;
pub const OID_BPCHAR_REGEXEQ_OP: u32 = 1055;
pub const BpcharLessOperator: u32 = 1058;
pub const BpcharGreaterEqualOperator: u32 = 1061;
pub const ARRAY_EQ_OP: u32 = 1070;
pub const ARRAY_LT_OP: u32 = 1072;
pub const ARRAY_GT_OP: u32 = 1073;
pub const OID_NAME_LIKE_OP: u32 = 1207;
pub const OID_TEXT_LIKE_OP: u32 = 1209;
pub const OID_BPCHAR_LIKE_OP: u32 = 1211;
pub const OID_NAME_ICREGEXEQ_OP: u32 = 1226;
pub const OID_TEXT_ICREGEXEQ_OP: u32 = 1228;
pub const OID_BPCHAR_ICREGEXEQ_OP: u32 = 1234;
pub const OID_INET_SUB_OP: u32 = 931;
pub const OID_INET_SUBEQ_OP: u32 = 932;
pub const OID_INET_SUP_OP: u32 = 933;
pub const OID_INET_SUPEQ_OP: u32 = 934;
pub const OID_INET_OVERLAP_OP: u32 = 3552;
pub const OID_NAME_ICLIKE_OP: u32 = 1625;
pub const OID_TEXT_ICLIKE_OP: u32 = 1627;
pub const OID_BPCHAR_ICLIKE_OP: u32 = 1629;
pub const ByteaEqualOperator: u32 = 1955;
pub const ByteaLessOperator: u32 = 1957;
pub const ByteaGreaterEqualOperator: u32 = 1960;
pub const OID_BYTEA_LIKE_OP: u32 = 2016;
pub const TextPatternLessOperator: u32 = 2314;
pub const TextPatternGreaterEqualOperator: u32 = 2317;
pub const BpcharPatternLessOperator: u32 = 2326;
pub const BpcharPatternGreaterEqualOperator: u32 = 2329;
pub const OID_ARRAY_OVERLAP_OP: u32 = 2750;
pub const OID_ARRAY_CONTAINS_OP: u32 = 2751;
pub const OID_ARRAY_CONTAINED_OP: u32 = 2752;
pub const RECORD_EQ_OP: u32 = 2988;
pub const RECORD_LT_OP: u32 = 2990;
pub const RECORD_GT_OP: u32 = 2991;
pub const OID_RANGE_LESS_OP: u32 = 3884;
pub const OID_RANGE_LESS_EQUAL_OP: u32 = 3885;
pub const OID_RANGE_GREATER_EQUAL_OP: u32 = 3886;
pub const OID_RANGE_GREATER_OP: u32 = 3887;
pub const OID_RANGE_OVERLAP_OP: u32 = 3888;
pub const OID_RANGE_CONTAINS_ELEM_OP: u32 = 3889;
pub const OID_RANGE_CONTAINS_OP: u32 = 3890;
pub const OID_RANGE_ELEM_CONTAINED_OP: u32 = 3891;
pub const OID_RANGE_CONTAINED_OP: u32 = 3892;
pub const OID_RANGE_LEFT_OP: u32 = 3893;
pub const OID_RANGE_RIGHT_OP: u32 = 3894;
pub const OID_RANGE_OVERLAPS_LEFT_OP: u32 = 3895;
pub const OID_RANGE_OVERLAPS_RIGHT_OP: u32 = 3896;
pub const OID_MULTIRANGE_LESS_OP: u32 = 2862;
pub const OID_MULTIRANGE_LESS_EQUAL_OP: u32 = 2863;
pub const OID_MULTIRANGE_GREATER_EQUAL_OP: u32 = 2864;
pub const OID_MULTIRANGE_GREATER_OP: u32 = 2865;
pub const OID_RANGE_OVERLAPS_MULTIRANGE_OP: u32 = 2866;
pub const OID_MULTIRANGE_OVERLAPS_RANGE_OP: u32 = 2867;
pub const OID_MULTIRANGE_OVERLAPS_MULTIRANGE_OP: u32 = 2868;
pub const OID_MULTIRANGE_CONTAINS_ELEM_OP: u32 = 2869;
pub const OID_MULTIRANGE_CONTAINS_RANGE_OP: u32 = 2870;
pub const OID_MULTIRANGE_CONTAINS_MULTIRANGE_OP: u32 = 2871;
pub const OID_MULTIRANGE_ELEM_CONTAINED_OP: u32 = 2872;
pub const OID_MULTIRANGE_RANGE_CONTAINED_OP: u32 = 2873;
pub const OID_MULTIRANGE_MULTIRANGE_CONTAINED_OP: u32 = 2874;
pub const OID_RANGE_CONTAINS_MULTIRANGE_OP: u32 = 4539;
pub const OID_RANGE_MULTIRANGE_CONTAINED_OP: u32 = 4540;
pub const OID_RANGE_OVERLAPS_LEFT_MULTIRANGE_OP: u32 = 2875;
pub const OID_MULTIRANGE_OVERLAPS_LEFT_RANGE_OP: u32 = 2876;
pub const OID_MULTIRANGE_OVERLAPS_LEFT_MULTIRANGE_OP: u32 = 2877;
pub const OID_RANGE_OVERLAPS_RIGHT_MULTIRANGE_OP: u32 = 3585;
pub const OID_MULTIRANGE_OVERLAPS_RIGHT_RANGE_OP: u32 = 4035;
pub const OID_MULTIRANGE_OVERLAPS_RIGHT_MULTIRANGE_OP: u32 = 4142;
pub const OID_RANGE_ADJACENT_MULTIRANGE_OP: u32 = 4179;
pub const OID_MULTIRANGE_ADJACENT_RANGE_OP: u32 = 4180;
pub const OID_MULTIRANGE_ADJACENT_MULTIRANGE_OP: u32 = 4198;
pub const OID_RANGE_LEFT_MULTIRANGE_OP: u32 = 4395;
pub const OID_MULTIRANGE_LEFT_RANGE_OP: u32 = 4396;
pub const OID_MULTIRANGE_LEFT_MULTIRANGE_OP: u32 = 4397;
pub const OID_RANGE_RIGHT_MULTIRANGE_OP: u32 = 4398;
pub const OID_MULTIRANGE_RIGHT_RANGE_OP: u32 = 4399;
pub const OID_MULTIRANGE_RIGHT_MULTIRANGE_OP: u32 = 4400;
pub const OperatorClassRelationId: Oid = Oid(2616);
pub const OpclassAmNameNspIndexId: u32 = 2686;
pub const OpclassOidIndexId: u32 = 2687;
pub const Anum_pg_opclass_oid: u32 = 1;
pub const Anum_pg_opclass_opcmethod: u32 = 2;
pub const Anum_pg_opclass_opcname: u32 = 3;
pub const Anum_pg_opclass_opcnamespace: u32 = 4;
pub const Anum_pg_opclass_opcowner: u32 = 5;
pub const Anum_pg_opclass_opcfamily: u32 = 6;
pub const Anum_pg_opclass_opcintype: u32 = 7;
pub const Anum_pg_opclass_opcdefault: u32 = 8;
pub const Anum_pg_opclass_opckeytype: u32 = 9;
pub const Natts_pg_opclass: u32 = 9;
pub const DATE_BTREE_OPS_OID: Oid = Oid(3122);
pub const FLOAT8_BTREE_OPS_OID: Oid = Oid(3123);
pub const INT2_BTREE_OPS_OID: Oid = Oid(1979);
pub const INT4_BTREE_OPS_OID: Oid = Oid(1978);
pub const INT8_BTREE_OPS_OID: Oid = Oid(3124);
pub const NUMERIC_BTREE_OPS_OID: Oid = Oid(3125);
pub const OID_BTREE_OPS_OID: Oid = Oid(1981);
pub const TEXT_BTREE_OPS_OID: Oid = Oid(3126);
pub const TIMESTAMPTZ_BTREE_OPS_OID: Oid = Oid(3127);
pub const TIMESTAMP_BTREE_OPS_OID: Oid = Oid(3128);
pub const TEXT_BTREE_PATTERN_OPS_OID: Oid = Oid(4217);
pub const VARCHAR_BTREE_PATTERN_OPS_OID: Oid = Oid(4218);
pub const BPCHAR_BTREE_PATTERN_OPS_OID: Oid = Oid(4219);
pub const OperatorFamilyRelationId: Oid = Oid(2753);
pub const OpfamilyAmNameNspIndexId: u32 = 2754;
pub const OpfamilyOidIndexId: u32 = 2755;
pub const Anum_pg_opfamily_oid: u32 = 1;
pub const Anum_pg_opfamily_opfmethod: u32 = 2;
pub const Anum_pg_opfamily_opfname: u32 = 3;
pub const Anum_pg_opfamily_opfnamespace: u32 = 4;
pub const Anum_pg_opfamily_opfowner: u32 = 5;
pub const Natts_pg_opfamily: u32 = 5;
pub const BOOL_BTREE_FAM_OID: Oid = Oid(424);
pub const BPCHAR_BTREE_FAM_OID: Oid = Oid(426);
pub const BYTEA_BTREE_FAM_OID: Oid = Oid(428);
pub const NETWORK_BTREE_FAM_OID: Oid = Oid(1974);
pub const INTEGER_BTREE_FAM_OID: Oid = Oid(1976);
pub const OID_BTREE_FAM_OID: Oid = Oid(1989);
pub const TEXT_BTREE_FAM_OID: Oid = Oid(1994);
pub const TEXT_PATTERN_BTREE_FAM_OID: Oid = Oid(2095);
pub const BPCHAR_PATTERN_BTREE_FAM_OID: Oid = Oid(2097);
pub const BOOL_HASH_FAM_OID: Oid = Oid(2222);
pub const TEXT_SPGIST_FAM_OID: Oid = Oid(4017);
pub const ProcedureRelationId: Oid = Oid(1255);
pub const ProcedureRelation_Rowtype_Id: u32 = 81;
pub const ProcedureOidIndexId: u32 = 2690;
pub const ProcedureNameArgsNspIndexId: u32 = 2691;
pub const Anum_pg_proc_oid: u32 = 1;
pub const Anum_pg_proc_proname: u32 = 2;
pub const Anum_pg_proc_pronamespace: u32 = 3;
pub const Anum_pg_proc_proowner: u32 = 4;
pub const Anum_pg_proc_prolang: u32 = 5;
pub const Anum_pg_proc_procost: u32 = 6;
pub const Anum_pg_proc_prorows: u32 = 7;
pub const Anum_pg_proc_provariadic: u32 = 8;
pub const Anum_pg_proc_prosupport: u32 = 9;
pub const Anum_pg_proc_prokind: u32 = 10;
pub const Anum_pg_proc_prosecdef: u32 = 11;
pub const Anum_pg_proc_proleakproof: u32 = 12;
pub const Anum_pg_proc_proisstrict: u32 = 13;
pub const Anum_pg_proc_proretset: u32 = 14;
pub const Anum_pg_proc_provolatile: u32 = 15;
pub const Anum_pg_proc_proparallel: u32 = 16;
pub const Anum_pg_proc_pronargs: u32 = 17;
pub const Anum_pg_proc_pronargdefaults: u32 = 18;
pub const Anum_pg_proc_prorettype: u32 = 19;
pub const Anum_pg_proc_proargtypes: u32 = 20;
pub const Anum_pg_proc_proallargtypes: u32 = 21;
pub const Anum_pg_proc_proargmodes: u32 = 22;
pub const Anum_pg_proc_proargnames: u32 = 23;
pub const Anum_pg_proc_proargdefaults: u32 = 24;
pub const Anum_pg_proc_protrftypes: u32 = 25;
pub const Anum_pg_proc_prosrc: u32 = 26;
pub const Anum_pg_proc_probin: u32 = 27;
pub const Anum_pg_proc_prosqlbody: u32 = 28;
pub const Anum_pg_proc_proconfig: u32 = 29;
pub const Anum_pg_proc_proacl: u32 = 30;
pub const Natts_pg_proc: u32 = 30;
pub const PROKIND_FUNCTION: u8 = 102u8;
pub const PROKIND_AGGREGATE: u8 = 97u8;
pub const PROKIND_WINDOW: u8 = 119u8;
pub const PROKIND_PROCEDURE: u8 = 112u8;
pub const PROVOLATILE_IMMUTABLE: u8 = 105u8;
pub const PROVOLATILE_STABLE: u8 = 115u8;
pub const PROVOLATILE_VOLATILE: u8 = 118u8;
pub const PROPARALLEL_SAFE: u8 = 115u8;
pub const PROPARALLEL_RESTRICTED: u8 = 114u8;
pub const PROPARALLEL_UNSAFE: u8 = 117u8;
pub const PROARGMODE_IN: u8 = 105u8;
pub const PROARGMODE_OUT: u8 = 111u8;
pub const PROARGMODE_INOUT: u8 = 98u8;
pub const PROARGMODE_VARIADIC: u8 = 118u8;
pub const PROARGMODE_TABLE: u8 = 116u8;
pub const NamespaceRelationId: Oid = Oid(2615);
pub const NamespaceNameIndexId: u32 = 2684;
pub const NamespaceOidIndexId: u32 = 2685;
pub const Anum_pg_namespace_oid: u32 = 1;
pub const Anum_pg_namespace_nspname: u32 = 2;
pub const Anum_pg_namespace_nspowner: u32 = 3;
pub const Anum_pg_namespace_nspacl: u32 = 4;
pub const Natts_pg_namespace: u32 = 4;
pub const PG_CATALOG_NAMESPACE: u32 = 11;
pub const PG_TOAST_NAMESPACE: u32 = 99;
pub const PG_PUBLIC_NAMESPACE: u32 = 2200;
pub const ACL_ID_PUBLIC: u32 = 0;
pub const ACL_MODECHG_ADD: u32 = 1;
pub const ACL_MODECHG_DEL: u32 = 2;
pub const ACL_MODECHG_EQL: u32 = 3;
pub const ACL_INSERT_CHR: u8 = 97u8;
pub const ACL_SELECT_CHR: u8 = 114u8;
pub const ACL_UPDATE_CHR: u8 = 119u8;
pub const ACL_DELETE_CHR: u8 = 100u8;
pub const ACL_TRUNCATE_CHR: u8 = 68u8;
pub const ACL_REFERENCES_CHR: u8 = 120u8;
pub const ACL_TRIGGER_CHR: u8 = 116u8;
pub const ACL_EXECUTE_CHR: u8 = 88u8;
pub const ACL_USAGE_CHR: u8 = 85u8;
pub const ACL_CREATE_CHR: u8 = 67u8;
pub const ACL_CREATE_TEMP_CHR: u8 = 84u8;
pub const ACL_CONNECT_CHR: u8 = 99u8;
pub const ACL_SET_CHR: u8 = 115u8;
pub const ACL_ALTER_SYSTEM_CHR: u8 = 65u8;
pub const ACL_ALL_RIGHTS_STR: &[u8; 15] = b"arwdDxtXUCTcsA\0";
pub const ACL_ALL_RIGHTS_COLUMN: u32 = 39;
pub const ACL_ALL_RIGHTS_RELATION: u32 = 127;
pub const ACL_ALL_RIGHTS_SEQUENCE: u32 = 262;
pub const ACL_ALL_RIGHTS_DATABASE: u32 = 3584;
pub const ACL_ALL_RIGHTS_FDW: u32 = 256;
pub const ACL_ALL_RIGHTS_FOREIGN_SERVER: u32 = 256;
pub const ACL_ALL_RIGHTS_FUNCTION: u32 = 128;
pub const ACL_ALL_RIGHTS_LANGUAGE: u32 = 256;
pub const ACL_ALL_RIGHTS_LARGEOBJECT: u32 = 6;
pub const ACL_ALL_RIGHTS_PARAMETER_ACL: u32 = 12288;
pub const ACL_ALL_RIGHTS_SCHEMA: u32 = 768;
pub const ACL_ALL_RIGHTS_TABLESPACE: u32 = 512;
pub const ACL_ALL_RIGHTS_TYPE: u32 = 256;
pub const TableSpaceRelationId: Oid = Oid(1213);
pub const PgTablespaceToastTable: u32 = 4185;
pub const PgTablespaceToastIndex: u32 = 4186;
pub const TablespaceOidIndexId: u32 = 2697;
pub const TablespaceNameIndexId: u32 = 2698;
pub const Anum_pg_tablespace_oid: u32 = 1;
pub const Anum_pg_tablespace_spcname: u32 = 2;
pub const Anum_pg_tablespace_spcowner: u32 = 3;
pub const Anum_pg_tablespace_spcacl: u32 = 4;
pub const Anum_pg_tablespace_spcoptions: u32 = 5;
pub const Natts_pg_tablespace: u32 = 5;
pub const DEFAULTTABLESPACE_OID: Oid = Oid(1663);
pub const GLOBALTABLESPACE_OID: Oid = Oid(1664);
pub const TriggerRelationId: Oid = Oid(2620);
pub const TriggerConstraintIndexId: u32 = 2699;
pub const TriggerRelidNameIndexId: u32 = 2701;
pub const TriggerOidIndexId: u32 = 2702;
pub const Anum_pg_trigger_oid: u32 = 1;
pub const Anum_pg_trigger_tgrelid: u32 = 2;
pub const Anum_pg_trigger_tgparentid: u32 = 3;
pub const Anum_pg_trigger_tgname: u32 = 4;
pub const Anum_pg_trigger_tgfoid: u32 = 5;
pub const Anum_pg_trigger_tgtype: u32 = 6;
pub const Anum_pg_trigger_tgenabled: u32 = 7;
pub const Anum_pg_trigger_tgisinternal: u32 = 8;
pub const Anum_pg_trigger_tgconstrrelid: u32 = 9;
pub const Anum_pg_trigger_tgconstrindid: u32 = 10;
pub const Anum_pg_trigger_tgconstraint: u32 = 11;
pub const Anum_pg_trigger_tgdeferrable: u32 = 12;
pub const Anum_pg_trigger_tginitdeferred: u32 = 13;
pub const Anum_pg_trigger_tgnargs: u32 = 14;
pub const Anum_pg_trigger_tgattr: u32 = 15;
pub const Anum_pg_trigger_tgargs: u32 = 16;
pub const Anum_pg_trigger_tgqual: u32 = 17;
pub const Anum_pg_trigger_tgoldtable: u32 = 18;
pub const Anum_pg_trigger_tgnewtable: u32 = 19;
pub const Natts_pg_trigger: u32 = 19;
pub const TRIGGER_TYPE_ROW: u32 = 1;
pub const TRIGGER_TYPE_BEFORE: u32 = 2;
pub const TRIGGER_TYPE_INSERT: u32 = 4;
pub const TRIGGER_TYPE_DELETE: u32 = 8;
pub const TRIGGER_TYPE_UPDATE: u32 = 16;
pub const TRIGGER_TYPE_TRUNCATE: u32 = 32;
pub const TRIGGER_TYPE_INSTEAD: u32 = 64;
pub const TRIGGER_TYPE_LEVEL_MASK: u32 = 1;
pub const TRIGGER_TYPE_STATEMENT: u32 = 0;
pub const TRIGGER_TYPE_TIMING_MASK: u32 = 66;
pub const TRIGGER_TYPE_AFTER: u32 = 0;
pub const TRIGGER_TYPE_EVENT_MASK: u32 = 60;
pub const EOH_HEADER_MAGIC: i32 = -1;
pub const MAXDIM: u32 = 6;
pub const EA_MAGIC: u32 = 689375833;
pub const EventTriggerRelationId: Oid = Oid(3466);
pub const EventTriggerNameIndexId: u32 = 3467;
pub const EventTriggerOidIndexId: u32 = 3468;
pub const Anum_pg_event_trigger_oid: u32 = 1;
pub const Anum_pg_event_trigger_evtname: u32 = 2;
pub const Anum_pg_event_trigger_evtevent: u32 = 3;
pub const Anum_pg_event_trigger_evtowner: u32 = 4;
pub const Anum_pg_event_trigger_evtfoid: u32 = 5;
pub const Anum_pg_event_trigger_evtenabled: u32 = 6;
pub const Anum_pg_event_trigger_evttags: u32 = 7;
pub const Natts_pg_event_trigger: u32 = 7;
pub const AT_REWRITE_ALTER_PERSISTENCE: u32 = 1;
pub const AT_REWRITE_DEFAULT_VAL: u32 = 2;
pub const AT_REWRITE_COLUMN_REWRITE: u32 = 4;
pub const AT_REWRITE_ACCESS_METHOD: u32 = 8;
pub const XLOG_TBLSPC_CREATE: u32 = 0;
pub const XLOG_TBLSPC_DROP: u32 = 16;
pub const TRIGGER_EVENT_INSERT: u32 = 0;
pub const TRIGGER_EVENT_DELETE: u32 = 1;
pub const TRIGGER_EVENT_UPDATE: u32 = 2;
pub const TRIGGER_EVENT_TRUNCATE: u32 = 3;
pub const TRIGGER_EVENT_OPMASK: u32 = 3;
pub const TRIGGER_EVENT_ROW: u32 = 4;
pub const TRIGGER_EVENT_BEFORE: u32 = 8;
pub const TRIGGER_EVENT_AFTER: u32 = 0;
pub const TRIGGER_EVENT_INSTEAD: u32 = 16;
pub const TRIGGER_EVENT_TIMINGMASK: u32 = 24;
pub const AFTER_TRIGGER_DEFERRABLE: u32 = 32;
pub const AFTER_TRIGGER_INITDEFERRED: u32 = 64;
pub const SESSION_REPLICATION_ROLE_ORIGIN: u32 = 0;
pub const SESSION_REPLICATION_ROLE_REPLICA: u32 = 1;
pub const SESSION_REPLICATION_ROLE_LOCAL: u32 = 2;
pub const TRIGGER_FIRES_ON_ORIGIN: u8 = 79u8;
pub const TRIGGER_FIRES_ALWAYS: u8 = 65u8;
pub const TRIGGER_FIRES_ON_REPLICA: u8 = 82u8;
pub const TRIGGER_DISABLED: u8 = 68u8;
pub const RI_TRIGGER_PK: u32 = 1;
pub const RI_TRIGGER_FK: u32 = 2;
pub const RI_TRIGGER_NONE: u32 = 0;
pub const PG_AUTOCONF_FILENAME: &[u8; 21] = b"postgresql.auto.conf\0";
pub const GUC_QUALIFIER_SEPARATOR: u8 = 46u8;
pub const GUC_LIST_INPUT: u32 = 1;
pub const GUC_LIST_QUOTE: u32 = 2;
pub const GUC_NO_SHOW_ALL: u32 = 4;
pub const GUC_NO_RESET: u32 = 8;
pub const GUC_NO_RESET_ALL: u32 = 16;
pub const GUC_EXPLAIN: u32 = 32;
pub const GUC_REPORT: u32 = 64;
pub const GUC_NOT_IN_SAMPLE: u32 = 128;
pub const GUC_DISALLOW_IN_FILE: u32 = 256;
pub const GUC_CUSTOM_PLACEHOLDER: u32 = 512;
pub const GUC_SUPERUSER_ONLY: u32 = 1024;
pub const GUC_IS_NAME: u32 = 2048;
pub const GUC_NOT_WHILE_SEC_REST: u32 = 4096;
pub const GUC_DISALLOW_IN_AUTO_FILE: u32 = 8192;
pub const GUC_RUNTIME_COMPUTED: u32 = 16384;
pub const GUC_UNIT_KB: u32 = 16777216;
pub const GUC_UNIT_BLOCKS: u32 = 33554432;
pub const GUC_UNIT_XBLOCKS: u32 = 50331648;
pub const GUC_UNIT_MB: u32 = 67108864;
pub const GUC_UNIT_BYTE: u32 = 83886080;
pub const GUC_UNIT_MEMORY: u32 = 251658240;
pub const GUC_UNIT_MS: u32 = 268435456;
pub const GUC_UNIT_S: u32 = 536870912;
pub const GUC_UNIT_MIN: u32 = 805306368;
pub const GUC_UNIT_TIME: u32 = 1879048192;
pub const GUC_UNIT: u32 = 2130706432;
pub const BGWORKER_SHMEM_ACCESS: u32 = 1;
pub const BGWORKER_BACKEND_DATABASE_CONNECTION: u32 = 2;
pub const BGWORKER_CLASS_PARALLEL: u32 = 16;
pub const BGW_DEFAULT_RESTART_INTERVAL: u32 = 60;
pub const BGW_NEVER_RESTART: i32 = -1;
pub const BGW_MAXLEN: u32 = 96;
pub const BGW_EXTRALEN: u32 = 128;
pub const BGWORKER_BYPASS_ALLOWCONN: u32 = 1;
pub const TRANSACTION_STATUS_IN_PROGRESS: u32 = 0;
pub const TRANSACTION_STATUS_COMMITTED: u32 = 1;
pub const TRANSACTION_STATUS_ABORTED: u32 = 2;
pub const TRANSACTION_STATUS_SUB_COMMITTED: u32 = 3;
pub const CLOG_ZEROPAGE: u32 = 0;
pub const CLOG_TRUNCATE: u32 = 16;
pub const WL_LATCH_SET: u32 = 1;
pub const WL_SOCKET_READABLE: u32 = 2;
pub const WL_SOCKET_WRITEABLE: u32 = 4;
pub const WL_TIMEOUT: u32 = 8;
pub const WL_POSTMASTER_DEATH: u32 = 16;
pub const WL_EXIT_ON_PM_DEATH: u32 = 32;
pub const WL_SOCKET_CONNECTED: u32 = 4;
pub const WL_SOCKET_CLOSED: u32 = 128;
pub const WL_SOCKET_ACCEPT: u32 = 2;
pub const WL_SOCKET_MASK: u32 = 134;
pub const PGPROC_MAX_CACHED_SUBXIDS: u32 = 64;
pub const PROC_IS_AUTOVACUUM: u32 = 1;
pub const PROC_IN_VACUUM: u32 = 2;
pub const PROC_IN_SAFE_IC: u32 = 4;
pub const PROC_VACUUM_FOR_WRAPAROUND: u32 = 8;
pub const PROC_IN_LOGICAL_DECODING: u32 = 16;
pub const PROC_AFFECTS_ALL_HORIZONS: u32 = 32;
pub const PROC_VACUUM_STATE_MASK: u32 = 14;
pub const PROC_XMIN_FLAGS: u32 = 6;
pub const FP_LOCK_SLOTS_PER_BACKEND: u32 = 16;
pub const INVALID_PGPROCNO: u32 = 2147483647;
pub const DELAY_CHKPT_START: u32 = 1;
pub const DELAY_CHKPT_COMPLETE: u32 = 2;
pub const NUM_AUXILIARY_PROCS: u32 = 5;
pub const StatisticRelationId: Oid = Oid(2619);
pub const StatisticRelidAttnumInhIndexId: u32 = 2696;
pub const Anum_pg_statistic_starelid: u32 = 1;
pub const Anum_pg_statistic_staattnum: u32 = 2;
pub const Anum_pg_statistic_stainherit: u32 = 3;
pub const Anum_pg_statistic_stanullfrac: u32 = 4;
pub const Anum_pg_statistic_stawidth: u32 = 5;
pub const Anum_pg_statistic_stadistinct: u32 = 6;
pub const Anum_pg_statistic_stakind1: u32 = 7;
pub const Anum_pg_statistic_stakind2: u32 = 8;
pub const Anum_pg_statistic_stakind3: u32 = 9;
pub const Anum_pg_statistic_stakind4: u32 = 10;
pub const Anum_pg_statistic_stakind5: u32 = 11;
pub const Anum_pg_statistic_staop1: u32 = 12;
pub const Anum_pg_statistic_staop2: u32 = 13;
pub const Anum_pg_statistic_staop3: u32 = 14;
pub const Anum_pg_statistic_staop4: u32 = 15;
pub const Anum_pg_statistic_staop5: u32 = 16;
pub const Anum_pg_statistic_stacoll1: u32 = 17;
pub const Anum_pg_statistic_stacoll2: u32 = 18;
pub const Anum_pg_statistic_stacoll3: u32 = 19;
pub const Anum_pg_statistic_stacoll4: u32 = 20;
pub const Anum_pg_statistic_stacoll5: u32 = 21;
pub const Anum_pg_statistic_stanumbers1: u32 = 22;
pub const Anum_pg_statistic_stanumbers2: u32 = 23;
pub const Anum_pg_statistic_stanumbers3: u32 = 24;
pub const Anum_pg_statistic_stanumbers4: u32 = 25;
pub const Anum_pg_statistic_stanumbers5: u32 = 26;
pub const Anum_pg_statistic_stavalues1: u32 = 27;
pub const Anum_pg_statistic_stavalues2: u32 = 28;
pub const Anum_pg_statistic_stavalues3: u32 = 29;
pub const Anum_pg_statistic_stavalues4: u32 = 30;
pub const Anum_pg_statistic_stavalues5: u32 = 31;
pub const Natts_pg_statistic: u32 = 31;
pub const STATISTIC_KIND_MCV: u32 = 1;
pub const STATISTIC_KIND_HISTOGRAM: u32 = 2;
pub const STATISTIC_KIND_CORRELATION: u32 = 3;
pub const STATISTIC_KIND_MCELEM: u32 = 4;
pub const STATISTIC_KIND_DECHIST: u32 = 5;
pub const STATISTIC_KIND_RANGE_LENGTH_HISTOGRAM: u32 = 6;
pub const STATISTIC_KIND_BOUNDS_HISTOGRAM: u32 = 7;
pub const STATISTIC_NUM_SLOTS: u32 = 5;
pub const VACUUM_OPTION_NO_PARALLEL: u32 = 0;
pub const VACUUM_OPTION_PARALLEL_BULKDEL: u32 = 1;
pub const VACUUM_OPTION_PARALLEL_COND_CLEANUP: u32 = 2;
pub const VACUUM_OPTION_PARALLEL_CLEANUP: u32 = 4;
pub const VACUUM_OPTION_MAX_VALID_VALUE: u32 = 7;
pub const VACOPT_VACUUM: u32 = 1;
pub const VACOPT_ANALYZE: u32 = 2;
pub const VACOPT_VERBOSE: u32 = 4;
pub const VACOPT_FREEZE: u32 = 8;
pub const VACOPT_FULL: u32 = 16;
pub const VACOPT_SKIP_LOCKED: u32 = 32;
pub const VACOPT_PROCESS_MAIN: u32 = 64;
pub const VACOPT_PROCESS_TOAST: u32 = 128;
pub const VACOPT_DISABLE_PAGE_SKIPPING: u32 = 256;
pub const VACOPT_SKIP_DATABASE_STATS: u32 = 512;
pub const VACOPT_ONLY_DATABASE_STATS: u32 = 1024;
pub const CACHEDPLANSOURCE_MAGIC: u32 = 195726186;
pub const CACHEDPLAN_MAGIC: u32 = 953717834;
pub const CACHEDEXPR_MAGIC: u32 = 838275847;
pub const SPI_ERROR_CONNECT: i32 = -1;
pub const SPI_ERROR_COPY: i32 = -2;
pub const SPI_ERROR_OPUNKNOWN: i32 = -3;
pub const SPI_ERROR_UNCONNECTED: i32 = -4;
pub const SPI_ERROR_CURSOR: i32 = -5;
pub const SPI_ERROR_ARGUMENT: i32 = -6;
pub const SPI_ERROR_PARAM: i32 = -7;
pub const SPI_ERROR_TRANSACTION: i32 = -8;
pub const SPI_ERROR_NOATTRIBUTE: i32 = -9;
pub const SPI_ERROR_NOOUTFUNC: i32 = -10;
pub const SPI_ERROR_TYPUNKNOWN: i32 = -11;
pub const SPI_ERROR_REL_DUPLICATE: i32 = -12;
pub const SPI_ERROR_REL_NOT_FOUND: i32 = -13;
pub const SPI_OK_CONNECT: u32 = 1;
pub const SPI_OK_FINISH: u32 = 2;
pub const SPI_OK_FETCH: u32 = 3;
pub const SPI_OK_UTILITY: u32 = 4;
pub const SPI_OK_SELECT: u32 = 5;
pub const SPI_OK_SELINTO: u32 = 6;
pub const SPI_OK_INSERT: u32 = 7;
pub const SPI_OK_DELETE: u32 = 8;
pub const SPI_OK_UPDATE: u32 = 9;
pub const SPI_OK_CURSOR: u32 = 10;
pub const SPI_OK_INSERT_RETURNING: u32 = 11;
pub const SPI_OK_DELETE_RETURNING: u32 = 12;
pub const SPI_OK_UPDATE_RETURNING: u32 = 13;
pub const SPI_OK_REWRITTEN: u32 = 14;
pub const SPI_OK_REL_REGISTER: u32 = 15;
pub const SPI_OK_REL_UNREGISTER: u32 = 16;
pub const SPI_OK_TD_REGISTER: u32 = 17;
pub const SPI_OK_MERGE: u32 = 18;
pub const SPI_OPT_NONATOMIC: u32 = 1;
pub const HAVE_PLANNERINFO_TYPEDEF: u32 = 1;
pub const AMFLAG_HAS_TID_RANGE: u32 = 1;
pub const HAVE_INDEXOPTINFO_TYPEDEF: u32 = 1;
pub const HAVE_SPECIALJOININFO_TYPEDEF: u32 = 1;
pub const GROUPING_CAN_USE_SORT: u32 = 1;
pub const GROUPING_CAN_USE_HASH: u32 = 2;
pub const GROUPING_CAN_PARTIAL_AGG: u32 = 4;
pub const FSV_MISSING_OK: u32 = 1;
pub const FDW_MISSING_OK: u32 = 1;
pub const _MM_HINT_ET0: u32 = 7;
pub const _MM_HINT_ET1: u32 = 6;
pub const _MM_HINT_T0: u32 = 3;
pub const _MM_HINT_T1: u32 = 2;
pub const _MM_HINT_T2: u32 = 1;
pub const _MM_HINT_NTA: u32 = 0;
pub const _MM_EXCEPT_INVALID: u32 = 1;
pub const _MM_EXCEPT_DENORM: u32 = 2;
pub const _MM_EXCEPT_DIV_ZERO: u32 = 4;
pub const _MM_EXCEPT_OVERFLOW: u32 = 8;
pub const _MM_EXCEPT_UNDERFLOW: u32 = 16;
pub const _MM_EXCEPT_INEXACT: u32 = 32;
pub const _MM_EXCEPT_MASK: u32 = 63;
pub const _MM_MASK_INVALID: u32 = 128;
pub const _MM_MASK_DENORM: u32 = 256;
pub const _MM_MASK_DIV_ZERO: u32 = 512;
pub const _MM_MASK_OVERFLOW: u32 = 1024;
pub const _MM_MASK_UNDERFLOW: u32 = 2048;
pub const _MM_MASK_INEXACT: u32 = 4096;
pub const _MM_MASK_MASK: u32 = 8064;
pub const _MM_ROUND_NEAREST: u32 = 0;
pub const _MM_ROUND_DOWN: u32 = 8192;
pub const _MM_ROUND_UP: u32 = 16384;
pub const _MM_ROUND_TOWARD_ZERO: u32 = 24576;
pub const _MM_ROUND_MASK: u32 = 24576;
pub const _MM_FLUSH_ZERO_MASK: u32 = 32768;
pub const _MM_FLUSH_ZERO_ON: u32 = 32768;
pub const _MM_FLUSH_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_ON: u32 = 64;
pub const _MM_DENORMALS_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_MASK: u32 = 64;
pub const MAX_MULTIBYTE_CHAR_LEN: u32 = 4;
pub const SS2: u32 = 142;
pub const SS3: u32 = 143;
pub const LC_ISO8859_1: u32 = 129;
pub const LC_ISO8859_2: u32 = 130;
pub const LC_ISO8859_3: u32 = 131;
pub const LC_ISO8859_4: u32 = 132;
pub const LC_TIS620: u32 = 133;
pub const LC_ISO8859_7: u32 = 134;
pub const LC_ISO8859_6: u32 = 135;
pub const LC_ISO8859_8: u32 = 136;
pub const LC_JISX0201K: u32 = 137;
pub const LC_JISX0201R: u32 = 138;
pub const LC_KOI8_R: u32 = 139;
pub const LC_ISO8859_5: u32 = 140;
pub const LC_ISO8859_9: u32 = 141;
pub const LC_ISO8859_15: u32 = 142;
pub const LC_JISX0208_1978: u32 = 144;
pub const LC_GB2312_80: u32 = 145;
pub const LC_JISX0208: u32 = 146;
pub const LC_KS5601: u32 = 147;
pub const LC_JISX0212: u32 = 148;
pub const LC_CNS11643_1: u32 = 149;
pub const LC_CNS11643_2: u32 = 150;
pub const LC_JISX0213_1: u32 = 151;
pub const LC_BIG5_1: u32 = 152;
pub const LC_BIG5_2: u32 = 153;
pub const LCPRV1_A: u32 = 154;
pub const LCPRV1_B: u32 = 155;
pub const LCPRV2_A: u32 = 156;
pub const LCPRV2_B: u32 = 157;
pub const LC_SISHENG: u32 = 160;
pub const LC_IPA: u32 = 161;
pub const LC_VISCII_LOWER: u32 = 162;
pub const LC_VISCII_UPPER: u32 = 163;
pub const LC_ARABIC_DIGIT: u32 = 164;
pub const LC_ARABIC_1_COLUMN: u32 = 165;
pub const LC_ASCII_RIGHT_TO_LEFT: u32 = 166;
pub const LC_LAO: u32 = 167;
pub const LC_ARABIC_2_COLUMN: u32 = 168;
pub const LC_INDIAN_1_COLUMN: u32 = 240;
pub const LC_TIBETAN_1_COLUMN: u32 = 241;
pub const LC_UNICODE_SUBSET_2: u32 = 242;
pub const LC_UNICODE_SUBSET_3: u32 = 243;
pub const LC_UNICODE_SUBSET: u32 = 244;
pub const LC_ETHIOPIC: u32 = 245;
pub const LC_CNS11643_3: u32 = 246;
pub const LC_CNS11643_4: u32 = 247;
pub const LC_CNS11643_5: u32 = 248;
pub const LC_CNS11643_6: u32 = 249;
pub const LC_CNS11643_7: u32 = 250;
pub const LC_INDIAN_2_COLUMN: u32 = 251;
pub const LC_TIBETAN: u32 = 252;
pub const MAX_CONVERSION_GROWTH: u32 = 4;
pub const MAX_CONVERSION_INPUT_LENGTH: u32 = 16;
pub const MAX_UNICODE_EQUIVALENT_STRING: u32 = 16;
pub const EXTNODENAME_MAX_LEN: u32 = 64;
pub const CUSTOMPATH_SUPPORT_BACKWARD_SCAN: u32 = 1;
pub const CUSTOMPATH_SUPPORT_MARK_RESTORE: u32 = 2;
pub const CUSTOMPATH_SUPPORT_PROJECTION: u32 = 4;
pub const QTW_IGNORE_RT_SUBQUERIES: u32 = 1;
pub const QTW_IGNORE_CTE_SUBQUERIES: u32 = 2;
pub const QTW_IGNORE_RC_SUBQUERIES: u32 = 3;
pub const QTW_IGNORE_JOINALIASES: u32 = 4;
pub const QTW_IGNORE_RANGE_TABLE: u32 = 8;
pub const QTW_EXAMINE_RTES_BEFORE: u32 = 16;
pub const QTW_EXAMINE_RTES_AFTER: u32 = 32;
pub const QTW_DONT_COPY_QUERY: u32 = 64;
pub const QTW_EXAMINE_SORTGROUP: u32 = 128;
pub const DEFAULT_SEQ_PAGE_COST: f64 = 1.0;
pub const DEFAULT_RANDOM_PAGE_COST: f64 = 4.0;
pub const DEFAULT_CPU_TUPLE_COST: f64 = 0.01;
pub const DEFAULT_CPU_INDEX_TUPLE_COST: f64 = 0.005;
pub const DEFAULT_CPU_OPERATOR_COST: f64 = 0.0025;
pub const DEFAULT_PARALLEL_TUPLE_COST: f64 = 0.1;
pub const DEFAULT_PARALLEL_SETUP_COST: f64 = 1000.0;
pub const DEFAULT_RECURSIVE_WORKTABLE_FACTOR: f64 = 10.0;
pub const DEFAULT_EFFECTIVE_CACHE_SIZE: u32 = 524288;
pub const PVC_INCLUDE_AGGREGATES: u32 = 1;
pub const PVC_RECURSE_AGGREGATES: u32 = 2;
pub const PVC_INCLUDE_WINDOWFUNCS: u32 = 4;
pub const PVC_RECURSE_WINDOWFUNCS: u32 = 8;
pub const PVC_INCLUDE_PLACEHOLDERS: u32 = 16;
pub const PVC_RECURSE_PLACEHOLDERS: u32 = 32;
pub const DEFAULT_CURSOR_TUPLE_FRACTION: f64 = 0.1;
pub const ER_MAGIC: u32 = 1384727874;
pub const ER_FLAG_FVALUE_VALID: u32 = 1;
pub const ER_FLAG_FVALUE_ALLOCED: u32 = 2;
pub const ER_FLAG_DVALUES_VALID: u32 = 4;
pub const ER_FLAG_DVALUES_ALLOCED: u32 = 8;
pub const ER_FLAG_HAVE_EXTERNAL: u32 = 16;
pub const ER_FLAG_TUPDESC_ALLOCED: u32 = 32;
pub const ER_FLAG_IS_DOMAIN: u32 = 64;
pub const ER_FLAG_IS_DUMMY: u32 = 128;
pub const ER_FLAGS_NON_DATA: u32 = 224;
pub const TYPECACHE_EQ_OPR: u32 = 1;
pub const TYPECACHE_LT_OPR: u32 = 2;
pub const TYPECACHE_GT_OPR: u32 = 4;
pub const TYPECACHE_CMP_PROC: u32 = 8;
pub const TYPECACHE_HASH_PROC: u32 = 16;
pub const TYPECACHE_EQ_OPR_FINFO: u32 = 32;
pub const TYPECACHE_CMP_PROC_FINFO: u32 = 64;
pub const TYPECACHE_HASH_PROC_FINFO: u32 = 128;
pub const TYPECACHE_TUPDESC: u32 = 256;
pub const TYPECACHE_BTREE_OPFAMILY: u32 = 512;
pub const TYPECACHE_HASH_OPFAMILY: u32 = 1024;
pub const TYPECACHE_RANGE_INFO: u32 = 2048;
pub const TYPECACHE_DOMAIN_BASE_INFO: u32 = 4096;
pub const TYPECACHE_DOMAIN_CONSTR_INFO: u32 = 8192;
pub const TYPECACHE_HASH_EXTENDED_PROC: u32 = 16384;
pub const TYPECACHE_HASH_EXTENDED_PROC_FINFO: u32 = 32768;
pub const TYPECACHE_MULTIRANGE_INFO: u32 = 65536;
pub const PLPGSQL_XCHECK_NONE: u32 = 0;
pub const PLPGSQL_XCHECK_SHADOWVAR: u32 = 2;
pub const PLPGSQL_XCHECK_TOOMANYROWS: u32 = 4;
pub const PLPGSQL_XCHECK_STRICTMULTIASSIGNMENT: u32 = 8;
pub const POSTMASTER_FD_WATCH: u32 = 0;
pub const POSTMASTER_FD_OWN: u32 = 1;
pub const MAX_BACKENDS: u32 = 262143;
pub const RBTXN_HAS_CATALOG_CHANGES: u32 = 1;
pub const RBTXN_IS_SUBXACT: u32 = 2;
pub const RBTXN_IS_SERIALIZED: u32 = 4;
pub const RBTXN_IS_SERIALIZED_CLEAR: u32 = 8;
pub const RBTXN_IS_STREAMED: u32 = 16;
pub const RBTXN_HAS_PARTIAL_CHANGE: u32 = 32;
pub const RBTXN_PREPARE: u32 = 64;
pub const RBTXN_SKIPPED_PREPARE: u32 = 128;
pub const RBTXN_HAS_STREAMABLE_CHANGE: u32 = 256;
pub const LOGICALREP_PROTO_MIN_VERSION_NUM: u32 = 1;
pub const LOGICALREP_PROTO_VERSION_NUM: u32 = 1;
pub const LOGICALREP_PROTO_STREAM_VERSION_NUM: u32 = 2;
pub const LOGICALREP_PROTO_TWOPHASE_VERSION_NUM: u32 = 3;
pub const LOGICALREP_PROTO_STREAM_PARALLEL_VERSION_NUM: u32 = 4;
pub const LOGICALREP_PROTO_MAX_VERSION_NUM: u32 = 4;
pub const LOGICALREP_COLUMN_NULL: u8 = 110u8;
pub const LOGICALREP_COLUMN_UNCHANGED: u8 = 117u8;
pub const LOGICALREP_COLUMN_TEXT: u8 = 116u8;
pub const LOGICALREP_COLUMN_BINARY: u8 = 98u8;
pub const MAXCONNINFO: u32 = 1024;
pub const OLD_SNAPSHOT_PADDING_ENTRIES: u32 = 10;
pub const DEFAULT_EFFECTIVE_IO_CONCURRENCY: u32 = 1;
pub const DEFAULT_MAINTENANCE_IO_CONCURRENCY: u32 = 10;
pub const MAX_IO_CONCURRENCY: u32 = 1000;
pub const BUFFER_LOCK_UNLOCK: u32 = 0;
pub const BUFFER_LOCK_SHARE: u32 = 1;
pub const BUFFER_LOCK_EXCLUSIVE: u32 = 2;
pub const XLOG_STANDBY_LOCK: u32 = 0;
pub const XLOG_RUNNING_XACTS: u32 = 16;
pub const XLOG_INVALIDATIONS: u32 = 32;
pub const STACK_DEPTH_SLOP: u32 = 524288;
pub const COMMAND_OK_IN_READ_ONLY_TXN: u32 = 1;
pub const COMMAND_OK_IN_PARALLEL_MODE: u32 = 2;
pub const COMMAND_OK_IN_RECOVERY: u32 = 4;
pub const COMMAND_IS_STRICTLY_READ_ONLY: u32 = 7;
pub const COMMAND_IS_NOT_READ_ONLY: u32 = 0;
pub const MAXSTRLEN: u32 = 2047;
pub const MAXSTRPOS: u32 = 1048575;
pub const MAXENTRYPOS: u32 = 16384;
pub const MAXNUMPOS: u32 = 256;
pub const QI_VAL: u32 = 1;
pub const QI_OPR: u32 = 2;
pub const QI_VALSTOP: u32 = 3;
pub const OP_NOT: u32 = 1;
pub const OP_AND: u32 = 2;
pub const OP_OR: u32 = 3;
pub const OP_PHRASE: u32 = 4;
pub const OP_COUNT: u32 = 4;
pub const TSL_ADDPOS: u32 = 1;
pub const TSL_PREFIX: u32 = 2;
pub const TSL_FILTER: u32 = 4;
pub const P_TSV_OPR_IS_DELIM: u32 = 1;
pub const P_TSV_IS_TSQUERY: u32 = 2;
pub const P_TSV_IS_WEB: u32 = 4;
pub const P_TSQ_PLAIN: u32 = 1;
pub const P_TSQ_WEB: u32 = 2;
pub const TS_EXEC_EMPTY: u32 = 0;
pub const TS_EXEC_SKIP_NOT: u32 = 1;
pub const TS_EXEC_PHRASE_NO_POS: u32 = 2;
pub const TSearchStrategyNumber: u32 = 1;
pub const TSearchWithClassStrategyNumber: u32 = 2;
pub const QTN_NEEDFREE: u32 = 1;
pub const QTN_NOCHANGE: u32 = 2;
pub const QTN_WORDFREE: u32 = 4;
pub const MAXINT8LEN: u32 = 20;
pub const FORMAT_TYPE_TYPEMOD_GIVEN: u32 = 1;
pub const FORMAT_TYPE_ALLOW_INVALID: u32 = 2;
pub const FORMAT_TYPE_FORCE_QUALIFY: u32 = 4;
pub const FORMAT_TYPE_INVALID_AS_NULL: u32 = 8;
pub const MAX_TIME_PRECISION: u32 = 6;
pub const DAGO: &[u8; 4] = b"ago\0";
pub const DCURRENT: &[u8; 8] = b"current\0";
pub const EPOCH: &[u8; 6] = b"epoch\0";
pub const INVALID: &[u8; 8] = b"invalid\0";
pub const EARLY: &[u8; 10] = b"-infinity\0";
pub const LATE: &[u8; 9] = b"infinity\0";
pub const NOW: &[u8; 4] = b"now\0";
pub const TODAY: &[u8; 6] = b"today\0";
pub const TOMORROW: &[u8; 9] = b"tomorrow\0";
pub const YESTERDAY: &[u8; 10] = b"yesterday\0";
pub const ZULU: &[u8; 5] = b"zulu\0";
pub const DMICROSEC: &[u8; 8] = b"usecond\0";
pub const DMILLISEC: &[u8; 8] = b"msecond\0";
pub const DSECOND: &[u8; 7] = b"second\0";
pub const DMINUTE: &[u8; 7] = b"minute\0";
pub const DHOUR: &[u8; 5] = b"hour\0";
pub const DDAY: &[u8; 4] = b"day\0";
pub const DWEEK: &[u8; 5] = b"week\0";
pub const DMONTH: &[u8; 6] = b"month\0";
pub const DQUARTER: &[u8; 8] = b"quarter\0";
pub const DYEAR: &[u8; 5] = b"year\0";
pub const DDECADE: &[u8; 7] = b"decade\0";
pub const DCENTURY: &[u8; 8] = b"century\0";
pub const DMILLENNIUM: &[u8; 11] = b"millennium\0";
pub const DA_D: &[u8; 3] = b"ad\0";
pub const DB_C: &[u8; 3] = b"bc\0";
pub const DTIMEZONE: &[u8; 9] = b"timezone\0";
pub const AM: u32 = 0;
pub const PM: u32 = 1;
pub const HR24: u32 = 2;
pub const AD: u32 = 0;
pub const BC: u32 = 1;
pub const RESERV: u32 = 0;
pub const MONTH: u32 = 1;
pub const YEAR: u32 = 2;
pub const DAY: u32 = 3;
pub const JULIAN: u32 = 4;
pub const TZ: u32 = 5;
pub const DTZ: u32 = 6;
pub const DYNTZ: u32 = 7;
pub const IGNORE_DTF: u32 = 8;
pub const AMPM: u32 = 9;
pub const HOUR: u32 = 10;
pub const MINUTE: u32 = 11;
pub const SECOND: u32 = 12;
pub const MILLISECOND: u32 = 13;
pub const MICROSECOND: u32 = 14;
pub const DOY: u32 = 15;
pub const DOW: u32 = 16;
pub const UNITS: u32 = 17;
pub const ADBC: u32 = 18;
pub const AGO: u32 = 19;
pub const ABS_BEFORE: u32 = 20;
pub const ABS_AFTER: u32 = 21;
pub const ISODATE: u32 = 22;
pub const ISOTIME: u32 = 23;
pub const WEEK: u32 = 24;
pub const DECADE: u32 = 25;
pub const CENTURY: u32 = 26;
pub const MILLENNIUM: u32 = 27;
pub const DTZMOD: u32 = 28;
pub const UNKNOWN_FIELD: u32 = 31;
pub const DTK_NUMBER: u32 = 0;
pub const DTK_STRING: u32 = 1;
pub const DTK_DATE: u32 = 2;
pub const DTK_TIME: u32 = 3;
pub const DTK_TZ: u32 = 4;
pub const DTK_AGO: u32 = 5;
pub const DTK_SPECIAL: u32 = 6;
pub const DTK_EARLY: u32 = 9;
pub const DTK_LATE: u32 = 10;
pub const DTK_EPOCH: u32 = 11;
pub const DTK_NOW: u32 = 12;
pub const DTK_YESTERDAY: u32 = 13;
pub const DTK_TODAY: u32 = 14;
pub const DTK_TOMORROW: u32 = 15;
pub const DTK_ZULU: u32 = 16;
pub const DTK_DELTA: u32 = 17;
pub const DTK_SECOND: u32 = 18;
pub const DTK_MINUTE: u32 = 19;
pub const DTK_HOUR: u32 = 20;
pub const DTK_DAY: u32 = 21;
pub const DTK_WEEK: u32 = 22;
pub const DTK_MONTH: u32 = 23;
pub const DTK_QUARTER: u32 = 24;
pub const DTK_YEAR: u32 = 25;
pub const DTK_DECADE: u32 = 26;
pub const DTK_CENTURY: u32 = 27;
pub const DTK_MILLENNIUM: u32 = 28;
pub const DTK_MILLISEC: u32 = 29;
pub const DTK_MICROSEC: u32 = 30;
pub const DTK_JULIAN: u32 = 31;
pub const DTK_DOW: u32 = 32;
pub const DTK_DOY: u32 = 33;
pub const DTK_TZ_HOUR: u32 = 34;
pub const DTK_TZ_MINUTE: u32 = 35;
pub const DTK_ISOYEAR: u32 = 36;
pub const DTK_ISODOW: u32 = 37;
pub const MAXDATELEN: u32 = 128;
pub const MAXDATEFIELDS: u32 = 25;
pub const TOKMAXLEN: u32 = 10;
pub const DTERR_BAD_FORMAT: i32 = -1;
pub const DTERR_FIELD_OVERFLOW: i32 = -2;
pub const DTERR_MD_FIELD_OVERFLOW: i32 = -3;
pub const DTERR_INTERVAL_OVERFLOW: i32 = -4;
pub const DTERR_TZDISP_OVERFLOW: i32 = -5;
pub const DTERR_BAD_TIMEZONE: i32 = -6;
pub const DTERR_BAD_ZONE_ABBREV: i32 = -7;
pub const TZNAME_FIXED_OFFSET: u32 = 0;
pub const TZNAME_DYNTZ: u32 = 1;
pub const TZNAME_ZONE: u32 = 2;
pub const RADIANS_PER_DEGREE: f64 = 0.017453292519943295;
pub const NUMERIC_MAX_PRECISION: u32 = 1000;
pub const NUMERIC_MIN_SCALE: i32 = -1000;
pub const NUMERIC_MAX_SCALE: u32 = 1000;
pub const NUMERIC_MAX_DISPLAY_SCALE: u32 = 1000;
pub const NUMERIC_MIN_DISPLAY_SCALE: u32 = 0;
pub const NUMERIC_MAX_RESULT_SCALE: u32 = 2000;
pub const NUMERIC_MIN_SIG_DIGITS: u32 = 16;
pub const JsonbContainsStrategyNumber: u32 = 7;
pub const JsonbExistsStrategyNumber: u32 = 9;
pub const JsonbExistsAnyStrategyNumber: u32 = 10;
pub const JsonbExistsAllStrategyNumber: u32 = 11;
pub const JsonbJsonpathExistsStrategyNumber: u32 = 15;
pub const JsonbJsonpathPredicateStrategyNumber: u32 = 16;
pub const JGINFLAG_KEY: u32 = 1;
pub const JGINFLAG_NULL: u32 = 2;
pub const JGINFLAG_BOOL: u32 = 3;
pub const JGINFLAG_NUM: u32 = 4;
pub const JGINFLAG_STR: u32 = 5;
pub const JGINFLAG_HASHED: u32 = 16;
pub const JGIN_MAXLENGTH: u32 = 125;
pub const JENTRY_OFFLENMASK: u32 = 268435455;
pub const JENTRY_TYPEMASK: u32 = 1879048192;
pub const JENTRY_HAS_OFF: u32 = 2147483648;
pub const JENTRY_ISSTRING: u32 = 0;
pub const JENTRY_ISNUMERIC: u32 = 268435456;
pub const JENTRY_ISBOOL_FALSE: u32 = 536870912;
pub const JENTRY_ISBOOL_TRUE: u32 = 805306368;
pub const JENTRY_ISNULL: u32 = 1073741824;
pub const JENTRY_ISCONTAINER: u32 = 1342177280;
pub const JB_OFFSET_STRIDE: u32 = 32;
pub const JB_CMASK: u32 = 268435455;
pub const JB_FSCALAR: u32 = 268435456;
pub const JB_FOBJECT: u32 = 536870912;
pub const JB_FARRAY: u32 = 1073741824;
pub const ATTSTATSSLOT_VALUES: u32 = 1;
pub const ATTSTATSSLOT_NUMBERS: u32 = 2;
pub const DEFAULT_EQ_SEL: f64 = 0.005;
pub const DEFAULT_INEQ_SEL: f64 = 0.3333333333333333;
pub const DEFAULT_RANGE_INEQ_SEL: f64 = 0.005;
pub const DEFAULT_MULTIRANGE_INEQ_SEL: f64 = 0.005;
pub const DEFAULT_MATCH_SEL: f64 = 0.005;
pub const DEFAULT_MATCHING_SEL: f64 = 0.01;
pub const DEFAULT_NUM_DISTINCT: u32 = 200;
pub const DEFAULT_UNK_SEL: f64 = 0.005;
pub const DEFAULT_NOT_UNK_SEL: f64 = 0.995;
pub const SELFLAG_USED_DEFAULT: u32 = 1;
pub const CATCACHE_MAXKEYS: u32 = 4;
pub const CT_MAGIC: u32 = 1462113538;
pub const CL_MAGIC: u32 = 1383485699;
pub const RANGE_EMPTY_LITERAL: &[u8; 6] = b"empty\0";
pub const RANGE_EMPTY: u32 = 1;
pub const RANGE_LB_INC: u32 = 2;
pub const RANGE_UB_INC: u32 = 4;
pub const RANGE_LB_INF: u32 = 8;
pub const RANGE_UB_INF: u32 = 16;
pub const RANGE_LB_NULL: u32 = 32;
pub const RANGE_UB_NULL: u32 = 64;
pub const RANGE_CONTAIN_EMPTY: u32 = 128;
pub const RANGESTRAT_BEFORE: u32 = 1;
pub const RANGESTRAT_OVERLEFT: u32 = 2;
pub const RANGESTRAT_OVERLAPS: u32 = 3;
pub const RANGESTRAT_OVERRIGHT: u32 = 4;
pub const RANGESTRAT_AFTER: u32 = 5;
pub const RANGESTRAT_ADJACENT: u32 = 6;
pub const RANGESTRAT_CONTAINS: u32 = 7;
pub const RANGESTRAT_CONTAINED_BY: u32 = 8;
pub const RANGESTRAT_CONTAINS_ELEM: u32 = 16;
pub const RANGESTRAT_EQ: u32 = 18;
pub type pg_int64 = ::std::os::raw::c_long;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
impl Default for __mbstate_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for __mbstate_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
impl Default for _G_fpos_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
impl Default for _G_fpos64_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
impl Default for _IO_FILE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
pub type fd_mask = __fd_mask;
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
impl Default for __atomic_wide_counter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
impl Default for __pthread_internal_list {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
impl Default for __pthread_internal_slist {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
impl Default for __pthread_mutex_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
impl Default for __pthread_cond_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
impl Default for pthread_mutexattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
impl Default for pthread_condattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
impl Default for pthread_attr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
impl Default for pthread_mutex_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
impl Default for pthread_cond_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
impl Default for pthread_rwlock_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
impl Default for pthread_rwlockattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
impl Default for pthread_barrier_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
impl Default for pthread_barrierattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
impl Default for random_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
impl Default for __locale_struct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lconv {
    pub decimal_point: *mut ::std::os::raw::c_char,
    pub thousands_sep: *mut ::std::os::raw::c_char,
    pub grouping: *mut ::std::os::raw::c_char,
    pub int_curr_symbol: *mut ::std::os::raw::c_char,
    pub currency_symbol: *mut ::std::os::raw::c_char,
    pub mon_decimal_point: *mut ::std::os::raw::c_char,
    pub mon_thousands_sep: *mut ::std::os::raw::c_char,
    pub mon_grouping: *mut ::std::os::raw::c_char,
    pub positive_sign: *mut ::std::os::raw::c_char,
    pub negative_sign: *mut ::std::os::raw::c_char,
    pub int_frac_digits: ::std::os::raw::c_char,
    pub frac_digits: ::std::os::raw::c_char,
    pub p_cs_precedes: ::std::os::raw::c_char,
    pub p_sep_by_space: ::std::os::raw::c_char,
    pub n_cs_precedes: ::std::os::raw::c_char,
    pub n_sep_by_space: ::std::os::raw::c_char,
    pub p_sign_posn: ::std::os::raw::c_char,
    pub n_sign_posn: ::std::os::raw::c_char,
    pub int_p_cs_precedes: ::std::os::raw::c_char,
    pub int_p_sep_by_space: ::std::os::raw::c_char,
    pub int_n_cs_precedes: ::std::os::raw::c_char,
    pub int_n_sep_by_space: ::std::os::raw::c_char,
    pub int_p_sign_posn: ::std::os::raw::c_char,
    pub int_n_sign_posn: ::std::os::raw::c_char,
}
impl Default for lconv {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pg_funcptr_t = ::std::option::Option<unsafe extern "C" fn()>;
pub type Pointer = *mut ::std::os::raw::c_char;
pub type int8 = ::std::os::raw::c_schar;
pub type int16 = ::std::os::raw::c_short;
pub type int32 = ::std::os::raw::c_int;
pub type uint8 = ::std::os::raw::c_uchar;
pub type uint16 = ::std::os::raw::c_ushort;
pub type uint32 = ::std::os::raw::c_uint;
pub type bits8 = uint8;
pub type bits16 = uint16;
pub type bits32 = uint32;
pub type int64 = ::std::os::raw::c_long;
pub type uint64 = ::std::os::raw::c_ulong;
pub type int128 = i128;
pub type uint128 = u128;
pub type Size = usize;
pub type Index = ::std::os::raw::c_uint;
pub type Offset = ::std::os::raw::c_int;
pub type float4 = f32;
pub type float8 = f64;
pub type regproc = Oid;
pub type RegProcedure = regproc;
pub type TransactionId = uint32;
pub type LocalTransactionId = uint32;
pub type SubTransactionId = uint32;
pub type MultiXactId = TransactionId;
pub type MultiXactOffset = uint32;
pub type CommandId = uint32;
#[repr(C)]
#[derive(Debug, Default)]
pub struct varlena {
    pub vl_len_: [::std::os::raw::c_char; 4usize],
    pub vl_dat: __IncompleteArrayField<::std::os::raw::c_char>,
}
pub type bytea = varlena;
pub type text = varlena;
pub type BpChar = varlena;
pub type VarChar = varlena;
#[repr(C)]
#[derive(Debug)]
pub struct int2vector {
    pub vl_len_: int32,
    pub ndim: ::std::os::raw::c_int,
    pub dataoffset: int32,
    pub elemtype: Oid,
    pub dim1: ::std::os::raw::c_int,
    pub lbound1: ::std::os::raw::c_int,
    pub values: __IncompleteArrayField<int16>,
}
impl Default for int2vector {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct oidvector {
    pub vl_len_: int32,
    pub ndim: ::std::os::raw::c_int,
    pub dataoffset: int32,
    pub elemtype: Oid,
    pub dim1: ::std::os::raw::c_int,
    pub lbound1: ::std::os::raw::c_int,
    pub values: __IncompleteArrayField<Oid>,
}
impl Default for oidvector {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nameData {
    pub data: [::std::os::raw::c_char; 64usize],
}
impl Default for nameData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NameData = nameData;
pub type Name = *mut NameData;
#[repr(C)]
#[derive(Copy, Clone)]
pub union PGAlignedBlock {
    pub data: [::std::os::raw::c_char; 8192usize],
    pub force_align_d: f64,
    pub force_align_i64: int64,
}
impl Default for PGAlignedBlock {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(4096))]
#[derive(Copy, Clone)]
pub union PGIOAlignedBlock {
    pub data: [::std::os::raw::c_char; 8192usize],
    pub force_align_d: f64,
    pub force_align_i64: int64,
}
impl Default for PGIOAlignedBlock {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(4096))]
#[derive(Copy, Clone)]
pub union PGAlignedXLogBlock {
    pub data: [::std::os::raw::c_char; 8192usize],
    pub force_align_d: f64,
    pub force_align_i64: int64,
}
impl Default for PGAlignedXLogBlock {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const _ISupper: _bindgen_ty_1 = 256;
pub const _ISlower: _bindgen_ty_1 = 512;
pub const _ISalpha: _bindgen_ty_1 = 1024;
pub const _ISdigit: _bindgen_ty_1 = 2048;
pub const _ISxdigit: _bindgen_ty_1 = 4096;
pub const _ISspace: _bindgen_ty_1 = 8192;
pub const _ISprint: _bindgen_ty_1 = 16384;
pub const _ISgraph: _bindgen_ty_1 = 32768;
pub const _ISblank: _bindgen_ty_1 = 1;
pub const _IScntrl: _bindgen_ty_1 = 2;
pub const _ISpunct: _bindgen_ty_1 = 4;
pub const _ISalnum: _bindgen_ty_1 = 8;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub type pgsocket = ::std::os::raw::c_int;
pub type float_t = f32;
pub type double_t = f64;
pub const FP_NAN: _bindgen_ty_2 = 0;
pub const FP_INFINITE: _bindgen_ty_2 = 1;
pub const FP_ZERO: _bindgen_ty_2 = 2;
pub const FP_SUBNORMAL: _bindgen_ty_2 = 3;
pub const FP_NORMAL: _bindgen_ty_2 = 4;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub type qsort_arg_comparator = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type pqsigfunc =
    ::std::option::Option<unsafe extern "C" fn(postgres_signal_arg: ::std::os::raw::c_int)>;
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
    pub __saved_mask: __sigset_t,
}
pub type jmp_buf = [__jmp_buf_tag; 1usize];
pub type sigjmp_buf = [__jmp_buf_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StringInfoData {
    pub data: *mut ::std::os::raw::c_char,
    pub len: ::std::os::raw::c_int,
    pub maxlen: ::std::os::raw::c_int,
    pub cursor: ::std::os::raw::c_int,
}
impl Default for StringInfoData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type StringInfo = *mut StringInfoData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ErrorContextCallback {
    pub previous: *mut ErrorContextCallback,
    pub callback: ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void)>,
    pub arg: *mut ::std::os::raw::c_void,
}
impl Default for ErrorContextCallback {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ErrorData {
    pub elevel: ::std::os::raw::c_int,
    pub output_to_server: bool,
    pub output_to_client: bool,
    pub hide_stmt: bool,
    pub hide_ctx: bool,
    pub filename: *const ::std::os::raw::c_char,
    pub lineno: ::std::os::raw::c_int,
    pub funcname: *const ::std::os::raw::c_char,
    pub domain: *const ::std::os::raw::c_char,
    pub context_domain: *const ::std::os::raw::c_char,
    pub sqlerrcode: ::std::os::raw::c_int,
    pub message: *mut ::std::os::raw::c_char,
    pub detail: *mut ::std::os::raw::c_char,
    pub detail_log: *mut ::std::os::raw::c_char,
    pub hint: *mut ::std::os::raw::c_char,
    pub context: *mut ::std::os::raw::c_char,
    pub backtrace: *mut ::std::os::raw::c_char,
    pub message_id: *const ::std::os::raw::c_char,
    pub schema_name: *mut ::std::os::raw::c_char,
    pub table_name: *mut ::std::os::raw::c_char,
    pub column_name: *mut ::std::os::raw::c_char,
    pub datatype_name: *mut ::std::os::raw::c_char,
    pub constraint_name: *mut ::std::os::raw::c_char,
    pub cursorpos: ::std::os::raw::c_int,
    pub internalpos: ::std::os::raw::c_int,
    pub internalquery: *mut ::std::os::raw::c_char,
    pub saved_errno: ::std::os::raw::c_int,
    pub assoc_context: *mut MemoryContextData,
}
impl Default for ErrorData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type emit_log_hook_type = ::std::option::Option<unsafe extern "C" fn(edata: *mut ErrorData)>;
pub const PGErrorVerbosity_PGERROR_TERSE: PGErrorVerbosity = 0;
pub const PGErrorVerbosity_PGERROR_DEFAULT: PGErrorVerbosity = 1;
pub const PGErrorVerbosity_PGERROR_VERBOSE: PGErrorVerbosity = 2;
pub type PGErrorVerbosity = ::std::os::raw::c_uint;
pub type MemoryContext = *mut MemoryContextData;
pub type MemoryContextCallbackFunction =
    ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryContextCallback {
    pub func: MemoryContextCallbackFunction,
    pub arg: *mut ::std::os::raw::c_void,
    pub next: *mut MemoryContextCallback,
}
impl Default for MemoryContextCallback {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type AttrNumber = int16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_attribute {
    pub attrelid: Oid,
    pub attname: NameData,
    pub atttypid: Oid,
    pub attlen: int16,
    pub attnum: int16,
    pub attcacheoff: int32,
    pub atttypmod: int32,
    pub attndims: int16,
    pub attbyval: bool,
    pub attalign: ::std::os::raw::c_char,
    pub attstorage: ::std::os::raw::c_char,
    pub attcompression: ::std::os::raw::c_char,
    pub attnotnull: bool,
    pub atthasdef: bool,
    pub atthasmissing: bool,
    pub attidentity: ::std::os::raw::c_char,
    pub attgenerated: ::std::os::raw::c_char,
    pub attisdropped: bool,
    pub attislocal: bool,
    pub attinhcount: int16,
    pub attstattarget: int16,
    pub attcollation: Oid,
}
impl Default for FormData_pg_attribute {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_attribute = *mut FormData_pg_attribute;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum NodeTag {
    T_Invalid = 0,
    T_List = 1,
    T_Alias = 2,
    T_RangeVar = 3,
    T_TableFunc = 4,
    T_IntoClause = 5,
    T_Var = 6,
    T_Const = 7,
    T_Param = 8,
    T_Aggref = 9,
    T_GroupingFunc = 10,
    T_WindowFunc = 11,
    T_SubscriptingRef = 12,
    T_FuncExpr = 13,
    T_NamedArgExpr = 14,
    T_OpExpr = 15,
    T_DistinctExpr = 16,
    T_NullIfExpr = 17,
    T_ScalarArrayOpExpr = 18,
    T_BoolExpr = 19,
    T_SubLink = 20,
    T_SubPlan = 21,
    T_AlternativeSubPlan = 22,
    T_FieldSelect = 23,
    T_FieldStore = 24,
    T_RelabelType = 25,
    T_CoerceViaIO = 26,
    T_ArrayCoerceExpr = 27,
    T_ConvertRowtypeExpr = 28,
    T_CollateExpr = 29,
    T_CaseExpr = 30,
    T_CaseWhen = 31,
    T_CaseTestExpr = 32,
    T_ArrayExpr = 33,
    T_RowExpr = 34,
    T_RowCompareExpr = 35,
    T_CoalesceExpr = 36,
    T_MinMaxExpr = 37,
    T_SQLValueFunction = 38,
    T_XmlExpr = 39,
    T_JsonFormat = 40,
    T_JsonReturning = 41,
    T_JsonValueExpr = 42,
    T_JsonConstructorExpr = 43,
    T_JsonIsPredicate = 44,
    T_NullTest = 45,
    T_BooleanTest = 46,
    T_CoerceToDomain = 47,
    T_CoerceToDomainValue = 48,
    T_SetToDefault = 49,
    T_CurrentOfExpr = 50,
    T_NextValueExpr = 51,
    T_InferenceElem = 52,
    T_TargetEntry = 53,
    T_RangeTblRef = 54,
    T_JoinExpr = 55,
    T_FromExpr = 56,
    T_OnConflictExpr = 57,
    T_Query = 58,
    T_TypeName = 59,
    T_ColumnRef = 60,
    T_ParamRef = 61,
    T_A_Expr = 62,
    T_A_Const = 63,
    T_TypeCast = 64,
    T_CollateClause = 65,
    T_RoleSpec = 66,
    T_FuncCall = 67,
    T_A_Star = 68,
    T_A_Indices = 69,
    T_A_Indirection = 70,
    T_A_ArrayExpr = 71,
    T_ResTarget = 72,
    T_MultiAssignRef = 73,
    T_SortBy = 74,
    T_WindowDef = 75,
    T_RangeSubselect = 76,
    T_RangeFunction = 77,
    T_RangeTableFunc = 78,
    T_RangeTableFuncCol = 79,
    T_RangeTableSample = 80,
    T_ColumnDef = 81,
    T_TableLikeClause = 82,
    T_IndexElem = 83,
    T_DefElem = 84,
    T_LockingClause = 85,
    T_XmlSerialize = 86,
    T_PartitionElem = 87,
    T_PartitionSpec = 88,
    T_PartitionBoundSpec = 89,
    T_PartitionRangeDatum = 90,
    T_PartitionCmd = 91,
    T_RangeTblEntry = 92,
    T_RTEPermissionInfo = 93,
    T_RangeTblFunction = 94,
    T_TableSampleClause = 95,
    T_WithCheckOption = 96,
    T_SortGroupClause = 97,
    T_GroupingSet = 98,
    T_WindowClause = 99,
    T_RowMarkClause = 100,
    T_WithClause = 101,
    T_InferClause = 102,
    T_OnConflictClause = 103,
    T_CTESearchClause = 104,
    T_CTECycleClause = 105,
    T_CommonTableExpr = 106,
    T_MergeWhenClause = 107,
    T_MergeAction = 108,
    T_TriggerTransition = 109,
    T_JsonOutput = 110,
    T_JsonKeyValue = 111,
    T_JsonObjectConstructor = 112,
    T_JsonArrayConstructor = 113,
    T_JsonArrayQueryConstructor = 114,
    T_JsonAggConstructor = 115,
    T_JsonObjectAgg = 116,
    T_JsonArrayAgg = 117,
    T_RawStmt = 118,
    T_InsertStmt = 119,
    T_DeleteStmt = 120,
    T_UpdateStmt = 121,
    T_MergeStmt = 122,
    T_SelectStmt = 123,
    T_SetOperationStmt = 124,
    T_ReturnStmt = 125,
    T_PLAssignStmt = 126,
    T_CreateSchemaStmt = 127,
    T_AlterTableStmt = 128,
    T_ReplicaIdentityStmt = 129,
    T_AlterTableCmd = 130,
    T_AlterCollationStmt = 131,
    T_AlterDomainStmt = 132,
    T_GrantStmt = 133,
    T_ObjectWithArgs = 134,
    T_AccessPriv = 135,
    T_GrantRoleStmt = 136,
    T_AlterDefaultPrivilegesStmt = 137,
    T_CopyStmt = 138,
    T_VariableSetStmt = 139,
    T_VariableShowStmt = 140,
    T_CreateStmt = 141,
    T_Constraint = 142,
    T_CreateTableSpaceStmt = 143,
    T_DropTableSpaceStmt = 144,
    T_AlterTableSpaceOptionsStmt = 145,
    T_AlterTableMoveAllStmt = 146,
    T_CreateExtensionStmt = 147,
    T_AlterExtensionStmt = 148,
    T_AlterExtensionContentsStmt = 149,
    T_CreateFdwStmt = 150,
    T_AlterFdwStmt = 151,
    T_CreateForeignServerStmt = 152,
    T_AlterForeignServerStmt = 153,
    T_CreateForeignTableStmt = 154,
    T_CreateUserMappingStmt = 155,
    T_AlterUserMappingStmt = 156,
    T_DropUserMappingStmt = 157,
    T_ImportForeignSchemaStmt = 158,
    T_CreatePolicyStmt = 159,
    T_AlterPolicyStmt = 160,
    T_CreateAmStmt = 161,
    T_CreateTrigStmt = 162,
    T_CreateEventTrigStmt = 163,
    T_AlterEventTrigStmt = 164,
    T_CreatePLangStmt = 165,
    T_CreateRoleStmt = 166,
    T_AlterRoleStmt = 167,
    T_AlterRoleSetStmt = 168,
    T_DropRoleStmt = 169,
    T_CreateSeqStmt = 170,
    T_AlterSeqStmt = 171,
    T_DefineStmt = 172,
    T_CreateDomainStmt = 173,
    T_CreateOpClassStmt = 174,
    T_CreateOpClassItem = 175,
    T_CreateOpFamilyStmt = 176,
    T_AlterOpFamilyStmt = 177,
    T_DropStmt = 178,
    T_TruncateStmt = 179,
    T_CommentStmt = 180,
    T_SecLabelStmt = 181,
    T_DeclareCursorStmt = 182,
    T_ClosePortalStmt = 183,
    T_FetchStmt = 184,
    T_IndexStmt = 185,
    T_CreateStatsStmt = 186,
    T_StatsElem = 187,
    T_AlterStatsStmt = 188,
    T_CreateFunctionStmt = 189,
    T_FunctionParameter = 190,
    T_AlterFunctionStmt = 191,
    T_DoStmt = 192,
    T_InlineCodeBlock = 193,
    T_CallStmt = 194,
    T_CallContext = 195,
    T_RenameStmt = 196,
    T_AlterObjectDependsStmt = 197,
    T_AlterObjectSchemaStmt = 198,
    T_AlterOwnerStmt = 199,
    T_AlterOperatorStmt = 200,
    T_AlterTypeStmt = 201,
    T_RuleStmt = 202,
    T_NotifyStmt = 203,
    T_ListenStmt = 204,
    T_UnlistenStmt = 205,
    T_TransactionStmt = 206,
    T_CompositeTypeStmt = 207,
    T_CreateEnumStmt = 208,
    T_CreateRangeStmt = 209,
    T_AlterEnumStmt = 210,
    T_ViewStmt = 211,
    T_LoadStmt = 212,
    T_CreatedbStmt = 213,
    T_AlterDatabaseStmt = 214,
    T_AlterDatabaseRefreshCollStmt = 215,
    T_AlterDatabaseSetStmt = 216,
    T_DropdbStmt = 217,
    T_AlterSystemStmt = 218,
    T_ClusterStmt = 219,
    T_VacuumStmt = 220,
    T_VacuumRelation = 221,
    T_ExplainStmt = 222,
    T_CreateTableAsStmt = 223,
    T_RefreshMatViewStmt = 224,
    T_CheckPointStmt = 225,
    T_DiscardStmt = 226,
    T_LockStmt = 227,
    T_ConstraintsSetStmt = 228,
    T_ReindexStmt = 229,
    T_CreateConversionStmt = 230,
    T_CreateCastStmt = 231,
    T_CreateTransformStmt = 232,
    T_PrepareStmt = 233,
    T_ExecuteStmt = 234,
    T_DeallocateStmt = 235,
    T_DropOwnedStmt = 236,
    T_ReassignOwnedStmt = 237,
    T_AlterTSDictionaryStmt = 238,
    T_AlterTSConfigurationStmt = 239,
    T_PublicationTable = 240,
    T_PublicationObjSpec = 241,
    T_CreatePublicationStmt = 242,
    T_AlterPublicationStmt = 243,
    T_CreateSubscriptionStmt = 244,
    T_AlterSubscriptionStmt = 245,
    T_DropSubscriptionStmt = 246,
    T_PlannerGlobal = 247,
    T_PlannerInfo = 248,
    T_RelOptInfo = 249,
    T_IndexOptInfo = 250,
    T_ForeignKeyOptInfo = 251,
    T_StatisticExtInfo = 252,
    T_JoinDomain = 253,
    T_EquivalenceClass = 254,
    T_EquivalenceMember = 255,
    T_PathKey = 256,
    T_PathTarget = 257,
    T_ParamPathInfo = 258,
    T_Path = 259,
    T_IndexPath = 260,
    T_IndexClause = 261,
    T_BitmapHeapPath = 262,
    T_BitmapAndPath = 263,
    T_BitmapOrPath = 264,
    T_TidPath = 265,
    T_TidRangePath = 266,
    T_SubqueryScanPath = 267,
    T_ForeignPath = 268,
    T_CustomPath = 269,
    T_AppendPath = 270,
    T_MergeAppendPath = 271,
    T_GroupResultPath = 272,
    T_MaterialPath = 273,
    T_MemoizePath = 274,
    T_UniquePath = 275,
    T_GatherPath = 276,
    T_GatherMergePath = 277,
    T_NestPath = 278,
    T_MergePath = 279,
    T_HashPath = 280,
    T_ProjectionPath = 281,
    T_ProjectSetPath = 282,
    T_SortPath = 283,
    T_IncrementalSortPath = 284,
    T_GroupPath = 285,
    T_UpperUniquePath = 286,
    T_AggPath = 287,
    T_GroupingSetData = 288,
    T_RollupData = 289,
    T_GroupingSetsPath = 290,
    T_MinMaxAggPath = 291,
    T_WindowAggPath = 292,
    T_SetOpPath = 293,
    T_RecursiveUnionPath = 294,
    T_LockRowsPath = 295,
    T_ModifyTablePath = 296,
    T_LimitPath = 297,
    T_RestrictInfo = 298,
    T_PlaceHolderVar = 299,
    T_SpecialJoinInfo = 300,
    T_OuterJoinClauseInfo = 301,
    T_AppendRelInfo = 302,
    T_RowIdentityVarInfo = 303,
    T_PlaceHolderInfo = 304,
    T_MinMaxAggInfo = 305,
    T_PlannerParamItem = 306,
    T_AggInfo = 307,
    T_AggTransInfo = 308,
    T_PlannedStmt = 309,
    T_Result = 310,
    T_ProjectSet = 311,
    T_ModifyTable = 312,
    T_Append = 313,
    T_MergeAppend = 314,
    T_RecursiveUnion = 315,
    T_BitmapAnd = 316,
    T_BitmapOr = 317,
    T_SeqScan = 318,
    T_SampleScan = 319,
    T_IndexScan = 320,
    T_IndexOnlyScan = 321,
    T_BitmapIndexScan = 322,
    T_BitmapHeapScan = 323,
    T_TidScan = 324,
    T_TidRangeScan = 325,
    T_SubqueryScan = 326,
    T_FunctionScan = 327,
    T_ValuesScan = 328,
    T_TableFuncScan = 329,
    T_CteScan = 330,
    T_NamedTuplestoreScan = 331,
    T_WorkTableScan = 332,
    T_ForeignScan = 333,
    T_CustomScan = 334,
    T_NestLoop = 335,
    T_NestLoopParam = 336,
    T_MergeJoin = 337,
    T_HashJoin = 338,
    T_Material = 339,
    T_Memoize = 340,
    T_Sort = 341,
    T_IncrementalSort = 342,
    T_Group = 343,
    T_Agg = 344,
    T_WindowAgg = 345,
    T_Unique = 346,
    T_Gather = 347,
    T_GatherMerge = 348,
    T_Hash = 349,
    T_SetOp = 350,
    T_LockRows = 351,
    T_Limit = 352,
    T_PlanRowMark = 353,
    T_PartitionPruneInfo = 354,
    T_PartitionedRelPruneInfo = 355,
    T_PartitionPruneStepOp = 356,
    T_PartitionPruneStepCombine = 357,
    T_PlanInvalItem = 358,
    T_ExprState = 359,
    T_IndexInfo = 360,
    T_ExprContext = 361,
    T_ReturnSetInfo = 362,
    T_ProjectionInfo = 363,
    T_JunkFilter = 364,
    T_OnConflictSetState = 365,
    T_MergeActionState = 366,
    T_ResultRelInfo = 367,
    T_EState = 368,
    T_WindowFuncExprState = 369,
    T_SetExprState = 370,
    T_SubPlanState = 371,
    T_DomainConstraintState = 372,
    T_ResultState = 373,
    T_ProjectSetState = 374,
    T_ModifyTableState = 375,
    T_AppendState = 376,
    T_MergeAppendState = 377,
    T_RecursiveUnionState = 378,
    T_BitmapAndState = 379,
    T_BitmapOrState = 380,
    T_ScanState = 381,
    T_SeqScanState = 382,
    T_SampleScanState = 383,
    T_IndexScanState = 384,
    T_IndexOnlyScanState = 385,
    T_BitmapIndexScanState = 386,
    T_BitmapHeapScanState = 387,
    T_TidScanState = 388,
    T_TidRangeScanState = 389,
    T_SubqueryScanState = 390,
    T_FunctionScanState = 391,
    T_ValuesScanState = 392,
    T_TableFuncScanState = 393,
    T_CteScanState = 394,
    T_NamedTuplestoreScanState = 395,
    T_WorkTableScanState = 396,
    T_ForeignScanState = 397,
    T_CustomScanState = 398,
    T_JoinState = 399,
    T_NestLoopState = 400,
    T_MergeJoinState = 401,
    T_HashJoinState = 402,
    T_MaterialState = 403,
    T_MemoizeState = 404,
    T_SortState = 405,
    T_IncrementalSortState = 406,
    T_GroupState = 407,
    T_AggState = 408,
    T_WindowAggState = 409,
    T_UniqueState = 410,
    T_GatherState = 411,
    T_GatherMergeState = 412,
    T_HashState = 413,
    T_SetOpState = 414,
    T_LockRowsState = 415,
    T_LimitState = 416,
    T_IndexAmRoutine = 417,
    T_TableAmRoutine = 418,
    T_TsmRoutine = 419,
    T_EventTriggerData = 420,
    T_TriggerData = 421,
    T_TupleTableSlot = 422,
    T_FdwRoutine = 423,
    T_Bitmapset = 424,
    T_ExtensibleNode = 425,
    T_ErrorSaveContext = 426,
    T_IdentifySystemCmd = 427,
    T_BaseBackupCmd = 428,
    T_CreateReplicationSlotCmd = 429,
    T_DropReplicationSlotCmd = 430,
    T_StartReplicationCmd = 431,
    T_ReadReplicationSlotCmd = 432,
    T_TimeLineHistoryCmd = 433,
    T_SupportRequestSimplify = 434,
    T_SupportRequestSelectivity = 435,
    T_SupportRequestCost = 436,
    T_SupportRequestRows = 437,
    T_SupportRequestIndexCondition = 438,
    T_SupportRequestWFuncMonotonic = 439,
    T_SupportRequestOptimizeWindowClause = 440,
    T_Integer = 441,
    T_Float = 442,
    T_Boolean = 443,
    T_String = 444,
    T_BitString = 445,
    T_ForeignKeyCacheInfo = 446,
    T_IntList = 447,
    T_OidList = 448,
    T_XidList = 449,
    T_AllocSetContext = 450,
    T_GenerationContext = 451,
    T_SlabContext = 452,
    T_TIDBitmap = 453,
    T_WindowObjectData = 454,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Node {
    pub type_: NodeTag,
}
impl Default for Node {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Selectivity = f64;
pub type Cost = f64;
pub type Cardinality = f64;
pub const CmdType_CMD_UNKNOWN: CmdType = 0;
pub const CmdType_CMD_SELECT: CmdType = 1;
pub const CmdType_CMD_UPDATE: CmdType = 2;
pub const CmdType_CMD_INSERT: CmdType = 3;
pub const CmdType_CMD_DELETE: CmdType = 4;
pub const CmdType_CMD_MERGE: CmdType = 5;
pub const CmdType_CMD_UTILITY: CmdType = 6;
pub const CmdType_CMD_NOTHING: CmdType = 7;
pub type CmdType = ::std::os::raw::c_uint;
pub const JoinType_JOIN_INNER: JoinType = 0;
pub const JoinType_JOIN_LEFT: JoinType = 1;
pub const JoinType_JOIN_FULL: JoinType = 2;
pub const JoinType_JOIN_RIGHT: JoinType = 3;
pub const JoinType_JOIN_SEMI: JoinType = 4;
pub const JoinType_JOIN_ANTI: JoinType = 5;
pub const JoinType_JOIN_RIGHT_ANTI: JoinType = 6;
pub const JoinType_JOIN_UNIQUE_OUTER: JoinType = 7;
pub const JoinType_JOIN_UNIQUE_INNER: JoinType = 8;
pub type JoinType = ::std::os::raw::c_uint;
pub const AggStrategy_AGG_PLAIN: AggStrategy = 0;
pub const AggStrategy_AGG_SORTED: AggStrategy = 1;
pub const AggStrategy_AGG_HASHED: AggStrategy = 2;
pub const AggStrategy_AGG_MIXED: AggStrategy = 3;
pub type AggStrategy = ::std::os::raw::c_uint;
pub const AggSplit_AGGSPLIT_SIMPLE: AggSplit = 0;
pub const AggSplit_AGGSPLIT_INITIAL_SERIAL: AggSplit = 6;
pub const AggSplit_AGGSPLIT_FINAL_DESERIAL: AggSplit = 9;
pub type AggSplit = ::std::os::raw::c_uint;
pub const SetOpCmd_SETOPCMD_INTERSECT: SetOpCmd = 0;
pub const SetOpCmd_SETOPCMD_INTERSECT_ALL: SetOpCmd = 1;
pub const SetOpCmd_SETOPCMD_EXCEPT: SetOpCmd = 2;
pub const SetOpCmd_SETOPCMD_EXCEPT_ALL: SetOpCmd = 3;
pub type SetOpCmd = ::std::os::raw::c_uint;
pub const SetOpStrategy_SETOP_SORTED: SetOpStrategy = 0;
pub const SetOpStrategy_SETOP_HASHED: SetOpStrategy = 1;
pub type SetOpStrategy = ::std::os::raw::c_uint;
pub const OnConflictAction_ONCONFLICT_NONE: OnConflictAction = 0;
pub const OnConflictAction_ONCONFLICT_NOTHING: OnConflictAction = 1;
pub const OnConflictAction_ONCONFLICT_UPDATE: OnConflictAction = 2;
pub type OnConflictAction = ::std::os::raw::c_uint;
pub const LimitOption_LIMIT_OPTION_COUNT: LimitOption = 0;
pub const LimitOption_LIMIT_OPTION_WITH_TIES: LimitOption = 1;
pub const LimitOption_LIMIT_OPTION_DEFAULT: LimitOption = 2;
pub type LimitOption = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union ListCell {
    pub ptr_value: *mut ::std::os::raw::c_void,
    pub int_value: ::std::os::raw::c_int,
    pub oid_value: Oid,
    pub xid_value: TransactionId,
}
impl Default for ListCell {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct List {
    pub type_: NodeTag,
    pub length: ::std::os::raw::c_int,
    pub max_length: ::std::os::raw::c_int,
    pub elements: *mut ListCell,
    pub initial_elements: __IncompleteArrayField<ListCell>,
}
impl Default for List {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForEachState {
    pub l: *const List,
    pub i: ::std::os::raw::c_int,
}
impl Default for ForEachState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForBothState {
    pub l1: *const List,
    pub l2: *const List,
    pub i: ::std::os::raw::c_int,
}
impl Default for ForBothState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForBothCellState {
    pub l1: *const List,
    pub l2: *const List,
    pub i1: ::std::os::raw::c_int,
    pub i2: ::std::os::raw::c_int,
}
impl Default for ForBothCellState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForThreeState {
    pub l1: *const List,
    pub l2: *const List,
    pub l3: *const List,
    pub i: ::std::os::raw::c_int,
}
impl Default for ForThreeState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForFourState {
    pub l1: *const List,
    pub l2: *const List,
    pub l3: *const List,
    pub l4: *const List,
    pub i: ::std::os::raw::c_int,
}
impl Default for ForFourState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForFiveState {
    pub l1: *const List,
    pub l2: *const List,
    pub l3: *const List,
    pub l4: *const List,
    pub l5: *const List,
    pub i: ::std::os::raw::c_int,
}
impl Default for ForFiveState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type list_sort_comparator = ::std::option::Option<
    unsafe extern "C" fn(a: *const ListCell, b: *const ListCell) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AttrDefault {
    pub adnum: AttrNumber,
    pub adbin: *mut ::std::os::raw::c_char,
}
impl Default for AttrDefault {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConstrCheck {
    pub ccname: *mut ::std::os::raw::c_char,
    pub ccbin: *mut ::std::os::raw::c_char,
    pub ccvalid: bool,
    pub ccnoinherit: bool,
}
impl Default for ConstrCheck {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TupleConstr {
    pub defval: *mut AttrDefault,
    pub check: *mut ConstrCheck,
    pub missing: *mut AttrMissing,
    pub num_defval: uint16,
    pub num_check: uint16,
    pub has_not_null: bool,
    pub has_generated_stored: bool,
}
impl Default for TupleConstr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct TupleDescData {
    pub natts: ::std::os::raw::c_int,
    pub tdtypeid: Oid,
    pub tdtypmod: int32,
    pub tdrefcount: ::std::os::raw::c_int,
    pub constr: *mut TupleConstr,
    pub attrs: __IncompleteArrayField<FormData_pg_attribute>,
}
impl Default for TupleDescData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TupleDesc = *mut TupleDescData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AttrMap {
    pub attnums: *mut AttrNumber,
    pub maplen: ::std::os::raw::c_int,
}
impl Default for AttrMap {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type BlockNumber = uint32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct BlockIdData {
    pub bi_hi: uint16,
    pub bi_lo: uint16,
}
pub type BlockId = *mut BlockIdData;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct ItemIdData {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl ItemIdData {
    #[inline]
    pub fn lp_off(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_lp_off(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn lp_flags(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_lp_flags(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn lp_len(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_lp_len(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        lp_off: ::std::os::raw::c_uint,
        lp_flags: ::std::os::raw::c_uint,
        lp_len: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 15u8, {
            let lp_off: u32 = unsafe { ::std::mem::transmute(lp_off) };
            lp_off as u64
        });
        __bindgen_bitfield_unit.set(15usize, 2u8, {
            let lp_flags: u32 = unsafe { ::std::mem::transmute(lp_flags) };
            lp_flags as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let lp_len: u32 = unsafe { ::std::mem::transmute(lp_len) };
            lp_len as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ItemId = *mut ItemIdData;
pub type ItemOffset = uint16;
pub type ItemLength = uint16;
pub type OffsetNumber = uint16;
#[repr(C, packed(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct ItemPointerData {
    pub ip_blkid: BlockIdData,
    pub ip_posid: OffsetNumber,
}
pub type ItemPointer = *mut ItemPointerData;
pub type HeapTupleHeader = *mut HeapTupleHeaderData;
pub type MinimalTuple = *mut MinimalTupleData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HeapTupleData {
    pub t_len: uint32,
    pub t_self: ItemPointerData,
    pub t_tableOid: Oid,
    pub t_data: HeapTupleHeader,
}
impl Default for HeapTupleData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type HeapTuple = *mut HeapTupleData;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct flock {
    pub l_type: ::std::os::raw::c_short,
    pub l_whence: ::std::os::raw::c_short,
    pub l_start: __off_t,
    pub l_len: __off_t,
    pub l_pid: __pid_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: ::std::os::raw::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3usize],
}
pub type XLogRecPtr = uint64;
pub type XLogSegNo = uint64;
pub type TimeLineID = uint32;
pub type RepOriginId = uint16;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FullTransactionId {
    pub value: uint64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VariableCacheData {
    pub nextOid: Oid,
    pub oidCount: uint32,
    pub nextXid: FullTransactionId,
    pub oldestXid: TransactionId,
    pub xidVacLimit: TransactionId,
    pub xidWarnLimit: TransactionId,
    pub xidStopLimit: TransactionId,
    pub xidWrapLimit: TransactionId,
    pub oldestXidDB: Oid,
    pub oldestCommitTsXid: TransactionId,
    pub newestCommitTsXid: TransactionId,
    pub latestCompletedXid: FullTransactionId,
    pub xactCompletionCount: uint64,
    pub oldestClogXid: TransactionId,
}
impl Default for VariableCacheData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VariableCache = *mut VariableCacheData;
pub type Item = Pointer;
pub type Page = Pointer;
pub type LocationIndex = uint16;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PageXLogRecPtr {
    pub xlogid: uint32,
    pub xrecoff: uint32,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct PageHeaderData {
    pub pd_lsn: PageXLogRecPtr,
    pub pd_checksum: uint16,
    pub pd_flags: uint16,
    pub pd_lower: LocationIndex,
    pub pd_upper: LocationIndex,
    pub pd_special: LocationIndex,
    pub pd_pagesize_version: uint16,
    pub pd_prune_xid: TransactionId,
    pub pd_linp: __IncompleteArrayField<ItemIdData>,
}
pub type PageHeader = *mut PageHeaderData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct varatt_external {
    pub va_rawsize: int32,
    pub va_extinfo: uint32,
    pub va_valueid: Oid,
    pub va_toastrelid: Oid,
}
impl Default for varatt_external {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct varatt_indirect {
    pub pointer: *mut varlena,
}
impl Default for varatt_indirect {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct varatt_expanded {
    pub eohptr: *mut ExpandedObjectHeader,
}
impl Default for varatt_expanded {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const vartag_external_VARTAG_INDIRECT: vartag_external = 1;
pub const vartag_external_VARTAG_EXPANDED_RO: vartag_external = 2;
pub const vartag_external_VARTAG_EXPANDED_RW: vartag_external = 3;
pub const vartag_external_VARTAG_ONDISK: vartag_external = 18;
pub type vartag_external = ::std::os::raw::c_uint;
#[repr(C)]
pub struct varattrib_4b {
    pub va_4byte: __BindgenUnionField<varattrib_4b__bindgen_ty_1>,
    pub va_compressed: __BindgenUnionField<varattrib_4b__bindgen_ty_2>,
    pub bindgen_union_field: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct varattrib_4b__bindgen_ty_1 {
    pub va_header: uint32,
    pub va_data: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct varattrib_4b__bindgen_ty_2 {
    pub va_header: uint32,
    pub va_tcinfo: uint32,
    pub va_data: __IncompleteArrayField<::std::os::raw::c_char>,
}
impl Default for varattrib_4b {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct varattrib_1b {
    pub va_header: uint8,
    pub va_data: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct varattrib_1b_e {
    pub va_header: uint8,
    pub va_tag: uint8,
    pub va_data: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HeapTupleFields {
    pub t_xmin: TransactionId,
    pub t_xmax: TransactionId,
    pub t_field3: HeapTupleFields__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union HeapTupleFields__bindgen_ty_1 {
    pub t_cid: CommandId,
    pub t_xvac: TransactionId,
}
impl Default for HeapTupleFields__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for HeapTupleFields {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DatumTupleFields {
    pub datum_len_: int32,
    pub datum_typmod: int32,
    pub datum_typeid: Oid,
}
impl Default for DatumTupleFields {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct HeapTupleHeaderData {
    pub t_choice: HeapTupleHeaderData__bindgen_ty_1,
    pub t_ctid: ItemPointerData,
    pub t_infomask2: uint16,
    pub t_infomask: uint16,
    pub t_hoff: uint8,
    pub t_bits: __IncompleteArrayField<bits8>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union HeapTupleHeaderData__bindgen_ty_1 {
    pub t_heap: HeapTupleFields,
    pub t_datum: DatumTupleFields,
}
impl Default for HeapTupleHeaderData__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for HeapTupleHeaderData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct MinimalTupleData {
    pub t_len: uint32,
    pub mt_padding: [::std::os::raw::c_char; 6usize],
    pub t_infomask2: uint16,
    pub t_infomask: uint16,
    pub t_hoff: uint8,
    pub t_bits: __IncompleteArrayField<bits8>,
}
pub type Buffer = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BufferAccessStrategyData {
    _unused: [u8; 0],
}
pub type BufferAccessStrategy = *mut BufferAccessStrategyData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TupleTableSlot {
    pub type_: NodeTag,
    pub tts_flags: uint16,
    pub tts_nvalid: AttrNumber,
    pub tts_ops: *const TupleTableSlotOps,
    pub tts_tupleDescriptor: TupleDesc,
    pub tts_values: *mut Datum,
    pub tts_isnull: *mut bool,
    pub tts_mcxt: MemoryContext,
    pub tts_tid: ItemPointerData,
    pub tts_tableOid: Oid,
}
impl Default for TupleTableSlot {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TupleTableSlotOps {
    pub base_slot_size: usize,
    pub init: ::std::option::Option<unsafe extern "C" fn(slot: *mut TupleTableSlot)>,
    pub release: ::std::option::Option<unsafe extern "C" fn(slot: *mut TupleTableSlot)>,
    pub clear: ::std::option::Option<unsafe extern "C" fn(slot: *mut TupleTableSlot)>,
    pub getsomeattrs: ::std::option::Option<
        unsafe extern "C" fn(slot: *mut TupleTableSlot, natts: ::std::os::raw::c_int),
    >,
    pub getsysattr: ::std::option::Option<
        unsafe extern "C" fn(
            slot: *mut TupleTableSlot,
            attnum: ::std::os::raw::c_int,
            isnull: *mut bool,
        ) -> Datum,
    >,
    pub materialize: ::std::option::Option<unsafe extern "C" fn(slot: *mut TupleTableSlot)>,
    pub copyslot: ::std::option::Option<
        unsafe extern "C" fn(dstslot: *mut TupleTableSlot, srcslot: *mut TupleTableSlot),
    >,
    pub get_heap_tuple:
        ::std::option::Option<unsafe extern "C" fn(slot: *mut TupleTableSlot) -> HeapTuple>,
    pub get_minimal_tuple:
        ::std::option::Option<unsafe extern "C" fn(slot: *mut TupleTableSlot) -> MinimalTuple>,
    pub copy_heap_tuple:
        ::std::option::Option<unsafe extern "C" fn(slot: *mut TupleTableSlot) -> HeapTuple>,
    pub copy_minimal_tuple:
        ::std::option::Option<unsafe extern "C" fn(slot: *mut TupleTableSlot) -> MinimalTuple>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VirtualTupleTableSlot {
    pub base: TupleTableSlot,
    pub data: *mut ::std::os::raw::c_char,
}
impl Default for VirtualTupleTableSlot {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HeapTupleTableSlot {
    pub base: TupleTableSlot,
    pub tuple: HeapTuple,
    pub off: uint32,
    pub tupdata: HeapTupleData,
}
impl Default for HeapTupleTableSlot {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BufferHeapTupleTableSlot {
    pub base: HeapTupleTableSlot,
    pub buffer: Buffer,
}
impl Default for BufferHeapTupleTableSlot {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MinimalTupleTableSlot {
    pub base: TupleTableSlot,
    pub tuple: HeapTuple,
    pub mintuple: MinimalTuple,
    pub minhdr: HeapTupleData,
    pub off: uint32,
}
impl Default for MinimalTupleTableSlot {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type bitmapword = uint64;
pub type signedbitmapword = int64;
#[repr(C)]
#[derive(Debug)]
pub struct Bitmapset {
    pub type_: NodeTag,
    pub nwords: ::std::os::raw::c_int,
    pub words: __IncompleteArrayField<bitmapword>,
}
impl Default for Bitmapset {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const BMS_Comparison_BMS_EQUAL: BMS_Comparison = 0;
pub const BMS_Comparison_BMS_SUBSET1: BMS_Comparison = 1;
pub const BMS_Comparison_BMS_SUBSET2: BMS_Comparison = 2;
pub const BMS_Comparison_BMS_DIFFERENT: BMS_Comparison = 3;
pub type BMS_Comparison = ::std::os::raw::c_uint;
pub const BMS_Membership_BMS_EMPTY_SET: BMS_Membership = 0;
pub const BMS_Membership_BMS_SINGLETON: BMS_Membership = 1;
pub const BMS_Membership_BMS_MULTIPLE: BMS_Membership = 2;
pub type BMS_Membership = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TupleConversionMap {
    pub indesc: TupleDesc,
    pub outdesc: TupleDesc,
    pub attrMap: *mut AttrMap,
    pub invalues: *mut Datum,
    pub inisnull: *mut bool,
    pub outvalues: *mut Datum,
    pub outisnull: *mut bool,
}
impl Default for TupleConversionMap {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct instr_time {
    pub ticks: int64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
impl Default for tm {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct BufferUsage {
    pub shared_blks_hit: int64,
    pub shared_blks_read: int64,
    pub shared_blks_dirtied: int64,
    pub shared_blks_written: int64,
    pub local_blks_hit: int64,
    pub local_blks_read: int64,
    pub local_blks_dirtied: int64,
    pub local_blks_written: int64,
    pub temp_blks_read: int64,
    pub temp_blks_written: int64,
    pub blk_read_time: instr_time,
    pub blk_write_time: instr_time,
    pub temp_blk_read_time: instr_time,
    pub temp_blk_write_time: instr_time,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WalUsage {
    pub wal_records: int64,
    pub wal_fpi: int64,
    pub wal_bytes: uint64,
}
pub const InstrumentOption_INSTRUMENT_TIMER: InstrumentOption = 1;
pub const InstrumentOption_INSTRUMENT_BUFFERS: InstrumentOption = 2;
pub const InstrumentOption_INSTRUMENT_ROWS: InstrumentOption = 4;
pub const InstrumentOption_INSTRUMENT_WAL: InstrumentOption = 8;
pub const InstrumentOption_INSTRUMENT_ALL: InstrumentOption = 2147483647;
pub type InstrumentOption = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Instrumentation {
    pub need_timer: bool,
    pub need_bufusage: bool,
    pub need_walusage: bool,
    pub async_mode: bool,
    pub running: bool,
    pub starttime: instr_time,
    pub counter: instr_time,
    pub firsttuple: f64,
    pub tuplecount: f64,
    pub bufusage_start: BufferUsage,
    pub walusage_start: WalUsage,
    pub startup: f64,
    pub total: f64,
    pub ntuples: f64,
    pub ntuples2: f64,
    pub nloops: f64,
    pub nfiltered1: f64,
    pub nfiltered2: f64,
    pub bufusage: BufferUsage,
    pub walusage: WalUsage,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct WorkerInstrumentation {
    pub num_workers: ::std::os::raw::c_int,
    pub instrument: __IncompleteArrayField<Instrumentation>,
}
pub type fmNodePtr = *mut Node;
pub type fmAggrefPtr = *mut Aggref;
pub type fmExprContextCallbackFunction = ::std::option::Option<unsafe extern "C" fn(arg: Datum)>;
pub type fmStringInfo = *mut StringInfoData;
pub type FunctionCallInfo = *mut FunctionCallInfoBaseData;
pub type PGFunction =
    ::std::option::Option<unsafe extern "C" fn(fcinfo: FunctionCallInfo) -> Datum>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FmgrInfo {
    pub fn_addr: PGFunction,
    pub fn_oid: Oid,
    pub fn_nargs: ::std::os::raw::c_short,
    pub fn_strict: bool,
    pub fn_retset: bool,
    pub fn_stats: ::std::os::raw::c_uchar,
    pub fn_extra: *mut ::std::os::raw::c_void,
    pub fn_mcxt: MemoryContext,
    pub fn_expr: fmNodePtr,
}
impl Default for FmgrInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct FunctionCallInfoBaseData {
    pub flinfo: *mut FmgrInfo,
    pub context: fmNodePtr,
    pub resultinfo: fmNodePtr,
    pub fncollation: Oid,
    pub isnull: bool,
    pub nargs: ::std::os::raw::c_short,
    pub args: __IncompleteArrayField<NullableDatum>,
}
impl Default for FunctionCallInfoBaseData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Pg_finfo_record {
    pub api_version: ::std::os::raw::c_int,
}
pub type PGFInfoFunction = ::std::option::Option<unsafe extern "C" fn() -> *const Pg_finfo_record>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Pg_magic_struct {
    pub len: ::std::os::raw::c_int,
    pub version: ::std::os::raw::c_int,
    pub funcmaxargs: ::std::os::raw::c_int,
    pub indexmaxkeys: ::std::os::raw::c_int,
    pub namedatalen: ::std::os::raw::c_int,
    pub float8byval: ::std::os::raw::c_int,
    pub abi_extra: [::std::os::raw::c_char; 32usize],
}
pub type PGModuleMagicFunction =
    ::std::option::Option<unsafe extern "C" fn() -> *const Pg_magic_struct>;
pub const FmgrHookEventType_FHET_START: FmgrHookEventType = 0;
pub const FmgrHookEventType_FHET_END: FmgrHookEventType = 1;
pub const FmgrHookEventType_FHET_ABORT: FmgrHookEventType = 2;
pub type FmgrHookEventType = ::std::os::raw::c_uint;
pub type needs_fmgr_hook_type = ::std::option::Option<unsafe extern "C" fn(fn_oid: Oid) -> bool>;
pub type fmgr_hook_type = ::std::option::Option<
    unsafe extern "C" fn(event: FmgrHookEventType, flinfo: *mut FmgrInfo, arg: *mut Datum),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dlist_node {
    pub prev: *mut dlist_node,
    pub next: *mut dlist_node,
}
impl Default for dlist_node {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dlist_head {
    pub head: dlist_node,
}
impl Default for dlist_head {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dlist_iter {
    pub cur: *mut dlist_node,
    pub end: *mut dlist_node,
}
impl Default for dlist_iter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dlist_mutable_iter {
    pub cur: *mut dlist_node,
    pub next: *mut dlist_node,
    pub end: *mut dlist_node,
}
impl Default for dlist_mutable_iter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dclist_head {
    pub dlist: dlist_head,
    pub count: uint32,
}
impl Default for dclist_head {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slist_node {
    pub next: *mut slist_node,
}
impl Default for slist_node {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slist_head {
    pub head: slist_node,
}
impl Default for slist_head {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slist_iter {
    pub cur: *mut slist_node,
}
impl Default for slist_iter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slist_mutable_iter {
    pub cur: *mut slist_node,
    pub next: *mut slist_node,
    pub prev: *mut slist_node,
}
impl Default for slist_mutable_iter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pairingheap_node {
    pub first_child: *mut pairingheap_node,
    pub next_sibling: *mut pairingheap_node,
    pub prev_or_parent: *mut pairingheap_node,
}
impl Default for pairingheap_node {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pairingheap_comparator = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const pairingheap_node,
        b: *const pairingheap_node,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pairingheap {
    pub ph_compare: pairingheap_comparator,
    pub ph_arg: *mut ::std::os::raw::c_void,
    pub ph_root: *mut pairingheap_node,
}
impl Default for pairingheap {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParamExternData {
    pub value: Datum,
    pub isnull: bool,
    pub pflags: uint16,
    pub ptype: Oid,
}
impl Default for ParamExternData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ParamListInfo = *mut ParamListInfoData;
pub type ParamFetchHook = ::std::option::Option<
    unsafe extern "C" fn(
        params: ParamListInfo,
        paramid: ::std::os::raw::c_int,
        speculative: bool,
        workspace: *mut ParamExternData,
    ) -> *mut ParamExternData,
>;
pub type ParamCompileHook = ::std::option::Option<
    unsafe extern "C" fn(
        params: ParamListInfo,
        param: *mut Param,
        state: *mut ExprState,
        resv: *mut Datum,
        resnull: *mut bool,
    ),
>;
pub type ParserSetupHook = ::std::option::Option<
    unsafe extern "C" fn(pstate: *mut ParseState, arg: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug)]
pub struct ParamListInfoData {
    pub paramFetch: ParamFetchHook,
    pub paramFetchArg: *mut ::std::os::raw::c_void,
    pub paramCompile: ParamCompileHook,
    pub paramCompileArg: *mut ::std::os::raw::c_void,
    pub parserSetup: ParserSetupHook,
    pub parserSetupArg: *mut ::std::os::raw::c_void,
    pub paramValuesStr: *mut ::std::os::raw::c_char,
    pub numParams: ::std::os::raw::c_int,
    pub params: __IncompleteArrayField<ParamExternData>,
}
impl Default for ParamListInfoData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParamExecData {
    pub execPlan: *mut ::std::os::raw::c_void,
    pub value: Datum,
    pub isnull: bool,
}
impl Default for ParamExecData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParamsErrorCbData {
    pub portalName: *const ::std::os::raw::c_char,
    pub params: ParamListInfo,
}
impl Default for ParamsErrorCbData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ScanDirection_BackwardScanDirection: ScanDirection = -1;
pub const ScanDirection_NoMovementScanDirection: ScanDirection = 0;
pub const ScanDirection_ForwardScanDirection: ScanDirection = 1;
pub type ScanDirection = ::std::os::raw::c_int;
pub type StrategyNumber = uint16;
pub type RelFileNumber = Oid;
pub const ForkNumber_InvalidForkNumber: ForkNumber = -1;
pub const ForkNumber_MAIN_FORKNUM: ForkNumber = 0;
pub const ForkNumber_FSM_FORKNUM: ForkNumber = 1;
pub const ForkNumber_VISIBILITYMAP_FORKNUM: ForkNumber = 2;
pub const ForkNumber_INIT_FORKNUM: ForkNumber = 3;
pub type ForkNumber = ::std::os::raw::c_int;
pub const LockClauseStrength_LCS_NONE: LockClauseStrength = 0;
pub const LockClauseStrength_LCS_FORKEYSHARE: LockClauseStrength = 1;
pub const LockClauseStrength_LCS_FORSHARE: LockClauseStrength = 2;
pub const LockClauseStrength_LCS_FORNOKEYUPDATE: LockClauseStrength = 3;
pub const LockClauseStrength_LCS_FORUPDATE: LockClauseStrength = 4;
pub type LockClauseStrength = ::std::os::raw::c_uint;
pub const LockWaitPolicy_LockWaitBlock: LockWaitPolicy = 0;
pub const LockWaitPolicy_LockWaitSkip: LockWaitPolicy = 1;
pub const LockWaitPolicy_LockWaitError: LockWaitPolicy = 2;
pub type LockWaitPolicy = ::std::os::raw::c_uint;
pub const LockTupleMode_LockTupleKeyShare: LockTupleMode = 0;
pub const LockTupleMode_LockTupleShare: LockTupleMode = 1;
pub const LockTupleMode_LockTupleNoKeyExclusive: LockTupleMode = 2;
pub const LockTupleMode_LockTupleExclusive: LockTupleMode = 3;
pub type LockTupleMode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Alias {
    pub type_: NodeTag,
    pub aliasname: *mut ::std::os::raw::c_char,
    pub colnames: *mut List,
}
impl Default for Alias {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const OnCommitAction_ONCOMMIT_NOOP: OnCommitAction = 0;
pub const OnCommitAction_ONCOMMIT_PRESERVE_ROWS: OnCommitAction = 1;
pub const OnCommitAction_ONCOMMIT_DELETE_ROWS: OnCommitAction = 2;
pub const OnCommitAction_ONCOMMIT_DROP: OnCommitAction = 3;
pub type OnCommitAction = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeVar {
    pub type_: NodeTag,
    pub catalogname: *mut ::std::os::raw::c_char,
    pub schemaname: *mut ::std::os::raw::c_char,
    pub relname: *mut ::std::os::raw::c_char,
    pub inh: bool,
    pub relpersistence: ::std::os::raw::c_char,
    pub alias: *mut Alias,
    pub location: ::std::os::raw::c_int,
}
impl Default for RangeVar {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TableFunc {
    pub type_: NodeTag,
    pub ns_uris: *mut List,
    pub ns_names: *mut List,
    pub docexpr: *mut Node,
    pub rowexpr: *mut Node,
    pub colnames: *mut List,
    pub coltypes: *mut List,
    pub coltypmods: *mut List,
    pub colcollations: *mut List,
    pub colexprs: *mut List,
    pub coldefexprs: *mut List,
    pub notnulls: *mut Bitmapset,
    pub ordinalitycol: ::std::os::raw::c_int,
    pub location: ::std::os::raw::c_int,
}
impl Default for TableFunc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IntoClause {
    pub type_: NodeTag,
    pub rel: *mut RangeVar,
    pub colNames: *mut List,
    pub accessMethod: *mut ::std::os::raw::c_char,
    pub options: *mut List,
    pub onCommit: OnCommitAction,
    pub tableSpaceName: *mut ::std::os::raw::c_char,
    pub viewQuery: *mut Node,
    pub skipData: bool,
}
impl Default for IntoClause {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Expr {
    pub type_: NodeTag,
}
impl Default for Expr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Var {
    pub xpr: Expr,
    pub varno: ::std::os::raw::c_int,
    pub varattno: AttrNumber,
    pub vartype: Oid,
    pub vartypmod: int32,
    pub varcollid: Oid,
    pub varnullingrels: *mut Bitmapset,
    pub varlevelsup: Index,
    pub varnosyn: Index,
    pub varattnosyn: AttrNumber,
    pub location: ::std::os::raw::c_int,
}
impl Default for Var {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Const {
    pub xpr: Expr,
    pub consttype: Oid,
    pub consttypmod: int32,
    pub constcollid: Oid,
    pub constlen: ::std::os::raw::c_int,
    pub constvalue: Datum,
    pub constisnull: bool,
    pub constbyval: bool,
    pub location: ::std::os::raw::c_int,
}
impl Default for Const {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ParamKind_PARAM_EXTERN: ParamKind = 0;
pub const ParamKind_PARAM_EXEC: ParamKind = 1;
pub const ParamKind_PARAM_SUBLINK: ParamKind = 2;
pub const ParamKind_PARAM_MULTIEXPR: ParamKind = 3;
pub type ParamKind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Param {
    pub xpr: Expr,
    pub paramkind: ParamKind,
    pub paramid: ::std::os::raw::c_int,
    pub paramtype: Oid,
    pub paramtypmod: int32,
    pub paramcollid: Oid,
    pub location: ::std::os::raw::c_int,
}
impl Default for Param {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Aggref {
    pub xpr: Expr,
    pub aggfnoid: Oid,
    pub aggtype: Oid,
    pub aggcollid: Oid,
    pub inputcollid: Oid,
    pub aggtranstype: Oid,
    pub aggargtypes: *mut List,
    pub aggdirectargs: *mut List,
    pub args: *mut List,
    pub aggorder: *mut List,
    pub aggdistinct: *mut List,
    pub aggfilter: *mut Expr,
    pub aggstar: bool,
    pub aggvariadic: bool,
    pub aggkind: ::std::os::raw::c_char,
    pub aggpresorted: bool,
    pub agglevelsup: Index,
    pub aggsplit: AggSplit,
    pub aggno: ::std::os::raw::c_int,
    pub aggtransno: ::std::os::raw::c_int,
    pub location: ::std::os::raw::c_int,
}
impl Default for Aggref {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GroupingFunc {
    pub xpr: Expr,
    pub args: *mut List,
    pub refs: *mut List,
    pub cols: *mut List,
    pub agglevelsup: Index,
    pub location: ::std::os::raw::c_int,
}
impl Default for GroupingFunc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowFunc {
    pub xpr: Expr,
    pub winfnoid: Oid,
    pub wintype: Oid,
    pub wincollid: Oid,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub aggfilter: *mut Expr,
    pub winref: Index,
    pub winstar: bool,
    pub winagg: bool,
    pub location: ::std::os::raw::c_int,
}
impl Default for WindowFunc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubscriptingRef {
    pub xpr: Expr,
    pub refcontainertype: Oid,
    pub refelemtype: Oid,
    pub refrestype: Oid,
    pub reftypmod: int32,
    pub refcollid: Oid,
    pub refupperindexpr: *mut List,
    pub reflowerindexpr: *mut List,
    pub refexpr: *mut Expr,
    pub refassgnexpr: *mut Expr,
}
impl Default for SubscriptingRef {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const CoercionContext_COERCION_IMPLICIT: CoercionContext = 0;
pub const CoercionContext_COERCION_ASSIGNMENT: CoercionContext = 1;
pub const CoercionContext_COERCION_PLPGSQL: CoercionContext = 2;
pub const CoercionContext_COERCION_EXPLICIT: CoercionContext = 3;
pub type CoercionContext = ::std::os::raw::c_uint;
pub const CoercionForm_COERCE_EXPLICIT_CALL: CoercionForm = 0;
pub const CoercionForm_COERCE_EXPLICIT_CAST: CoercionForm = 1;
pub const CoercionForm_COERCE_IMPLICIT_CAST: CoercionForm = 2;
pub const CoercionForm_COERCE_SQL_SYNTAX: CoercionForm = 3;
pub type CoercionForm = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuncExpr {
    pub xpr: Expr,
    pub funcid: Oid,
    pub funcresulttype: Oid,
    pub funcretset: bool,
    pub funcvariadic: bool,
    pub funcformat: CoercionForm,
    pub funccollid: Oid,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl Default for FuncExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NamedArgExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub name: *mut ::std::os::raw::c_char,
    pub argnumber: ::std::os::raw::c_int,
    pub location: ::std::os::raw::c_int,
}
impl Default for NamedArgExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpExpr {
    pub xpr: Expr,
    pub opno: Oid,
    pub opfuncid: Oid,
    pub opresulttype: Oid,
    pub opretset: bool,
    pub opcollid: Oid,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl Default for OpExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type DistinctExpr = OpExpr;
pub type NullIfExpr = OpExpr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScalarArrayOpExpr {
    pub xpr: Expr,
    pub opno: Oid,
    pub opfuncid: Oid,
    pub hashfuncid: Oid,
    pub negfuncid: Oid,
    pub useOr: bool,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl Default for ScalarArrayOpExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const BoolExprType_AND_EXPR: BoolExprType = 0;
pub const BoolExprType_OR_EXPR: BoolExprType = 1;
pub const BoolExprType_NOT_EXPR: BoolExprType = 2;
pub type BoolExprType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BoolExpr {
    pub xpr: Expr,
    pub boolop: BoolExprType,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl Default for BoolExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const SubLinkType_EXISTS_SUBLINK: SubLinkType = 0;
pub const SubLinkType_ALL_SUBLINK: SubLinkType = 1;
pub const SubLinkType_ANY_SUBLINK: SubLinkType = 2;
pub const SubLinkType_ROWCOMPARE_SUBLINK: SubLinkType = 3;
pub const SubLinkType_EXPR_SUBLINK: SubLinkType = 4;
pub const SubLinkType_MULTIEXPR_SUBLINK: SubLinkType = 5;
pub const SubLinkType_ARRAY_SUBLINK: SubLinkType = 6;
pub const SubLinkType_CTE_SUBLINK: SubLinkType = 7;
pub type SubLinkType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubLink {
    pub xpr: Expr,
    pub subLinkType: SubLinkType,
    pub subLinkId: ::std::os::raw::c_int,
    pub testexpr: *mut Node,
    pub operName: *mut List,
    pub subselect: *mut Node,
    pub location: ::std::os::raw::c_int,
}
impl Default for SubLink {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubPlan {
    pub xpr: Expr,
    pub subLinkType: SubLinkType,
    pub testexpr: *mut Node,
    pub paramIds: *mut List,
    pub plan_id: ::std::os::raw::c_int,
    pub plan_name: *mut ::std::os::raw::c_char,
    pub firstColType: Oid,
    pub firstColTypmod: int32,
    pub firstColCollation: Oid,
    pub useHashTable: bool,
    pub unknownEqFalse: bool,
    pub parallel_safe: bool,
    pub setParam: *mut List,
    pub parParam: *mut List,
    pub args: *mut List,
    pub startup_cost: Cost,
    pub per_call_cost: Cost,
}
impl Default for SubPlan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlternativeSubPlan {
    pub xpr: Expr,
    pub subplans: *mut List,
}
impl Default for AlternativeSubPlan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FieldSelect {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub fieldnum: AttrNumber,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
}
impl Default for FieldSelect {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FieldStore {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub newvals: *mut List,
    pub fieldnums: *mut List,
    pub resulttype: Oid,
}
impl Default for FieldStore {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RelabelType {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
    pub relabelformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
impl Default for RelabelType {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CoerceViaIO {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub resultcollid: Oid,
    pub coerceformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
impl Default for CoerceViaIO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayCoerceExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub elemexpr: *mut Expr,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
    pub coerceformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
impl Default for ArrayCoerceExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConvertRowtypeExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub convertformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
impl Default for ConvertRowtypeExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CollateExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub collOid: Oid,
    pub location: ::std::os::raw::c_int,
}
impl Default for CollateExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CaseExpr {
    pub xpr: Expr,
    pub casetype: Oid,
    pub casecollid: Oid,
    pub arg: *mut Expr,
    pub args: *mut List,
    pub defresult: *mut Expr,
    pub location: ::std::os::raw::c_int,
}
impl Default for CaseExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CaseWhen {
    pub xpr: Expr,
    pub expr: *mut Expr,
    pub result: *mut Expr,
    pub location: ::std::os::raw::c_int,
}
impl Default for CaseWhen {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CaseTestExpr {
    pub xpr: Expr,
    pub typeId: Oid,
    pub typeMod: int32,
    pub collation: Oid,
}
impl Default for CaseTestExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayExpr {
    pub xpr: Expr,
    pub array_typeid: Oid,
    pub array_collid: Oid,
    pub element_typeid: Oid,
    pub elements: *mut List,
    pub multidims: bool,
    pub location: ::std::os::raw::c_int,
}
impl Default for ArrayExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RowExpr {
    pub xpr: Expr,
    pub args: *mut List,
    pub row_typeid: Oid,
    pub row_format: CoercionForm,
    pub colnames: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl Default for RowExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const RowCompareType_ROWCOMPARE_LT: RowCompareType = 1;
pub const RowCompareType_ROWCOMPARE_LE: RowCompareType = 2;
pub const RowCompareType_ROWCOMPARE_EQ: RowCompareType = 3;
pub const RowCompareType_ROWCOMPARE_GE: RowCompareType = 4;
pub const RowCompareType_ROWCOMPARE_GT: RowCompareType = 5;
pub const RowCompareType_ROWCOMPARE_NE: RowCompareType = 6;
pub type RowCompareType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RowCompareExpr {
    pub xpr: Expr,
    pub rctype: RowCompareType,
    pub opnos: *mut List,
    pub opfamilies: *mut List,
    pub inputcollids: *mut List,
    pub largs: *mut List,
    pub rargs: *mut List,
}
impl Default for RowCompareExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CoalesceExpr {
    pub xpr: Expr,
    pub coalescetype: Oid,
    pub coalescecollid: Oid,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl Default for CoalesceExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const MinMaxOp_IS_GREATEST: MinMaxOp = 0;
pub const MinMaxOp_IS_LEAST: MinMaxOp = 1;
pub type MinMaxOp = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MinMaxExpr {
    pub xpr: Expr,
    pub minmaxtype: Oid,
    pub minmaxcollid: Oid,
    pub inputcollid: Oid,
    pub op: MinMaxOp,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl Default for MinMaxExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const SQLValueFunctionOp_SVFOP_CURRENT_DATE: SQLValueFunctionOp = 0;
pub const SQLValueFunctionOp_SVFOP_CURRENT_TIME: SQLValueFunctionOp = 1;
pub const SQLValueFunctionOp_SVFOP_CURRENT_TIME_N: SQLValueFunctionOp = 2;
pub const SQLValueFunctionOp_SVFOP_CURRENT_TIMESTAMP: SQLValueFunctionOp = 3;
pub const SQLValueFunctionOp_SVFOP_CURRENT_TIMESTAMP_N: SQLValueFunctionOp = 4;
pub const SQLValueFunctionOp_SVFOP_LOCALTIME: SQLValueFunctionOp = 5;
pub const SQLValueFunctionOp_SVFOP_LOCALTIME_N: SQLValueFunctionOp = 6;
pub const SQLValueFunctionOp_SVFOP_LOCALTIMESTAMP: SQLValueFunctionOp = 7;
pub const SQLValueFunctionOp_SVFOP_LOCALTIMESTAMP_N: SQLValueFunctionOp = 8;
pub const SQLValueFunctionOp_SVFOP_CURRENT_ROLE: SQLValueFunctionOp = 9;
pub const SQLValueFunctionOp_SVFOP_CURRENT_USER: SQLValueFunctionOp = 10;
pub const SQLValueFunctionOp_SVFOP_USER: SQLValueFunctionOp = 11;
pub const SQLValueFunctionOp_SVFOP_SESSION_USER: SQLValueFunctionOp = 12;
pub const SQLValueFunctionOp_SVFOP_CURRENT_CATALOG: SQLValueFunctionOp = 13;
pub const SQLValueFunctionOp_SVFOP_CURRENT_SCHEMA: SQLValueFunctionOp = 14;
pub type SQLValueFunctionOp = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SQLValueFunction {
    pub xpr: Expr,
    pub op: SQLValueFunctionOp,
    pub type_: Oid,
    pub typmod: int32,
    pub location: ::std::os::raw::c_int,
}
impl Default for SQLValueFunction {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const XmlExprOp_IS_XMLCONCAT: XmlExprOp = 0;
pub const XmlExprOp_IS_XMLELEMENT: XmlExprOp = 1;
pub const XmlExprOp_IS_XMLFOREST: XmlExprOp = 2;
pub const XmlExprOp_IS_XMLPARSE: XmlExprOp = 3;
pub const XmlExprOp_IS_XMLPI: XmlExprOp = 4;
pub const XmlExprOp_IS_XMLROOT: XmlExprOp = 5;
pub const XmlExprOp_IS_XMLSERIALIZE: XmlExprOp = 6;
pub const XmlExprOp_IS_DOCUMENT: XmlExprOp = 7;
pub type XmlExprOp = ::std::os::raw::c_uint;
pub const XmlOptionType_XMLOPTION_DOCUMENT: XmlOptionType = 0;
pub const XmlOptionType_XMLOPTION_CONTENT: XmlOptionType = 1;
pub type XmlOptionType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XmlExpr {
    pub xpr: Expr,
    pub op: XmlExprOp,
    pub name: *mut ::std::os::raw::c_char,
    pub named_args: *mut List,
    pub arg_names: *mut List,
    pub args: *mut List,
    pub xmloption: XmlOptionType,
    pub indent: bool,
    pub type_: Oid,
    pub typmod: int32,
    pub location: ::std::os::raw::c_int,
}
impl Default for XmlExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const JsonEncoding_JS_ENC_DEFAULT: JsonEncoding = 0;
pub const JsonEncoding_JS_ENC_UTF8: JsonEncoding = 1;
pub const JsonEncoding_JS_ENC_UTF16: JsonEncoding = 2;
pub const JsonEncoding_JS_ENC_UTF32: JsonEncoding = 3;
pub type JsonEncoding = ::std::os::raw::c_uint;
pub const JsonFormatType_JS_FORMAT_DEFAULT: JsonFormatType = 0;
pub const JsonFormatType_JS_FORMAT_JSON: JsonFormatType = 1;
pub const JsonFormatType_JS_FORMAT_JSONB: JsonFormatType = 2;
pub type JsonFormatType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonFormat {
    pub type_: NodeTag,
    pub format_type: JsonFormatType,
    pub encoding: JsonEncoding,
    pub location: ::std::os::raw::c_int,
}
impl Default for JsonFormat {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonReturning {
    pub type_: NodeTag,
    pub format: *mut JsonFormat,
    pub typid: Oid,
    pub typmod: int32,
}
impl Default for JsonReturning {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonValueExpr {
    pub type_: NodeTag,
    pub raw_expr: *mut Expr,
    pub formatted_expr: *mut Expr,
    pub format: *mut JsonFormat,
}
impl Default for JsonValueExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const JsonConstructorType_JSCTOR_JSON_OBJECT: JsonConstructorType = 1;
pub const JsonConstructorType_JSCTOR_JSON_ARRAY: JsonConstructorType = 2;
pub const JsonConstructorType_JSCTOR_JSON_OBJECTAGG: JsonConstructorType = 3;
pub const JsonConstructorType_JSCTOR_JSON_ARRAYAGG: JsonConstructorType = 4;
pub type JsonConstructorType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonConstructorExpr {
    pub xpr: Expr,
    pub type_: JsonConstructorType,
    pub args: *mut List,
    pub func: *mut Expr,
    pub coercion: *mut Expr,
    pub returning: *mut JsonReturning,
    pub absent_on_null: bool,
    pub unique: bool,
    pub location: ::std::os::raw::c_int,
}
impl Default for JsonConstructorExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const JsonValueType_JS_TYPE_ANY: JsonValueType = 0;
pub const JsonValueType_JS_TYPE_OBJECT: JsonValueType = 1;
pub const JsonValueType_JS_TYPE_ARRAY: JsonValueType = 2;
pub const JsonValueType_JS_TYPE_SCALAR: JsonValueType = 3;
pub type JsonValueType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonIsPredicate {
    pub type_: NodeTag,
    pub expr: *mut Node,
    pub format: *mut JsonFormat,
    pub item_type: JsonValueType,
    pub unique_keys: bool,
    pub location: ::std::os::raw::c_int,
}
impl Default for JsonIsPredicate {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const NullTestType_IS_NULL: NullTestType = 0;
pub const NullTestType_IS_NOT_NULL: NullTestType = 1;
pub type NullTestType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NullTest {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub nulltesttype: NullTestType,
    pub argisrow: bool,
    pub location: ::std::os::raw::c_int,
}
impl Default for NullTest {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const BoolTestType_IS_TRUE: BoolTestType = 0;
pub const BoolTestType_IS_NOT_TRUE: BoolTestType = 1;
pub const BoolTestType_IS_FALSE: BoolTestType = 2;
pub const BoolTestType_IS_NOT_FALSE: BoolTestType = 3;
pub const BoolTestType_IS_UNKNOWN: BoolTestType = 4;
pub const BoolTestType_IS_NOT_UNKNOWN: BoolTestType = 5;
pub type BoolTestType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BooleanTest {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub booltesttype: BoolTestType,
    pub location: ::std::os::raw::c_int,
}
impl Default for BooleanTest {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CoerceToDomain {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
    pub coercionformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
impl Default for CoerceToDomain {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CoerceToDomainValue {
    pub xpr: Expr,
    pub typeId: Oid,
    pub typeMod: int32,
    pub collation: Oid,
    pub location: ::std::os::raw::c_int,
}
impl Default for CoerceToDomainValue {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SetToDefault {
    pub xpr: Expr,
    pub typeId: Oid,
    pub typeMod: int32,
    pub collation: Oid,
    pub location: ::std::os::raw::c_int,
}
impl Default for SetToDefault {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CurrentOfExpr {
    pub xpr: Expr,
    pub cvarno: Index,
    pub cursor_name: *mut ::std::os::raw::c_char,
    pub cursor_param: ::std::os::raw::c_int,
}
impl Default for CurrentOfExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NextValueExpr {
    pub xpr: Expr,
    pub seqid: Oid,
    pub typeId: Oid,
}
impl Default for NextValueExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InferenceElem {
    pub xpr: Expr,
    pub expr: *mut Node,
    pub infercollid: Oid,
    pub inferopclass: Oid,
}
impl Default for InferenceElem {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TargetEntry {
    pub xpr: Expr,
    pub expr: *mut Expr,
    pub resno: AttrNumber,
    pub resname: *mut ::std::os::raw::c_char,
    pub ressortgroupref: Index,
    pub resorigtbl: Oid,
    pub resorigcol: AttrNumber,
    pub resjunk: bool,
}
impl Default for TargetEntry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeTblRef {
    pub type_: NodeTag,
    pub rtindex: ::std::os::raw::c_int,
}
impl Default for RangeTblRef {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JoinExpr {
    pub type_: NodeTag,
    pub jointype: JoinType,
    pub isNatural: bool,
    pub larg: *mut Node,
    pub rarg: *mut Node,
    pub usingClause: *mut List,
    pub join_using_alias: *mut Alias,
    pub quals: *mut Node,
    pub alias: *mut Alias,
    pub rtindex: ::std::os::raw::c_int,
}
impl Default for JoinExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FromExpr {
    pub type_: NodeTag,
    pub fromlist: *mut List,
    pub quals: *mut Node,
}
impl Default for FromExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OnConflictExpr {
    pub type_: NodeTag,
    pub action: OnConflictAction,
    pub arbiterElems: *mut List,
    pub arbiterWhere: *mut Node,
    pub constraint: Oid,
    pub onConflictSet: *mut List,
    pub onConflictWhere: *mut Node,
    pub exclRelIndex: ::std::os::raw::c_int,
    pub exclRelTlist: *mut List,
}
impl Default for OnConflictExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Integer {
    pub type_: NodeTag,
    pub ival: ::std::os::raw::c_int,
}
impl Default for Integer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Float {
    pub type_: NodeTag,
    pub fval: *mut ::std::os::raw::c_char,
}
impl Default for Float {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Boolean {
    pub type_: NodeTag,
    pub boolval: bool,
}
impl Default for Boolean {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct String {
    pub type_: NodeTag,
    pub sval: *mut ::std::os::raw::c_char,
}
impl Default for String {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitString {
    pub type_: NodeTag,
    pub bsval: *mut ::std::os::raw::c_char,
}
impl Default for BitString {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionBoundInfoData {
    _unused: [u8; 0],
}
pub type PartitionBoundInfo = *mut PartitionBoundInfoData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionKeyData {
    _unused: [u8; 0],
}
pub type PartitionKey = *mut PartitionKeyData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionDescData {
    _unused: [u8; 0],
}
pub type PartitionDesc = *mut PartitionDescData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionDirectoryData {
    _unused: [u8; 0],
}
pub type PartitionDirectory = *mut PartitionDirectoryData;
pub const OverridingKind_OVERRIDING_NOT_SET: OverridingKind = 0;
pub const OverridingKind_OVERRIDING_USER_VALUE: OverridingKind = 1;
pub const OverridingKind_OVERRIDING_SYSTEM_VALUE: OverridingKind = 2;
pub type OverridingKind = ::std::os::raw::c_uint;
pub const QuerySource_QSRC_ORIGINAL: QuerySource = 0;
pub const QuerySource_QSRC_PARSER: QuerySource = 1;
pub const QuerySource_QSRC_INSTEAD_RULE: QuerySource = 2;
pub const QuerySource_QSRC_QUAL_INSTEAD_RULE: QuerySource = 3;
pub const QuerySource_QSRC_NON_INSTEAD_RULE: QuerySource = 4;
pub type QuerySource = ::std::os::raw::c_uint;
pub const SortByDir_SORTBY_DEFAULT: SortByDir = 0;
pub const SortByDir_SORTBY_ASC: SortByDir = 1;
pub const SortByDir_SORTBY_DESC: SortByDir = 2;
pub const SortByDir_SORTBY_USING: SortByDir = 3;
pub type SortByDir = ::std::os::raw::c_uint;
pub const SortByNulls_SORTBY_NULLS_DEFAULT: SortByNulls = 0;
pub const SortByNulls_SORTBY_NULLS_FIRST: SortByNulls = 1;
pub const SortByNulls_SORTBY_NULLS_LAST: SortByNulls = 2;
pub type SortByNulls = ::std::os::raw::c_uint;
pub const SetQuantifier_SET_QUANTIFIER_DEFAULT: SetQuantifier = 0;
pub const SetQuantifier_SET_QUANTIFIER_ALL: SetQuantifier = 1;
pub const SetQuantifier_SET_QUANTIFIER_DISTINCT: SetQuantifier = 2;
pub type SetQuantifier = ::std::os::raw::c_uint;
pub type AclMode = uint64;
#[doc = "\tQuery Tree"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Query {
    pub type_: NodeTag,
    pub commandType: CmdType,
    pub querySource: QuerySource,
    pub queryId: uint64,
    pub canSetTag: bool,
    pub utilityStmt: *mut Node,
    pub resultRelation: ::std::os::raw::c_int,
    pub hasAggs: bool,
    pub hasWindowFuncs: bool,
    pub hasTargetSRFs: bool,
    pub hasSubLinks: bool,
    pub hasDistinctOn: bool,
    pub hasRecursive: bool,
    pub hasModifyingCTE: bool,
    pub hasForUpdate: bool,
    pub hasRowSecurity: bool,
    pub isReturn: bool,
    pub cteList: *mut List,
    pub rtable: *mut List,
    pub rteperminfos: *mut List,
    pub jointree: *mut FromExpr,
    pub mergeActionList: *mut List,
    pub mergeUseOuterJoin: bool,
    pub targetList: *mut List,
    pub override_: OverridingKind,
    pub onConflict: *mut OnConflictExpr,
    pub returningList: *mut List,
    pub groupClause: *mut List,
    pub groupDistinct: bool,
    pub groupingSets: *mut List,
    pub havingQual: *mut Node,
    pub windowClause: *mut List,
    pub distinctClause: *mut List,
    pub sortClause: *mut List,
    pub limitOffset: *mut Node,
    pub limitCount: *mut Node,
    pub limitOption: LimitOption,
    pub rowMarks: *mut List,
    pub setOperations: *mut Node,
    pub constraintDeps: *mut List,
    pub withCheckOptions: *mut List,
    pub stmt_location: ::std::os::raw::c_int,
    pub stmt_len: ::std::os::raw::c_int,
}
impl Default for Query {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\tSupporting data structures for Parse Trees\n\n\tMost of these node types appear in raw parsetrees output by the grammar,\n\tand get transformed to something else by the analyzer.  A few of them\n\tare used as-is in transformed querytrees."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TypeName {
    pub type_: NodeTag,
    pub names: *mut List,
    pub typeOid: Oid,
    pub setof: bool,
    pub pct_type: bool,
    pub typmods: *mut List,
    pub typemod: int32,
    pub arrayBounds: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl Default for TypeName {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ColumnRef {
    pub type_: NodeTag,
    pub fields: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl Default for ColumnRef {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParamRef {
    pub type_: NodeTag,
    pub number: ::std::os::raw::c_int,
    pub location: ::std::os::raw::c_int,
}
impl Default for ParamRef {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const A_Expr_Kind_AEXPR_OP: A_Expr_Kind = 0;
pub const A_Expr_Kind_AEXPR_OP_ANY: A_Expr_Kind = 1;
pub const A_Expr_Kind_AEXPR_OP_ALL: A_Expr_Kind = 2;
pub const A_Expr_Kind_AEXPR_DISTINCT: A_Expr_Kind = 3;
pub const A_Expr_Kind_AEXPR_NOT_DISTINCT: A_Expr_Kind = 4;
pub const A_Expr_Kind_AEXPR_NULLIF: A_Expr_Kind = 5;
pub const A_Expr_Kind_AEXPR_IN: A_Expr_Kind = 6;
pub const A_Expr_Kind_AEXPR_LIKE: A_Expr_Kind = 7;
pub const A_Expr_Kind_AEXPR_ILIKE: A_Expr_Kind = 8;
pub const A_Expr_Kind_AEXPR_SIMILAR: A_Expr_Kind = 9;
pub const A_Expr_Kind_AEXPR_BETWEEN: A_Expr_Kind = 10;
pub const A_Expr_Kind_AEXPR_NOT_BETWEEN: A_Expr_Kind = 11;
pub const A_Expr_Kind_AEXPR_BETWEEN_SYM: A_Expr_Kind = 12;
pub const A_Expr_Kind_AEXPR_NOT_BETWEEN_SYM: A_Expr_Kind = 13;
pub type A_Expr_Kind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct A_Expr {
    pub type_: NodeTag,
    pub kind: A_Expr_Kind,
    pub name: *mut List,
    pub lexpr: *mut Node,
    pub rexpr: *mut Node,
    pub location: ::std::os::raw::c_int,
}
impl Default for A_Expr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ValUnion {
    pub node: Node,
    pub ival: Integer,
    pub fval: Float,
    pub boolval: Boolean,
    pub sval: String,
    pub bsval: BitString,
}
impl Default for ValUnion {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct A_Const {
    pub type_: NodeTag,
    pub val: ValUnion,
    pub isnull: bool,
    pub location: ::std::os::raw::c_int,
}
impl Default for A_Const {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TypeCast {
    pub type_: NodeTag,
    pub arg: *mut Node,
    pub typeName: *mut TypeName,
    pub location: ::std::os::raw::c_int,
}
impl Default for TypeCast {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CollateClause {
    pub type_: NodeTag,
    pub arg: *mut Node,
    pub collname: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl Default for CollateClause {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const RoleSpecType_ROLESPEC_CSTRING: RoleSpecType = 0;
pub const RoleSpecType_ROLESPEC_CURRENT_ROLE: RoleSpecType = 1;
pub const RoleSpecType_ROLESPEC_CURRENT_USER: RoleSpecType = 2;
pub const RoleSpecType_ROLESPEC_SESSION_USER: RoleSpecType = 3;
pub const RoleSpecType_ROLESPEC_PUBLIC: RoleSpecType = 4;
pub type RoleSpecType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RoleSpec {
    pub type_: NodeTag,
    pub roletype: RoleSpecType,
    pub rolename: *mut ::std::os::raw::c_char,
    pub location: ::std::os::raw::c_int,
}
impl Default for RoleSpec {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuncCall {
    pub type_: NodeTag,
    pub funcname: *mut List,
    pub args: *mut List,
    pub agg_order: *mut List,
    pub agg_filter: *mut Node,
    pub over: *mut WindowDef,
    pub agg_within_group: bool,
    pub agg_star: bool,
    pub agg_distinct: bool,
    pub func_variadic: bool,
    pub funcformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
impl Default for FuncCall {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct A_Star {
    pub type_: NodeTag,
}
impl Default for A_Star {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct A_Indices {
    pub type_: NodeTag,
    pub is_slice: bool,
    pub lidx: *mut Node,
    pub uidx: *mut Node,
}
impl Default for A_Indices {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct A_Indirection {
    pub type_: NodeTag,
    pub arg: *mut Node,
    pub indirection: *mut List,
}
impl Default for A_Indirection {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct A_ArrayExpr {
    pub type_: NodeTag,
    pub elements: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl Default for A_ArrayExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResTarget {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub indirection: *mut List,
    pub val: *mut Node,
    pub location: ::std::os::raw::c_int,
}
impl Default for ResTarget {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MultiAssignRef {
    pub type_: NodeTag,
    pub source: *mut Node,
    pub colno: ::std::os::raw::c_int,
    pub ncolumns: ::std::os::raw::c_int,
}
impl Default for MultiAssignRef {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SortBy {
    pub type_: NodeTag,
    pub node: *mut Node,
    pub sortby_dir: SortByDir,
    pub sortby_nulls: SortByNulls,
    pub useOp: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl Default for SortBy {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowDef {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub refname: *mut ::std::os::raw::c_char,
    pub partitionClause: *mut List,
    pub orderClause: *mut List,
    pub frameOptions: ::std::os::raw::c_int,
    pub startOffset: *mut Node,
    pub endOffset: *mut Node,
    pub location: ::std::os::raw::c_int,
}
impl Default for WindowDef {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeSubselect {
    pub type_: NodeTag,
    pub lateral: bool,
    pub subquery: *mut Node,
    pub alias: *mut Alias,
}
impl Default for RangeSubselect {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeFunction {
    pub type_: NodeTag,
    pub lateral: bool,
    pub ordinality: bool,
    pub is_rowsfrom: bool,
    pub functions: *mut List,
    pub alias: *mut Alias,
    pub coldeflist: *mut List,
}
impl Default for RangeFunction {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeTableFunc {
    pub type_: NodeTag,
    pub lateral: bool,
    pub docexpr: *mut Node,
    pub rowexpr: *mut Node,
    pub namespaces: *mut List,
    pub columns: *mut List,
    pub alias: *mut Alias,
    pub location: ::std::os::raw::c_int,
}
impl Default for RangeTableFunc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeTableFuncCol {
    pub type_: NodeTag,
    pub colname: *mut ::std::os::raw::c_char,
    pub typeName: *mut TypeName,
    pub for_ordinality: bool,
    pub is_not_null: bool,
    pub colexpr: *mut Node,
    pub coldefexpr: *mut Node,
    pub location: ::std::os::raw::c_int,
}
impl Default for RangeTableFuncCol {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeTableSample {
    pub type_: NodeTag,
    pub relation: *mut Node,
    pub method: *mut List,
    pub args: *mut List,
    pub repeatable: *mut Node,
    pub location: ::std::os::raw::c_int,
}
impl Default for RangeTableSample {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ColumnDef {
    pub type_: NodeTag,
    pub colname: *mut ::std::os::raw::c_char,
    pub typeName: *mut TypeName,
    pub compression: *mut ::std::os::raw::c_char,
    pub inhcount: ::std::os::raw::c_int,
    pub is_local: bool,
    pub is_not_null: bool,
    pub is_from_type: bool,
    pub storage: ::std::os::raw::c_char,
    pub storage_name: *mut ::std::os::raw::c_char,
    pub raw_default: *mut Node,
    pub cooked_default: *mut Node,
    pub identity: ::std::os::raw::c_char,
    pub identitySequence: *mut RangeVar,
    pub generated: ::std::os::raw::c_char,
    pub collClause: *mut CollateClause,
    pub collOid: Oid,
    pub constraints: *mut List,
    pub fdwoptions: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl Default for ColumnDef {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TableLikeClause {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub options: bits32,
    pub relationOid: Oid,
}
impl Default for TableLikeClause {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const TableLikeOption_CREATE_TABLE_LIKE_COMMENTS: TableLikeOption = 1;
pub const TableLikeOption_CREATE_TABLE_LIKE_COMPRESSION: TableLikeOption = 2;
pub const TableLikeOption_CREATE_TABLE_LIKE_CONSTRAINTS: TableLikeOption = 4;
pub const TableLikeOption_CREATE_TABLE_LIKE_DEFAULTS: TableLikeOption = 8;
pub const TableLikeOption_CREATE_TABLE_LIKE_GENERATED: TableLikeOption = 16;
pub const TableLikeOption_CREATE_TABLE_LIKE_IDENTITY: TableLikeOption = 32;
pub const TableLikeOption_CREATE_TABLE_LIKE_INDEXES: TableLikeOption = 64;
pub const TableLikeOption_CREATE_TABLE_LIKE_STATISTICS: TableLikeOption = 128;
pub const TableLikeOption_CREATE_TABLE_LIKE_STORAGE: TableLikeOption = 256;
pub const TableLikeOption_CREATE_TABLE_LIKE_ALL: TableLikeOption = 2147483647;
pub type TableLikeOption = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexElem {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub expr: *mut Node,
    pub indexcolname: *mut ::std::os::raw::c_char,
    pub collation: *mut List,
    pub opclass: *mut List,
    pub opclassopts: *mut List,
    pub ordering: SortByDir,
    pub nulls_ordering: SortByNulls,
}
impl Default for IndexElem {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const DefElemAction_DEFELEM_UNSPEC: DefElemAction = 0;
pub const DefElemAction_DEFELEM_SET: DefElemAction = 1;
pub const DefElemAction_DEFELEM_ADD: DefElemAction = 2;
pub const DefElemAction_DEFELEM_DROP: DefElemAction = 3;
pub type DefElemAction = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DefElem {
    pub type_: NodeTag,
    pub defnamespace: *mut ::std::os::raw::c_char,
    pub defname: *mut ::std::os::raw::c_char,
    pub arg: *mut Node,
    pub defaction: DefElemAction,
    pub location: ::std::os::raw::c_int,
}
impl Default for DefElem {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LockingClause {
    pub type_: NodeTag,
    pub lockedRels: *mut List,
    pub strength: LockClauseStrength,
    pub waitPolicy: LockWaitPolicy,
}
impl Default for LockingClause {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XmlSerialize {
    pub type_: NodeTag,
    pub xmloption: XmlOptionType,
    pub expr: *mut Node,
    pub typeName: *mut TypeName,
    pub indent: bool,
    pub location: ::std::os::raw::c_int,
}
impl Default for XmlSerialize {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionElem {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub expr: *mut Node,
    pub collation: *mut List,
    pub opclass: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl Default for PartitionElem {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const PartitionStrategy_PARTITION_STRATEGY_LIST: PartitionStrategy = 108;
pub const PartitionStrategy_PARTITION_STRATEGY_RANGE: PartitionStrategy = 114;
pub const PartitionStrategy_PARTITION_STRATEGY_HASH: PartitionStrategy = 104;
pub type PartitionStrategy = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionSpec {
    pub type_: NodeTag,
    pub strategy: PartitionStrategy,
    pub partParams: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl Default for PartitionSpec {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionBoundSpec {
    pub type_: NodeTag,
    pub strategy: ::std::os::raw::c_char,
    pub is_default: bool,
    pub modulus: ::std::os::raw::c_int,
    pub remainder: ::std::os::raw::c_int,
    pub listdatums: *mut List,
    pub lowerdatums: *mut List,
    pub upperdatums: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl Default for PartitionBoundSpec {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const PartitionRangeDatumKind_PARTITION_RANGE_DATUM_MINVALUE: PartitionRangeDatumKind = -1;
pub const PartitionRangeDatumKind_PARTITION_RANGE_DATUM_VALUE: PartitionRangeDatumKind = 0;
pub const PartitionRangeDatumKind_PARTITION_RANGE_DATUM_MAXVALUE: PartitionRangeDatumKind = 1;
pub type PartitionRangeDatumKind = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionRangeDatum {
    pub type_: NodeTag,
    pub kind: PartitionRangeDatumKind,
    pub value: *mut Node,
    pub location: ::std::os::raw::c_int,
}
impl Default for PartitionRangeDatum {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionCmd {
    pub type_: NodeTag,
    pub name: *mut RangeVar,
    pub bound: *mut PartitionBoundSpec,
    pub concurrent: bool,
}
impl Default for PartitionCmd {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const RTEKind_RTE_RELATION: RTEKind = 0;
pub const RTEKind_RTE_SUBQUERY: RTEKind = 1;
pub const RTEKind_RTE_JOIN: RTEKind = 2;
pub const RTEKind_RTE_FUNCTION: RTEKind = 3;
pub const RTEKind_RTE_TABLEFUNC: RTEKind = 4;
pub const RTEKind_RTE_VALUES: RTEKind = 5;
pub const RTEKind_RTE_CTE: RTEKind = 6;
pub const RTEKind_RTE_NAMEDTUPLESTORE: RTEKind = 7;
pub const RTEKind_RTE_RESULT: RTEKind = 8;
pub type RTEKind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeTblEntry {
    pub type_: NodeTag,
    pub rtekind: RTEKind,
    pub relid: Oid,
    pub relkind: ::std::os::raw::c_char,
    pub rellockmode: ::std::os::raw::c_int,
    pub tablesample: *mut TableSampleClause,
    pub perminfoindex: Index,
    pub subquery: *mut Query,
    pub security_barrier: bool,
    pub jointype: JoinType,
    pub joinmergedcols: ::std::os::raw::c_int,
    pub joinaliasvars: *mut List,
    pub joinleftcols: *mut List,
    pub joinrightcols: *mut List,
    pub join_using_alias: *mut Alias,
    pub functions: *mut List,
    pub funcordinality: bool,
    pub tablefunc: *mut TableFunc,
    pub values_lists: *mut List,
    pub ctename: *mut ::std::os::raw::c_char,
    pub ctelevelsup: Index,
    pub self_reference: bool,
    pub coltypes: *mut List,
    pub coltypmods: *mut List,
    pub colcollations: *mut List,
    pub enrname: *mut ::std::os::raw::c_char,
    pub enrtuples: Cardinality,
    pub alias: *mut Alias,
    pub eref: *mut Alias,
    pub lateral: bool,
    pub inh: bool,
    pub inFromCl: bool,
    pub securityQuals: *mut List,
}
impl Default for RangeTblEntry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RTEPermissionInfo {
    pub type_: NodeTag,
    pub relid: Oid,
    pub inh: bool,
    pub requiredPerms: AclMode,
    pub checkAsUser: Oid,
    pub selectedCols: *mut Bitmapset,
    pub insertedCols: *mut Bitmapset,
    pub updatedCols: *mut Bitmapset,
}
impl Default for RTEPermissionInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeTblFunction {
    pub type_: NodeTag,
    pub funcexpr: *mut Node,
    pub funccolcount: ::std::os::raw::c_int,
    pub funccolnames: *mut List,
    pub funccoltypes: *mut List,
    pub funccoltypmods: *mut List,
    pub funccolcollations: *mut List,
    pub funcparams: *mut Bitmapset,
}
impl Default for RangeTblFunction {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TableSampleClause {
    pub type_: NodeTag,
    pub tsmhandler: Oid,
    pub args: *mut List,
    pub repeatable: *mut Expr,
}
impl Default for TableSampleClause {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const WCOKind_WCO_VIEW_CHECK: WCOKind = 0;
pub const WCOKind_WCO_RLS_INSERT_CHECK: WCOKind = 1;
pub const WCOKind_WCO_RLS_UPDATE_CHECK: WCOKind = 2;
pub const WCOKind_WCO_RLS_CONFLICT_CHECK: WCOKind = 3;
pub const WCOKind_WCO_RLS_MERGE_UPDATE_CHECK: WCOKind = 4;
pub const WCOKind_WCO_RLS_MERGE_DELETE_CHECK: WCOKind = 5;
pub type WCOKind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WithCheckOption {
    pub type_: NodeTag,
    pub kind: WCOKind,
    pub relname: *mut ::std::os::raw::c_char,
    pub polname: *mut ::std::os::raw::c_char,
    pub qual: *mut Node,
    pub cascaded: bool,
}
impl Default for WithCheckOption {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SortGroupClause {
    pub type_: NodeTag,
    pub tleSortGroupRef: Index,
    pub eqop: Oid,
    pub sortop: Oid,
    pub nulls_first: bool,
    pub hashable: bool,
}
impl Default for SortGroupClause {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const GroupingSetKind_GROUPING_SET_EMPTY: GroupingSetKind = 0;
pub const GroupingSetKind_GROUPING_SET_SIMPLE: GroupingSetKind = 1;
pub const GroupingSetKind_GROUPING_SET_ROLLUP: GroupingSetKind = 2;
pub const GroupingSetKind_GROUPING_SET_CUBE: GroupingSetKind = 3;
pub const GroupingSetKind_GROUPING_SET_SETS: GroupingSetKind = 4;
pub type GroupingSetKind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GroupingSet {
    pub type_: NodeTag,
    pub kind: GroupingSetKind,
    pub content: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl Default for GroupingSet {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowClause {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub refname: *mut ::std::os::raw::c_char,
    pub partitionClause: *mut List,
    pub orderClause: *mut List,
    pub frameOptions: ::std::os::raw::c_int,
    pub startOffset: *mut Node,
    pub endOffset: *mut Node,
    pub runCondition: *mut List,
    pub startInRangeFunc: Oid,
    pub endInRangeFunc: Oid,
    pub inRangeColl: Oid,
    pub inRangeAsc: bool,
    pub inRangeNullsFirst: bool,
    pub winref: Index,
    pub copiedOrder: bool,
}
impl Default for WindowClause {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RowMarkClause {
    pub type_: NodeTag,
    pub rti: Index,
    pub strength: LockClauseStrength,
    pub waitPolicy: LockWaitPolicy,
    pub pushedDown: bool,
}
impl Default for RowMarkClause {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WithClause {
    pub type_: NodeTag,
    pub ctes: *mut List,
    pub recursive: bool,
    pub location: ::std::os::raw::c_int,
}
impl Default for WithClause {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InferClause {
    pub type_: NodeTag,
    pub indexElems: *mut List,
    pub whereClause: *mut Node,
    pub conname: *mut ::std::os::raw::c_char,
    pub location: ::std::os::raw::c_int,
}
impl Default for InferClause {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OnConflictClause {
    pub type_: NodeTag,
    pub action: OnConflictAction,
    pub infer: *mut InferClause,
    pub targetList: *mut List,
    pub whereClause: *mut Node,
    pub location: ::std::os::raw::c_int,
}
impl Default for OnConflictClause {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const CTEMaterialize_CTEMaterializeDefault: CTEMaterialize = 0;
pub const CTEMaterialize_CTEMaterializeAlways: CTEMaterialize = 1;
pub const CTEMaterialize_CTEMaterializeNever: CTEMaterialize = 2;
pub type CTEMaterialize = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CTESearchClause {
    pub type_: NodeTag,
    pub search_col_list: *mut List,
    pub search_breadth_first: bool,
    pub search_seq_column: *mut ::std::os::raw::c_char,
    pub location: ::std::os::raw::c_int,
}
impl Default for CTESearchClause {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CTECycleClause {
    pub type_: NodeTag,
    pub cycle_col_list: *mut List,
    pub cycle_mark_column: *mut ::std::os::raw::c_char,
    pub cycle_mark_value: *mut Node,
    pub cycle_mark_default: *mut Node,
    pub cycle_path_column: *mut ::std::os::raw::c_char,
    pub location: ::std::os::raw::c_int,
    pub cycle_mark_type: Oid,
    pub cycle_mark_typmod: ::std::os::raw::c_int,
    pub cycle_mark_collation: Oid,
    pub cycle_mark_neop: Oid,
}
impl Default for CTECycleClause {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CommonTableExpr {
    pub type_: NodeTag,
    pub ctename: *mut ::std::os::raw::c_char,
    pub aliascolnames: *mut List,
    pub ctematerialized: CTEMaterialize,
    pub ctequery: *mut Node,
    pub search_clause: *mut CTESearchClause,
    pub cycle_clause: *mut CTECycleClause,
    pub location: ::std::os::raw::c_int,
    pub cterecursive: bool,
    pub cterefcount: ::std::os::raw::c_int,
    pub ctecolnames: *mut List,
    pub ctecoltypes: *mut List,
    pub ctecoltypmods: *mut List,
    pub ctecolcollations: *mut List,
}
impl Default for CommonTableExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeWhenClause {
    pub type_: NodeTag,
    pub matched: bool,
    pub commandType: CmdType,
    pub override_: OverridingKind,
    pub condition: *mut Node,
    pub targetList: *mut List,
    pub values: *mut List,
}
impl Default for MergeWhenClause {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeAction {
    pub type_: NodeTag,
    pub matched: bool,
    pub commandType: CmdType,
    pub override_: OverridingKind,
    pub qual: *mut Node,
    pub targetList: *mut List,
    pub updateColnos: *mut List,
}
impl Default for MergeAction {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TriggerTransition {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub isNew: bool,
    pub isTable: bool,
}
impl Default for TriggerTransition {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonOutput {
    pub type_: NodeTag,
    pub typeName: *mut TypeName,
    pub returning: *mut JsonReturning,
}
impl Default for JsonOutput {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonKeyValue {
    pub type_: NodeTag,
    pub key: *mut Expr,
    pub value: *mut JsonValueExpr,
}
impl Default for JsonKeyValue {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonObjectConstructor {
    pub type_: NodeTag,
    pub exprs: *mut List,
    pub output: *mut JsonOutput,
    pub absent_on_null: bool,
    pub unique: bool,
    pub location: ::std::os::raw::c_int,
}
impl Default for JsonObjectConstructor {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonArrayConstructor {
    pub type_: NodeTag,
    pub exprs: *mut List,
    pub output: *mut JsonOutput,
    pub absent_on_null: bool,
    pub location: ::std::os::raw::c_int,
}
impl Default for JsonArrayConstructor {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonArrayQueryConstructor {
    pub type_: NodeTag,
    pub query: *mut Node,
    pub output: *mut JsonOutput,
    pub format: *mut JsonFormat,
    pub absent_on_null: bool,
    pub location: ::std::os::raw::c_int,
}
impl Default for JsonArrayQueryConstructor {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonAggConstructor {
    pub type_: NodeTag,
    pub output: *mut JsonOutput,
    pub agg_filter: *mut Node,
    pub agg_order: *mut List,
    pub over: *mut WindowDef,
    pub location: ::std::os::raw::c_int,
}
impl Default for JsonAggConstructor {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonObjectAgg {
    pub type_: NodeTag,
    pub constructor: *mut JsonAggConstructor,
    pub arg: *mut JsonKeyValue,
    pub absent_on_null: bool,
    pub unique: bool,
}
impl Default for JsonObjectAgg {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonArrayAgg {
    pub type_: NodeTag,
    pub constructor: *mut JsonAggConstructor,
    pub arg: *mut JsonValueExpr,
    pub absent_on_null: bool,
}
impl Default for JsonArrayAgg {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\t\tRaw Grammar Output Statements"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RawStmt {
    pub type_: NodeTag,
    pub stmt: *mut Node,
    pub stmt_location: ::std::os::raw::c_int,
    pub stmt_len: ::std::os::raw::c_int,
}
impl Default for RawStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\t\tOptimizable Statements"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InsertStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub cols: *mut List,
    pub selectStmt: *mut Node,
    pub onConflictClause: *mut OnConflictClause,
    pub returningList: *mut List,
    pub withClause: *mut WithClause,
    pub override_: OverridingKind,
}
impl Default for InsertStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeleteStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub usingClause: *mut List,
    pub whereClause: *mut Node,
    pub returningList: *mut List,
    pub withClause: *mut WithClause,
}
impl Default for DeleteStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UpdateStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub targetList: *mut List,
    pub whereClause: *mut Node,
    pub fromClause: *mut List,
    pub returningList: *mut List,
    pub withClause: *mut WithClause,
}
impl Default for UpdateStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub sourceRelation: *mut Node,
    pub joinCondition: *mut Node,
    pub mergeWhenClauses: *mut List,
    pub withClause: *mut WithClause,
}
impl Default for MergeStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const SetOperation_SETOP_NONE: SetOperation = 0;
pub const SetOperation_SETOP_UNION: SetOperation = 1;
pub const SetOperation_SETOP_INTERSECT: SetOperation = 2;
pub const SetOperation_SETOP_EXCEPT: SetOperation = 3;
pub type SetOperation = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SelectStmt {
    pub type_: NodeTag,
    pub distinctClause: *mut List,
    pub intoClause: *mut IntoClause,
    pub targetList: *mut List,
    pub fromClause: *mut List,
    pub whereClause: *mut Node,
    pub groupClause: *mut List,
    pub groupDistinct: bool,
    pub havingClause: *mut Node,
    pub windowClause: *mut List,
    pub valuesLists: *mut List,
    pub sortClause: *mut List,
    pub limitOffset: *mut Node,
    pub limitCount: *mut Node,
    pub limitOption: LimitOption,
    pub lockingClause: *mut List,
    pub withClause: *mut WithClause,
    pub op: SetOperation,
    pub all: bool,
    pub larg: *mut SelectStmt,
    pub rarg: *mut SelectStmt,
}
impl Default for SelectStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SetOperationStmt {
    pub type_: NodeTag,
    pub op: SetOperation,
    pub all: bool,
    pub larg: *mut Node,
    pub rarg: *mut Node,
    pub colTypes: *mut List,
    pub colTypmods: *mut List,
    pub colCollations: *mut List,
    pub groupClauses: *mut List,
}
impl Default for SetOperationStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReturnStmt {
    pub type_: NodeTag,
    pub returnval: *mut Node,
}
impl Default for ReturnStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLAssignStmt {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub indirection: *mut List,
    pub nnames: ::std::os::raw::c_int,
    pub val: *mut SelectStmt,
    pub location: ::std::os::raw::c_int,
}
impl Default for PLAssignStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ObjectType_OBJECT_ACCESS_METHOD: ObjectType = 0;
pub const ObjectType_OBJECT_AGGREGATE: ObjectType = 1;
pub const ObjectType_OBJECT_AMOP: ObjectType = 2;
pub const ObjectType_OBJECT_AMPROC: ObjectType = 3;
pub const ObjectType_OBJECT_ATTRIBUTE: ObjectType = 4;
pub const ObjectType_OBJECT_CAST: ObjectType = 5;
pub const ObjectType_OBJECT_COLUMN: ObjectType = 6;
pub const ObjectType_OBJECT_COLLATION: ObjectType = 7;
pub const ObjectType_OBJECT_CONVERSION: ObjectType = 8;
pub const ObjectType_OBJECT_DATABASE: ObjectType = 9;
pub const ObjectType_OBJECT_DEFAULT: ObjectType = 10;
pub const ObjectType_OBJECT_DEFACL: ObjectType = 11;
pub const ObjectType_OBJECT_DOMAIN: ObjectType = 12;
pub const ObjectType_OBJECT_DOMCONSTRAINT: ObjectType = 13;
pub const ObjectType_OBJECT_EVENT_TRIGGER: ObjectType = 14;
pub const ObjectType_OBJECT_EXTENSION: ObjectType = 15;
pub const ObjectType_OBJECT_FDW: ObjectType = 16;
pub const ObjectType_OBJECT_FOREIGN_SERVER: ObjectType = 17;
pub const ObjectType_OBJECT_FOREIGN_TABLE: ObjectType = 18;
pub const ObjectType_OBJECT_FUNCTION: ObjectType = 19;
pub const ObjectType_OBJECT_INDEX: ObjectType = 20;
pub const ObjectType_OBJECT_LANGUAGE: ObjectType = 21;
pub const ObjectType_OBJECT_LARGEOBJECT: ObjectType = 22;
pub const ObjectType_OBJECT_MATVIEW: ObjectType = 23;
pub const ObjectType_OBJECT_OPCLASS: ObjectType = 24;
pub const ObjectType_OBJECT_OPERATOR: ObjectType = 25;
pub const ObjectType_OBJECT_OPFAMILY: ObjectType = 26;
pub const ObjectType_OBJECT_PARAMETER_ACL: ObjectType = 27;
pub const ObjectType_OBJECT_POLICY: ObjectType = 28;
pub const ObjectType_OBJECT_PROCEDURE: ObjectType = 29;
pub const ObjectType_OBJECT_PUBLICATION: ObjectType = 30;
pub const ObjectType_OBJECT_PUBLICATION_NAMESPACE: ObjectType = 31;
pub const ObjectType_OBJECT_PUBLICATION_REL: ObjectType = 32;
pub const ObjectType_OBJECT_ROLE: ObjectType = 33;
pub const ObjectType_OBJECT_ROUTINE: ObjectType = 34;
pub const ObjectType_OBJECT_RULE: ObjectType = 35;
pub const ObjectType_OBJECT_SCHEMA: ObjectType = 36;
pub const ObjectType_OBJECT_SEQUENCE: ObjectType = 37;
pub const ObjectType_OBJECT_SUBSCRIPTION: ObjectType = 38;
pub const ObjectType_OBJECT_STATISTIC_EXT: ObjectType = 39;
pub const ObjectType_OBJECT_TABCONSTRAINT: ObjectType = 40;
pub const ObjectType_OBJECT_TABLE: ObjectType = 41;
pub const ObjectType_OBJECT_TABLESPACE: ObjectType = 42;
pub const ObjectType_OBJECT_TRANSFORM: ObjectType = 43;
pub const ObjectType_OBJECT_TRIGGER: ObjectType = 44;
pub const ObjectType_OBJECT_TSCONFIGURATION: ObjectType = 45;
pub const ObjectType_OBJECT_TSDICTIONARY: ObjectType = 46;
pub const ObjectType_OBJECT_TSPARSER: ObjectType = 47;
pub const ObjectType_OBJECT_TSTEMPLATE: ObjectType = 48;
pub const ObjectType_OBJECT_TYPE: ObjectType = 49;
pub const ObjectType_OBJECT_USER_MAPPING: ObjectType = 50;
pub const ObjectType_OBJECT_VIEW: ObjectType = 51;
#[doc = "\t\tOther Statements (no optimizations required)\n\n\t\tThese are not touched by parser/analyze.c except to put them into\n\t\tthe utilityStmt field of a Query.  This is eventually passed to\n\t\tProcessUtility (by-passing rewriting and planning).  Some of the\n\t\tstatements do need attention from parse analysis, and this is\n\t\tdone by routines in parser/parse_utilcmd.c after ProcessUtility\n\t\treceives the command for execution.\n\t\tDECLARE CURSOR, EXPLAIN, and CREATE TABLE AS are special cases:\n\t\tthey contain optimizable statements, which get processed normally\n\t\tby parser/analyze.c."]
pub type ObjectType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateSchemaStmt {
    pub type_: NodeTag,
    pub schemaname: *mut ::std::os::raw::c_char,
    pub authrole: *mut RoleSpec,
    pub schemaElts: *mut List,
    pub if_not_exists: bool,
}
impl Default for CreateSchemaStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const DropBehavior_DROP_RESTRICT: DropBehavior = 0;
pub const DropBehavior_DROP_CASCADE: DropBehavior = 1;
pub type DropBehavior = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterTableStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub cmds: *mut List,
    pub objtype: ObjectType,
    pub missing_ok: bool,
}
impl Default for AlterTableStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const AlterTableType_AT_AddColumn: AlterTableType = 0;
pub const AlterTableType_AT_AddColumnToView: AlterTableType = 1;
pub const AlterTableType_AT_ColumnDefault: AlterTableType = 2;
pub const AlterTableType_AT_CookedColumnDefault: AlterTableType = 3;
pub const AlterTableType_AT_DropNotNull: AlterTableType = 4;
pub const AlterTableType_AT_SetNotNull: AlterTableType = 5;
pub const AlterTableType_AT_DropExpression: AlterTableType = 6;
pub const AlterTableType_AT_CheckNotNull: AlterTableType = 7;
pub const AlterTableType_AT_SetStatistics: AlterTableType = 8;
pub const AlterTableType_AT_SetOptions: AlterTableType = 9;
pub const AlterTableType_AT_ResetOptions: AlterTableType = 10;
pub const AlterTableType_AT_SetStorage: AlterTableType = 11;
pub const AlterTableType_AT_SetCompression: AlterTableType = 12;
pub const AlterTableType_AT_DropColumn: AlterTableType = 13;
pub const AlterTableType_AT_AddIndex: AlterTableType = 14;
pub const AlterTableType_AT_ReAddIndex: AlterTableType = 15;
pub const AlterTableType_AT_AddConstraint: AlterTableType = 16;
pub const AlterTableType_AT_ReAddConstraint: AlterTableType = 17;
pub const AlterTableType_AT_ReAddDomainConstraint: AlterTableType = 18;
pub const AlterTableType_AT_AlterConstraint: AlterTableType = 19;
pub const AlterTableType_AT_ValidateConstraint: AlterTableType = 20;
pub const AlterTableType_AT_AddIndexConstraint: AlterTableType = 21;
pub const AlterTableType_AT_DropConstraint: AlterTableType = 22;
pub const AlterTableType_AT_ReAddComment: AlterTableType = 23;
pub const AlterTableType_AT_AlterColumnType: AlterTableType = 24;
pub const AlterTableType_AT_AlterColumnGenericOptions: AlterTableType = 25;
pub const AlterTableType_AT_ChangeOwner: AlterTableType = 26;
pub const AlterTableType_AT_ClusterOn: AlterTableType = 27;
pub const AlterTableType_AT_DropCluster: AlterTableType = 28;
pub const AlterTableType_AT_SetLogged: AlterTableType = 29;
pub const AlterTableType_AT_SetUnLogged: AlterTableType = 30;
pub const AlterTableType_AT_DropOids: AlterTableType = 31;
pub const AlterTableType_AT_SetAccessMethod: AlterTableType = 32;
pub const AlterTableType_AT_SetTableSpace: AlterTableType = 33;
pub const AlterTableType_AT_SetRelOptions: AlterTableType = 34;
pub const AlterTableType_AT_ResetRelOptions: AlterTableType = 35;
pub const AlterTableType_AT_ReplaceRelOptions: AlterTableType = 36;
pub const AlterTableType_AT_EnableTrig: AlterTableType = 37;
pub const AlterTableType_AT_EnableAlwaysTrig: AlterTableType = 38;
pub const AlterTableType_AT_EnableReplicaTrig: AlterTableType = 39;
pub const AlterTableType_AT_DisableTrig: AlterTableType = 40;
pub const AlterTableType_AT_EnableTrigAll: AlterTableType = 41;
pub const AlterTableType_AT_DisableTrigAll: AlterTableType = 42;
pub const AlterTableType_AT_EnableTrigUser: AlterTableType = 43;
pub const AlterTableType_AT_DisableTrigUser: AlterTableType = 44;
pub const AlterTableType_AT_EnableRule: AlterTableType = 45;
pub const AlterTableType_AT_EnableAlwaysRule: AlterTableType = 46;
pub const AlterTableType_AT_EnableReplicaRule: AlterTableType = 47;
pub const AlterTableType_AT_DisableRule: AlterTableType = 48;
pub const AlterTableType_AT_AddInherit: AlterTableType = 49;
pub const AlterTableType_AT_DropInherit: AlterTableType = 50;
pub const AlterTableType_AT_AddOf: AlterTableType = 51;
pub const AlterTableType_AT_DropOf: AlterTableType = 52;
pub const AlterTableType_AT_ReplicaIdentity: AlterTableType = 53;
pub const AlterTableType_AT_EnableRowSecurity: AlterTableType = 54;
pub const AlterTableType_AT_DisableRowSecurity: AlterTableType = 55;
pub const AlterTableType_AT_ForceRowSecurity: AlterTableType = 56;
pub const AlterTableType_AT_NoForceRowSecurity: AlterTableType = 57;
pub const AlterTableType_AT_GenericOptions: AlterTableType = 58;
pub const AlterTableType_AT_AttachPartition: AlterTableType = 59;
pub const AlterTableType_AT_DetachPartition: AlterTableType = 60;
pub const AlterTableType_AT_DetachPartitionFinalize: AlterTableType = 61;
pub const AlterTableType_AT_AddIdentity: AlterTableType = 62;
pub const AlterTableType_AT_SetIdentity: AlterTableType = 63;
pub const AlterTableType_AT_DropIdentity: AlterTableType = 64;
pub const AlterTableType_AT_ReAddStatistics: AlterTableType = 65;
pub type AlterTableType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReplicaIdentityStmt {
    pub type_: NodeTag,
    pub identity_type: ::std::os::raw::c_char,
    pub name: *mut ::std::os::raw::c_char,
}
impl Default for ReplicaIdentityStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterTableCmd {
    pub type_: NodeTag,
    pub subtype: AlterTableType,
    pub name: *mut ::std::os::raw::c_char,
    pub num: int16,
    pub newowner: *mut RoleSpec,
    pub def: *mut Node,
    pub behavior: DropBehavior,
    pub missing_ok: bool,
    pub recurse: bool,
}
impl Default for AlterTableCmd {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterCollationStmt {
    pub type_: NodeTag,
    pub collname: *mut List,
}
impl Default for AlterCollationStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterDomainStmt {
    pub type_: NodeTag,
    pub subtype: ::std::os::raw::c_char,
    pub typeName: *mut List,
    pub name: *mut ::std::os::raw::c_char,
    pub def: *mut Node,
    pub behavior: DropBehavior,
    pub missing_ok: bool,
}
impl Default for AlterDomainStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const GrantTargetType_ACL_TARGET_OBJECT: GrantTargetType = 0;
pub const GrantTargetType_ACL_TARGET_ALL_IN_SCHEMA: GrantTargetType = 1;
pub const GrantTargetType_ACL_TARGET_DEFAULTS: GrantTargetType = 2;
pub type GrantTargetType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrantStmt {
    pub type_: NodeTag,
    pub is_grant: bool,
    pub targtype: GrantTargetType,
    pub objtype: ObjectType,
    pub objects: *mut List,
    pub privileges: *mut List,
    pub grantees: *mut List,
    pub grant_option: bool,
    pub grantor: *mut RoleSpec,
    pub behavior: DropBehavior,
}
impl Default for GrantStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjectWithArgs {
    pub type_: NodeTag,
    pub objname: *mut List,
    pub objargs: *mut List,
    pub objfuncargs: *mut List,
    pub args_unspecified: bool,
}
impl Default for ObjectWithArgs {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AccessPriv {
    pub type_: NodeTag,
    pub priv_name: *mut ::std::os::raw::c_char,
    pub cols: *mut List,
}
impl Default for AccessPriv {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrantRoleStmt {
    pub type_: NodeTag,
    pub granted_roles: *mut List,
    pub grantee_roles: *mut List,
    pub is_grant: bool,
    pub opt: *mut List,
    pub grantor: *mut RoleSpec,
    pub behavior: DropBehavior,
}
impl Default for GrantRoleStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterDefaultPrivilegesStmt {
    pub type_: NodeTag,
    pub options: *mut List,
    pub action: *mut GrantStmt,
}
impl Default for AlterDefaultPrivilegesStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CopyStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub query: *mut Node,
    pub attlist: *mut List,
    pub is_from: bool,
    pub is_program: bool,
    pub filename: *mut ::std::os::raw::c_char,
    pub options: *mut List,
    pub whereClause: *mut Node,
}
impl Default for CopyStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const VariableSetKind_VAR_SET_VALUE: VariableSetKind = 0;
pub const VariableSetKind_VAR_SET_DEFAULT: VariableSetKind = 1;
pub const VariableSetKind_VAR_SET_CURRENT: VariableSetKind = 2;
pub const VariableSetKind_VAR_SET_MULTI: VariableSetKind = 3;
pub const VariableSetKind_VAR_RESET: VariableSetKind = 4;
pub const VariableSetKind_VAR_RESET_ALL: VariableSetKind = 5;
pub type VariableSetKind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VariableSetStmt {
    pub type_: NodeTag,
    pub kind: VariableSetKind,
    pub name: *mut ::std::os::raw::c_char,
    pub args: *mut List,
    pub is_local: bool,
}
impl Default for VariableSetStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VariableShowStmt {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
}
impl Default for VariableShowStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub tableElts: *mut List,
    pub inhRelations: *mut List,
    pub partbound: *mut PartitionBoundSpec,
    pub partspec: *mut PartitionSpec,
    pub ofTypename: *mut TypeName,
    pub constraints: *mut List,
    pub options: *mut List,
    pub oncommit: OnCommitAction,
    pub tablespacename: *mut ::std::os::raw::c_char,
    pub accessMethod: *mut ::std::os::raw::c_char,
    pub if_not_exists: bool,
}
impl Default for CreateStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ConstrType_CONSTR_NULL: ConstrType = 0;
pub const ConstrType_CONSTR_NOTNULL: ConstrType = 1;
pub const ConstrType_CONSTR_DEFAULT: ConstrType = 2;
pub const ConstrType_CONSTR_IDENTITY: ConstrType = 3;
pub const ConstrType_CONSTR_GENERATED: ConstrType = 4;
pub const ConstrType_CONSTR_CHECK: ConstrType = 5;
pub const ConstrType_CONSTR_PRIMARY: ConstrType = 6;
pub const ConstrType_CONSTR_UNIQUE: ConstrType = 7;
pub const ConstrType_CONSTR_EXCLUSION: ConstrType = 8;
pub const ConstrType_CONSTR_FOREIGN: ConstrType = 9;
pub const ConstrType_CONSTR_ATTR_DEFERRABLE: ConstrType = 10;
pub const ConstrType_CONSTR_ATTR_NOT_DEFERRABLE: ConstrType = 11;
pub const ConstrType_CONSTR_ATTR_DEFERRED: ConstrType = 12;
pub const ConstrType_CONSTR_ATTR_IMMEDIATE: ConstrType = 13;
pub type ConstrType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Constraint {
    pub type_: NodeTag,
    pub contype: ConstrType,
    pub conname: *mut ::std::os::raw::c_char,
    pub deferrable: bool,
    pub initdeferred: bool,
    pub location: ::std::os::raw::c_int,
    pub is_no_inherit: bool,
    pub raw_expr: *mut Node,
    pub cooked_expr: *mut ::std::os::raw::c_char,
    pub generated_when: ::std::os::raw::c_char,
    pub nulls_not_distinct: bool,
    pub keys: *mut List,
    pub including: *mut List,
    pub exclusions: *mut List,
    pub options: *mut List,
    pub indexname: *mut ::std::os::raw::c_char,
    pub indexspace: *mut ::std::os::raw::c_char,
    pub reset_default_tblspc: bool,
    pub access_method: *mut ::std::os::raw::c_char,
    pub where_clause: *mut Node,
    pub pktable: *mut RangeVar,
    pub fk_attrs: *mut List,
    pub pk_attrs: *mut List,
    pub fk_matchtype: ::std::os::raw::c_char,
    pub fk_upd_action: ::std::os::raw::c_char,
    pub fk_del_action: ::std::os::raw::c_char,
    pub fk_del_set_cols: *mut List,
    pub old_conpfeqop: *mut List,
    pub old_pktable_oid: Oid,
    pub skip_validation: bool,
    pub initially_valid: bool,
}
impl Default for Constraint {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateTableSpaceStmt {
    pub type_: NodeTag,
    pub tablespacename: *mut ::std::os::raw::c_char,
    pub owner: *mut RoleSpec,
    pub location: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl Default for CreateTableSpaceStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DropTableSpaceStmt {
    pub type_: NodeTag,
    pub tablespacename: *mut ::std::os::raw::c_char,
    pub missing_ok: bool,
}
impl Default for DropTableSpaceStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterTableSpaceOptionsStmt {
    pub type_: NodeTag,
    pub tablespacename: *mut ::std::os::raw::c_char,
    pub options: *mut List,
    pub isReset: bool,
}
impl Default for AlterTableSpaceOptionsStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterTableMoveAllStmt {
    pub type_: NodeTag,
    pub orig_tablespacename: *mut ::std::os::raw::c_char,
    pub objtype: ObjectType,
    pub roles: *mut List,
    pub new_tablespacename: *mut ::std::os::raw::c_char,
    pub nowait: bool,
}
impl Default for AlterTableMoveAllStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateExtensionStmt {
    pub type_: NodeTag,
    pub extname: *mut ::std::os::raw::c_char,
    pub if_not_exists: bool,
    pub options: *mut List,
}
impl Default for CreateExtensionStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterExtensionStmt {
    pub type_: NodeTag,
    pub extname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl Default for AlterExtensionStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterExtensionContentsStmt {
    pub type_: NodeTag,
    pub extname: *mut ::std::os::raw::c_char,
    pub action: ::std::os::raw::c_int,
    pub objtype: ObjectType,
    pub object: *mut Node,
}
impl Default for AlterExtensionContentsStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateFdwStmt {
    pub type_: NodeTag,
    pub fdwname: *mut ::std::os::raw::c_char,
    pub func_options: *mut List,
    pub options: *mut List,
}
impl Default for CreateFdwStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterFdwStmt {
    pub type_: NodeTag,
    pub fdwname: *mut ::std::os::raw::c_char,
    pub func_options: *mut List,
    pub options: *mut List,
}
impl Default for AlterFdwStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateForeignServerStmt {
    pub type_: NodeTag,
    pub servername: *mut ::std::os::raw::c_char,
    pub servertype: *mut ::std::os::raw::c_char,
    pub version: *mut ::std::os::raw::c_char,
    pub fdwname: *mut ::std::os::raw::c_char,
    pub if_not_exists: bool,
    pub options: *mut List,
}
impl Default for CreateForeignServerStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterForeignServerStmt {
    pub type_: NodeTag,
    pub servername: *mut ::std::os::raw::c_char,
    pub version: *mut ::std::os::raw::c_char,
    pub options: *mut List,
    pub has_version: bool,
}
impl Default for AlterForeignServerStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateForeignTableStmt {
    pub base: CreateStmt,
    pub servername: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl Default for CreateForeignTableStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateUserMappingStmt {
    pub type_: NodeTag,
    pub user: *mut RoleSpec,
    pub servername: *mut ::std::os::raw::c_char,
    pub if_not_exists: bool,
    pub options: *mut List,
}
impl Default for CreateUserMappingStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterUserMappingStmt {
    pub type_: NodeTag,
    pub user: *mut RoleSpec,
    pub servername: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl Default for AlterUserMappingStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DropUserMappingStmt {
    pub type_: NodeTag,
    pub user: *mut RoleSpec,
    pub servername: *mut ::std::os::raw::c_char,
    pub missing_ok: bool,
}
impl Default for DropUserMappingStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ImportForeignSchemaType_FDW_IMPORT_SCHEMA_ALL: ImportForeignSchemaType = 0;
pub const ImportForeignSchemaType_FDW_IMPORT_SCHEMA_LIMIT_TO: ImportForeignSchemaType = 1;
pub const ImportForeignSchemaType_FDW_IMPORT_SCHEMA_EXCEPT: ImportForeignSchemaType = 2;
pub type ImportForeignSchemaType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImportForeignSchemaStmt {
    pub type_: NodeTag,
    pub server_name: *mut ::std::os::raw::c_char,
    pub remote_schema: *mut ::std::os::raw::c_char,
    pub local_schema: *mut ::std::os::raw::c_char,
    pub list_type: ImportForeignSchemaType,
    pub table_list: *mut List,
    pub options: *mut List,
}
impl Default for ImportForeignSchemaStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreatePolicyStmt {
    pub type_: NodeTag,
    pub policy_name: *mut ::std::os::raw::c_char,
    pub table: *mut RangeVar,
    pub cmd_name: *mut ::std::os::raw::c_char,
    pub permissive: bool,
    pub roles: *mut List,
    pub qual: *mut Node,
    pub with_check: *mut Node,
}
impl Default for CreatePolicyStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterPolicyStmt {
    pub type_: NodeTag,
    pub policy_name: *mut ::std::os::raw::c_char,
    pub table: *mut RangeVar,
    pub roles: *mut List,
    pub qual: *mut Node,
    pub with_check: *mut Node,
}
impl Default for AlterPolicyStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateAmStmt {
    pub type_: NodeTag,
    pub amname: *mut ::std::os::raw::c_char,
    pub handler_name: *mut List,
    pub amtype: ::std::os::raw::c_char,
}
impl Default for CreateAmStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateTrigStmt {
    pub type_: NodeTag,
    pub replace: bool,
    pub isconstraint: bool,
    pub trigname: *mut ::std::os::raw::c_char,
    pub relation: *mut RangeVar,
    pub funcname: *mut List,
    pub args: *mut List,
    pub row: bool,
    pub timing: int16,
    pub events: int16,
    pub columns: *mut List,
    pub whenClause: *mut Node,
    pub transitionRels: *mut List,
    pub deferrable: bool,
    pub initdeferred: bool,
    pub constrrel: *mut RangeVar,
}
impl Default for CreateTrigStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateEventTrigStmt {
    pub type_: NodeTag,
    pub trigname: *mut ::std::os::raw::c_char,
    pub eventname: *mut ::std::os::raw::c_char,
    pub whenclause: *mut List,
    pub funcname: *mut List,
}
impl Default for CreateEventTrigStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterEventTrigStmt {
    pub type_: NodeTag,
    pub trigname: *mut ::std::os::raw::c_char,
    pub tgenabled: ::std::os::raw::c_char,
}
impl Default for AlterEventTrigStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreatePLangStmt {
    pub type_: NodeTag,
    pub replace: bool,
    pub plname: *mut ::std::os::raw::c_char,
    pub plhandler: *mut List,
    pub plinline: *mut List,
    pub plvalidator: *mut List,
    pub pltrusted: bool,
}
impl Default for CreatePLangStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const RoleStmtType_ROLESTMT_ROLE: RoleStmtType = 0;
pub const RoleStmtType_ROLESTMT_USER: RoleStmtType = 1;
pub const RoleStmtType_ROLESTMT_GROUP: RoleStmtType = 2;
pub type RoleStmtType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateRoleStmt {
    pub type_: NodeTag,
    pub stmt_type: RoleStmtType,
    pub role: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl Default for CreateRoleStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterRoleStmt {
    pub type_: NodeTag,
    pub role: *mut RoleSpec,
    pub options: *mut List,
    pub action: ::std::os::raw::c_int,
}
impl Default for AlterRoleStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterRoleSetStmt {
    pub type_: NodeTag,
    pub role: *mut RoleSpec,
    pub database: *mut ::std::os::raw::c_char,
    pub setstmt: *mut VariableSetStmt,
}
impl Default for AlterRoleSetStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DropRoleStmt {
    pub type_: NodeTag,
    pub roles: *mut List,
    pub missing_ok: bool,
}
impl Default for DropRoleStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateSeqStmt {
    pub type_: NodeTag,
    pub sequence: *mut RangeVar,
    pub options: *mut List,
    pub ownerId: Oid,
    pub for_identity: bool,
    pub if_not_exists: bool,
}
impl Default for CreateSeqStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterSeqStmt {
    pub type_: NodeTag,
    pub sequence: *mut RangeVar,
    pub options: *mut List,
    pub for_identity: bool,
    pub missing_ok: bool,
}
impl Default for AlterSeqStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DefineStmt {
    pub type_: NodeTag,
    pub kind: ObjectType,
    pub oldstyle: bool,
    pub defnames: *mut List,
    pub args: *mut List,
    pub definition: *mut List,
    pub if_not_exists: bool,
    pub replace: bool,
}
impl Default for DefineStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateDomainStmt {
    pub type_: NodeTag,
    pub domainname: *mut List,
    pub typeName: *mut TypeName,
    pub collClause: *mut CollateClause,
    pub constraints: *mut List,
}
impl Default for CreateDomainStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateOpClassStmt {
    pub type_: NodeTag,
    pub opclassname: *mut List,
    pub opfamilyname: *mut List,
    pub amname: *mut ::std::os::raw::c_char,
    pub datatype: *mut TypeName,
    pub items: *mut List,
    pub isDefault: bool,
}
impl Default for CreateOpClassStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateOpClassItem {
    pub type_: NodeTag,
    pub itemtype: ::std::os::raw::c_int,
    pub name: *mut ObjectWithArgs,
    pub number: ::std::os::raw::c_int,
    pub order_family: *mut List,
    pub class_args: *mut List,
    pub storedtype: *mut TypeName,
}
impl Default for CreateOpClassItem {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateOpFamilyStmt {
    pub type_: NodeTag,
    pub opfamilyname: *mut List,
    pub amname: *mut ::std::os::raw::c_char,
}
impl Default for CreateOpFamilyStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterOpFamilyStmt {
    pub type_: NodeTag,
    pub opfamilyname: *mut List,
    pub amname: *mut ::std::os::raw::c_char,
    pub isDrop: bool,
    pub items: *mut List,
}
impl Default for AlterOpFamilyStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DropStmt {
    pub type_: NodeTag,
    pub objects: *mut List,
    pub removeType: ObjectType,
    pub behavior: DropBehavior,
    pub missing_ok: bool,
    pub concurrent: bool,
}
impl Default for DropStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TruncateStmt {
    pub type_: NodeTag,
    pub relations: *mut List,
    pub restart_seqs: bool,
    pub behavior: DropBehavior,
}
impl Default for TruncateStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CommentStmt {
    pub type_: NodeTag,
    pub objtype: ObjectType,
    pub object: *mut Node,
    pub comment: *mut ::std::os::raw::c_char,
}
impl Default for CommentStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SecLabelStmt {
    pub type_: NodeTag,
    pub objtype: ObjectType,
    pub object: *mut Node,
    pub provider: *mut ::std::os::raw::c_char,
    pub label: *mut ::std::os::raw::c_char,
}
impl Default for SecLabelStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeclareCursorStmt {
    pub type_: NodeTag,
    pub portalname: *mut ::std::os::raw::c_char,
    pub options: ::std::os::raw::c_int,
    pub query: *mut Node,
}
impl Default for DeclareCursorStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ClosePortalStmt {
    pub type_: NodeTag,
    pub portalname: *mut ::std::os::raw::c_char,
}
impl Default for ClosePortalStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const FetchDirection_FETCH_FORWARD: FetchDirection = 0;
pub const FetchDirection_FETCH_BACKWARD: FetchDirection = 1;
pub const FetchDirection_FETCH_ABSOLUTE: FetchDirection = 2;
pub const FetchDirection_FETCH_RELATIVE: FetchDirection = 3;
pub type FetchDirection = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FetchStmt {
    pub type_: NodeTag,
    pub direction: FetchDirection,
    pub howMany: ::std::os::raw::c_long,
    pub portalname: *mut ::std::os::raw::c_char,
    pub ismove: bool,
}
impl Default for FetchStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexStmt {
    pub type_: NodeTag,
    pub idxname: *mut ::std::os::raw::c_char,
    pub relation: *mut RangeVar,
    pub accessMethod: *mut ::std::os::raw::c_char,
    pub tableSpace: *mut ::std::os::raw::c_char,
    pub indexParams: *mut List,
    pub indexIncludingParams: *mut List,
    pub options: *mut List,
    pub whereClause: *mut Node,
    pub excludeOpNames: *mut List,
    pub idxcomment: *mut ::std::os::raw::c_char,
    pub indexOid: Oid,
    pub oldNumber: RelFileNumber,
    pub oldCreateSubid: SubTransactionId,
    pub oldFirstRelfilelocatorSubid: SubTransactionId,
    pub unique: bool,
    pub nulls_not_distinct: bool,
    pub primary: bool,
    pub isconstraint: bool,
    pub deferrable: bool,
    pub initdeferred: bool,
    pub transformed: bool,
    pub concurrent: bool,
    pub if_not_exists: bool,
    pub reset_default_tblspc: bool,
}
impl Default for IndexStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateStatsStmt {
    pub type_: NodeTag,
    pub defnames: *mut List,
    pub stat_types: *mut List,
    pub exprs: *mut List,
    pub relations: *mut List,
    pub stxcomment: *mut ::std::os::raw::c_char,
    pub transformed: bool,
    pub if_not_exists: bool,
}
impl Default for CreateStatsStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StatsElem {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub expr: *mut Node,
}
impl Default for StatsElem {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterStatsStmt {
    pub type_: NodeTag,
    pub defnames: *mut List,
    pub stxstattarget: ::std::os::raw::c_int,
    pub missing_ok: bool,
}
impl Default for AlterStatsStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateFunctionStmt {
    pub type_: NodeTag,
    pub is_procedure: bool,
    pub replace: bool,
    pub funcname: *mut List,
    pub parameters: *mut List,
    pub returnType: *mut TypeName,
    pub options: *mut List,
    pub sql_body: *mut Node,
}
impl Default for CreateFunctionStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const FunctionParameterMode_FUNC_PARAM_IN: FunctionParameterMode = 105;
pub const FunctionParameterMode_FUNC_PARAM_OUT: FunctionParameterMode = 111;
pub const FunctionParameterMode_FUNC_PARAM_INOUT: FunctionParameterMode = 98;
pub const FunctionParameterMode_FUNC_PARAM_VARIADIC: FunctionParameterMode = 118;
pub const FunctionParameterMode_FUNC_PARAM_TABLE: FunctionParameterMode = 116;
pub const FunctionParameterMode_FUNC_PARAM_DEFAULT: FunctionParameterMode = 100;
pub type FunctionParameterMode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FunctionParameter {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub argType: *mut TypeName,
    pub mode: FunctionParameterMode,
    pub defexpr: *mut Node,
}
impl Default for FunctionParameter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterFunctionStmt {
    pub type_: NodeTag,
    pub objtype: ObjectType,
    pub func: *mut ObjectWithArgs,
    pub actions: *mut List,
}
impl Default for AlterFunctionStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DoStmt {
    pub type_: NodeTag,
    pub args: *mut List,
}
impl Default for DoStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InlineCodeBlock {
    pub type_: NodeTag,
    pub source_text: *mut ::std::os::raw::c_char,
    pub langOid: Oid,
    pub langIsTrusted: bool,
    pub atomic: bool,
}
impl Default for InlineCodeBlock {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CallStmt {
    pub type_: NodeTag,
    pub funccall: *mut FuncCall,
    pub funcexpr: *mut FuncExpr,
    pub outargs: *mut List,
}
impl Default for CallStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CallContext {
    pub type_: NodeTag,
    pub atomic: bool,
}
impl Default for CallContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RenameStmt {
    pub type_: NodeTag,
    pub renameType: ObjectType,
    pub relationType: ObjectType,
    pub relation: *mut RangeVar,
    pub object: *mut Node,
    pub subname: *mut ::std::os::raw::c_char,
    pub newname: *mut ::std::os::raw::c_char,
    pub behavior: DropBehavior,
    pub missing_ok: bool,
}
impl Default for RenameStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterObjectDependsStmt {
    pub type_: NodeTag,
    pub objectType: ObjectType,
    pub relation: *mut RangeVar,
    pub object: *mut Node,
    pub extname: *mut String,
    pub remove: bool,
}
impl Default for AlterObjectDependsStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterObjectSchemaStmt {
    pub type_: NodeTag,
    pub objectType: ObjectType,
    pub relation: *mut RangeVar,
    pub object: *mut Node,
    pub newschema: *mut ::std::os::raw::c_char,
    pub missing_ok: bool,
}
impl Default for AlterObjectSchemaStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterOwnerStmt {
    pub type_: NodeTag,
    pub objectType: ObjectType,
    pub relation: *mut RangeVar,
    pub object: *mut Node,
    pub newowner: *mut RoleSpec,
}
impl Default for AlterOwnerStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterOperatorStmt {
    pub type_: NodeTag,
    pub opername: *mut ObjectWithArgs,
    pub options: *mut List,
}
impl Default for AlterOperatorStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterTypeStmt {
    pub type_: NodeTag,
    pub typeName: *mut List,
    pub options: *mut List,
}
impl Default for AlterTypeStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RuleStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub rulename: *mut ::std::os::raw::c_char,
    pub whereClause: *mut Node,
    pub event: CmdType,
    pub instead: bool,
    pub actions: *mut List,
    pub replace: bool,
}
impl Default for RuleStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotifyStmt {
    pub type_: NodeTag,
    pub conditionname: *mut ::std::os::raw::c_char,
    pub payload: *mut ::std::os::raw::c_char,
}
impl Default for NotifyStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ListenStmt {
    pub type_: NodeTag,
    pub conditionname: *mut ::std::os::raw::c_char,
}
impl Default for ListenStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UnlistenStmt {
    pub type_: NodeTag,
    pub conditionname: *mut ::std::os::raw::c_char,
}
impl Default for UnlistenStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const TransactionStmtKind_TRANS_STMT_BEGIN: TransactionStmtKind = 0;
pub const TransactionStmtKind_TRANS_STMT_START: TransactionStmtKind = 1;
pub const TransactionStmtKind_TRANS_STMT_COMMIT: TransactionStmtKind = 2;
pub const TransactionStmtKind_TRANS_STMT_ROLLBACK: TransactionStmtKind = 3;
pub const TransactionStmtKind_TRANS_STMT_SAVEPOINT: TransactionStmtKind = 4;
pub const TransactionStmtKind_TRANS_STMT_RELEASE: TransactionStmtKind = 5;
pub const TransactionStmtKind_TRANS_STMT_ROLLBACK_TO: TransactionStmtKind = 6;
pub const TransactionStmtKind_TRANS_STMT_PREPARE: TransactionStmtKind = 7;
pub const TransactionStmtKind_TRANS_STMT_COMMIT_PREPARED: TransactionStmtKind = 8;
pub const TransactionStmtKind_TRANS_STMT_ROLLBACK_PREPARED: TransactionStmtKind = 9;
pub type TransactionStmtKind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TransactionStmt {
    pub type_: NodeTag,
    pub kind: TransactionStmtKind,
    pub options: *mut List,
    pub savepoint_name: *mut ::std::os::raw::c_char,
    pub gid: *mut ::std::os::raw::c_char,
    pub chain: bool,
}
impl Default for TransactionStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CompositeTypeStmt {
    pub type_: NodeTag,
    pub typevar: *mut RangeVar,
    pub coldeflist: *mut List,
}
impl Default for CompositeTypeStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateEnumStmt {
    pub type_: NodeTag,
    pub typeName: *mut List,
    pub vals: *mut List,
}
impl Default for CreateEnumStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateRangeStmt {
    pub type_: NodeTag,
    pub typeName: *mut List,
    pub params: *mut List,
}
impl Default for CreateRangeStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterEnumStmt {
    pub type_: NodeTag,
    pub typeName: *mut List,
    pub oldVal: *mut ::std::os::raw::c_char,
    pub newVal: *mut ::std::os::raw::c_char,
    pub newValNeighbor: *mut ::std::os::raw::c_char,
    pub newValIsAfter: bool,
    pub skipIfNewValExists: bool,
}
impl Default for AlterEnumStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ViewCheckOption_NO_CHECK_OPTION: ViewCheckOption = 0;
pub const ViewCheckOption_LOCAL_CHECK_OPTION: ViewCheckOption = 1;
pub const ViewCheckOption_CASCADED_CHECK_OPTION: ViewCheckOption = 2;
pub type ViewCheckOption = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ViewStmt {
    pub type_: NodeTag,
    pub view: *mut RangeVar,
    pub aliases: *mut List,
    pub query: *mut Node,
    pub replace: bool,
    pub options: *mut List,
    pub withCheckOption: ViewCheckOption,
}
impl Default for ViewStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LoadStmt {
    pub type_: NodeTag,
    pub filename: *mut ::std::os::raw::c_char,
}
impl Default for LoadStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreatedbStmt {
    pub type_: NodeTag,
    pub dbname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl Default for CreatedbStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterDatabaseStmt {
    pub type_: NodeTag,
    pub dbname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl Default for AlterDatabaseStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterDatabaseRefreshCollStmt {
    pub type_: NodeTag,
    pub dbname: *mut ::std::os::raw::c_char,
}
impl Default for AlterDatabaseRefreshCollStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterDatabaseSetStmt {
    pub type_: NodeTag,
    pub dbname: *mut ::std::os::raw::c_char,
    pub setstmt: *mut VariableSetStmt,
}
impl Default for AlterDatabaseSetStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DropdbStmt {
    pub type_: NodeTag,
    pub dbname: *mut ::std::os::raw::c_char,
    pub missing_ok: bool,
    pub options: *mut List,
}
impl Default for DropdbStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterSystemStmt {
    pub type_: NodeTag,
    pub setstmt: *mut VariableSetStmt,
}
impl Default for AlterSystemStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ClusterStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub indexname: *mut ::std::os::raw::c_char,
    pub params: *mut List,
}
impl Default for ClusterStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VacuumStmt {
    pub type_: NodeTag,
    pub options: *mut List,
    pub rels: *mut List,
    pub is_vacuumcmd: bool,
}
impl Default for VacuumStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VacuumRelation {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub oid: Oid,
    pub va_cols: *mut List,
}
impl Default for VacuumRelation {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExplainStmt {
    pub type_: NodeTag,
    pub query: *mut Node,
    pub options: *mut List,
}
impl Default for ExplainStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateTableAsStmt {
    pub type_: NodeTag,
    pub query: *mut Node,
    pub into: *mut IntoClause,
    pub objtype: ObjectType,
    pub is_select_into: bool,
    pub if_not_exists: bool,
}
impl Default for CreateTableAsStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RefreshMatViewStmt {
    pub type_: NodeTag,
    pub concurrent: bool,
    pub skipData: bool,
    pub relation: *mut RangeVar,
}
impl Default for RefreshMatViewStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CheckPointStmt {
    pub type_: NodeTag,
}
impl Default for CheckPointStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const DiscardMode_DISCARD_ALL: DiscardMode = 0;
pub const DiscardMode_DISCARD_PLANS: DiscardMode = 1;
pub const DiscardMode_DISCARD_SEQUENCES: DiscardMode = 2;
pub const DiscardMode_DISCARD_TEMP: DiscardMode = 3;
pub type DiscardMode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DiscardStmt {
    pub type_: NodeTag,
    pub target: DiscardMode,
}
impl Default for DiscardStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LockStmt {
    pub type_: NodeTag,
    pub relations: *mut List,
    pub mode: ::std::os::raw::c_int,
    pub nowait: bool,
}
impl Default for LockStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConstraintsSetStmt {
    pub type_: NodeTag,
    pub constraints: *mut List,
    pub deferred: bool,
}
impl Default for ConstraintsSetStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ReindexObjectType_REINDEX_OBJECT_INDEX: ReindexObjectType = 0;
pub const ReindexObjectType_REINDEX_OBJECT_TABLE: ReindexObjectType = 1;
pub const ReindexObjectType_REINDEX_OBJECT_SCHEMA: ReindexObjectType = 2;
pub const ReindexObjectType_REINDEX_OBJECT_SYSTEM: ReindexObjectType = 3;
pub const ReindexObjectType_REINDEX_OBJECT_DATABASE: ReindexObjectType = 4;
pub type ReindexObjectType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReindexStmt {
    pub type_: NodeTag,
    pub kind: ReindexObjectType,
    pub relation: *mut RangeVar,
    pub name: *const ::std::os::raw::c_char,
    pub params: *mut List,
}
impl Default for ReindexStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateConversionStmt {
    pub type_: NodeTag,
    pub conversion_name: *mut List,
    pub for_encoding_name: *mut ::std::os::raw::c_char,
    pub to_encoding_name: *mut ::std::os::raw::c_char,
    pub func_name: *mut List,
    pub def: bool,
}
impl Default for CreateConversionStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateCastStmt {
    pub type_: NodeTag,
    pub sourcetype: *mut TypeName,
    pub targettype: *mut TypeName,
    pub func: *mut ObjectWithArgs,
    pub context: CoercionContext,
    pub inout: bool,
}
impl Default for CreateCastStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateTransformStmt {
    pub type_: NodeTag,
    pub replace: bool,
    pub type_name: *mut TypeName,
    pub lang: *mut ::std::os::raw::c_char,
    pub fromsql: *mut ObjectWithArgs,
    pub tosql: *mut ObjectWithArgs,
}
impl Default for CreateTransformStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PrepareStmt {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub argtypes: *mut List,
    pub query: *mut Node,
}
impl Default for PrepareStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExecuteStmt {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub params: *mut List,
}
impl Default for ExecuteStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeallocateStmt {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
}
impl Default for DeallocateStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DropOwnedStmt {
    pub type_: NodeTag,
    pub roles: *mut List,
    pub behavior: DropBehavior,
}
impl Default for DropOwnedStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReassignOwnedStmt {
    pub type_: NodeTag,
    pub roles: *mut List,
    pub newrole: *mut RoleSpec,
}
impl Default for ReassignOwnedStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterTSDictionaryStmt {
    pub type_: NodeTag,
    pub dictname: *mut List,
    pub options: *mut List,
}
impl Default for AlterTSDictionaryStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const AlterTSConfigType_ALTER_TSCONFIG_ADD_MAPPING: AlterTSConfigType = 0;
pub const AlterTSConfigType_ALTER_TSCONFIG_ALTER_MAPPING_FOR_TOKEN: AlterTSConfigType = 1;
pub const AlterTSConfigType_ALTER_TSCONFIG_REPLACE_DICT: AlterTSConfigType = 2;
pub const AlterTSConfigType_ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN: AlterTSConfigType = 3;
pub const AlterTSConfigType_ALTER_TSCONFIG_DROP_MAPPING: AlterTSConfigType = 4;
pub type AlterTSConfigType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterTSConfigurationStmt {
    pub type_: NodeTag,
    pub kind: AlterTSConfigType,
    pub cfgname: *mut List,
    pub tokentype: *mut List,
    pub dicts: *mut List,
    pub override_: bool,
    pub replace: bool,
    pub missing_ok: bool,
}
impl Default for AlterTSConfigurationStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PublicationTable {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub whereClause: *mut Node,
    pub columns: *mut List,
}
impl Default for PublicationTable {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const PublicationObjSpecType_PUBLICATIONOBJ_TABLE: PublicationObjSpecType = 0;
pub const PublicationObjSpecType_PUBLICATIONOBJ_TABLES_IN_SCHEMA: PublicationObjSpecType = 1;
pub const PublicationObjSpecType_PUBLICATIONOBJ_TABLES_IN_CUR_SCHEMA: PublicationObjSpecType = 2;
pub const PublicationObjSpecType_PUBLICATIONOBJ_CONTINUATION: PublicationObjSpecType = 3;
pub type PublicationObjSpecType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PublicationObjSpec {
    pub type_: NodeTag,
    pub pubobjtype: PublicationObjSpecType,
    pub name: *mut ::std::os::raw::c_char,
    pub pubtable: *mut PublicationTable,
    pub location: ::std::os::raw::c_int,
}
impl Default for PublicationObjSpec {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreatePublicationStmt {
    pub type_: NodeTag,
    pub pubname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
    pub pubobjects: *mut List,
    pub for_all_tables: bool,
}
impl Default for CreatePublicationStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const AlterPublicationAction_AP_AddObjects: AlterPublicationAction = 0;
pub const AlterPublicationAction_AP_DropObjects: AlterPublicationAction = 1;
pub const AlterPublicationAction_AP_SetObjects: AlterPublicationAction = 2;
pub type AlterPublicationAction = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterPublicationStmt {
    pub type_: NodeTag,
    pub pubname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
    pub pubobjects: *mut List,
    pub for_all_tables: bool,
    pub action: AlterPublicationAction,
}
impl Default for AlterPublicationStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateSubscriptionStmt {
    pub type_: NodeTag,
    pub subname: *mut ::std::os::raw::c_char,
    pub conninfo: *mut ::std::os::raw::c_char,
    pub publication: *mut List,
    pub options: *mut List,
}
impl Default for CreateSubscriptionStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const AlterSubscriptionType_ALTER_SUBSCRIPTION_OPTIONS: AlterSubscriptionType = 0;
pub const AlterSubscriptionType_ALTER_SUBSCRIPTION_CONNECTION: AlterSubscriptionType = 1;
pub const AlterSubscriptionType_ALTER_SUBSCRIPTION_SET_PUBLICATION: AlterSubscriptionType = 2;
pub const AlterSubscriptionType_ALTER_SUBSCRIPTION_ADD_PUBLICATION: AlterSubscriptionType = 3;
pub const AlterSubscriptionType_ALTER_SUBSCRIPTION_DROP_PUBLICATION: AlterSubscriptionType = 4;
pub const AlterSubscriptionType_ALTER_SUBSCRIPTION_REFRESH: AlterSubscriptionType = 5;
pub const AlterSubscriptionType_ALTER_SUBSCRIPTION_ENABLED: AlterSubscriptionType = 6;
pub const AlterSubscriptionType_ALTER_SUBSCRIPTION_SKIP: AlterSubscriptionType = 7;
pub type AlterSubscriptionType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterSubscriptionStmt {
    pub type_: NodeTag,
    pub kind: AlterSubscriptionType,
    pub subname: *mut ::std::os::raw::c_char,
    pub conninfo: *mut ::std::os::raw::c_char,
    pub publication: *mut List,
    pub options: *mut List,
}
impl Default for AlterSubscriptionStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DropSubscriptionStmt {
    pub type_: NodeTag,
    pub subname: *mut ::std::os::raw::c_char,
    pub missing_ok: bool,
    pub behavior: DropBehavior,
}
impl Default for DropSubscriptionStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PlannedStmt {
    pub type_: NodeTag,
    pub commandType: CmdType,
    pub queryId: uint64,
    pub hasReturning: bool,
    pub hasModifyingCTE: bool,
    pub canSetTag: bool,
    pub transientPlan: bool,
    pub dependsOnRole: bool,
    pub parallelModeNeeded: bool,
    pub jitFlags: ::std::os::raw::c_int,
    pub planTree: *mut Plan,
    pub rtable: *mut List,
    pub permInfos: *mut List,
    pub resultRelations: *mut List,
    pub appendRelations: *mut List,
    pub subplans: *mut List,
    pub rewindPlanIDs: *mut Bitmapset,
    pub rowMarks: *mut List,
    pub relationOids: *mut List,
    pub invalItems: *mut List,
    pub paramExecTypes: *mut List,
    pub utilityStmt: *mut Node,
    pub stmt_location: ::std::os::raw::c_int,
    pub stmt_len: ::std::os::raw::c_int,
}
impl Default for PlannedStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Plan {
    pub type_: NodeTag,
    pub startup_cost: Cost,
    pub total_cost: Cost,
    pub plan_rows: Cardinality,
    pub plan_width: ::std::os::raw::c_int,
    pub parallel_aware: bool,
    pub parallel_safe: bool,
    pub async_capable: bool,
    pub plan_node_id: ::std::os::raw::c_int,
    pub targetlist: *mut List,
    pub qual: *mut List,
    pub lefttree: *mut Plan,
    pub righttree: *mut Plan,
    pub initPlan: *mut List,
    pub extParam: *mut Bitmapset,
    pub allParam: *mut Bitmapset,
}
impl Default for Plan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Result {
    pub plan: Plan,
    pub resconstantqual: *mut Node,
}
impl Default for Result {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProjectSet {
    pub plan: Plan,
}
impl Default for ProjectSet {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ModifyTable {
    pub plan: Plan,
    pub operation: CmdType,
    pub canSetTag: bool,
    pub nominalRelation: Index,
    pub rootRelation: Index,
    pub partColsUpdated: bool,
    pub resultRelations: *mut List,
    pub updateColnosLists: *mut List,
    pub withCheckOptionLists: *mut List,
    pub returningLists: *mut List,
    pub fdwPrivLists: *mut List,
    pub fdwDirectModifyPlans: *mut Bitmapset,
    pub rowMarks: *mut List,
    pub epqParam: ::std::os::raw::c_int,
    pub onConflictAction: OnConflictAction,
    pub arbiterIndexes: *mut List,
    pub onConflictSet: *mut List,
    pub onConflictCols: *mut List,
    pub onConflictWhere: *mut Node,
    pub exclRelRTI: Index,
    pub exclRelTlist: *mut List,
    pub mergeActionLists: *mut List,
}
impl Default for ModifyTable {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Append {
    pub plan: Plan,
    pub apprelids: *mut Bitmapset,
    pub appendplans: *mut List,
    pub nasyncplans: ::std::os::raw::c_int,
    pub first_partial_plan: ::std::os::raw::c_int,
    pub part_prune_info: *mut PartitionPruneInfo,
}
impl Default for Append {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeAppend {
    pub plan: Plan,
    pub apprelids: *mut Bitmapset,
    pub mergeplans: *mut List,
    pub numCols: ::std::os::raw::c_int,
    pub sortColIdx: *mut AttrNumber,
    pub sortOperators: *mut Oid,
    pub collations: *mut Oid,
    pub nullsFirst: *mut bool,
    pub part_prune_info: *mut PartitionPruneInfo,
}
impl Default for MergeAppend {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RecursiveUnion {
    pub plan: Plan,
    pub wtParam: ::std::os::raw::c_int,
    pub numCols: ::std::os::raw::c_int,
    pub dupColIdx: *mut AttrNumber,
    pub dupOperators: *mut Oid,
    pub dupCollations: *mut Oid,
    pub numGroups: ::std::os::raw::c_long,
}
impl Default for RecursiveUnion {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapAnd {
    pub plan: Plan,
    pub bitmapplans: *mut List,
}
impl Default for BitmapAnd {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapOr {
    pub plan: Plan,
    pub isshared: bool,
    pub bitmapplans: *mut List,
}
impl Default for BitmapOr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Scan {
    pub plan: Plan,
    pub scanrelid: Index,
}
impl Default for Scan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SeqScan {
    pub scan: Scan,
}
impl Default for SeqScan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SampleScan {
    pub scan: Scan,
    pub tablesample: *mut TableSampleClause,
}
impl Default for SampleScan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexScan {
    pub scan: Scan,
    pub indexid: Oid,
    pub indexqual: *mut List,
    pub indexqualorig: *mut List,
    pub indexorderby: *mut List,
    pub indexorderbyorig: *mut List,
    pub indexorderbyops: *mut List,
    pub indexorderdir: ScanDirection,
}
impl Default for IndexScan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexOnlyScan {
    pub scan: Scan,
    pub indexid: Oid,
    pub indexqual: *mut List,
    pub recheckqual: *mut List,
    pub indexorderby: *mut List,
    pub indextlist: *mut List,
    pub indexorderdir: ScanDirection,
}
impl Default for IndexOnlyScan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapIndexScan {
    pub scan: Scan,
    pub indexid: Oid,
    pub isshared: bool,
    pub indexqual: *mut List,
    pub indexqualorig: *mut List,
}
impl Default for BitmapIndexScan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapHeapScan {
    pub scan: Scan,
    pub bitmapqualorig: *mut List,
}
impl Default for BitmapHeapScan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TidScan {
    pub scan: Scan,
    pub tidquals: *mut List,
}
impl Default for TidScan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TidRangeScan {
    pub scan: Scan,
    pub tidrangequals: *mut List,
}
impl Default for TidRangeScan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const SubqueryScanStatus_SUBQUERY_SCAN_UNKNOWN: SubqueryScanStatus = 0;
pub const SubqueryScanStatus_SUBQUERY_SCAN_TRIVIAL: SubqueryScanStatus = 1;
pub const SubqueryScanStatus_SUBQUERY_SCAN_NONTRIVIAL: SubqueryScanStatus = 2;
pub type SubqueryScanStatus = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubqueryScan {
    pub scan: Scan,
    pub subplan: *mut Plan,
    pub scanstatus: SubqueryScanStatus,
}
impl Default for SubqueryScan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FunctionScan {
    pub scan: Scan,
    pub functions: *mut List,
    pub funcordinality: bool,
}
impl Default for FunctionScan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ValuesScan {
    pub scan: Scan,
    pub values_lists: *mut List,
}
impl Default for ValuesScan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TableFuncScan {
    pub scan: Scan,
    pub tablefunc: *mut TableFunc,
}
impl Default for TableFuncScan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CteScan {
    pub scan: Scan,
    pub ctePlanId: ::std::os::raw::c_int,
    pub cteParam: ::std::os::raw::c_int,
}
impl Default for CteScan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NamedTuplestoreScan {
    pub scan: Scan,
    pub enrname: *mut ::std::os::raw::c_char,
}
impl Default for NamedTuplestoreScan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WorkTableScan {
    pub scan: Scan,
    pub wtParam: ::std::os::raw::c_int,
}
impl Default for WorkTableScan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForeignScan {
    pub scan: Scan,
    pub operation: CmdType,
    pub resultRelation: Index,
    pub checkAsUser: Oid,
    pub fs_server: Oid,
    pub fdw_exprs: *mut List,
    pub fdw_private: *mut List,
    pub fdw_scan_tlist: *mut List,
    pub fdw_recheck_quals: *mut List,
    pub fs_relids: *mut Bitmapset,
    pub fs_base_relids: *mut Bitmapset,
    pub fsSystemCol: bool,
}
impl Default for ForeignScan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CustomScan {
    pub scan: Scan,
    pub flags: uint32,
    pub custom_plans: *mut List,
    pub custom_exprs: *mut List,
    pub custom_private: *mut List,
    pub custom_scan_tlist: *mut List,
    pub custom_relids: *mut Bitmapset,
    pub methods: *const CustomScanMethods,
}
impl Default for CustomScan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Join {
    pub plan: Plan,
    pub jointype: JoinType,
    pub inner_unique: bool,
    pub joinqual: *mut List,
}
impl Default for Join {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NestLoop {
    pub join: Join,
    pub nestParams: *mut List,
}
impl Default for NestLoop {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NestLoopParam {
    pub type_: NodeTag,
    pub paramno: ::std::os::raw::c_int,
    pub paramval: *mut Var,
}
impl Default for NestLoopParam {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeJoin {
    pub join: Join,
    pub skip_mark_restore: bool,
    pub mergeclauses: *mut List,
    pub mergeFamilies: *mut Oid,
    pub mergeCollations: *mut Oid,
    pub mergeStrategies: *mut ::std::os::raw::c_int,
    pub mergeNullsFirst: *mut bool,
}
impl Default for MergeJoin {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HashJoin {
    pub join: Join,
    pub hashclauses: *mut List,
    pub hashoperators: *mut List,
    pub hashcollations: *mut List,
    pub hashkeys: *mut List,
}
impl Default for HashJoin {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Material {
    pub plan: Plan,
}
impl Default for Material {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Memoize {
    pub plan: Plan,
    pub numKeys: ::std::os::raw::c_int,
    pub hashOperators: *mut Oid,
    pub collations: *mut Oid,
    pub param_exprs: *mut List,
    pub singlerow: bool,
    pub binary_mode: bool,
    pub est_entries: uint32,
    pub keyparamids: *mut Bitmapset,
}
impl Default for Memoize {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sort {
    pub plan: Plan,
    pub numCols: ::std::os::raw::c_int,
    pub sortColIdx: *mut AttrNumber,
    pub sortOperators: *mut Oid,
    pub collations: *mut Oid,
    pub nullsFirst: *mut bool,
}
impl Default for Sort {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IncrementalSort {
    pub sort: Sort,
    pub nPresortedCols: ::std::os::raw::c_int,
}
impl Default for IncrementalSort {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Group {
    pub plan: Plan,
    pub numCols: ::std::os::raw::c_int,
    pub grpColIdx: *mut AttrNumber,
    pub grpOperators: *mut Oid,
    pub grpCollations: *mut Oid,
}
impl Default for Group {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Agg {
    pub plan: Plan,
    pub aggstrategy: AggStrategy,
    pub aggsplit: AggSplit,
    pub numCols: ::std::os::raw::c_int,
    pub grpColIdx: *mut AttrNumber,
    pub grpOperators: *mut Oid,
    pub grpCollations: *mut Oid,
    pub numGroups: ::std::os::raw::c_long,
    pub transitionSpace: uint64,
    pub aggParams: *mut Bitmapset,
    pub groupingSets: *mut List,
    pub chain: *mut List,
}
impl Default for Agg {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowAgg {
    pub plan: Plan,
    pub winref: Index,
    pub partNumCols: ::std::os::raw::c_int,
    pub partColIdx: *mut AttrNumber,
    pub partOperators: *mut Oid,
    pub partCollations: *mut Oid,
    pub ordNumCols: ::std::os::raw::c_int,
    pub ordColIdx: *mut AttrNumber,
    pub ordOperators: *mut Oid,
    pub ordCollations: *mut Oid,
    pub frameOptions: ::std::os::raw::c_int,
    pub startOffset: *mut Node,
    pub endOffset: *mut Node,
    pub runCondition: *mut List,
    pub runConditionOrig: *mut List,
    pub startInRangeFunc: Oid,
    pub endInRangeFunc: Oid,
    pub inRangeColl: Oid,
    pub inRangeAsc: bool,
    pub inRangeNullsFirst: bool,
    pub topWindow: bool,
}
impl Default for WindowAgg {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Unique {
    pub plan: Plan,
    pub numCols: ::std::os::raw::c_int,
    pub uniqColIdx: *mut AttrNumber,
    pub uniqOperators: *mut Oid,
    pub uniqCollations: *mut Oid,
}
impl Default for Unique {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Gather {
    pub plan: Plan,
    pub num_workers: ::std::os::raw::c_int,
    pub rescan_param: ::std::os::raw::c_int,
    pub single_copy: bool,
    pub invisible: bool,
    pub initParam: *mut Bitmapset,
}
impl Default for Gather {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GatherMerge {
    pub plan: Plan,
    pub num_workers: ::std::os::raw::c_int,
    pub rescan_param: ::std::os::raw::c_int,
    pub numCols: ::std::os::raw::c_int,
    pub sortColIdx: *mut AttrNumber,
    pub sortOperators: *mut Oid,
    pub collations: *mut Oid,
    pub nullsFirst: *mut bool,
    pub initParam: *mut Bitmapset,
}
impl Default for GatherMerge {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Hash {
    pub plan: Plan,
    pub hashkeys: *mut List,
    pub skewTable: Oid,
    pub skewColumn: AttrNumber,
    pub skewInherit: bool,
    pub rows_total: Cardinality,
}
impl Default for Hash {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SetOp {
    pub plan: Plan,
    pub cmd: SetOpCmd,
    pub strategy: SetOpStrategy,
    pub numCols: ::std::os::raw::c_int,
    pub dupColIdx: *mut AttrNumber,
    pub dupOperators: *mut Oid,
    pub dupCollations: *mut Oid,
    pub flagColIdx: AttrNumber,
    pub firstFlag: ::std::os::raw::c_int,
    pub numGroups: ::std::os::raw::c_long,
}
impl Default for SetOp {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LockRows {
    pub plan: Plan,
    pub rowMarks: *mut List,
    pub epqParam: ::std::os::raw::c_int,
}
impl Default for LockRows {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Limit {
    pub plan: Plan,
    pub limitOffset: *mut Node,
    pub limitCount: *mut Node,
    pub limitOption: LimitOption,
    pub uniqNumCols: ::std::os::raw::c_int,
    pub uniqColIdx: *mut AttrNumber,
    pub uniqOperators: *mut Oid,
    pub uniqCollations: *mut Oid,
}
impl Default for Limit {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const RowMarkType_ROW_MARK_EXCLUSIVE: RowMarkType = 0;
pub const RowMarkType_ROW_MARK_NOKEYEXCLUSIVE: RowMarkType = 1;
pub const RowMarkType_ROW_MARK_SHARE: RowMarkType = 2;
pub const RowMarkType_ROW_MARK_KEYSHARE: RowMarkType = 3;
pub const RowMarkType_ROW_MARK_REFERENCE: RowMarkType = 4;
pub const RowMarkType_ROW_MARK_COPY: RowMarkType = 5;
pub type RowMarkType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PlanRowMark {
    pub type_: NodeTag,
    pub rti: Index,
    pub prti: Index,
    pub rowmarkId: Index,
    pub markType: RowMarkType,
    pub allMarkTypes: ::std::os::raw::c_int,
    pub strength: LockClauseStrength,
    pub waitPolicy: LockWaitPolicy,
    pub isParent: bool,
}
impl Default for PlanRowMark {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionPruneInfo {
    pub type_: NodeTag,
    pub prune_infos: *mut List,
    pub other_subplans: *mut Bitmapset,
}
impl Default for PartitionPruneInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionedRelPruneInfo {
    pub type_: NodeTag,
    pub rtindex: Index,
    pub present_parts: *mut Bitmapset,
    pub nparts: ::std::os::raw::c_int,
    pub subplan_map: *mut ::std::os::raw::c_int,
    pub subpart_map: *mut ::std::os::raw::c_int,
    pub relid_map: *mut Oid,
    pub initial_pruning_steps: *mut List,
    pub exec_pruning_steps: *mut List,
    pub execparamids: *mut Bitmapset,
}
impl Default for PartitionedRelPruneInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionPruneStep {
    pub type_: NodeTag,
    pub step_id: ::std::os::raw::c_int,
}
impl Default for PartitionPruneStep {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionPruneStepOp {
    pub step: PartitionPruneStep,
    pub opstrategy: StrategyNumber,
    pub exprs: *mut List,
    pub cmpfns: *mut List,
    pub nullkeys: *mut Bitmapset,
}
impl Default for PartitionPruneStepOp {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const PartitionPruneCombineOp_PARTPRUNE_COMBINE_UNION: PartitionPruneCombineOp = 0;
pub const PartitionPruneCombineOp_PARTPRUNE_COMBINE_INTERSECT: PartitionPruneCombineOp = 1;
pub type PartitionPruneCombineOp = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionPruneStepCombine {
    pub step: PartitionPruneStep,
    pub combineOp: PartitionPruneCombineOp,
    pub source_stepids: *mut List,
}
impl Default for PartitionPruneStepCombine {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PlanInvalItem {
    pub type_: NodeTag,
    pub cacheId: ::std::os::raw::c_int,
    pub hashValue: uint32,
}
impl Default for PlanInvalItem {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const MonotonicFunction_MONOTONICFUNC_NONE: MonotonicFunction = 0;
pub const MonotonicFunction_MONOTONICFUNC_INCREASING: MonotonicFunction = 1;
pub const MonotonicFunction_MONOTONICFUNC_DECREASING: MonotonicFunction = 2;
pub const MonotonicFunction_MONOTONICFUNC_BOTH: MonotonicFunction = 3;
pub type MonotonicFunction = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pg_atomic_flag {
    pub value: ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pg_atomic_uint32 {
    pub value: uint32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pg_atomic_uint64 {
    pub value: uint64,
}
pub type dsm_handle = uint32;
pub const dsm_op_DSM_OP_CREATE: dsm_op = 0;
pub const dsm_op_DSM_OP_ATTACH: dsm_op = 1;
pub const dsm_op_DSM_OP_DETACH: dsm_op = 2;
pub const dsm_op_DSM_OP_DESTROY: dsm_op = 3;
pub type dsm_op = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsm_segment {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PGShmemHeader {
    _unused: [u8; 0],
}
pub type on_dsm_detach_callback =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut dsm_segment, arg: Datum)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_area {
    _unused: [u8; 0],
}
pub type dsa_pointer = uint64;
pub type dsa_pointer_atomic = pg_atomic_uint64;
pub type dsa_handle = dsm_handle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TIDBitmap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TBMIterator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TBMSharedIterator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct TBMIterateResult {
    pub blockno: BlockNumber,
    pub ntuples: ::std::os::raw::c_int,
    pub recheck: bool,
    pub offsets: __IncompleteArrayField<OffsetNumber>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct proclist_node {
    pub next: ::std::os::raw::c_int,
    pub prev: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct proclist_head {
    pub head: ::std::os::raw::c_int,
    pub tail: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct proclist_mutable_iter {
    pub cur: ::std::os::raw::c_int,
    pub next: ::std::os::raw::c_int,
}
pub type slock_t = ::std::os::raw::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SpinDelayStatus {
    pub spins: ::std::os::raw::c_int,
    pub delays: ::std::os::raw::c_int,
    pub cur_delay: ::std::os::raw::c_int,
    pub file: *const ::std::os::raw::c_char,
    pub line: ::std::os::raw::c_int,
    pub func: *const ::std::os::raw::c_char,
}
impl Default for SpinDelayStatus {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ConditionVariable {
    pub mutex: slock_t,
    pub wakeup: proclist_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ConditionVariableMinimallyPadded {
    pub cv: ConditionVariable,
    pub pad: [::std::os::raw::c_char; 16usize],
}
impl Default for ConditionVariableMinimallyPadded {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type HashValueFunc = ::std::option::Option<
    unsafe extern "C" fn(key: *const ::std::os::raw::c_void, keysize: Size) -> uint32,
>;
pub type HashCompareFunc = ::std::option::Option<
    unsafe extern "C" fn(
        key1: *const ::std::os::raw::c_void,
        key2: *const ::std::os::raw::c_void,
        keysize: Size,
    ) -> ::std::os::raw::c_int,
>;
pub type HashCopyFunc = ::std::option::Option<
    unsafe extern "C" fn(
        dest: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        keysize: Size,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type HashAllocFunc =
    ::std::option::Option<unsafe extern "C" fn(request: Size) -> *mut ::std::os::raw::c_void>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HASHELEMENT {
    pub link: *mut HASHELEMENT,
    pub hashvalue: uint32,
}
impl Default for HASHELEMENT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HASHHDR {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTAB {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HASHCTL {
    pub num_partitions: ::std::os::raw::c_long,
    pub ssize: ::std::os::raw::c_long,
    pub dsize: ::std::os::raw::c_long,
    pub max_dsize: ::std::os::raw::c_long,
    pub keysize: Size,
    pub entrysize: Size,
    pub hash: HashValueFunc,
    pub match_: HashCompareFunc,
    pub keycopy: HashCopyFunc,
    pub alloc: HashAllocFunc,
    pub hcxt: MemoryContext,
    pub hctl: *mut HASHHDR,
}
impl Default for HASHCTL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const HASHACTION_HASH_FIND: HASHACTION = 0;
pub const HASHACTION_HASH_ENTER: HASHACTION = 1;
pub const HASHACTION_HASH_REMOVE: HASHACTION = 2;
pub const HASHACTION_HASH_ENTER_NULL: HASHACTION = 3;
pub type HASHACTION = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HASH_SEQ_STATUS {
    pub hashp: *mut HTAB,
    pub curBucket: uint32,
    pub curEntry: *mut HASHELEMENT,
}
impl Default for HASH_SEQ_STATUS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const EphemeralNameRelationType_ENR_NAMED_TUPLESTORE: EphemeralNameRelationType = 0;
pub type EphemeralNameRelationType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EphemeralNamedRelationMetadataData {
    pub name: *mut ::std::os::raw::c_char,
    pub reliddesc: Oid,
    pub tupdesc: TupleDesc,
    pub enrtype: EphemeralNameRelationType,
    pub enrtuples: f64,
}
impl Default for EphemeralNamedRelationMetadataData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type EphemeralNamedRelationMetadata = *mut EphemeralNamedRelationMetadataData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EphemeralNamedRelationData {
    pub md: EphemeralNamedRelationMetadataData,
    pub reldata: *mut ::std::os::raw::c_void,
}
impl Default for EphemeralNamedRelationData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type EphemeralNamedRelation = *mut EphemeralNamedRelationData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueryEnvironment {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Trigger {
    pub tgoid: Oid,
    pub tgname: *mut ::std::os::raw::c_char,
    pub tgfoid: Oid,
    pub tgtype: int16,
    pub tgenabled: ::std::os::raw::c_char,
    pub tgisinternal: bool,
    pub tgisclone: bool,
    pub tgconstrrelid: Oid,
    pub tgconstrindid: Oid,
    pub tgconstraint: Oid,
    pub tgdeferrable: bool,
    pub tginitdeferred: bool,
    pub tgnargs: int16,
    pub tgnattr: int16,
    pub tgattr: *mut int16,
    pub tgargs: *mut *mut ::std::os::raw::c_char,
    pub tgqual: *mut ::std::os::raw::c_char,
    pub tgoldtable: *mut ::std::os::raw::c_char,
    pub tgnewtable: *mut ::std::os::raw::c_char,
}
impl Default for Trigger {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TriggerDesc {
    pub triggers: *mut Trigger,
    pub numtriggers: ::std::os::raw::c_int,
    pub trig_insert_before_row: bool,
    pub trig_insert_after_row: bool,
    pub trig_insert_instead_row: bool,
    pub trig_insert_before_statement: bool,
    pub trig_insert_after_statement: bool,
    pub trig_update_before_row: bool,
    pub trig_update_after_row: bool,
    pub trig_update_instead_row: bool,
    pub trig_update_before_statement: bool,
    pub trig_update_after_statement: bool,
    pub trig_delete_before_row: bool,
    pub trig_delete_after_row: bool,
    pub trig_delete_instead_row: bool,
    pub trig_delete_before_statement: bool,
    pub trig_delete_after_statement: bool,
    pub trig_truncate_before_statement: bool,
    pub trig_truncate_after_statement: bool,
    pub trig_insert_new_table: bool,
    pub trig_update_old_table: bool,
    pub trig_update_new_table: bool,
    pub trig_delete_old_table: bool,
}
impl Default for TriggerDesc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dirent {
    pub d_ino: __ino_t,
    pub d_off: __off_t,
    pub d_reclen: ::std::os::raw::c_ushort,
    pub d_type: ::std::os::raw::c_uchar,
    pub d_name: [::std::os::raw::c_char; 256usize],
}
impl Default for dirent {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const DT_UNKNOWN: _bindgen_ty_3 = 0;
pub const DT_FIFO: _bindgen_ty_3 = 1;
pub const DT_CHR: _bindgen_ty_3 = 2;
pub const DT_DIR: _bindgen_ty_3 = 4;
pub const DT_BLK: _bindgen_ty_3 = 6;
pub const DT_REG: _bindgen_ty_3 = 8;
pub const DT_LNK: _bindgen_ty_3 = 10;
pub const DT_SOCK: _bindgen_ty_3 = 12;
pub const DT_WHT: _bindgen_ty_3 = 14;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __dirstream {
    _unused: [u8; 0],
}
pub type DIR = __dirstream;
pub const RecoveryInitSyncMethod_RECOVERY_INIT_SYNC_METHOD_FSYNC: RecoveryInitSyncMethod = 0;
pub const RecoveryInitSyncMethod_RECOVERY_INIT_SYNC_METHOD_SYNCFS: RecoveryInitSyncMethod = 1;
pub type RecoveryInitSyncMethod = ::std::os::raw::c_uint;
pub type File = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FileSet {
    pub creator_pid: pid_t,
    pub number: uint32,
    pub ntablespaces: ::std::os::raw::c_int,
    pub tablespaces: [Oid; 8usize],
}
impl Default for FileSet {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SharedFileSet {
    pub fs: FileSet,
    pub mutex: slock_t,
    pub refcnt: ::std::os::raw::c_int,
}
impl Default for SharedFileSet {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SharedTuplestore {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SharedTuplestoreAccessor {
    _unused: [u8; 0],
}
pub type Timestamp = int64;
pub type TimestampTz = int64;
pub type TimeOffset = int64;
pub type fsec_t = int32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Interval {
    pub time: TimeOffset,
    pub day: int32,
    pub month: int32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pg_itm {
    pub tm_usec: ::std::os::raw::c_int,
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: int64,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pg_itm_in {
    pub tm_usec: int64,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
}
pub const SnapshotType_SNAPSHOT_MVCC: SnapshotType = 0;
pub const SnapshotType_SNAPSHOT_SELF: SnapshotType = 1;
pub const SnapshotType_SNAPSHOT_ANY: SnapshotType = 2;
pub const SnapshotType_SNAPSHOT_TOAST: SnapshotType = 3;
pub const SnapshotType_SNAPSHOT_DIRTY: SnapshotType = 4;
pub const SnapshotType_SNAPSHOT_HISTORIC_MVCC: SnapshotType = 5;
pub const SnapshotType_SNAPSHOT_NON_VACUUMABLE: SnapshotType = 6;
pub type SnapshotType = ::std::os::raw::c_uint;
pub type Snapshot = *mut SnapshotData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SnapshotData {
    pub snapshot_type: SnapshotType,
    pub xmin: TransactionId,
    pub xmax: TransactionId,
    pub xip: *mut TransactionId,
    pub xcnt: uint32,
    pub subxip: *mut TransactionId,
    pub subxcnt: int32,
    pub suboverflowed: bool,
    pub takenDuringRecovery: bool,
    pub copied: bool,
    pub curcid: CommandId,
    pub speculativeToken: uint32,
    pub vistest: *mut GlobalVisState,
    pub active_count: uint32,
    pub regd_count: uint32,
    pub ph_node: pairingheap_node,
    pub whenTaken: TimestampTz,
    pub lsn: XLogRecPtr,
    pub snapXactCompletionCount: uint64,
}
impl Default for SnapshotData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Relation = *mut RelationData;
pub type RelationPtr = *mut Relation;
pub const IndexAttrBitmapKind_INDEX_ATTR_BITMAP_KEY: IndexAttrBitmapKind = 0;
pub const IndexAttrBitmapKind_INDEX_ATTR_BITMAP_PRIMARY_KEY: IndexAttrBitmapKind = 1;
pub const IndexAttrBitmapKind_INDEX_ATTR_BITMAP_IDENTITY_KEY: IndexAttrBitmapKind = 2;
pub const IndexAttrBitmapKind_INDEX_ATTR_BITMAP_HOT_BLOCKING: IndexAttrBitmapKind = 3;
pub const IndexAttrBitmapKind_INDEX_ATTR_BITMAP_SUMMARIZED: IndexAttrBitmapKind = 4;
pub type IndexAttrBitmapKind = ::std::os::raw::c_uint;
pub type SortSupport = *mut SortSupportData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SortSupportData {
    pub ssup_cxt: MemoryContext,
    pub ssup_collation: Oid,
    pub ssup_reverse: bool,
    pub ssup_nulls_first: bool,
    pub ssup_attno: AttrNumber,
    pub ssup_extra: *mut ::std::os::raw::c_void,
    pub comparator: ::std::option::Option<
        unsafe extern "C" fn(x: Datum, y: Datum, ssup: SortSupport) -> ::std::os::raw::c_int,
    >,
    pub abbreviate: bool,
    pub abbrev_converter:
        ::std::option::Option<unsafe extern "C" fn(original: Datum, ssup: SortSupport) -> Datum>,
    pub abbrev_abort: ::std::option::Option<
        unsafe extern "C" fn(memtupcount: ::std::os::raw::c_int, ssup: SortSupport) -> bool,
    >,
    pub abbrev_full_comparator: ::std::option::Option<
        unsafe extern "C" fn(x: Datum, y: Datum, ssup: SortSupport) -> ::std::os::raw::c_int,
    >,
}
impl Default for SortSupportData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IndexTupleData {
    pub t_tid: ItemPointerData,
    pub t_info: ::std::os::raw::c_ushort,
}
pub type IndexTuple = *mut IndexTupleData;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IndexAttributeBitMapData {
    pub bits: [bits8; 4usize],
}
pub type IndexAttributeBitMap = *mut IndexAttributeBitMapData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LogicalTapeSet {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LogicalTape {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TapeShare {
    pub firstblocknumber: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Tuplesortstate {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sharedsort {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SortCoordinateData {
    pub isWorker: bool,
    pub nParticipants: ::std::os::raw::c_int,
    pub sharedsort: *mut Sharedsort,
}
impl Default for SortCoordinateData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SortCoordinate = *mut SortCoordinateData;
pub const TuplesortMethod_SORT_TYPE_STILL_IN_PROGRESS: TuplesortMethod = 0;
pub const TuplesortMethod_SORT_TYPE_TOP_N_HEAPSORT: TuplesortMethod = 1;
pub const TuplesortMethod_SORT_TYPE_QUICKSORT: TuplesortMethod = 2;
pub const TuplesortMethod_SORT_TYPE_EXTERNAL_SORT: TuplesortMethod = 4;
pub const TuplesortMethod_SORT_TYPE_EXTERNAL_MERGE: TuplesortMethod = 8;
pub type TuplesortMethod = ::std::os::raw::c_uint;
pub const TuplesortSpaceType_SORT_SPACE_TYPE_DISK: TuplesortSpaceType = 0;
pub const TuplesortSpaceType_SORT_SPACE_TYPE_MEMORY: TuplesortSpaceType = 1;
pub type TuplesortSpaceType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TuplesortInstrumentation {
    pub sortMethod: TuplesortMethod,
    pub spaceType: TuplesortSpaceType,
    pub spaceUsed: int64,
}
impl Default for TuplesortInstrumentation {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SortTuple {
    pub tuple: *mut ::std::os::raw::c_void,
    pub datum1: Datum,
    pub isnull1: bool,
    pub srctape: ::std::os::raw::c_int,
}
impl Default for SortTuple {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SortTupleComparator = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const SortTuple,
        b: *const SortTuple,
        state: *mut Tuplesortstate,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TuplesortPublic {
    pub comparetup: SortTupleComparator,
    pub removeabbrev: ::std::option::Option<
        unsafe extern "C" fn(
            state: *mut Tuplesortstate,
            stups: *mut SortTuple,
            count: ::std::os::raw::c_int,
        ),
    >,
    pub writetup: ::std::option::Option<
        unsafe extern "C" fn(
            state: *mut Tuplesortstate,
            tape: *mut LogicalTape,
            stup: *mut SortTuple,
        ),
    >,
    pub readtup: ::std::option::Option<
        unsafe extern "C" fn(
            state: *mut Tuplesortstate,
            stup: *mut SortTuple,
            tape: *mut LogicalTape,
            len: ::std::os::raw::c_uint,
        ),
    >,
    pub freestate: ::std::option::Option<unsafe extern "C" fn(state: *mut Tuplesortstate)>,
    pub maincontext: MemoryContext,
    pub sortcontext: MemoryContext,
    pub tuplecontext: MemoryContext,
    pub haveDatum1: bool,
    pub nKeys: ::std::os::raw::c_int,
    pub sortKeys: SortSupport,
    pub onlyKey: SortSupport,
    pub sortopt: ::std::os::raw::c_int,
    pub tuples: bool,
    pub arg: *mut ::std::os::raw::c_void,
}
impl Default for TuplesortPublic {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Tuplestorestate {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParallelHashJoinState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CopyMultiInsertBuffer {
    _unused: [u8; 0],
}
pub type ExprStateEvalFunc = ::std::option::Option<
    unsafe extern "C" fn(
        expression: *mut ExprState,
        econtext: *mut ExprContext,
        isNull: *mut bool,
    ) -> Datum,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprState {
    pub type_: NodeTag,
    pub flags: uint8,
    pub resnull: bool,
    pub resvalue: Datum,
    pub resultslot: *mut TupleTableSlot,
    pub steps: *mut ExprEvalStep,
    pub evalfunc: ExprStateEvalFunc,
    pub expr: *mut Expr,
    pub evalfunc_private: *mut ::std::os::raw::c_void,
    pub steps_len: ::std::os::raw::c_int,
    pub steps_alloc: ::std::os::raw::c_int,
    pub parent: *mut PlanState,
    pub ext_params: ParamListInfo,
    pub innermost_caseval: *mut Datum,
    pub innermost_casenull: *mut bool,
    pub innermost_domainval: *mut Datum,
    pub innermost_domainnull: *mut bool,
}
impl Default for ExprState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexInfo {
    pub type_: NodeTag,
    pub ii_NumIndexAttrs: ::std::os::raw::c_int,
    pub ii_NumIndexKeyAttrs: ::std::os::raw::c_int,
    pub ii_IndexAttrNumbers: [AttrNumber; 32usize],
    pub ii_Expressions: *mut List,
    pub ii_ExpressionsState: *mut List,
    pub ii_Predicate: *mut List,
    pub ii_PredicateState: *mut ExprState,
    pub ii_ExclusionOps: *mut Oid,
    pub ii_ExclusionProcs: *mut Oid,
    pub ii_ExclusionStrats: *mut uint16,
    pub ii_UniqueOps: *mut Oid,
    pub ii_UniqueProcs: *mut Oid,
    pub ii_UniqueStrats: *mut uint16,
    pub ii_OpclassOptions: *mut Datum,
    pub ii_Unique: bool,
    pub ii_NullsNotDistinct: bool,
    pub ii_ReadyForInserts: bool,
    pub ii_CheckedUnchanged: bool,
    pub ii_IndexUnchanged: bool,
    pub ii_Concurrent: bool,
    pub ii_BrokenHotChain: bool,
    pub ii_Summarizing: bool,
    pub ii_ParallelWorkers: ::std::os::raw::c_int,
    pub ii_Am: Oid,
    pub ii_AmCache: *mut ::std::os::raw::c_void,
    pub ii_Context: MemoryContext,
}
impl Default for IndexInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ExprContextCallbackFunction = ::std::option::Option<unsafe extern "C" fn(arg: Datum)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprContext_CB {
    pub next: *mut ExprContext_CB,
    pub function: ExprContextCallbackFunction,
    pub arg: Datum,
}
impl Default for ExprContext_CB {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprContext {
    pub type_: NodeTag,
    pub ecxt_scantuple: *mut TupleTableSlot,
    pub ecxt_innertuple: *mut TupleTableSlot,
    pub ecxt_outertuple: *mut TupleTableSlot,
    pub ecxt_per_query_memory: MemoryContext,
    pub ecxt_per_tuple_memory: MemoryContext,
    pub ecxt_param_exec_vals: *mut ParamExecData,
    pub ecxt_param_list_info: ParamListInfo,
    pub ecxt_aggvalues: *mut Datum,
    pub ecxt_aggnulls: *mut bool,
    pub caseValue_datum: Datum,
    pub caseValue_isNull: bool,
    pub domainValue_datum: Datum,
    pub domainValue_isNull: bool,
    pub ecxt_estate: *mut EState,
    pub ecxt_callbacks: *mut ExprContext_CB,
}
impl Default for ExprContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ExprDoneCond_ExprSingleResult: ExprDoneCond = 0;
pub const ExprDoneCond_ExprMultipleResult: ExprDoneCond = 1;
pub const ExprDoneCond_ExprEndResult: ExprDoneCond = 2;
pub type ExprDoneCond = ::std::os::raw::c_uint;
pub const SetFunctionReturnMode_SFRM_ValuePerCall: SetFunctionReturnMode = 1;
pub const SetFunctionReturnMode_SFRM_Materialize: SetFunctionReturnMode = 2;
pub const SetFunctionReturnMode_SFRM_Materialize_Random: SetFunctionReturnMode = 4;
pub const SetFunctionReturnMode_SFRM_Materialize_Preferred: SetFunctionReturnMode = 8;
pub type SetFunctionReturnMode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReturnSetInfo {
    pub type_: NodeTag,
    pub econtext: *mut ExprContext,
    pub expectedDesc: TupleDesc,
    pub allowedModes: ::std::os::raw::c_int,
    pub returnMode: SetFunctionReturnMode,
    pub isDone: ExprDoneCond,
    pub setResult: *mut Tuplestorestate,
    pub setDesc: TupleDesc,
}
impl Default for ReturnSetInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProjectionInfo {
    pub type_: NodeTag,
    pub pi_state: ExprState,
    pub pi_exprContext: *mut ExprContext,
}
impl Default for ProjectionInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JunkFilter {
    pub type_: NodeTag,
    pub jf_targetList: *mut List,
    pub jf_cleanTupType: TupleDesc,
    pub jf_cleanMap: *mut AttrNumber,
    pub jf_resultSlot: *mut TupleTableSlot,
}
impl Default for JunkFilter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OnConflictSetState {
    pub type_: NodeTag,
    pub oc_Existing: *mut TupleTableSlot,
    pub oc_ProjSlot: *mut TupleTableSlot,
    pub oc_ProjInfo: *mut ProjectionInfo,
    pub oc_WhereClause: *mut ExprState,
}
impl Default for OnConflictSetState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeActionState {
    pub type_: NodeTag,
    pub mas_action: *mut MergeAction,
    pub mas_proj: *mut ProjectionInfo,
    pub mas_whenqual: *mut ExprState,
}
impl Default for MergeActionState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResultRelInfo {
    pub type_: NodeTag,
    pub ri_RangeTableIndex: Index,
    pub ri_RelationDesc: Relation,
    pub ri_NumIndices: ::std::os::raw::c_int,
    pub ri_IndexRelationDescs: RelationPtr,
    pub ri_IndexRelationInfo: *mut *mut IndexInfo,
    pub ri_RowIdAttNo: AttrNumber,
    pub ri_extraUpdatedCols: *mut Bitmapset,
    pub ri_projectNew: *mut ProjectionInfo,
    pub ri_newTupleSlot: *mut TupleTableSlot,
    pub ri_oldTupleSlot: *mut TupleTableSlot,
    pub ri_projectNewInfoValid: bool,
    pub ri_TrigDesc: *mut TriggerDesc,
    pub ri_TrigFunctions: *mut FmgrInfo,
    pub ri_TrigWhenExprs: *mut *mut ExprState,
    pub ri_TrigInstrument: *mut Instrumentation,
    pub ri_ReturningSlot: *mut TupleTableSlot,
    pub ri_TrigOldSlot: *mut TupleTableSlot,
    pub ri_TrigNewSlot: *mut TupleTableSlot,
    pub ri_FdwRoutine: *mut FdwRoutine,
    pub ri_FdwState: *mut ::std::os::raw::c_void,
    pub ri_usesFdwDirectModify: bool,
    pub ri_NumSlots: ::std::os::raw::c_int,
    pub ri_NumSlotsInitialized: ::std::os::raw::c_int,
    pub ri_BatchSize: ::std::os::raw::c_int,
    pub ri_Slots: *mut *mut TupleTableSlot,
    pub ri_PlanSlots: *mut *mut TupleTableSlot,
    pub ri_WithCheckOptions: *mut List,
    pub ri_WithCheckOptionExprs: *mut List,
    pub ri_ConstraintExprs: *mut *mut ExprState,
    pub ri_GeneratedExprsI: *mut *mut ExprState,
    pub ri_GeneratedExprsU: *mut *mut ExprState,
    pub ri_NumGeneratedNeededI: ::std::os::raw::c_int,
    pub ri_NumGeneratedNeededU: ::std::os::raw::c_int,
    pub ri_returningList: *mut List,
    pub ri_projectReturning: *mut ProjectionInfo,
    pub ri_onConflictArbiterIndexes: *mut List,
    pub ri_onConflict: *mut OnConflictSetState,
    pub ri_matchedMergeAction: *mut List,
    pub ri_notMatchedMergeAction: *mut List,
    pub ri_PartitionCheckExpr: *mut ExprState,
    pub ri_ChildToRootMap: *mut TupleConversionMap,
    pub ri_ChildToRootMapValid: bool,
    pub ri_RootToChildMap: *mut TupleConversionMap,
    pub ri_RootToChildMapValid: bool,
    pub ri_RootResultRelInfo: *mut ResultRelInfo,
    pub ri_PartitionTupleSlot: *mut TupleTableSlot,
    pub ri_CopyMultiInsertBuffer: *mut CopyMultiInsertBuffer,
    pub ri_ancestorResultRels: *mut List,
}
impl Default for ResultRelInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AsyncRequest {
    pub requestor: *mut PlanState,
    pub requestee: *mut PlanState,
    pub request_index: ::std::os::raw::c_int,
    pub callback_pending: bool,
    pub request_complete: bool,
    pub result: *mut TupleTableSlot,
}
impl Default for AsyncRequest {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EState {
    pub type_: NodeTag,
    pub es_direction: ScanDirection,
    pub es_snapshot: Snapshot,
    pub es_crosscheck_snapshot: Snapshot,
    pub es_range_table: *mut List,
    pub es_range_table_size: Index,
    pub es_relations: *mut Relation,
    pub es_rowmarks: *mut *mut ExecRowMark,
    pub es_rteperminfos: *mut List,
    pub es_plannedstmt: *mut PlannedStmt,
    pub es_sourceText: *const ::std::os::raw::c_char,
    pub es_junkFilter: *mut JunkFilter,
    pub es_output_cid: CommandId,
    pub es_result_relations: *mut *mut ResultRelInfo,
    pub es_opened_result_relations: *mut List,
    pub es_partition_directory: PartitionDirectory,
    pub es_tuple_routing_result_relations: *mut List,
    pub es_trig_target_relations: *mut List,
    pub es_param_list_info: ParamListInfo,
    pub es_param_exec_vals: *mut ParamExecData,
    pub es_queryEnv: *mut QueryEnvironment,
    pub es_query_cxt: MemoryContext,
    pub es_tupleTable: *mut List,
    pub es_processed: uint64,
    pub es_total_processed: uint64,
    pub es_top_eflags: ::std::os::raw::c_int,
    pub es_instrument: ::std::os::raw::c_int,
    pub es_finished: bool,
    pub es_exprcontexts: *mut List,
    pub es_subplanstates: *mut List,
    pub es_auxmodifytables: *mut List,
    pub es_per_tuple_exprcontext: *mut ExprContext,
    pub es_epq_active: *mut EPQState,
    pub es_use_parallel_mode: bool,
    pub es_query_dsa: *mut dsa_area,
    pub es_jit_flags: ::std::os::raw::c_int,
    pub es_jit: *mut JitContext,
    pub es_jit_worker_instr: *mut JitInstrumentation,
    pub es_insert_pending_result_relations: *mut List,
    pub es_insert_pending_modifytables: *mut List,
}
impl Default for EState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExecRowMark {
    pub relation: Relation,
    pub relid: Oid,
    pub rti: Index,
    pub prti: Index,
    pub rowmarkId: Index,
    pub markType: RowMarkType,
    pub strength: LockClauseStrength,
    pub waitPolicy: LockWaitPolicy,
    pub ermActive: bool,
    pub curCtid: ItemPointerData,
    pub ermExtra: *mut ::std::os::raw::c_void,
}
impl Default for ExecRowMark {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExecAuxRowMark {
    pub rowmark: *mut ExecRowMark,
    pub ctidAttNo: AttrNumber,
    pub toidAttNo: AttrNumber,
    pub wholeAttNo: AttrNumber,
}
impl Default for ExecAuxRowMark {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TupleHashEntry = *mut TupleHashEntryData;
pub type TupleHashTable = *mut TupleHashTableData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TupleHashEntryData {
    pub firstTuple: MinimalTuple,
    pub additional: *mut ::std::os::raw::c_void,
    pub status: uint32,
    pub hash: uint32,
}
impl Default for TupleHashEntryData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tuplehash_hash {
    pub size: uint64,
    pub members: uint32,
    pub sizemask: uint32,
    pub grow_threshold: uint32,
    pub data: *mut TupleHashEntryData,
    pub ctx: MemoryContext,
    pub private_data: *mut ::std::os::raw::c_void,
}
impl Default for tuplehash_hash {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const tuplehash_status_tuplehash_SH_EMPTY: tuplehash_status = 0;
pub const tuplehash_status_tuplehash_SH_IN_USE: tuplehash_status = 1;
pub type tuplehash_status = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tuplehash_iterator {
    pub cur: uint32,
    pub end: uint32,
    pub done: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TupleHashTableData {
    pub hashtab: *mut tuplehash_hash,
    pub numCols: ::std::os::raw::c_int,
    pub keyColIdx: *mut AttrNumber,
    pub tab_hash_funcs: *mut FmgrInfo,
    pub tab_eq_func: *mut ExprState,
    pub tab_collations: *mut Oid,
    pub tablecxt: MemoryContext,
    pub tempcxt: MemoryContext,
    pub entrysize: Size,
    pub tableslot: *mut TupleTableSlot,
    pub inputslot: *mut TupleTableSlot,
    pub in_hash_funcs: *mut FmgrInfo,
    pub cur_eq_func: *mut ExprState,
    pub hash_iv: uint32,
    pub exprcontext: *mut ExprContext,
}
impl Default for TupleHashTableData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TupleHashIterator = tuplehash_iterator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowFuncExprState {
    pub type_: NodeTag,
    pub wfunc: *mut WindowFunc,
    pub args: *mut List,
    pub aggfilter: *mut ExprState,
    pub wfuncno: ::std::os::raw::c_int,
}
impl Default for WindowFuncExprState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SetExprState {
    pub type_: NodeTag,
    pub expr: *mut Expr,
    pub args: *mut List,
    pub elidedFuncState: *mut ExprState,
    pub func: FmgrInfo,
    pub funcResultStore: *mut Tuplestorestate,
    pub funcResultSlot: *mut TupleTableSlot,
    pub funcResultDesc: TupleDesc,
    pub funcReturnsTuple: bool,
    pub funcReturnsSet: bool,
    pub setArgsValid: bool,
    pub shutdown_reg: bool,
    pub fcinfo: FunctionCallInfo,
}
impl Default for SetExprState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubPlanState {
    pub type_: NodeTag,
    pub subplan: *mut SubPlan,
    pub planstate: *mut PlanState,
    pub parent: *mut PlanState,
    pub testexpr: *mut ExprState,
    pub args: *mut List,
    pub curTuple: HeapTuple,
    pub curArray: Datum,
    pub descRight: TupleDesc,
    pub projLeft: *mut ProjectionInfo,
    pub projRight: *mut ProjectionInfo,
    pub hashtable: TupleHashTable,
    pub hashnulls: TupleHashTable,
    pub havehashrows: bool,
    pub havenullrows: bool,
    pub hashtablecxt: MemoryContext,
    pub hashtempcxt: MemoryContext,
    pub innerecontext: *mut ExprContext,
    pub numCols: ::std::os::raw::c_int,
    pub keyColIdx: *mut AttrNumber,
    pub tab_eq_funcoids: *mut Oid,
    pub tab_collations: *mut Oid,
    pub tab_hash_funcs: *mut FmgrInfo,
    pub tab_eq_funcs: *mut FmgrInfo,
    pub lhs_hash_funcs: *mut FmgrInfo,
    pub cur_eq_funcs: *mut FmgrInfo,
    pub cur_eq_comp: *mut ExprState,
}
impl Default for SubPlanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const DomainConstraintType_DOM_CONSTRAINT_NOTNULL: DomainConstraintType = 0;
pub const DomainConstraintType_DOM_CONSTRAINT_CHECK: DomainConstraintType = 1;
pub type DomainConstraintType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DomainConstraintState {
    pub type_: NodeTag,
    pub constrainttype: DomainConstraintType,
    pub name: *mut ::std::os::raw::c_char,
    pub check_expr: *mut Expr,
    pub check_exprstate: *mut ExprState,
}
impl Default for DomainConstraintState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ExecProcNodeMtd =
    ::std::option::Option<unsafe extern "C" fn(pstate: *mut PlanState) -> *mut TupleTableSlot>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PlanState {
    pub type_: NodeTag,
    pub plan: *mut Plan,
    pub state: *mut EState,
    pub ExecProcNode: ExecProcNodeMtd,
    pub ExecProcNodeReal: ExecProcNodeMtd,
    pub instrument: *mut Instrumentation,
    pub worker_instrument: *mut WorkerInstrumentation,
    pub worker_jit_instrument: *mut SharedJitInstrumentation,
    pub qual: *mut ExprState,
    pub lefttree: *mut PlanState,
    pub righttree: *mut PlanState,
    pub initPlan: *mut List,
    pub subPlan: *mut List,
    pub chgParam: *mut Bitmapset,
    pub ps_ResultTupleDesc: TupleDesc,
    pub ps_ResultTupleSlot: *mut TupleTableSlot,
    pub ps_ExprContext: *mut ExprContext,
    pub ps_ProjInfo: *mut ProjectionInfo,
    pub async_capable: bool,
    pub scandesc: TupleDesc,
    pub scanops: *const TupleTableSlotOps,
    pub outerops: *const TupleTableSlotOps,
    pub innerops: *const TupleTableSlotOps,
    pub resultops: *const TupleTableSlotOps,
    pub scanopsfixed: bool,
    pub outeropsfixed: bool,
    pub inneropsfixed: bool,
    pub resultopsfixed: bool,
    pub scanopsset: bool,
    pub outeropsset: bool,
    pub inneropsset: bool,
    pub resultopsset: bool,
}
impl Default for PlanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EPQState {
    pub parentestate: *mut EState,
    pub epqParam: ::std::os::raw::c_int,
    pub resultRelations: *mut List,
    pub tuple_table: *mut List,
    pub relsubs_slot: *mut *mut TupleTableSlot,
    pub plan: *mut Plan,
    pub arowMarks: *mut List,
    pub origslot: *mut TupleTableSlot,
    pub recheckestate: *mut EState,
    pub relsubs_rowmark: *mut *mut ExecAuxRowMark,
    pub relsubs_done: *mut bool,
    pub relsubs_blocked: *mut bool,
    pub recheckplanstate: *mut PlanState,
}
impl Default for EPQState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResultState {
    pub ps: PlanState,
    pub resconstantqual: *mut ExprState,
    pub rs_done: bool,
    pub rs_checkqual: bool,
}
impl Default for ResultState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProjectSetState {
    pub ps: PlanState,
    pub elems: *mut *mut Node,
    pub elemdone: *mut ExprDoneCond,
    pub nelems: ::std::os::raw::c_int,
    pub pending_srf_tuples: bool,
    pub argcontext: MemoryContext,
}
impl Default for ProjectSetState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ModifyTableState {
    pub ps: PlanState,
    pub operation: CmdType,
    pub canSetTag: bool,
    pub mt_done: bool,
    pub mt_nrels: ::std::os::raw::c_int,
    pub resultRelInfo: *mut ResultRelInfo,
    pub rootResultRelInfo: *mut ResultRelInfo,
    pub mt_epqstate: EPQState,
    pub fireBSTriggers: bool,
    pub mt_resultOidAttno: ::std::os::raw::c_int,
    pub mt_lastResultOid: Oid,
    pub mt_lastResultIndex: ::std::os::raw::c_int,
    pub mt_resultOidHash: *mut HTAB,
    pub mt_root_tuple_slot: *mut TupleTableSlot,
    pub mt_partition_tuple_routing: *mut PartitionTupleRouting,
    pub mt_transition_capture: *mut TransitionCaptureState,
    pub mt_oc_transition_capture: *mut TransitionCaptureState,
    pub mt_merge_subcommands: ::std::os::raw::c_int,
    pub mt_merge_inserted: f64,
    pub mt_merge_updated: f64,
    pub mt_merge_deleted: f64,
}
impl Default for ModifyTableState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParallelAppendState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionPruneState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AppendState {
    pub ps: PlanState,
    pub appendplans: *mut *mut PlanState,
    pub as_nplans: ::std::os::raw::c_int,
    pub as_whichplan: ::std::os::raw::c_int,
    pub as_begun: bool,
    pub as_asyncplans: *mut Bitmapset,
    pub as_nasyncplans: ::std::os::raw::c_int,
    pub as_asyncrequests: *mut *mut AsyncRequest,
    pub as_asyncresults: *mut *mut TupleTableSlot,
    pub as_nasyncresults: ::std::os::raw::c_int,
    pub as_syncdone: bool,
    pub as_nasyncremain: ::std::os::raw::c_int,
    pub as_needrequest: *mut Bitmapset,
    pub as_eventset: *mut WaitEventSet,
    pub as_first_partial_plan: ::std::os::raw::c_int,
    pub as_pstate: *mut ParallelAppendState,
    pub pstate_len: Size,
    pub as_prune_state: *mut PartitionPruneState,
    pub as_valid_subplans_identified: bool,
    pub as_valid_subplans: *mut Bitmapset,
    pub as_valid_asyncplans: *mut Bitmapset,
    pub choose_next_subplan:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut AppendState) -> bool>,
}
impl Default for AppendState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeAppendState {
    pub ps: PlanState,
    pub mergeplans: *mut *mut PlanState,
    pub ms_nplans: ::std::os::raw::c_int,
    pub ms_nkeys: ::std::os::raw::c_int,
    pub ms_sortkeys: SortSupport,
    pub ms_slots: *mut *mut TupleTableSlot,
    pub ms_heap: *mut binaryheap,
    pub ms_initialized: bool,
    pub ms_prune_state: *mut PartitionPruneState,
    pub ms_valid_subplans: *mut Bitmapset,
}
impl Default for MergeAppendState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RecursiveUnionState {
    pub ps: PlanState,
    pub recursing: bool,
    pub intermediate_empty: bool,
    pub working_table: *mut Tuplestorestate,
    pub intermediate_table: *mut Tuplestorestate,
    pub eqfuncoids: *mut Oid,
    pub hashfunctions: *mut FmgrInfo,
    pub tempContext: MemoryContext,
    pub hashtable: TupleHashTable,
    pub tableContext: MemoryContext,
}
impl Default for RecursiveUnionState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapAndState {
    pub ps: PlanState,
    pub bitmapplans: *mut *mut PlanState,
    pub nplans: ::std::os::raw::c_int,
}
impl Default for BitmapAndState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapOrState {
    pub ps: PlanState,
    pub bitmapplans: *mut *mut PlanState,
    pub nplans: ::std::os::raw::c_int,
}
impl Default for BitmapOrState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScanState {
    pub ps: PlanState,
    pub ss_currentRelation: Relation,
    pub ss_currentScanDesc: *mut TableScanDescData,
    pub ss_ScanTupleSlot: *mut TupleTableSlot,
}
impl Default for ScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SeqScanState {
    pub ss: ScanState,
    pub pscan_len: Size,
}
impl Default for SeqScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SampleScanState {
    pub ss: ScanState,
    pub args: *mut List,
    pub repeatable: *mut ExprState,
    pub tsmroutine: *mut TsmRoutine,
    pub tsm_state: *mut ::std::os::raw::c_void,
    pub use_bulkread: bool,
    pub use_pagemode: bool,
    pub begun: bool,
    pub seed: uint32,
    pub donetuples: int64,
    pub haveblock: bool,
    pub done: bool,
}
impl Default for SampleScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexRuntimeKeyInfo {
    pub scan_key: *mut ScanKeyData,
    pub key_expr: *mut ExprState,
    pub key_toastable: bool,
}
impl Default for IndexRuntimeKeyInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexArrayKeyInfo {
    pub scan_key: *mut ScanKeyData,
    pub array_expr: *mut ExprState,
    pub next_elem: ::std::os::raw::c_int,
    pub num_elems: ::std::os::raw::c_int,
    pub elem_values: *mut Datum,
    pub elem_nulls: *mut bool,
}
impl Default for IndexArrayKeyInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexScanState {
    pub ss: ScanState,
    pub indexqualorig: *mut ExprState,
    pub indexorderbyorig: *mut List,
    pub iss_ScanKeys: *mut ScanKeyData,
    pub iss_NumScanKeys: ::std::os::raw::c_int,
    pub iss_OrderByKeys: *mut ScanKeyData,
    pub iss_NumOrderByKeys: ::std::os::raw::c_int,
    pub iss_RuntimeKeys: *mut IndexRuntimeKeyInfo,
    pub iss_NumRuntimeKeys: ::std::os::raw::c_int,
    pub iss_RuntimeKeysReady: bool,
    pub iss_RuntimeContext: *mut ExprContext,
    pub iss_RelationDesc: Relation,
    pub iss_ScanDesc: *mut IndexScanDescData,
    pub iss_ReorderQueue: *mut pairingheap,
    pub iss_ReachedEnd: bool,
    pub iss_OrderByValues: *mut Datum,
    pub iss_OrderByNulls: *mut bool,
    pub iss_SortSupport: SortSupport,
    pub iss_OrderByTypByVals: *mut bool,
    pub iss_OrderByTypLens: *mut int16,
    pub iss_PscanLen: Size,
}
impl Default for IndexScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexOnlyScanState {
    pub ss: ScanState,
    pub recheckqual: *mut ExprState,
    pub ioss_ScanKeys: *mut ScanKeyData,
    pub ioss_NumScanKeys: ::std::os::raw::c_int,
    pub ioss_OrderByKeys: *mut ScanKeyData,
    pub ioss_NumOrderByKeys: ::std::os::raw::c_int,
    pub ioss_RuntimeKeys: *mut IndexRuntimeKeyInfo,
    pub ioss_NumRuntimeKeys: ::std::os::raw::c_int,
    pub ioss_RuntimeKeysReady: bool,
    pub ioss_RuntimeContext: *mut ExprContext,
    pub ioss_RelationDesc: Relation,
    pub ioss_ScanDesc: *mut IndexScanDescData,
    pub ioss_TableSlot: *mut TupleTableSlot,
    pub ioss_VMBuffer: Buffer,
    pub ioss_PscanLen: Size,
}
impl Default for IndexOnlyScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapIndexScanState {
    pub ss: ScanState,
    pub biss_result: *mut TIDBitmap,
    pub biss_ScanKeys: *mut ScanKeyData,
    pub biss_NumScanKeys: ::std::os::raw::c_int,
    pub biss_RuntimeKeys: *mut IndexRuntimeKeyInfo,
    pub biss_NumRuntimeKeys: ::std::os::raw::c_int,
    pub biss_ArrayKeys: *mut IndexArrayKeyInfo,
    pub biss_NumArrayKeys: ::std::os::raw::c_int,
    pub biss_RuntimeKeysReady: bool,
    pub biss_RuntimeContext: *mut ExprContext,
    pub biss_RelationDesc: Relation,
    pub biss_ScanDesc: *mut IndexScanDescData,
}
impl Default for BitmapIndexScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const SharedBitmapState_BM_INITIAL: SharedBitmapState = 0;
pub const SharedBitmapState_BM_INPROGRESS: SharedBitmapState = 1;
pub const SharedBitmapState_BM_FINISHED: SharedBitmapState = 2;
pub type SharedBitmapState = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct ParallelBitmapHeapState {
    pub tbmiterator: dsa_pointer,
    pub prefetch_iterator: dsa_pointer,
    pub mutex: slock_t,
    pub prefetch_pages: ::std::os::raw::c_int,
    pub prefetch_target: ::std::os::raw::c_int,
    pub state: SharedBitmapState,
    pub cv: ConditionVariable,
    pub phs_snapshot_data: __IncompleteArrayField<::std::os::raw::c_char>,
}
impl Default for ParallelBitmapHeapState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapHeapScanState {
    pub ss: ScanState,
    pub bitmapqualorig: *mut ExprState,
    pub tbm: *mut TIDBitmap,
    pub tbmiterator: *mut TBMIterator,
    pub tbmres: *mut TBMIterateResult,
    pub can_skip_fetch: bool,
    pub return_empty_tuples: ::std::os::raw::c_int,
    pub vmbuffer: Buffer,
    pub pvmbuffer: Buffer,
    pub exact_pages: ::std::os::raw::c_long,
    pub lossy_pages: ::std::os::raw::c_long,
    pub prefetch_iterator: *mut TBMIterator,
    pub prefetch_pages: ::std::os::raw::c_int,
    pub prefetch_target: ::std::os::raw::c_int,
    pub prefetch_maximum: ::std::os::raw::c_int,
    pub pscan_len: Size,
    pub initialized: bool,
    pub shared_tbmiterator: *mut TBMSharedIterator,
    pub shared_prefetch_iterator: *mut TBMSharedIterator,
    pub pstate: *mut ParallelBitmapHeapState,
}
impl Default for BitmapHeapScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TidScanState {
    pub ss: ScanState,
    pub tss_tidexprs: *mut List,
    pub tss_isCurrentOf: bool,
    pub tss_NumTids: ::std::os::raw::c_int,
    pub tss_TidPtr: ::std::os::raw::c_int,
    pub tss_TidList: *mut ItemPointerData,
    pub tss_htup: HeapTupleData,
}
impl Default for TidScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TidRangeScanState {
    pub ss: ScanState,
    pub trss_tidexprs: *mut List,
    pub trss_mintid: ItemPointerData,
    pub trss_maxtid: ItemPointerData,
    pub trss_inScan: bool,
}
impl Default for TidRangeScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubqueryScanState {
    pub ss: ScanState,
    pub subplan: *mut PlanState,
}
impl Default for SubqueryScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FunctionScanPerFuncState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FunctionScanState {
    pub ss: ScanState,
    pub eflags: ::std::os::raw::c_int,
    pub ordinality: bool,
    pub simple: bool,
    pub ordinal: int64,
    pub nfuncs: ::std::os::raw::c_int,
    pub funcstates: *mut FunctionScanPerFuncState,
    pub argcontext: MemoryContext,
}
impl Default for FunctionScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ValuesScanState {
    pub ss: ScanState,
    pub rowcontext: *mut ExprContext,
    pub exprlists: *mut *mut List,
    pub exprstatelists: *mut *mut List,
    pub array_len: ::std::os::raw::c_int,
    pub curr_idx: ::std::os::raw::c_int,
}
impl Default for ValuesScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TableFuncScanState {
    pub ss: ScanState,
    pub docexpr: *mut ExprState,
    pub rowexpr: *mut ExprState,
    pub colexprs: *mut List,
    pub coldefexprs: *mut List,
    pub ns_names: *mut List,
    pub ns_uris: *mut List,
    pub notnulls: *mut Bitmapset,
    pub opaque: *mut ::std::os::raw::c_void,
    pub routine: *mut TableFuncRoutine,
    pub in_functions: *mut FmgrInfo,
    pub typioparams: *mut Oid,
    pub ordinal: int64,
    pub perTableCxt: MemoryContext,
    pub tupstore: *mut Tuplestorestate,
}
impl Default for TableFuncScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CteScanState {
    pub ss: ScanState,
    pub eflags: ::std::os::raw::c_int,
    pub readptr: ::std::os::raw::c_int,
    pub cteplanstate: *mut PlanState,
    pub leader: *mut CteScanState,
    pub cte_table: *mut Tuplestorestate,
    pub eof_cte: bool,
}
impl Default for CteScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NamedTuplestoreScanState {
    pub ss: ScanState,
    pub readptr: ::std::os::raw::c_int,
    pub tupdesc: TupleDesc,
    pub relation: *mut Tuplestorestate,
}
impl Default for NamedTuplestoreScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WorkTableScanState {
    pub ss: ScanState,
    pub rustate: *mut RecursiveUnionState,
}
impl Default for WorkTableScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForeignScanState {
    pub ss: ScanState,
    pub fdw_recheck_quals: *mut ExprState,
    pub pscan_len: Size,
    pub resultRelInfo: *mut ResultRelInfo,
    pub fdwroutine: *mut FdwRoutine,
    pub fdw_state: *mut ::std::os::raw::c_void,
}
impl Default for ForeignScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CustomScanState {
    pub ss: ScanState,
    pub flags: uint32,
    pub custom_ps: *mut List,
    pub pscan_len: Size,
    pub methods: *const CustomExecMethods,
    pub slotOps: *const TupleTableSlotOps,
}
impl Default for CustomScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JoinState {
    pub ps: PlanState,
    pub jointype: JoinType,
    pub single_match: bool,
    pub joinqual: *mut ExprState,
}
impl Default for JoinState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NestLoopState {
    pub js: JoinState,
    pub nl_NeedNewOuter: bool,
    pub nl_MatchedOuter: bool,
    pub nl_NullInnerTupleSlot: *mut TupleTableSlot,
}
impl Default for NestLoopState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeJoinClauseData {
    _unused: [u8; 0],
}
pub type MergeJoinClause = *mut MergeJoinClauseData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeJoinState {
    pub js: JoinState,
    pub mj_NumClauses: ::std::os::raw::c_int,
    pub mj_Clauses: MergeJoinClause,
    pub mj_JoinState: ::std::os::raw::c_int,
    pub mj_SkipMarkRestore: bool,
    pub mj_ExtraMarks: bool,
    pub mj_ConstFalseJoin: bool,
    pub mj_FillOuter: bool,
    pub mj_FillInner: bool,
    pub mj_MatchedOuter: bool,
    pub mj_MatchedInner: bool,
    pub mj_OuterTupleSlot: *mut TupleTableSlot,
    pub mj_InnerTupleSlot: *mut TupleTableSlot,
    pub mj_MarkedTupleSlot: *mut TupleTableSlot,
    pub mj_NullOuterTupleSlot: *mut TupleTableSlot,
    pub mj_NullInnerTupleSlot: *mut TupleTableSlot,
    pub mj_OuterEContext: *mut ExprContext,
    pub mj_InnerEContext: *mut ExprContext,
}
impl Default for MergeJoinState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HashJoinTupleData {
    _unused: [u8; 0],
}
pub type HashJoinTuple = *mut HashJoinTupleData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HashJoinTableData {
    _unused: [u8; 0],
}
pub type HashJoinTable = *mut HashJoinTableData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HashJoinState {
    pub js: JoinState,
    pub hashclauses: *mut ExprState,
    pub hj_OuterHashKeys: *mut List,
    pub hj_HashOperators: *mut List,
    pub hj_Collations: *mut List,
    pub hj_HashTable: HashJoinTable,
    pub hj_CurHashValue: uint32,
    pub hj_CurBucketNo: ::std::os::raw::c_int,
    pub hj_CurSkewBucketNo: ::std::os::raw::c_int,
    pub hj_CurTuple: HashJoinTuple,
    pub hj_OuterTupleSlot: *mut TupleTableSlot,
    pub hj_HashTupleSlot: *mut TupleTableSlot,
    pub hj_NullOuterTupleSlot: *mut TupleTableSlot,
    pub hj_NullInnerTupleSlot: *mut TupleTableSlot,
    pub hj_FirstOuterTupleSlot: *mut TupleTableSlot,
    pub hj_JoinState: ::std::os::raw::c_int,
    pub hj_MatchedOuter: bool,
    pub hj_OuterNotEmpty: bool,
}
impl Default for HashJoinState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MaterialState {
    pub ss: ScanState,
    pub eflags: ::std::os::raw::c_int,
    pub eof_underlying: bool,
    pub tuplestorestate: *mut Tuplestorestate,
}
impl Default for MaterialState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoizeEntry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoizeTuple {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoizeKey {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MemoizeInstrumentation {
    pub cache_hits: uint64,
    pub cache_misses: uint64,
    pub cache_evictions: uint64,
    pub cache_overflows: uint64,
    pub mem_peak: uint64,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct SharedMemoizeInfo {
    pub num_workers: ::std::os::raw::c_int,
    pub sinstrument: __IncompleteArrayField<MemoizeInstrumentation>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoizeState {
    pub ss: ScanState,
    pub mstatus: ::std::os::raw::c_int,
    pub nkeys: ::std::os::raw::c_int,
    pub hashtable: *mut memoize_hash,
    pub hashkeydesc: TupleDesc,
    pub tableslot: *mut TupleTableSlot,
    pub probeslot: *mut TupleTableSlot,
    pub cache_eq_expr: *mut ExprState,
    pub param_exprs: *mut *mut ExprState,
    pub hashfunctions: *mut FmgrInfo,
    pub collations: *mut Oid,
    pub mem_used: uint64,
    pub mem_limit: uint64,
    pub tableContext: MemoryContext,
    pub lru_list: dlist_head,
    pub last_tuple: *mut MemoizeTuple,
    pub entry: *mut MemoizeEntry,
    pub singlerow: bool,
    pub binary_mode: bool,
    pub stats: MemoizeInstrumentation,
    pub shared_info: *mut SharedMemoizeInfo,
    pub keyparamids: *mut Bitmapset,
}
impl Default for MemoizeState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PresortedKeyData {
    pub flinfo: FmgrInfo,
    pub fcinfo: FunctionCallInfo,
    pub attno: OffsetNumber,
}
impl Default for PresortedKeyData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SharedSortInfo {
    pub num_workers: ::std::os::raw::c_int,
    pub sinstrument: __IncompleteArrayField<TuplesortInstrumentation>,
}
impl Default for SharedSortInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SortState {
    pub ss: ScanState,
    pub randomAccess: bool,
    pub bounded: bool,
    pub bound: int64,
    pub sort_Done: bool,
    pub bounded_Done: bool,
    pub bound_Done: int64,
    pub tuplesortstate: *mut ::std::os::raw::c_void,
    pub am_worker: bool,
    pub datumSort: bool,
    pub shared_info: *mut SharedSortInfo,
}
impl Default for SortState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IncrementalSortGroupInfo {
    pub groupCount: int64,
    pub maxDiskSpaceUsed: int64,
    pub totalDiskSpaceUsed: int64,
    pub maxMemorySpaceUsed: int64,
    pub totalMemorySpaceUsed: int64,
    pub sortMethods: bits32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IncrementalSortInfo {
    pub fullsortGroupInfo: IncrementalSortGroupInfo,
    pub prefixsortGroupInfo: IncrementalSortGroupInfo,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct SharedIncrementalSortInfo {
    pub num_workers: ::std::os::raw::c_int,
    pub sinfo: __IncompleteArrayField<IncrementalSortInfo>,
}
pub const IncrementalSortExecutionStatus_INCSORT_LOADFULLSORT: IncrementalSortExecutionStatus = 0;
pub const IncrementalSortExecutionStatus_INCSORT_LOADPREFIXSORT: IncrementalSortExecutionStatus = 1;
pub const IncrementalSortExecutionStatus_INCSORT_READFULLSORT: IncrementalSortExecutionStatus = 2;
pub const IncrementalSortExecutionStatus_INCSORT_READPREFIXSORT: IncrementalSortExecutionStatus = 3;
pub type IncrementalSortExecutionStatus = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IncrementalSortState {
    pub ss: ScanState,
    pub bounded: bool,
    pub bound: int64,
    pub outerNodeDone: bool,
    pub bound_Done: int64,
    pub execution_status: IncrementalSortExecutionStatus,
    pub n_fullsort_remaining: int64,
    pub fullsort_state: *mut Tuplesortstate,
    pub prefixsort_state: *mut Tuplesortstate,
    pub presorted_keys: *mut PresortedKeyData,
    pub incsort_info: IncrementalSortInfo,
    pub group_pivot: *mut TupleTableSlot,
    pub transfer_tuple: *mut TupleTableSlot,
    pub am_worker: bool,
    pub shared_info: *mut SharedIncrementalSortInfo,
}
impl Default for IncrementalSortState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GroupState {
    pub ss: ScanState,
    pub eqfunction: *mut ExprState,
    pub grp_done: bool,
}
impl Default for GroupState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AggregateInstrumentation {
    pub hash_mem_peak: Size,
    pub hash_disk_used: uint64,
    pub hash_batches_used: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct SharedAggInfo {
    pub num_workers: ::std::os::raw::c_int,
    pub sinstrument: __IncompleteArrayField<AggregateInstrumentation>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggStatePerAggData {
    _unused: [u8; 0],
}
pub type AggStatePerAgg = *mut AggStatePerAggData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggStatePerTransData {
    _unused: [u8; 0],
}
pub type AggStatePerTrans = *mut AggStatePerTransData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggStatePerGroupData {
    _unused: [u8; 0],
}
pub type AggStatePerGroup = *mut AggStatePerGroupData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggStatePerPhaseData {
    _unused: [u8; 0],
}
pub type AggStatePerPhase = *mut AggStatePerPhaseData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggStatePerHashData {
    _unused: [u8; 0],
}
pub type AggStatePerHash = *mut AggStatePerHashData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggState {
    pub ss: ScanState,
    pub aggs: *mut List,
    pub numaggs: ::std::os::raw::c_int,
    pub numtrans: ::std::os::raw::c_int,
    pub aggstrategy: AggStrategy,
    pub aggsplit: AggSplit,
    pub phase: AggStatePerPhase,
    pub numphases: ::std::os::raw::c_int,
    pub current_phase: ::std::os::raw::c_int,
    pub peragg: AggStatePerAgg,
    pub pertrans: AggStatePerTrans,
    pub hashcontext: *mut ExprContext,
    pub aggcontexts: *mut *mut ExprContext,
    pub tmpcontext: *mut ExprContext,
    pub curaggcontext: *mut ExprContext,
    pub curperagg: AggStatePerAgg,
    pub curpertrans: AggStatePerTrans,
    pub input_done: bool,
    pub agg_done: bool,
    pub projected_set: ::std::os::raw::c_int,
    pub current_set: ::std::os::raw::c_int,
    pub grouped_cols: *mut Bitmapset,
    pub all_grouped_cols: *mut List,
    pub colnos_needed: *mut Bitmapset,
    pub max_colno_needed: ::std::os::raw::c_int,
    pub all_cols_needed: bool,
    pub maxsets: ::std::os::raw::c_int,
    pub phases: AggStatePerPhase,
    pub sort_in: *mut Tuplesortstate,
    pub sort_out: *mut Tuplesortstate,
    pub sort_slot: *mut TupleTableSlot,
    pub pergroups: *mut AggStatePerGroup,
    pub grp_firstTuple: HeapTuple,
    pub table_filled: bool,
    pub num_hashes: ::std::os::raw::c_int,
    pub hash_metacxt: MemoryContext,
    pub hash_tapeset: *mut LogicalTapeSet,
    pub hash_spills: *mut HashAggSpill,
    pub hash_spill_rslot: *mut TupleTableSlot,
    pub hash_spill_wslot: *mut TupleTableSlot,
    pub hash_batches: *mut List,
    pub hash_ever_spilled: bool,
    pub hash_spill_mode: bool,
    pub hash_mem_limit: Size,
    pub hash_ngroups_limit: uint64,
    pub hash_planned_partitions: ::std::os::raw::c_int,
    pub hashentrysize: f64,
    pub hash_mem_peak: Size,
    pub hash_ngroups_current: uint64,
    pub hash_disk_used: uint64,
    pub hash_batches_used: ::std::os::raw::c_int,
    pub perhash: AggStatePerHash,
    pub hash_pergroup: *mut AggStatePerGroup,
    pub all_pergroups: *mut AggStatePerGroup,
    pub combinedproj: *mut ProjectionInfo,
    pub shared_info: *mut SharedAggInfo,
}
impl Default for AggState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowStatePerFuncData {
    _unused: [u8; 0],
}
pub type WindowStatePerFunc = *mut WindowStatePerFuncData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowStatePerAggData {
    _unused: [u8; 0],
}
pub type WindowStatePerAgg = *mut WindowStatePerAggData;
pub const WindowAggStatus_WINDOWAGG_DONE: WindowAggStatus = 0;
pub const WindowAggStatus_WINDOWAGG_RUN: WindowAggStatus = 1;
pub const WindowAggStatus_WINDOWAGG_PASSTHROUGH: WindowAggStatus = 2;
pub const WindowAggStatus_WINDOWAGG_PASSTHROUGH_STRICT: WindowAggStatus = 3;
pub type WindowAggStatus = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowAggState {
    pub ss: ScanState,
    pub funcs: *mut List,
    pub numfuncs: ::std::os::raw::c_int,
    pub numaggs: ::std::os::raw::c_int,
    pub perfunc: WindowStatePerFunc,
    pub peragg: WindowStatePerAgg,
    pub partEqfunction: *mut ExprState,
    pub ordEqfunction: *mut ExprState,
    pub buffer: *mut Tuplestorestate,
    pub current_ptr: ::std::os::raw::c_int,
    pub framehead_ptr: ::std::os::raw::c_int,
    pub frametail_ptr: ::std::os::raw::c_int,
    pub grouptail_ptr: ::std::os::raw::c_int,
    pub spooled_rows: int64,
    pub currentpos: int64,
    pub frameheadpos: int64,
    pub frametailpos: int64,
    pub agg_winobj: *mut WindowObjectData,
    pub aggregatedbase: int64,
    pub aggregatedupto: int64,
    pub status: WindowAggStatus,
    pub frameOptions: ::std::os::raw::c_int,
    pub startOffset: *mut ExprState,
    pub endOffset: *mut ExprState,
    pub startOffsetValue: Datum,
    pub endOffsetValue: Datum,
    pub startInRangeFunc: FmgrInfo,
    pub endInRangeFunc: FmgrInfo,
    pub inRangeColl: Oid,
    pub inRangeAsc: bool,
    pub inRangeNullsFirst: bool,
    pub currentgroup: int64,
    pub frameheadgroup: int64,
    pub frametailgroup: int64,
    pub groupheadpos: int64,
    pub grouptailpos: int64,
    pub partcontext: MemoryContext,
    pub aggcontext: MemoryContext,
    pub curaggcontext: MemoryContext,
    pub tmpcontext: *mut ExprContext,
    pub runcondition: *mut ExprState,
    pub use_pass_through: bool,
    pub top_window: bool,
    pub all_first: bool,
    pub partition_spooled: bool,
    pub more_partitions: bool,
    pub framehead_valid: bool,
    pub frametail_valid: bool,
    pub grouptail_valid: bool,
    pub first_part_slot: *mut TupleTableSlot,
    pub framehead_slot: *mut TupleTableSlot,
    pub frametail_slot: *mut TupleTableSlot,
    pub agg_row_slot: *mut TupleTableSlot,
    pub temp_slot_1: *mut TupleTableSlot,
    pub temp_slot_2: *mut TupleTableSlot,
}
impl Default for WindowAggState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UniqueState {
    pub ps: PlanState,
    pub eqfunction: *mut ExprState,
}
impl Default for UniqueState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GatherState {
    pub ps: PlanState,
    pub initialized: bool,
    pub need_to_scan_locally: bool,
    pub tuples_needed: int64,
    pub funnel_slot: *mut TupleTableSlot,
    pub pei: *mut ParallelExecutorInfo,
    pub nworkers_launched: ::std::os::raw::c_int,
    pub nreaders: ::std::os::raw::c_int,
    pub nextreader: ::std::os::raw::c_int,
    pub reader: *mut *mut TupleQueueReader,
}
impl Default for GatherState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GMReaderTupleBuffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GatherMergeState {
    pub ps: PlanState,
    pub initialized: bool,
    pub gm_initialized: bool,
    pub need_to_scan_locally: bool,
    pub tuples_needed: int64,
    pub tupDesc: TupleDesc,
    pub gm_nkeys: ::std::os::raw::c_int,
    pub gm_sortkeys: SortSupport,
    pub pei: *mut ParallelExecutorInfo,
    pub nworkers_launched: ::std::os::raw::c_int,
    pub nreaders: ::std::os::raw::c_int,
    pub gm_slots: *mut *mut TupleTableSlot,
    pub reader: *mut *mut TupleQueueReader,
    pub gm_tuple_buffers: *mut GMReaderTupleBuffer,
    pub gm_heap: *mut binaryheap,
}
impl Default for GatherMergeState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HashInstrumentation {
    pub nbuckets: ::std::os::raw::c_int,
    pub nbuckets_original: ::std::os::raw::c_int,
    pub nbatch: ::std::os::raw::c_int,
    pub nbatch_original: ::std::os::raw::c_int,
    pub space_peak: Size,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct SharedHashInfo {
    pub num_workers: ::std::os::raw::c_int,
    pub hinstrument: __IncompleteArrayField<HashInstrumentation>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HashState {
    pub ps: PlanState,
    pub hashtable: HashJoinTable,
    pub hashkeys: *mut List,
    pub shared_info: *mut SharedHashInfo,
    pub hinstrument: *mut HashInstrumentation,
    pub parallel_state: *mut ParallelHashJoinState,
}
impl Default for HashState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SetOpStatePerGroupData {
    _unused: [u8; 0],
}
pub type SetOpStatePerGroup = *mut SetOpStatePerGroupData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SetOpState {
    pub ps: PlanState,
    pub eqfunction: *mut ExprState,
    pub eqfuncoids: *mut Oid,
    pub hashfunctions: *mut FmgrInfo,
    pub setop_done: bool,
    pub numOutput: ::std::os::raw::c_long,
    pub pergroup: SetOpStatePerGroup,
    pub grp_firstTuple: HeapTuple,
    pub hashtable: TupleHashTable,
    pub tableContext: MemoryContext,
    pub table_filled: bool,
    pub hashiter: TupleHashIterator,
}
impl Default for SetOpState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LockRowsState {
    pub ps: PlanState,
    pub lr_arowMarks: *mut List,
    pub lr_epqstate: EPQState,
}
impl Default for LockRowsState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const LimitStateCond_LIMIT_INITIAL: LimitStateCond = 0;
pub const LimitStateCond_LIMIT_RESCAN: LimitStateCond = 1;
pub const LimitStateCond_LIMIT_EMPTY: LimitStateCond = 2;
pub const LimitStateCond_LIMIT_INWINDOW: LimitStateCond = 3;
pub const LimitStateCond_LIMIT_WINDOWEND_TIES: LimitStateCond = 4;
pub const LimitStateCond_LIMIT_SUBPLANEOF: LimitStateCond = 5;
pub const LimitStateCond_LIMIT_WINDOWEND: LimitStateCond = 6;
pub const LimitStateCond_LIMIT_WINDOWSTART: LimitStateCond = 7;
pub type LimitStateCond = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LimitState {
    pub ps: PlanState,
    pub limitOffset: *mut ExprState,
    pub limitCount: *mut ExprState,
    pub limitOption: LimitOption,
    pub offset: int64,
    pub count: int64,
    pub noCount: bool,
    pub lstate: LimitStateCond,
    pub position: int64,
    pub subSlot: *mut TupleTableSlot,
    pub eqfunction: *mut ExprState,
    pub last_slot: *mut TupleTableSlot,
}
impl Default for LimitState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const CommandTag_CMDTAG_UNKNOWN: CommandTag = 0;
pub const CommandTag_CMDTAG_ALTER_ACCESS_METHOD: CommandTag = 1;
pub const CommandTag_CMDTAG_ALTER_AGGREGATE: CommandTag = 2;
pub const CommandTag_CMDTAG_ALTER_CAST: CommandTag = 3;
pub const CommandTag_CMDTAG_ALTER_COLLATION: CommandTag = 4;
pub const CommandTag_CMDTAG_ALTER_CONSTRAINT: CommandTag = 5;
pub const CommandTag_CMDTAG_ALTER_CONVERSION: CommandTag = 6;
pub const CommandTag_CMDTAG_ALTER_DATABASE: CommandTag = 7;
pub const CommandTag_CMDTAG_ALTER_DEFAULT_PRIVILEGES: CommandTag = 8;
pub const CommandTag_CMDTAG_ALTER_DOMAIN: CommandTag = 9;
pub const CommandTag_CMDTAG_ALTER_EVENT_TRIGGER: CommandTag = 10;
pub const CommandTag_CMDTAG_ALTER_EXTENSION: CommandTag = 11;
pub const CommandTag_CMDTAG_ALTER_FOREIGN_DATA_WRAPPER: CommandTag = 12;
pub const CommandTag_CMDTAG_ALTER_FOREIGN_TABLE: CommandTag = 13;
pub const CommandTag_CMDTAG_ALTER_FUNCTION: CommandTag = 14;
pub const CommandTag_CMDTAG_ALTER_INDEX: CommandTag = 15;
pub const CommandTag_CMDTAG_ALTER_LANGUAGE: CommandTag = 16;
pub const CommandTag_CMDTAG_ALTER_LARGE_OBJECT: CommandTag = 17;
pub const CommandTag_CMDTAG_ALTER_MATERIALIZED_VIEW: CommandTag = 18;
pub const CommandTag_CMDTAG_ALTER_OPERATOR: CommandTag = 19;
pub const CommandTag_CMDTAG_ALTER_OPERATOR_CLASS: CommandTag = 20;
pub const CommandTag_CMDTAG_ALTER_OPERATOR_FAMILY: CommandTag = 21;
pub const CommandTag_CMDTAG_ALTER_POLICY: CommandTag = 22;
pub const CommandTag_CMDTAG_ALTER_PROCEDURE: CommandTag = 23;
pub const CommandTag_CMDTAG_ALTER_PUBLICATION: CommandTag = 24;
pub const CommandTag_CMDTAG_ALTER_ROLE: CommandTag = 25;
pub const CommandTag_CMDTAG_ALTER_ROUTINE: CommandTag = 26;
pub const CommandTag_CMDTAG_ALTER_RULE: CommandTag = 27;
pub const CommandTag_CMDTAG_ALTER_SCHEMA: CommandTag = 28;
pub const CommandTag_CMDTAG_ALTER_SEQUENCE: CommandTag = 29;
pub const CommandTag_CMDTAG_ALTER_SERVER: CommandTag = 30;
pub const CommandTag_CMDTAG_ALTER_STATISTICS: CommandTag = 31;
pub const CommandTag_CMDTAG_ALTER_SUBSCRIPTION: CommandTag = 32;
pub const CommandTag_CMDTAG_ALTER_SYSTEM: CommandTag = 33;
pub const CommandTag_CMDTAG_ALTER_TABLE: CommandTag = 34;
pub const CommandTag_CMDTAG_ALTER_TABLESPACE: CommandTag = 35;
pub const CommandTag_CMDTAG_ALTER_TEXT_SEARCH_CONFIGURATION: CommandTag = 36;
pub const CommandTag_CMDTAG_ALTER_TEXT_SEARCH_DICTIONARY: CommandTag = 37;
pub const CommandTag_CMDTAG_ALTER_TEXT_SEARCH_PARSER: CommandTag = 38;
pub const CommandTag_CMDTAG_ALTER_TEXT_SEARCH_TEMPLATE: CommandTag = 39;
pub const CommandTag_CMDTAG_ALTER_TRANSFORM: CommandTag = 40;
pub const CommandTag_CMDTAG_ALTER_TRIGGER: CommandTag = 41;
pub const CommandTag_CMDTAG_ALTER_TYPE: CommandTag = 42;
pub const CommandTag_CMDTAG_ALTER_USER_MAPPING: CommandTag = 43;
pub const CommandTag_CMDTAG_ALTER_VIEW: CommandTag = 44;
pub const CommandTag_CMDTAG_ANALYZE: CommandTag = 45;
pub const CommandTag_CMDTAG_BEGIN: CommandTag = 46;
pub const CommandTag_CMDTAG_CALL: CommandTag = 47;
pub const CommandTag_CMDTAG_CHECKPOINT: CommandTag = 48;
pub const CommandTag_CMDTAG_CLOSE: CommandTag = 49;
pub const CommandTag_CMDTAG_CLOSE_CURSOR: CommandTag = 50;
pub const CommandTag_CMDTAG_CLOSE_CURSOR_ALL: CommandTag = 51;
pub const CommandTag_CMDTAG_CLUSTER: CommandTag = 52;
pub const CommandTag_CMDTAG_COMMENT: CommandTag = 53;
pub const CommandTag_CMDTAG_COMMIT: CommandTag = 54;
pub const CommandTag_CMDTAG_COMMIT_PREPARED: CommandTag = 55;
pub const CommandTag_CMDTAG_COPY: CommandTag = 56;
pub const CommandTag_CMDTAG_COPY_FROM: CommandTag = 57;
pub const CommandTag_CMDTAG_CREATE_ACCESS_METHOD: CommandTag = 58;
pub const CommandTag_CMDTAG_CREATE_AGGREGATE: CommandTag = 59;
pub const CommandTag_CMDTAG_CREATE_CAST: CommandTag = 60;
pub const CommandTag_CMDTAG_CREATE_COLLATION: CommandTag = 61;
pub const CommandTag_CMDTAG_CREATE_CONSTRAINT: CommandTag = 62;
pub const CommandTag_CMDTAG_CREATE_CONVERSION: CommandTag = 63;
pub const CommandTag_CMDTAG_CREATE_DATABASE: CommandTag = 64;
pub const CommandTag_CMDTAG_CREATE_DOMAIN: CommandTag = 65;
pub const CommandTag_CMDTAG_CREATE_EVENT_TRIGGER: CommandTag = 66;
pub const CommandTag_CMDTAG_CREATE_EXTENSION: CommandTag = 67;
pub const CommandTag_CMDTAG_CREATE_FOREIGN_DATA_WRAPPER: CommandTag = 68;
pub const CommandTag_CMDTAG_CREATE_FOREIGN_TABLE: CommandTag = 69;
pub const CommandTag_CMDTAG_CREATE_FUNCTION: CommandTag = 70;
pub const CommandTag_CMDTAG_CREATE_INDEX: CommandTag = 71;
pub const CommandTag_CMDTAG_CREATE_LANGUAGE: CommandTag = 72;
pub const CommandTag_CMDTAG_CREATE_MATERIALIZED_VIEW: CommandTag = 73;
pub const CommandTag_CMDTAG_CREATE_OPERATOR: CommandTag = 74;
pub const CommandTag_CMDTAG_CREATE_OPERATOR_CLASS: CommandTag = 75;
pub const CommandTag_CMDTAG_CREATE_OPERATOR_FAMILY: CommandTag = 76;
pub const CommandTag_CMDTAG_CREATE_POLICY: CommandTag = 77;
pub const CommandTag_CMDTAG_CREATE_PROCEDURE: CommandTag = 78;
pub const CommandTag_CMDTAG_CREATE_PUBLICATION: CommandTag = 79;
pub const CommandTag_CMDTAG_CREATE_ROLE: CommandTag = 80;
pub const CommandTag_CMDTAG_CREATE_ROUTINE: CommandTag = 81;
pub const CommandTag_CMDTAG_CREATE_RULE: CommandTag = 82;
pub const CommandTag_CMDTAG_CREATE_SCHEMA: CommandTag = 83;
pub const CommandTag_CMDTAG_CREATE_SEQUENCE: CommandTag = 84;
pub const CommandTag_CMDTAG_CREATE_SERVER: CommandTag = 85;
pub const CommandTag_CMDTAG_CREATE_STATISTICS: CommandTag = 86;
pub const CommandTag_CMDTAG_CREATE_SUBSCRIPTION: CommandTag = 87;
pub const CommandTag_CMDTAG_CREATE_TABLE: CommandTag = 88;
pub const CommandTag_CMDTAG_CREATE_TABLE_AS: CommandTag = 89;
pub const CommandTag_CMDTAG_CREATE_TABLESPACE: CommandTag = 90;
pub const CommandTag_CMDTAG_CREATE_TEXT_SEARCH_CONFIGURATION: CommandTag = 91;
pub const CommandTag_CMDTAG_CREATE_TEXT_SEARCH_DICTIONARY: CommandTag = 92;
pub const CommandTag_CMDTAG_CREATE_TEXT_SEARCH_PARSER: CommandTag = 93;
pub const CommandTag_CMDTAG_CREATE_TEXT_SEARCH_TEMPLATE: CommandTag = 94;
pub const CommandTag_CMDTAG_CREATE_TRANSFORM: CommandTag = 95;
pub const CommandTag_CMDTAG_CREATE_TRIGGER: CommandTag = 96;
pub const CommandTag_CMDTAG_CREATE_TYPE: CommandTag = 97;
pub const CommandTag_CMDTAG_CREATE_USER_MAPPING: CommandTag = 98;
pub const CommandTag_CMDTAG_CREATE_VIEW: CommandTag = 99;
pub const CommandTag_CMDTAG_DEALLOCATE: CommandTag = 100;
pub const CommandTag_CMDTAG_DEALLOCATE_ALL: CommandTag = 101;
pub const CommandTag_CMDTAG_DECLARE_CURSOR: CommandTag = 102;
pub const CommandTag_CMDTAG_DELETE: CommandTag = 103;
pub const CommandTag_CMDTAG_DISCARD: CommandTag = 104;
pub const CommandTag_CMDTAG_DISCARD_ALL: CommandTag = 105;
pub const CommandTag_CMDTAG_DISCARD_PLANS: CommandTag = 106;
pub const CommandTag_CMDTAG_DISCARD_SEQUENCES: CommandTag = 107;
pub const CommandTag_CMDTAG_DISCARD_TEMP: CommandTag = 108;
pub const CommandTag_CMDTAG_DO: CommandTag = 109;
pub const CommandTag_CMDTAG_DROP_ACCESS_METHOD: CommandTag = 110;
pub const CommandTag_CMDTAG_DROP_AGGREGATE: CommandTag = 111;
pub const CommandTag_CMDTAG_DROP_CAST: CommandTag = 112;
pub const CommandTag_CMDTAG_DROP_COLLATION: CommandTag = 113;
pub const CommandTag_CMDTAG_DROP_CONSTRAINT: CommandTag = 114;
pub const CommandTag_CMDTAG_DROP_CONVERSION: CommandTag = 115;
pub const CommandTag_CMDTAG_DROP_DATABASE: CommandTag = 116;
pub const CommandTag_CMDTAG_DROP_DOMAIN: CommandTag = 117;
pub const CommandTag_CMDTAG_DROP_EVENT_TRIGGER: CommandTag = 118;
pub const CommandTag_CMDTAG_DROP_EXTENSION: CommandTag = 119;
pub const CommandTag_CMDTAG_DROP_FOREIGN_DATA_WRAPPER: CommandTag = 120;
pub const CommandTag_CMDTAG_DROP_FOREIGN_TABLE: CommandTag = 121;
pub const CommandTag_CMDTAG_DROP_FUNCTION: CommandTag = 122;
pub const CommandTag_CMDTAG_DROP_INDEX: CommandTag = 123;
pub const CommandTag_CMDTAG_DROP_LANGUAGE: CommandTag = 124;
pub const CommandTag_CMDTAG_DROP_MATERIALIZED_VIEW: CommandTag = 125;
pub const CommandTag_CMDTAG_DROP_OPERATOR: CommandTag = 126;
pub const CommandTag_CMDTAG_DROP_OPERATOR_CLASS: CommandTag = 127;
pub const CommandTag_CMDTAG_DROP_OPERATOR_FAMILY: CommandTag = 128;
pub const CommandTag_CMDTAG_DROP_OWNED: CommandTag = 129;
pub const CommandTag_CMDTAG_DROP_POLICY: CommandTag = 130;
pub const CommandTag_CMDTAG_DROP_PROCEDURE: CommandTag = 131;
pub const CommandTag_CMDTAG_DROP_PUBLICATION: CommandTag = 132;
pub const CommandTag_CMDTAG_DROP_ROLE: CommandTag = 133;
pub const CommandTag_CMDTAG_DROP_ROUTINE: CommandTag = 134;
pub const CommandTag_CMDTAG_DROP_RULE: CommandTag = 135;
pub const CommandTag_CMDTAG_DROP_SCHEMA: CommandTag = 136;
pub const CommandTag_CMDTAG_DROP_SEQUENCE: CommandTag = 137;
pub const CommandTag_CMDTAG_DROP_SERVER: CommandTag = 138;
pub const CommandTag_CMDTAG_DROP_STATISTICS: CommandTag = 139;
pub const CommandTag_CMDTAG_DROP_SUBSCRIPTION: CommandTag = 140;
pub const CommandTag_CMDTAG_DROP_TABLE: CommandTag = 141;
pub const CommandTag_CMDTAG_DROP_TABLESPACE: CommandTag = 142;
pub const CommandTag_CMDTAG_DROP_TEXT_SEARCH_CONFIGURATION: CommandTag = 143;
pub const CommandTag_CMDTAG_DROP_TEXT_SEARCH_DICTIONARY: CommandTag = 144;
pub const CommandTag_CMDTAG_DROP_TEXT_SEARCH_PARSER: CommandTag = 145;
pub const CommandTag_CMDTAG_DROP_TEXT_SEARCH_TEMPLATE: CommandTag = 146;
pub const CommandTag_CMDTAG_DROP_TRANSFORM: CommandTag = 147;
pub const CommandTag_CMDTAG_DROP_TRIGGER: CommandTag = 148;
pub const CommandTag_CMDTAG_DROP_TYPE: CommandTag = 149;
pub const CommandTag_CMDTAG_DROP_USER_MAPPING: CommandTag = 150;
pub const CommandTag_CMDTAG_DROP_VIEW: CommandTag = 151;
pub const CommandTag_CMDTAG_EXECUTE: CommandTag = 152;
pub const CommandTag_CMDTAG_EXPLAIN: CommandTag = 153;
pub const CommandTag_CMDTAG_FETCH: CommandTag = 154;
pub const CommandTag_CMDTAG_GRANT: CommandTag = 155;
pub const CommandTag_CMDTAG_GRANT_ROLE: CommandTag = 156;
pub const CommandTag_CMDTAG_IMPORT_FOREIGN_SCHEMA: CommandTag = 157;
pub const CommandTag_CMDTAG_INSERT: CommandTag = 158;
pub const CommandTag_CMDTAG_LISTEN: CommandTag = 159;
pub const CommandTag_CMDTAG_LOAD: CommandTag = 160;
pub const CommandTag_CMDTAG_LOCK_TABLE: CommandTag = 161;
pub const CommandTag_CMDTAG_MERGE: CommandTag = 162;
pub const CommandTag_CMDTAG_MOVE: CommandTag = 163;
pub const CommandTag_CMDTAG_NOTIFY: CommandTag = 164;
pub const CommandTag_CMDTAG_PREPARE: CommandTag = 165;
pub const CommandTag_CMDTAG_PREPARE_TRANSACTION: CommandTag = 166;
pub const CommandTag_CMDTAG_REASSIGN_OWNED: CommandTag = 167;
pub const CommandTag_CMDTAG_REFRESH_MATERIALIZED_VIEW: CommandTag = 168;
pub const CommandTag_CMDTAG_REINDEX: CommandTag = 169;
pub const CommandTag_CMDTAG_RELEASE: CommandTag = 170;
pub const CommandTag_CMDTAG_RESET: CommandTag = 171;
pub const CommandTag_CMDTAG_REVOKE: CommandTag = 172;
pub const CommandTag_CMDTAG_REVOKE_ROLE: CommandTag = 173;
pub const CommandTag_CMDTAG_ROLLBACK: CommandTag = 174;
pub const CommandTag_CMDTAG_ROLLBACK_PREPARED: CommandTag = 175;
pub const CommandTag_CMDTAG_SAVEPOINT: CommandTag = 176;
pub const CommandTag_CMDTAG_SECURITY_LABEL: CommandTag = 177;
pub const CommandTag_CMDTAG_SELECT: CommandTag = 178;
pub const CommandTag_CMDTAG_SELECT_FOR_KEY_SHARE: CommandTag = 179;
pub const CommandTag_CMDTAG_SELECT_FOR_NO_KEY_UPDATE: CommandTag = 180;
pub const CommandTag_CMDTAG_SELECT_FOR_SHARE: CommandTag = 181;
pub const CommandTag_CMDTAG_SELECT_FOR_UPDATE: CommandTag = 182;
pub const CommandTag_CMDTAG_SELECT_INTO: CommandTag = 183;
pub const CommandTag_CMDTAG_SET: CommandTag = 184;
pub const CommandTag_CMDTAG_SET_CONSTRAINTS: CommandTag = 185;
pub const CommandTag_CMDTAG_SHOW: CommandTag = 186;
pub const CommandTag_CMDTAG_START_TRANSACTION: CommandTag = 187;
pub const CommandTag_CMDTAG_TRUNCATE_TABLE: CommandTag = 188;
pub const CommandTag_CMDTAG_UNLISTEN: CommandTag = 189;
pub const CommandTag_CMDTAG_UPDATE: CommandTag = 190;
pub const CommandTag_CMDTAG_VACUUM: CommandTag = 191;
pub const CommandTag_COMMAND_TAG_NEXTTAG: CommandTag = 192;
pub type CommandTag = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueryCompletion {
    pub commandTag: CommandTag,
    pub nprocessed: uint64,
}
impl Default for QueryCompletion {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const CommandDest_DestNone: CommandDest = 0;
pub const CommandDest_DestDebug: CommandDest = 1;
pub const CommandDest_DestRemote: CommandDest = 2;
pub const CommandDest_DestRemoteExecute: CommandDest = 3;
pub const CommandDest_DestRemoteSimple: CommandDest = 4;
pub const CommandDest_DestSPI: CommandDest = 5;
pub const CommandDest_DestTuplestore: CommandDest = 6;
pub const CommandDest_DestIntoRel: CommandDest = 7;
pub const CommandDest_DestCopyOut: CommandDest = 8;
pub const CommandDest_DestSQLFunction: CommandDest = 9;
pub const CommandDest_DestTransientRel: CommandDest = 10;
pub const CommandDest_DestTupleQueue: CommandDest = 11;
pub type CommandDest = ::std::os::raw::c_uint;
pub type DestReceiver = _DestReceiver;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DestReceiver {
    pub receiveSlot: ::std::option::Option<
        unsafe extern "C" fn(slot: *mut TupleTableSlot, self_: *mut DestReceiver) -> bool,
    >,
    pub rStartup: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut DestReceiver,
            operation: ::std::os::raw::c_int,
            typeinfo: TupleDesc,
        ),
    >,
    pub rShutdown: ::std::option::Option<unsafe extern "C" fn(self_: *mut DestReceiver)>,
    pub rDestroy: ::std::option::Option<unsafe extern "C" fn(self_: *mut DestReceiver)>,
    pub mydest: CommandDest,
}
impl Default for _DestReceiver {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueryDesc {
    pub operation: CmdType,
    pub plannedstmt: *mut PlannedStmt,
    pub sourceText: *const ::std::os::raw::c_char,
    pub snapshot: Snapshot,
    pub crosscheck_snapshot: Snapshot,
    pub dest: *mut DestReceiver,
    pub params: ParamListInfo,
    pub queryEnv: *mut QueryEnvironment,
    pub instrument_options: ::std::os::raw::c_int,
    pub tupDesc: TupleDesc,
    pub estate: *mut EState,
    pub planstate: *mut PlanState,
    pub already_executed: bool,
    pub totaltime: *mut Instrumentation,
}
impl Default for QueryDesc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MemoryContextCounters {
    pub nblocks: Size,
    pub freechunks: Size,
    pub totalspace: Size,
    pub freespace: Size,
}
pub type MemoryStatsPrintFunc = ::std::option::Option<
    unsafe extern "C" fn(
        context: MemoryContext,
        passthru: *mut ::std::os::raw::c_void,
        stats_string: *const ::std::os::raw::c_char,
        print_to_stderr: bool,
    ),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MemoryContextMethods {
    pub alloc: ::std::option::Option<
        unsafe extern "C" fn(context: MemoryContext, size: Size) -> *mut ::std::os::raw::c_void,
    >,
    pub free_p: ::std::option::Option<unsafe extern "C" fn(pointer: *mut ::std::os::raw::c_void)>,
    pub realloc: ::std::option::Option<
        unsafe extern "C" fn(
            pointer: *mut ::std::os::raw::c_void,
            size: Size,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub reset: ::std::option::Option<unsafe extern "C" fn(context: MemoryContext)>,
    pub delete_context: ::std::option::Option<unsafe extern "C" fn(context: MemoryContext)>,
    pub get_chunk_context: ::std::option::Option<
        unsafe extern "C" fn(pointer: *mut ::std::os::raw::c_void) -> MemoryContext,
    >,
    pub get_chunk_space:
        ::std::option::Option<unsafe extern "C" fn(pointer: *mut ::std::os::raw::c_void) -> Size>,
    pub is_empty: ::std::option::Option<unsafe extern "C" fn(context: MemoryContext) -> bool>,
    pub stats: ::std::option::Option<
        unsafe extern "C" fn(
            context: MemoryContext,
            printfunc: MemoryStatsPrintFunc,
            passthru: *mut ::std::os::raw::c_void,
            totals: *mut MemoryContextCounters,
            print_to_stderr: bool,
        ),
    >,
    pub check: ::std::option::Option<unsafe extern "C" fn(context: MemoryContext)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryContextData {
    pub type_: NodeTag,
    pub isReset: bool,
    pub allowInCritSection: bool,
    pub mem_allocated: Size,
    pub methods: *const MemoryContextMethods,
    pub parent: MemoryContext,
    pub firstchild: MemoryContext,
    pub prevchild: MemoryContext,
    pub nextchild: MemoryContext,
    pub name: *const ::std::os::raw::c_char,
    pub ident: *const ::std::os::raw::c_char,
    pub reset_cbs: *mut MemoryContextCallback,
}
impl Default for MemoryContextData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ExecutorStart_hook_type = ::std::option::Option<
    unsafe extern "C" fn(queryDesc: *mut QueryDesc, eflags: ::std::os::raw::c_int),
>;
pub type ExecutorRun_hook_type = ::std::option::Option<
    unsafe extern "C" fn(
        queryDesc: *mut QueryDesc,
        direction: ScanDirection,
        count: uint64,
        execute_once: bool,
    ),
>;
pub type ExecutorFinish_hook_type =
    ::std::option::Option<unsafe extern "C" fn(queryDesc: *mut QueryDesc)>;
pub type ExecutorEnd_hook_type =
    ::std::option::Option<unsafe extern "C" fn(queryDesc: *mut QueryDesc)>;
pub type ExecutorCheckPerms_hook_type = ::std::option::Option<
    unsafe extern "C" fn(
        rangeTable: *mut List,
        rtePermInfos: *mut List,
        ereport_on_violation: bool,
    ) -> bool,
>;
pub type ExecScanAccessMtd =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ScanState) -> *mut TupleTableSlot>;
pub type ExecScanRecheckMtd = ::std::option::Option<
    unsafe extern "C" fn(node: *mut ScanState, slot: *mut TupleTableSlot) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TupOutputState {
    pub slot: *mut TupleTableSlot,
    pub dest: *mut DestReceiver,
}
impl Default for TupOutputState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AttInMetadata {
    pub tupdesc: TupleDesc,
    pub attinfuncs: *mut FmgrInfo,
    pub attioparams: *mut Oid,
    pub atttypmods: *mut int32,
}
impl Default for AttInMetadata {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuncCallContext {
    pub call_cntr: uint64,
    pub max_calls: uint64,
    pub user_fctx: *mut ::std::os::raw::c_void,
    pub attinmeta: *mut AttInMetadata,
    pub multi_call_memory_ctx: MemoryContext,
    pub tuple_desc: TupleDesc,
}
impl Default for FuncCallContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const TypeFuncClass_TYPEFUNC_SCALAR: TypeFuncClass = 0;
pub const TypeFuncClass_TYPEFUNC_COMPOSITE: TypeFuncClass = 1;
pub const TypeFuncClass_TYPEFUNC_COMPOSITE_DOMAIN: TypeFuncClass = 2;
pub const TypeFuncClass_TYPEFUNC_RECORD: TypeFuncClass = 3;
pub const TypeFuncClass_TYPEFUNC_OTHER: TypeFuncClass = 4;
pub type TypeFuncClass = ::std::os::raw::c_uint;
pub type sig_atomic_t = __sig_atomic_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
impl Default for sigval {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __sigval_t = sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub __pad0: ::std::os::raw::c_int,
    pub _sifields: siginfo_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 28usize],
    pub _kill: siginfo_t__bindgen_ty_1__bindgen_ty_1,
    pub _timer: siginfo_t__bindgen_ty_1__bindgen_ty_2,
    pub _rt: siginfo_t__bindgen_ty_1__bindgen_ty_3,
    pub _sigchld: siginfo_t__bindgen_ty_1__bindgen_ty_4,
    pub _sigfault: siginfo_t__bindgen_ty_1__bindgen_ty_5,
    pub _sigpoll: siginfo_t__bindgen_ty_1__bindgen_ty_6,
    pub _sigsys: siginfo_t__bindgen_ty_1__bindgen_ty_7,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_2 {
    pub si_tid: ::std::os::raw::c_int,
    pub si_overrun: ::std::os::raw::c_int,
    pub si_sigval: __sigval_t,
}
impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_3 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_sigval: __sigval_t,
}
impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_4 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_utime: __clock_t,
    pub si_stime: __clock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5 {
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_addr_lsb: ::std::os::raw::c_short,
    pub _bounds: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub _addr_bnd: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _pkey: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _lower: *mut ::std::os::raw::c_void,
    pub _upper: *mut ::std::os::raw::c_void,
}
impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_6 {
    pub si_band: ::std::os::raw::c_long,
    pub si_fd: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_7 {
    pub _call_addr: *mut ::std::os::raw::c_void,
    pub _syscall: ::std::os::raw::c_int,
    pub _arch: ::std::os::raw::c_uint,
}
impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_7 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for siginfo_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for siginfo_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const SI_ASYNCNL: _bindgen_ty_4 = -60;
pub const SI_DETHREAD: _bindgen_ty_4 = -7;
pub const SI_TKILL: _bindgen_ty_4 = -6;
pub const SI_SIGIO: _bindgen_ty_4 = -5;
pub const SI_ASYNCIO: _bindgen_ty_4 = -4;
pub const SI_MESGQ: _bindgen_ty_4 = -3;
pub const SI_TIMER: _bindgen_ty_4 = -2;
pub const SI_QUEUE: _bindgen_ty_4 = -1;
pub const SI_USER: _bindgen_ty_4 = 0;
pub const SI_KERNEL: _bindgen_ty_4 = 128;
pub type _bindgen_ty_4 = ::std::os::raw::c_int;
pub const ILL_ILLOPC: _bindgen_ty_5 = 1;
pub const ILL_ILLOPN: _bindgen_ty_5 = 2;
pub const ILL_ILLADR: _bindgen_ty_5 = 3;
pub const ILL_ILLTRP: _bindgen_ty_5 = 4;
pub const ILL_PRVOPC: _bindgen_ty_5 = 5;
pub const ILL_PRVREG: _bindgen_ty_5 = 6;
pub const ILL_COPROC: _bindgen_ty_5 = 7;
pub const ILL_BADSTK: _bindgen_ty_5 = 8;
pub const ILL_BADIADDR: _bindgen_ty_5 = 9;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub const FPE_INTDIV: _bindgen_ty_6 = 1;
pub const FPE_INTOVF: _bindgen_ty_6 = 2;
pub const FPE_FLTDIV: _bindgen_ty_6 = 3;
pub const FPE_FLTOVF: _bindgen_ty_6 = 4;
pub const FPE_FLTUND: _bindgen_ty_6 = 5;
pub const FPE_FLTRES: _bindgen_ty_6 = 6;
pub const FPE_FLTINV: _bindgen_ty_6 = 7;
pub const FPE_FLTSUB: _bindgen_ty_6 = 8;
pub const FPE_FLTUNK: _bindgen_ty_6 = 14;
pub const FPE_CONDTRAP: _bindgen_ty_6 = 15;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
pub const SEGV_MAPERR: _bindgen_ty_7 = 1;
pub const SEGV_ACCERR: _bindgen_ty_7 = 2;
pub const SEGV_BNDERR: _bindgen_ty_7 = 3;
pub const SEGV_PKUERR: _bindgen_ty_7 = 4;
pub const SEGV_ACCADI: _bindgen_ty_7 = 5;
pub const SEGV_ADIDERR: _bindgen_ty_7 = 6;
pub const SEGV_ADIPERR: _bindgen_ty_7 = 7;
pub const SEGV_MTEAERR: _bindgen_ty_7 = 8;
pub const SEGV_MTESERR: _bindgen_ty_7 = 9;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
pub const BUS_ADRALN: _bindgen_ty_8 = 1;
pub const BUS_ADRERR: _bindgen_ty_8 = 2;
pub const BUS_OBJERR: _bindgen_ty_8 = 3;
pub const BUS_MCEERR_AR: _bindgen_ty_8 = 4;
pub const BUS_MCEERR_AO: _bindgen_ty_8 = 5;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
pub const CLD_EXITED: _bindgen_ty_9 = 1;
pub const CLD_KILLED: _bindgen_ty_9 = 2;
pub const CLD_DUMPED: _bindgen_ty_9 = 3;
pub const CLD_TRAPPED: _bindgen_ty_9 = 4;
pub const CLD_STOPPED: _bindgen_ty_9 = 5;
pub const CLD_CONTINUED: _bindgen_ty_9 = 6;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
pub const POLL_IN: _bindgen_ty_10 = 1;
pub const POLL_OUT: _bindgen_ty_10 = 2;
pub const POLL_MSG: _bindgen_ty_10 = 3;
pub const POLL_ERR: _bindgen_ty_10 = 4;
pub const POLL_PRI: _bindgen_ty_10 = 5;
pub const POLL_HUP: _bindgen_ty_10 = 6;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
pub type sigval_t = __sigval_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_value: __sigval_t,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_notify: ::std::os::raw::c_int,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigevent__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 12usize],
    pub _tid: __pid_t,
    pub _sigev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::std::option::Option<unsafe extern "C" fn(arg1: __sigval_t)>,
    pub _attribute: *mut pthread_attr_t,
}
impl Default for sigevent__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sigevent__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sigevent {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type sigevent_t = sigevent;
pub const SIGEV_SIGNAL: _bindgen_ty_11 = 0;
pub const SIGEV_NONE: _bindgen_ty_11 = 1;
pub const SIGEV_THREAD: _bindgen_ty_11 = 2;
pub const SIGEV_THREAD_ID: _bindgen_ty_11 = 4;
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
pub type __sighandler_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type sig_t = __sighandler_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_handler: sigaction__bindgen_ty_1,
    pub sa_mask: __sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
    pub sa_restorer: ::std::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigaction__bindgen_ty_1 {
    pub sa_handler: __sighandler_t,
    pub sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut siginfo_t,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
impl Default for sigaction__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sigaction {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _fpx_sw_bytes {
    pub magic1: __uint32_t,
    pub extended_size: __uint32_t,
    pub xstate_bv: __uint64_t,
    pub xstate_size: __uint32_t,
    pub __glibc_reserved1: [__uint32_t; 7usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _fpreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub __glibc_reserved1: [::std::os::raw::c_ushort; 3usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_fpxreg; 8usize],
    pub _xmm: [_xmmreg; 16usize],
    pub __glibc_reserved1: [__uint32_t; 24usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigcontext {
    pub r8: __uint64_t,
    pub r9: __uint64_t,
    pub r10: __uint64_t,
    pub r11: __uint64_t,
    pub r12: __uint64_t,
    pub r13: __uint64_t,
    pub r14: __uint64_t,
    pub r15: __uint64_t,
    pub rdi: __uint64_t,
    pub rsi: __uint64_t,
    pub rbp: __uint64_t,
    pub rbx: __uint64_t,
    pub rdx: __uint64_t,
    pub rax: __uint64_t,
    pub rcx: __uint64_t,
    pub rsp: __uint64_t,
    pub rip: __uint64_t,
    pub eflags: __uint64_t,
    pub cs: ::std::os::raw::c_ushort,
    pub gs: ::std::os::raw::c_ushort,
    pub fs: ::std::os::raw::c_ushort,
    pub __pad0: ::std::os::raw::c_ushort,
    pub err: __uint64_t,
    pub trapno: __uint64_t,
    pub oldmask: __uint64_t,
    pub cr2: __uint64_t,
    pub __bindgen_anon_1: sigcontext__bindgen_ty_1,
    pub __reserved1: [__uint64_t; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigcontext__bindgen_ty_1 {
    pub fpstate: *mut _fpstate,
    pub __fpstate_word: __uint64_t,
}
impl Default for sigcontext__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for sigcontext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _xsave_hdr {
    pub xstate_bv: __uint64_t,
    pub __glibc_reserved1: [__uint64_t; 2usize],
    pub __glibc_reserved2: [__uint64_t; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ymmh_state {
    pub ymmh_space: [__uint32_t; 64usize],
}
impl Default for _ymmh_state {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xstate {
    pub fpstate: _fpstate,
    pub xstate_hdr: _xsave_hdr,
    pub ymmh: _ymmh_state,
}
impl Default for _xstate {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_t {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_flags: ::std::os::raw::c_int,
    pub ss_size: usize,
}
impl Default for stack_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type greg_t = ::std::os::raw::c_longlong;
pub type gregset_t = [greg_t; 23usize];
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _libc_fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub __glibc_reserved1: [::std::os::raw::c_ushort; 3usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _libc_xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _libc_fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_libc_fpxreg; 8usize],
    pub _xmm: [_libc_xmmreg; 16usize],
    pub __glibc_reserved1: [__uint32_t; 24usize],
}
pub type fpregset_t = *mut _libc_fpstate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcontext_t {
    pub gregs: gregset_t,
    pub fpregs: fpregset_t,
    pub __reserved1: [::std::os::raw::c_ulonglong; 8usize],
}
impl Default for mcontext_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucontext_t {
    pub uc_flags: ::std::os::raw::c_ulong,
    pub uc_link: *mut ucontext_t,
    pub uc_stack: stack_t,
    pub uc_mcontext: mcontext_t,
    pub uc_sigmask: sigset_t,
    pub __fpregs_mem: _libc_fpstate,
    pub __ssp: [::std::os::raw::c_ulonglong; 4usize],
}
impl Default for ucontext_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const SS_ONSTACK: _bindgen_ty_12 = 1;
pub const SS_DISABLE: _bindgen_ty_12 = 2;
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_onstack: ::std::os::raw::c_int,
}
impl Default for sigstack {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pg_time_t = int64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pg_tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
impl Default for pg_tm {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pg_tz {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pg_tzenum {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Port {
    _unused: [u8; 0],
}
pub type pg_stack_base_t = *mut ::std::os::raw::c_char;
pub const BackendType_B_INVALID: BackendType = 0;
pub const BackendType_B_ARCHIVER: BackendType = 1;
pub const BackendType_B_AUTOVAC_LAUNCHER: BackendType = 2;
pub const BackendType_B_AUTOVAC_WORKER: BackendType = 3;
pub const BackendType_B_BACKEND: BackendType = 4;
pub const BackendType_B_BG_WORKER: BackendType = 5;
pub const BackendType_B_BG_WRITER: BackendType = 6;
pub const BackendType_B_CHECKPOINTER: BackendType = 7;
pub const BackendType_B_LOGGER: BackendType = 8;
pub const BackendType_B_STANDALONE_BACKEND: BackendType = 9;
pub const BackendType_B_STARTUP: BackendType = 10;
pub const BackendType_B_WAL_RECEIVER: BackendType = 11;
pub const BackendType_B_WAL_SENDER: BackendType = 12;
pub const BackendType_B_WAL_WRITER: BackendType = 13;
pub type BackendType = ::std::os::raw::c_uint;
pub const ProcessingMode_BootstrapProcessing: ProcessingMode = 0;
pub const ProcessingMode_InitProcessing: ProcessingMode = 1;
pub const ProcessingMode_NormalProcessing: ProcessingMode = 2;
#[doc = "\t  pmod.h --\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t *\n\t\t\tPOSTGRES processing mode definitions.                            *"]
pub type ProcessingMode = ::std::os::raw::c_uint;
pub const AuxProcType_NotAnAuxProcess: AuxProcType = -1;
pub const AuxProcType_StartupProcess: AuxProcType = 0;
pub const AuxProcType_BgWriterProcess: AuxProcType = 1;
pub const AuxProcType_ArchiverProcess: AuxProcType = 2;
pub const AuxProcType_CheckpointerProcess: AuxProcType = 3;
pub const AuxProcType_WalWriterProcess: AuxProcType = 4;
pub const AuxProcType_WalReceiverProcess: AuxProcType = 5;
pub const AuxProcType_NUM_AUXPROCTYPES: AuxProcType = 6;
pub type AuxProcType = ::std::os::raw::c_int;
pub type shmem_request_hook_type = ::std::option::Option<unsafe extern "C" fn()>;
pub const ProgressCommandType_PROGRESS_COMMAND_INVALID: ProgressCommandType = 0;
pub const ProgressCommandType_PROGRESS_COMMAND_VACUUM: ProgressCommandType = 1;
pub const ProgressCommandType_PROGRESS_COMMAND_ANALYZE: ProgressCommandType = 2;
pub const ProgressCommandType_PROGRESS_COMMAND_CLUSTER: ProgressCommandType = 3;
pub const ProgressCommandType_PROGRESS_COMMAND_CREATE_INDEX: ProgressCommandType = 4;
pub const ProgressCommandType_PROGRESS_COMMAND_BASEBACKUP: ProgressCommandType = 5;
pub const ProgressCommandType_PROGRESS_COMMAND_COPY: ProgressCommandType = 6;
pub type ProgressCommandType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
impl Default for iovec {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type socklen_t = __socklen_t;
pub const __socket_type_SOCK_STREAM: __socket_type = 1;
pub const __socket_type_SOCK_DGRAM: __socket_type = 2;
pub const __socket_type_SOCK_RAW: __socket_type = 3;
pub const __socket_type_SOCK_RDM: __socket_type = 4;
pub const __socket_type_SOCK_SEQPACKET: __socket_type = 5;
pub const __socket_type_SOCK_DCCP: __socket_type = 6;
pub const __socket_type_SOCK_PACKET: __socket_type = 10;
pub const __socket_type_SOCK_CLOEXEC: __socket_type = 524288;
pub const __socket_type_SOCK_NONBLOCK: __socket_type = 2048;
pub type __socket_type = ::std::os::raw::c_uint;
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::std::os::raw::c_char; 118usize],
    pub __ss_align: ::std::os::raw::c_ulong,
}
impl Default for sockaddr_storage {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const MSG_OOB: _bindgen_ty_13 = 1;
pub const MSG_PEEK: _bindgen_ty_13 = 2;
pub const MSG_DONTROUTE: _bindgen_ty_13 = 4;
pub const MSG_CTRUNC: _bindgen_ty_13 = 8;
pub const MSG_PROXY: _bindgen_ty_13 = 16;
pub const MSG_TRUNC: _bindgen_ty_13 = 32;
pub const MSG_DONTWAIT: _bindgen_ty_13 = 64;
pub const MSG_EOR: _bindgen_ty_13 = 128;
pub const MSG_WAITALL: _bindgen_ty_13 = 256;
pub const MSG_FIN: _bindgen_ty_13 = 512;
pub const MSG_SYN: _bindgen_ty_13 = 1024;
pub const MSG_CONFIRM: _bindgen_ty_13 = 2048;
pub const MSG_RST: _bindgen_ty_13 = 4096;
pub const MSG_ERRQUEUE: _bindgen_ty_13 = 8192;
pub const MSG_NOSIGNAL: _bindgen_ty_13 = 16384;
pub const MSG_MORE: _bindgen_ty_13 = 32768;
pub const MSG_WAITFORONE: _bindgen_ty_13 = 65536;
pub const MSG_BATCH: _bindgen_ty_13 = 262144;
pub const MSG_ZEROCOPY: _bindgen_ty_13 = 67108864;
pub const MSG_FASTOPEN: _bindgen_ty_13 = 536870912;
pub const MSG_CMSG_CLOEXEC: _bindgen_ty_13 = 1073741824;
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: usize,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: usize,
    pub msg_flags: ::std::os::raw::c_int,
}
impl Default for msghdr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct cmsghdr {
    pub cmsg_len: usize,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
    pub __cmsg_data: __IncompleteArrayField<::std::os::raw::c_uchar>,
}
pub const SCM_RIGHTS: _bindgen_ty_14 = 1;
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct osockaddr {
    pub sa_family: ::std::os::raw::c_ushort,
    pub sa_data: [::std::os::raw::c_uchar; 14usize],
}
pub const SHUT_RD: _bindgen_ty_15 = 0;
pub const SHUT_WR: _bindgen_ty_15 = 1;
pub const SHUT_RDWR: _bindgen_ty_15 = 2;
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_un {
    pub sun_family: sa_family_t,
    pub sun_path: [::std::os::raw::c_char; 108usize],
}
impl Default for sockaddr_un {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_opts {
    pub ip_dst: in_addr,
    pub ip_opts: [::std::os::raw::c_char; 40usize],
}
impl Default for ip_opts {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_int,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
pub const IPPROTO_IP: _bindgen_ty_16 = 0;
pub const IPPROTO_ICMP: _bindgen_ty_16 = 1;
pub const IPPROTO_IGMP: _bindgen_ty_16 = 2;
pub const IPPROTO_IPIP: _bindgen_ty_16 = 4;
pub const IPPROTO_TCP: _bindgen_ty_16 = 6;
pub const IPPROTO_EGP: _bindgen_ty_16 = 8;
pub const IPPROTO_PUP: _bindgen_ty_16 = 12;
pub const IPPROTO_UDP: _bindgen_ty_16 = 17;
pub const IPPROTO_IDP: _bindgen_ty_16 = 22;
pub const IPPROTO_TP: _bindgen_ty_16 = 29;
pub const IPPROTO_DCCP: _bindgen_ty_16 = 33;
pub const IPPROTO_IPV6: _bindgen_ty_16 = 41;
pub const IPPROTO_RSVP: _bindgen_ty_16 = 46;
pub const IPPROTO_GRE: _bindgen_ty_16 = 47;
pub const IPPROTO_ESP: _bindgen_ty_16 = 50;
pub const IPPROTO_AH: _bindgen_ty_16 = 51;
pub const IPPROTO_MTP: _bindgen_ty_16 = 92;
pub const IPPROTO_BEETPH: _bindgen_ty_16 = 94;
pub const IPPROTO_ENCAP: _bindgen_ty_16 = 98;
pub const IPPROTO_PIM: _bindgen_ty_16 = 103;
pub const IPPROTO_COMP: _bindgen_ty_16 = 108;
pub const IPPROTO_SCTP: _bindgen_ty_16 = 132;
pub const IPPROTO_UDPLITE: _bindgen_ty_16 = 136;
pub const IPPROTO_MPLS: _bindgen_ty_16 = 137;
pub const IPPROTO_ETHERNET: _bindgen_ty_16 = 143;
pub const IPPROTO_RAW: _bindgen_ty_16 = 255;
pub const IPPROTO_MPTCP: _bindgen_ty_16 = 262;
pub const IPPROTO_MAX: _bindgen_ty_16 = 263;
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
pub const IPPROTO_HOPOPTS: _bindgen_ty_17 = 0;
pub const IPPROTO_ROUTING: _bindgen_ty_17 = 43;
pub const IPPROTO_FRAGMENT: _bindgen_ty_17 = 44;
pub const IPPROTO_ICMPV6: _bindgen_ty_17 = 58;
pub const IPPROTO_NONE: _bindgen_ty_17 = 59;
pub const IPPROTO_DSTOPTS: _bindgen_ty_17 = 60;
pub const IPPROTO_MH: _bindgen_ty_17 = 135;
pub type _bindgen_ty_17 = ::std::os::raw::c_uint;
pub type in_port_t = u16;
pub const IPPORT_ECHO: _bindgen_ty_18 = 7;
pub const IPPORT_DISCARD: _bindgen_ty_18 = 9;
pub const IPPORT_SYSTAT: _bindgen_ty_18 = 11;
pub const IPPORT_DAYTIME: _bindgen_ty_18 = 13;
pub const IPPORT_NETSTAT: _bindgen_ty_18 = 15;
pub const IPPORT_FTP: _bindgen_ty_18 = 21;
pub const IPPORT_TELNET: _bindgen_ty_18 = 23;
pub const IPPORT_SMTP: _bindgen_ty_18 = 25;
pub const IPPORT_TIMESERVER: _bindgen_ty_18 = 37;
pub const IPPORT_NAMESERVER: _bindgen_ty_18 = 42;
pub const IPPORT_WHOIS: _bindgen_ty_18 = 43;
pub const IPPORT_MTP: _bindgen_ty_18 = 57;
pub const IPPORT_TFTP: _bindgen_ty_18 = 69;
pub const IPPORT_RJE: _bindgen_ty_18 = 77;
pub const IPPORT_FINGER: _bindgen_ty_18 = 79;
pub const IPPORT_TTYLINK: _bindgen_ty_18 = 87;
pub const IPPORT_SUPDUP: _bindgen_ty_18 = 95;
pub const IPPORT_EXECSERVER: _bindgen_ty_18 = 512;
pub const IPPORT_LOGINSERVER: _bindgen_ty_18 = 513;
pub const IPPORT_CMDSERVER: _bindgen_ty_18 = 514;
pub const IPPORT_EFSSERVER: _bindgen_ty_18 = 520;
pub const IPPORT_BIFFUDP: _bindgen_ty_18 = 512;
pub const IPPORT_WHOSERVER: _bindgen_ty_18 = 513;
pub const IPPORT_ROUTESERVER: _bindgen_ty_18 = 520;
pub const IPPORT_RESERVED: _bindgen_ty_18 = 1024;
pub const IPPORT_USERRESERVED: _bindgen_ty_18 = 5000;
pub type _bindgen_ty_18 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [u8; 16usize],
    pub __u6_addr16: [u16; 8usize],
    pub __u6_addr32: [u32; 4usize],
}
impl Default for in6_addr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for in6_addr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_uchar; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32,
}
impl Default for sockaddr_in6 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
    pub imr_sourceaddr: in_addr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::std::os::raw::c_uint,
}
impl Default for ipv6_mreq {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_req {
    pub gr_interface: u32,
    pub gr_group: sockaddr_storage,
}
impl Default for group_req {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_source_req {
    pub gsr_interface: u32,
    pub gsr_group: sockaddr_storage,
    pub gsr_source: sockaddr_storage,
}
impl Default for group_source_req {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ip_msfilter {
    pub imsf_multiaddr: in_addr,
    pub imsf_interface: in_addr,
    pub imsf_fmode: u32,
    pub imsf_numsrc: u32,
    pub imsf_slist: [in_addr; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_filter {
    pub gf_interface: u32,
    pub gf_group: sockaddr_storage,
    pub gf_fmode: u32,
    pub gf_numsrc: u32,
    pub gf_slist: [sockaddr_storage; 1usize],
}
impl Default for group_filter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpcent {
    pub r_name: *mut ::std::os::raw::c_char,
    pub r_aliases: *mut *mut ::std::os::raw::c_char,
    pub r_number: ::std::os::raw::c_int,
}
impl Default for rpcent {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netent {
    pub n_name: *mut ::std::os::raw::c_char,
    pub n_aliases: *mut *mut ::std::os::raw::c_char,
    pub n_addrtype: ::std::os::raw::c_int,
    pub n_net: u32,
}
impl Default for netent {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hostent {
    pub h_name: *mut ::std::os::raw::c_char,
    pub h_aliases: *mut *mut ::std::os::raw::c_char,
    pub h_addrtype: ::std::os::raw::c_int,
    pub h_length: ::std::os::raw::c_int,
    pub h_addr_list: *mut *mut ::std::os::raw::c_char,
}
impl Default for hostent {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct servent {
    pub s_name: *mut ::std::os::raw::c_char,
    pub s_aliases: *mut *mut ::std::os::raw::c_char,
    pub s_port: ::std::os::raw::c_int,
    pub s_proto: *mut ::std::os::raw::c_char,
}
impl Default for servent {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct protoent {
    pub p_name: *mut ::std::os::raw::c_char,
    pub p_aliases: *mut *mut ::std::os::raw::c_char,
    pub p_proto: ::std::os::raw::c_int,
}
impl Default for protoent {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct addrinfo {
    pub ai_flags: ::std::os::raw::c_int,
    pub ai_family: ::std::os::raw::c_int,
    pub ai_socktype: ::std::os::raw::c_int,
    pub ai_protocol: ::std::os::raw::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_addr: *mut sockaddr,
    pub ai_canonname: *mut ::std::os::raw::c_char,
    pub ai_next: *mut addrinfo,
}
impl Default for addrinfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SockAddr {
    pub addr: sockaddr_storage,
    pub salen: socklen_t,
}
impl Default for SockAddr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AddrInfo {
    pub family: ::std::os::raw::c_int,
    pub addr: SockAddr,
}
impl Default for AddrInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ProtocolVersion = uint32;
pub type MsgType = ProtocolVersion;
pub type PacketLen = uint32;
pub type AuthRequest = uint32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CancelRequestPacket {
    pub cancelRequestCode: MsgType,
    pub backendPID: uint32,
    pub cancelAuthCode: uint32,
}
pub type BackendId = ::std::os::raw::c_int;
pub const BackendState_STATE_UNDEFINED: BackendState = 0;
pub const BackendState_STATE_IDLE: BackendState = 1;
pub const BackendState_STATE_RUNNING: BackendState = 2;
pub const BackendState_STATE_IDLEINTRANSACTION: BackendState = 3;
pub const BackendState_STATE_FASTPATH: BackendState = 4;
pub const BackendState_STATE_IDLEINTRANSACTION_ABORTED: BackendState = 5;
pub const BackendState_STATE_DISABLED: BackendState = 6;
pub type BackendState = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgBackendSSLStatus {
    pub ssl_bits: ::std::os::raw::c_int,
    pub ssl_version: [::std::os::raw::c_char; 64usize],
    pub ssl_cipher: [::std::os::raw::c_char; 64usize],
    pub ssl_client_dn: [::std::os::raw::c_char; 64usize],
    pub ssl_client_serial: [::std::os::raw::c_char; 64usize],
    pub ssl_issuer_dn: [::std::os::raw::c_char; 64usize],
}
impl Default for PgBackendSSLStatus {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgBackendGSSStatus {
    pub gss_princ: [::std::os::raw::c_char; 64usize],
    pub gss_auth: bool,
    pub gss_enc: bool,
    pub gss_delegation: bool,
}
impl Default for PgBackendGSSStatus {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgBackendStatus {
    pub st_changecount: ::std::os::raw::c_int,
    pub st_procpid: ::std::os::raw::c_int,
    pub st_backendType: BackendType,
    pub st_proc_start_timestamp: TimestampTz,
    pub st_xact_start_timestamp: TimestampTz,
    pub st_activity_start_timestamp: TimestampTz,
    pub st_state_start_timestamp: TimestampTz,
    pub st_databaseid: Oid,
    pub st_userid: Oid,
    pub st_clientaddr: SockAddr,
    pub st_clienthostname: *mut ::std::os::raw::c_char,
    pub st_ssl: bool,
    pub st_sslstatus: *mut PgBackendSSLStatus,
    pub st_gss: bool,
    pub st_gssstatus: *mut PgBackendGSSStatus,
    pub st_state: BackendState,
    pub st_appname: *mut ::std::os::raw::c_char,
    pub st_activity_raw: *mut ::std::os::raw::c_char,
    pub st_progress_command: ProgressCommandType,
    pub st_progress_command_target: Oid,
    pub st_progress_param: [int64; 20usize],
    pub st_query_id: uint64,
}
impl Default for PgBackendStatus {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LocalPgBackendStatus {
    pub backendStatus: PgBackendStatus,
    pub backend_id: BackendId,
    pub backend_xid: TransactionId,
    pub backend_xmin: TransactionId,
    pub backend_subxact_count: ::std::os::raw::c_int,
    pub backend_subxact_overflowed: bool,
}
impl Default for LocalPgBackendStatus {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const WaitEventActivity_WAIT_EVENT_ARCHIVER_MAIN: WaitEventActivity = 83886080;
pub const WaitEventActivity_WAIT_EVENT_AUTOVACUUM_MAIN: WaitEventActivity = 83886081;
pub const WaitEventActivity_WAIT_EVENT_BGWRITER_HIBERNATE: WaitEventActivity = 83886082;
pub const WaitEventActivity_WAIT_EVENT_BGWRITER_MAIN: WaitEventActivity = 83886083;
pub const WaitEventActivity_WAIT_EVENT_CHECKPOINTER_MAIN: WaitEventActivity = 83886084;
pub const WaitEventActivity_WAIT_EVENT_LOGICAL_APPLY_MAIN: WaitEventActivity = 83886085;
pub const WaitEventActivity_WAIT_EVENT_LOGICAL_LAUNCHER_MAIN: WaitEventActivity = 83886086;
pub const WaitEventActivity_WAIT_EVENT_LOGICAL_PARALLEL_APPLY_MAIN: WaitEventActivity = 83886087;
pub const WaitEventActivity_WAIT_EVENT_RECOVERY_WAL_STREAM: WaitEventActivity = 83886088;
pub const WaitEventActivity_WAIT_EVENT_SYSLOGGER_MAIN: WaitEventActivity = 83886089;
pub const WaitEventActivity_WAIT_EVENT_WAL_RECEIVER_MAIN: WaitEventActivity = 83886090;
pub const WaitEventActivity_WAIT_EVENT_WAL_SENDER_MAIN: WaitEventActivity = 83886091;
pub const WaitEventActivity_WAIT_EVENT_WAL_WRITER_MAIN: WaitEventActivity = 83886092;
pub type WaitEventActivity = ::std::os::raw::c_uint;
pub const WaitEventClient_WAIT_EVENT_CLIENT_READ: WaitEventClient = 100663296;
pub const WaitEventClient_WAIT_EVENT_CLIENT_WRITE: WaitEventClient = 100663297;
pub const WaitEventClient_WAIT_EVENT_GSS_OPEN_SERVER: WaitEventClient = 100663298;
pub const WaitEventClient_WAIT_EVENT_LIBPQWALRECEIVER_CONNECT: WaitEventClient = 100663299;
pub const WaitEventClient_WAIT_EVENT_LIBPQWALRECEIVER_RECEIVE: WaitEventClient = 100663300;
pub const WaitEventClient_WAIT_EVENT_SSL_OPEN_SERVER: WaitEventClient = 100663301;
pub const WaitEventClient_WAIT_EVENT_WAL_SENDER_WAIT_WAL: WaitEventClient = 100663302;
pub const WaitEventClient_WAIT_EVENT_WAL_SENDER_WRITE_DATA: WaitEventClient = 100663303;
pub type WaitEventClient = ::std::os::raw::c_uint;
pub const WaitEventIPC_WAIT_EVENT_APPEND_READY: WaitEventIPC = 134217728;
pub const WaitEventIPC_WAIT_EVENT_ARCHIVE_CLEANUP_COMMAND: WaitEventIPC = 134217729;
pub const WaitEventIPC_WAIT_EVENT_ARCHIVE_COMMAND: WaitEventIPC = 134217730;
pub const WaitEventIPC_WAIT_EVENT_BACKEND_TERMINATION: WaitEventIPC = 134217731;
pub const WaitEventIPC_WAIT_EVENT_BACKUP_WAIT_WAL_ARCHIVE: WaitEventIPC = 134217732;
pub const WaitEventIPC_WAIT_EVENT_BGWORKER_SHUTDOWN: WaitEventIPC = 134217733;
pub const WaitEventIPC_WAIT_EVENT_BGWORKER_STARTUP: WaitEventIPC = 134217734;
pub const WaitEventIPC_WAIT_EVENT_BTREE_PAGE: WaitEventIPC = 134217735;
pub const WaitEventIPC_WAIT_EVENT_BUFFER_IO: WaitEventIPC = 134217736;
pub const WaitEventIPC_WAIT_EVENT_CHECKPOINT_DONE: WaitEventIPC = 134217737;
pub const WaitEventIPC_WAIT_EVENT_CHECKPOINT_START: WaitEventIPC = 134217738;
pub const WaitEventIPC_WAIT_EVENT_EXECUTE_GATHER: WaitEventIPC = 134217739;
pub const WaitEventIPC_WAIT_EVENT_HASH_BATCH_ALLOCATE: WaitEventIPC = 134217740;
pub const WaitEventIPC_WAIT_EVENT_HASH_BATCH_ELECT: WaitEventIPC = 134217741;
pub const WaitEventIPC_WAIT_EVENT_HASH_BATCH_LOAD: WaitEventIPC = 134217742;
pub const WaitEventIPC_WAIT_EVENT_HASH_BUILD_ALLOCATE: WaitEventIPC = 134217743;
pub const WaitEventIPC_WAIT_EVENT_HASH_BUILD_ELECT: WaitEventIPC = 134217744;
pub const WaitEventIPC_WAIT_EVENT_HASH_BUILD_HASH_INNER: WaitEventIPC = 134217745;
pub const WaitEventIPC_WAIT_EVENT_HASH_BUILD_HASH_OUTER: WaitEventIPC = 134217746;
pub const WaitEventIPC_WAIT_EVENT_HASH_GROW_BATCHES_DECIDE: WaitEventIPC = 134217747;
pub const WaitEventIPC_WAIT_EVENT_HASH_GROW_BATCHES_ELECT: WaitEventIPC = 134217748;
pub const WaitEventIPC_WAIT_EVENT_HASH_GROW_BATCHES_FINISH: WaitEventIPC = 134217749;
pub const WaitEventIPC_WAIT_EVENT_HASH_GROW_BATCHES_REALLOCATE: WaitEventIPC = 134217750;
pub const WaitEventIPC_WAIT_EVENT_HASH_GROW_BATCHES_REPARTITION: WaitEventIPC = 134217751;
pub const WaitEventIPC_WAIT_EVENT_HASH_GROW_BUCKETS_ELECT: WaitEventIPC = 134217752;
pub const WaitEventIPC_WAIT_EVENT_HASH_GROW_BUCKETS_REALLOCATE: WaitEventIPC = 134217753;
pub const WaitEventIPC_WAIT_EVENT_HASH_GROW_BUCKETS_REINSERT: WaitEventIPC = 134217754;
pub const WaitEventIPC_WAIT_EVENT_LOGICAL_APPLY_SEND_DATA: WaitEventIPC = 134217755;
pub const WaitEventIPC_WAIT_EVENT_LOGICAL_PARALLEL_APPLY_STATE_CHANGE: WaitEventIPC = 134217756;
pub const WaitEventIPC_WAIT_EVENT_LOGICAL_SYNC_DATA: WaitEventIPC = 134217757;
pub const WaitEventIPC_WAIT_EVENT_LOGICAL_SYNC_STATE_CHANGE: WaitEventIPC = 134217758;
pub const WaitEventIPC_WAIT_EVENT_MQ_INTERNAL: WaitEventIPC = 134217759;
pub const WaitEventIPC_WAIT_EVENT_MQ_PUT_MESSAGE: WaitEventIPC = 134217760;
pub const WaitEventIPC_WAIT_EVENT_MQ_RECEIVE: WaitEventIPC = 134217761;
pub const WaitEventIPC_WAIT_EVENT_MQ_SEND: WaitEventIPC = 134217762;
pub const WaitEventIPC_WAIT_EVENT_PARALLEL_BITMAP_SCAN: WaitEventIPC = 134217763;
pub const WaitEventIPC_WAIT_EVENT_PARALLEL_CREATE_INDEX_SCAN: WaitEventIPC = 134217764;
pub const WaitEventIPC_WAIT_EVENT_PARALLEL_FINISH: WaitEventIPC = 134217765;
pub const WaitEventIPC_WAIT_EVENT_PROCARRAY_GROUP_UPDATE: WaitEventIPC = 134217766;
pub const WaitEventIPC_WAIT_EVENT_PROC_SIGNAL_BARRIER: WaitEventIPC = 134217767;
pub const WaitEventIPC_WAIT_EVENT_PROMOTE: WaitEventIPC = 134217768;
pub const WaitEventIPC_WAIT_EVENT_RECOVERY_CONFLICT_SNAPSHOT: WaitEventIPC = 134217769;
pub const WaitEventIPC_WAIT_EVENT_RECOVERY_CONFLICT_TABLESPACE: WaitEventIPC = 134217770;
pub const WaitEventIPC_WAIT_EVENT_RECOVERY_END_COMMAND: WaitEventIPC = 134217771;
pub const WaitEventIPC_WAIT_EVENT_RECOVERY_PAUSE: WaitEventIPC = 134217772;
pub const WaitEventIPC_WAIT_EVENT_REPLICATION_ORIGIN_DROP: WaitEventIPC = 134217773;
pub const WaitEventIPC_WAIT_EVENT_REPLICATION_SLOT_DROP: WaitEventIPC = 134217774;
pub const WaitEventIPC_WAIT_EVENT_RESTORE_COMMAND: WaitEventIPC = 134217775;
pub const WaitEventIPC_WAIT_EVENT_SAFE_SNAPSHOT: WaitEventIPC = 134217776;
pub const WaitEventIPC_WAIT_EVENT_SYNC_REP: WaitEventIPC = 134217777;
pub const WaitEventIPC_WAIT_EVENT_WAL_RECEIVER_EXIT: WaitEventIPC = 134217778;
pub const WaitEventIPC_WAIT_EVENT_WAL_RECEIVER_WAIT_START: WaitEventIPC = 134217779;
pub const WaitEventIPC_WAIT_EVENT_XACT_GROUP_UPDATE: WaitEventIPC = 134217780;
pub type WaitEventIPC = ::std::os::raw::c_uint;
pub const WaitEventTimeout_WAIT_EVENT_BASE_BACKUP_THROTTLE: WaitEventTimeout = 150994944;
pub const WaitEventTimeout_WAIT_EVENT_CHECKPOINT_WRITE_DELAY: WaitEventTimeout = 150994945;
pub const WaitEventTimeout_WAIT_EVENT_PG_SLEEP: WaitEventTimeout = 150994946;
pub const WaitEventTimeout_WAIT_EVENT_RECOVERY_APPLY_DELAY: WaitEventTimeout = 150994947;
pub const WaitEventTimeout_WAIT_EVENT_RECOVERY_RETRIEVE_RETRY_INTERVAL: WaitEventTimeout =
    150994948;
pub const WaitEventTimeout_WAIT_EVENT_REGISTER_SYNC_REQUEST: WaitEventTimeout = 150994949;
pub const WaitEventTimeout_WAIT_EVENT_SPIN_DELAY: WaitEventTimeout = 150994950;
pub const WaitEventTimeout_WAIT_EVENT_VACUUM_DELAY: WaitEventTimeout = 150994951;
pub const WaitEventTimeout_WAIT_EVENT_VACUUM_TRUNCATE: WaitEventTimeout = 150994952;
pub type WaitEventTimeout = ::std::os::raw::c_uint;
pub const WaitEventIO_WAIT_EVENT_BASEBACKUP_READ: WaitEventIO = 167772160;
pub const WaitEventIO_WAIT_EVENT_BASEBACKUP_SYNC: WaitEventIO = 167772161;
pub const WaitEventIO_WAIT_EVENT_BASEBACKUP_WRITE: WaitEventIO = 167772162;
pub const WaitEventIO_WAIT_EVENT_BUFFILE_READ: WaitEventIO = 167772163;
pub const WaitEventIO_WAIT_EVENT_BUFFILE_WRITE: WaitEventIO = 167772164;
pub const WaitEventIO_WAIT_EVENT_BUFFILE_TRUNCATE: WaitEventIO = 167772165;
pub const WaitEventIO_WAIT_EVENT_CONTROL_FILE_READ: WaitEventIO = 167772166;
pub const WaitEventIO_WAIT_EVENT_CONTROL_FILE_SYNC: WaitEventIO = 167772167;
pub const WaitEventIO_WAIT_EVENT_CONTROL_FILE_SYNC_UPDATE: WaitEventIO = 167772168;
pub const WaitEventIO_WAIT_EVENT_CONTROL_FILE_WRITE: WaitEventIO = 167772169;
pub const WaitEventIO_WAIT_EVENT_CONTROL_FILE_WRITE_UPDATE: WaitEventIO = 167772170;
pub const WaitEventIO_WAIT_EVENT_COPY_FILE_READ: WaitEventIO = 167772171;
pub const WaitEventIO_WAIT_EVENT_COPY_FILE_WRITE: WaitEventIO = 167772172;
pub const WaitEventIO_WAIT_EVENT_DATA_FILE_EXTEND: WaitEventIO = 167772173;
pub const WaitEventIO_WAIT_EVENT_DATA_FILE_FLUSH: WaitEventIO = 167772174;
pub const WaitEventIO_WAIT_EVENT_DATA_FILE_IMMEDIATE_SYNC: WaitEventIO = 167772175;
pub const WaitEventIO_WAIT_EVENT_DATA_FILE_PREFETCH: WaitEventIO = 167772176;
pub const WaitEventIO_WAIT_EVENT_DATA_FILE_READ: WaitEventIO = 167772177;
pub const WaitEventIO_WAIT_EVENT_DATA_FILE_SYNC: WaitEventIO = 167772178;
pub const WaitEventIO_WAIT_EVENT_DATA_FILE_TRUNCATE: WaitEventIO = 167772179;
pub const WaitEventIO_WAIT_EVENT_DATA_FILE_WRITE: WaitEventIO = 167772180;
pub const WaitEventIO_WAIT_EVENT_DSM_ALLOCATE: WaitEventIO = 167772181;
pub const WaitEventIO_WAIT_EVENT_DSM_FILL_ZERO_WRITE: WaitEventIO = 167772182;
pub const WaitEventIO_WAIT_EVENT_LOCK_FILE_ADDTODATADIR_READ: WaitEventIO = 167772183;
pub const WaitEventIO_WAIT_EVENT_LOCK_FILE_ADDTODATADIR_SYNC: WaitEventIO = 167772184;
pub const WaitEventIO_WAIT_EVENT_LOCK_FILE_ADDTODATADIR_WRITE: WaitEventIO = 167772185;
pub const WaitEventIO_WAIT_EVENT_LOCK_FILE_CREATE_READ: WaitEventIO = 167772186;
pub const WaitEventIO_WAIT_EVENT_LOCK_FILE_CREATE_SYNC: WaitEventIO = 167772187;
pub const WaitEventIO_WAIT_EVENT_LOCK_FILE_CREATE_WRITE: WaitEventIO = 167772188;
pub const WaitEventIO_WAIT_EVENT_LOCK_FILE_RECHECKDATADIR_READ: WaitEventIO = 167772189;
pub const WaitEventIO_WAIT_EVENT_LOGICAL_REWRITE_CHECKPOINT_SYNC: WaitEventIO = 167772190;
pub const WaitEventIO_WAIT_EVENT_LOGICAL_REWRITE_MAPPING_SYNC: WaitEventIO = 167772191;
pub const WaitEventIO_WAIT_EVENT_LOGICAL_REWRITE_MAPPING_WRITE: WaitEventIO = 167772192;
pub const WaitEventIO_WAIT_EVENT_LOGICAL_REWRITE_SYNC: WaitEventIO = 167772193;
pub const WaitEventIO_WAIT_EVENT_LOGICAL_REWRITE_TRUNCATE: WaitEventIO = 167772194;
pub const WaitEventIO_WAIT_EVENT_LOGICAL_REWRITE_WRITE: WaitEventIO = 167772195;
pub const WaitEventIO_WAIT_EVENT_RELATION_MAP_READ: WaitEventIO = 167772196;
pub const WaitEventIO_WAIT_EVENT_RELATION_MAP_REPLACE: WaitEventIO = 167772197;
pub const WaitEventIO_WAIT_EVENT_RELATION_MAP_WRITE: WaitEventIO = 167772198;
pub const WaitEventIO_WAIT_EVENT_REORDER_BUFFER_READ: WaitEventIO = 167772199;
pub const WaitEventIO_WAIT_EVENT_REORDER_BUFFER_WRITE: WaitEventIO = 167772200;
pub const WaitEventIO_WAIT_EVENT_REORDER_LOGICAL_MAPPING_READ: WaitEventIO = 167772201;
pub const WaitEventIO_WAIT_EVENT_REPLICATION_SLOT_READ: WaitEventIO = 167772202;
pub const WaitEventIO_WAIT_EVENT_REPLICATION_SLOT_RESTORE_SYNC: WaitEventIO = 167772203;
pub const WaitEventIO_WAIT_EVENT_REPLICATION_SLOT_SYNC: WaitEventIO = 167772204;
pub const WaitEventIO_WAIT_EVENT_REPLICATION_SLOT_WRITE: WaitEventIO = 167772205;
pub const WaitEventIO_WAIT_EVENT_SLRU_FLUSH_SYNC: WaitEventIO = 167772206;
pub const WaitEventIO_WAIT_EVENT_SLRU_READ: WaitEventIO = 167772207;
pub const WaitEventIO_WAIT_EVENT_SLRU_SYNC: WaitEventIO = 167772208;
pub const WaitEventIO_WAIT_EVENT_SLRU_WRITE: WaitEventIO = 167772209;
pub const WaitEventIO_WAIT_EVENT_SNAPBUILD_READ: WaitEventIO = 167772210;
pub const WaitEventIO_WAIT_EVENT_SNAPBUILD_SYNC: WaitEventIO = 167772211;
pub const WaitEventIO_WAIT_EVENT_SNAPBUILD_WRITE: WaitEventIO = 167772212;
pub const WaitEventIO_WAIT_EVENT_TIMELINE_HISTORY_FILE_SYNC: WaitEventIO = 167772213;
pub const WaitEventIO_WAIT_EVENT_TIMELINE_HISTORY_FILE_WRITE: WaitEventIO = 167772214;
pub const WaitEventIO_WAIT_EVENT_TIMELINE_HISTORY_READ: WaitEventIO = 167772215;
pub const WaitEventIO_WAIT_EVENT_TIMELINE_HISTORY_SYNC: WaitEventIO = 167772216;
pub const WaitEventIO_WAIT_EVENT_TIMELINE_HISTORY_WRITE: WaitEventIO = 167772217;
pub const WaitEventIO_WAIT_EVENT_TWOPHASE_FILE_READ: WaitEventIO = 167772218;
pub const WaitEventIO_WAIT_EVENT_TWOPHASE_FILE_SYNC: WaitEventIO = 167772219;
pub const WaitEventIO_WAIT_EVENT_TWOPHASE_FILE_WRITE: WaitEventIO = 167772220;
pub const WaitEventIO_WAIT_EVENT_VERSION_FILE_WRITE: WaitEventIO = 167772221;
pub const WaitEventIO_WAIT_EVENT_WALSENDER_TIMELINE_HISTORY_READ: WaitEventIO = 167772222;
pub const WaitEventIO_WAIT_EVENT_WAL_BOOTSTRAP_SYNC: WaitEventIO = 167772223;
pub const WaitEventIO_WAIT_EVENT_WAL_BOOTSTRAP_WRITE: WaitEventIO = 167772224;
pub const WaitEventIO_WAIT_EVENT_WAL_COPY_READ: WaitEventIO = 167772225;
pub const WaitEventIO_WAIT_EVENT_WAL_COPY_SYNC: WaitEventIO = 167772226;
pub const WaitEventIO_WAIT_EVENT_WAL_COPY_WRITE: WaitEventIO = 167772227;
pub const WaitEventIO_WAIT_EVENT_WAL_INIT_SYNC: WaitEventIO = 167772228;
pub const WaitEventIO_WAIT_EVENT_WAL_INIT_WRITE: WaitEventIO = 167772229;
pub const WaitEventIO_WAIT_EVENT_WAL_READ: WaitEventIO = 167772230;
pub const WaitEventIO_WAIT_EVENT_WAL_SYNC: WaitEventIO = 167772231;
pub const WaitEventIO_WAIT_EVENT_WAL_SYNC_METHOD_ASSIGN: WaitEventIO = 167772232;
pub const WaitEventIO_WAIT_EVENT_WAL_WRITE: WaitEventIO = 167772233;
pub type WaitEventIO = ::std::os::raw::c_uint;
pub const PgStat_Kind_PGSTAT_KIND_INVALID: PgStat_Kind = 0;
pub const PgStat_Kind_PGSTAT_KIND_DATABASE: PgStat_Kind = 1;
pub const PgStat_Kind_PGSTAT_KIND_RELATION: PgStat_Kind = 2;
pub const PgStat_Kind_PGSTAT_KIND_FUNCTION: PgStat_Kind = 3;
pub const PgStat_Kind_PGSTAT_KIND_REPLSLOT: PgStat_Kind = 4;
pub const PgStat_Kind_PGSTAT_KIND_SUBSCRIPTION: PgStat_Kind = 5;
pub const PgStat_Kind_PGSTAT_KIND_ARCHIVER: PgStat_Kind = 6;
pub const PgStat_Kind_PGSTAT_KIND_BGWRITER: PgStat_Kind = 7;
pub const PgStat_Kind_PGSTAT_KIND_CHECKPOINTER: PgStat_Kind = 8;
pub const PgStat_Kind_PGSTAT_KIND_IO: PgStat_Kind = 9;
pub const PgStat_Kind_PGSTAT_KIND_SLRU: PgStat_Kind = 10;
pub const PgStat_Kind_PGSTAT_KIND_WAL: PgStat_Kind = 11;
pub type PgStat_Kind = ::std::os::raw::c_uint;
pub const TrackFunctionsLevel_TRACK_FUNC_OFF: TrackFunctionsLevel = 0;
pub const TrackFunctionsLevel_TRACK_FUNC_PL: TrackFunctionsLevel = 1;
pub const TrackFunctionsLevel_TRACK_FUNC_ALL: TrackFunctionsLevel = 2;
pub type TrackFunctionsLevel = ::std::os::raw::c_uint;
pub const PgStat_FetchConsistency_PGSTAT_FETCH_CONSISTENCY_NONE: PgStat_FetchConsistency = 0;
pub const PgStat_FetchConsistency_PGSTAT_FETCH_CONSISTENCY_CACHE: PgStat_FetchConsistency = 1;
pub const PgStat_FetchConsistency_PGSTAT_FETCH_CONSISTENCY_SNAPSHOT: PgStat_FetchConsistency = 2;
pub type PgStat_FetchConsistency = ::std::os::raw::c_uint;
pub const SessionEndType_DISCONNECT_NOT_YET: SessionEndType = 0;
pub const SessionEndType_DISCONNECT_NORMAL: SessionEndType = 1;
pub const SessionEndType_DISCONNECT_CLIENT_EOF: SessionEndType = 2;
pub const SessionEndType_DISCONNECT_FATAL: SessionEndType = 3;
pub const SessionEndType_DISCONNECT_KILLED: SessionEndType = 4;
pub type SessionEndType = ::std::os::raw::c_uint;
pub type PgStat_Counter = int64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_FunctionCounts {
    pub numcalls: PgStat_Counter,
    pub total_time: instr_time,
    pub self_time: instr_time,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_FunctionCallUsage {
    pub fs: *mut PgStat_FunctionCounts,
    pub save_f_total_time: instr_time,
    pub save_total: instr_time,
    pub start: instr_time,
}
impl Default for PgStat_FunctionCallUsage {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_BackendSubEntry {
    pub apply_error_count: PgStat_Counter,
    pub sync_error_count: PgStat_Counter,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_TableCounts {
    pub numscans: PgStat_Counter,
    pub tuples_returned: PgStat_Counter,
    pub tuples_fetched: PgStat_Counter,
    pub tuples_inserted: PgStat_Counter,
    pub tuples_updated: PgStat_Counter,
    pub tuples_deleted: PgStat_Counter,
    pub tuples_hot_updated: PgStat_Counter,
    pub tuples_newpage_updated: PgStat_Counter,
    pub truncdropped: bool,
    pub delta_live_tuples: PgStat_Counter,
    pub delta_dead_tuples: PgStat_Counter,
    pub changed_tuples: PgStat_Counter,
    pub blocks_fetched: PgStat_Counter,
    pub blocks_hit: PgStat_Counter,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_TableStatus {
    pub id: Oid,
    pub shared: bool,
    pub trans: *mut PgStat_TableXactStatus,
    pub counts: PgStat_TableCounts,
    pub relation: Relation,
}
impl Default for PgStat_TableStatus {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_TableXactStatus {
    pub tuples_inserted: PgStat_Counter,
    pub tuples_updated: PgStat_Counter,
    pub tuples_deleted: PgStat_Counter,
    pub truncdropped: bool,
    pub inserted_pre_truncdrop: PgStat_Counter,
    pub updated_pre_truncdrop: PgStat_Counter,
    pub deleted_pre_truncdrop: PgStat_Counter,
    pub nest_level: ::std::os::raw::c_int,
    pub upper: *mut PgStat_TableXactStatus,
    pub parent: *mut PgStat_TableStatus,
    pub next: *mut PgStat_TableXactStatus,
}
impl Default for PgStat_TableXactStatus {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_ArchiverStats {
    pub archived_count: PgStat_Counter,
    pub last_archived_wal: [::std::os::raw::c_char; 41usize],
    pub last_archived_timestamp: TimestampTz,
    pub failed_count: PgStat_Counter,
    pub last_failed_wal: [::std::os::raw::c_char; 41usize],
    pub last_failed_timestamp: TimestampTz,
    pub stat_reset_timestamp: TimestampTz,
}
impl Default for PgStat_ArchiverStats {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_BgWriterStats {
    pub buf_written_clean: PgStat_Counter,
    pub maxwritten_clean: PgStat_Counter,
    pub buf_alloc: PgStat_Counter,
    pub stat_reset_timestamp: TimestampTz,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_CheckpointerStats {
    pub timed_checkpoints: PgStat_Counter,
    pub requested_checkpoints: PgStat_Counter,
    pub checkpoint_write_time: PgStat_Counter,
    pub checkpoint_sync_time: PgStat_Counter,
    pub buf_written_checkpoints: PgStat_Counter,
    pub buf_written_backend: PgStat_Counter,
    pub buf_fsync_backend: PgStat_Counter,
}
pub const IOObject_IOOBJECT_RELATION: IOObject = 0;
pub const IOObject_IOOBJECT_TEMP_RELATION: IOObject = 1;
pub type IOObject = ::std::os::raw::c_uint;
pub const IOContext_IOCONTEXT_BULKREAD: IOContext = 0;
pub const IOContext_IOCONTEXT_BULKWRITE: IOContext = 1;
pub const IOContext_IOCONTEXT_NORMAL: IOContext = 2;
pub const IOContext_IOCONTEXT_VACUUM: IOContext = 3;
pub type IOContext = ::std::os::raw::c_uint;
pub const IOOp_IOOP_EVICT: IOOp = 0;
pub const IOOp_IOOP_EXTEND: IOOp = 1;
pub const IOOp_IOOP_FSYNC: IOOp = 2;
pub const IOOp_IOOP_HIT: IOOp = 3;
pub const IOOp_IOOP_READ: IOOp = 4;
pub const IOOp_IOOP_REUSE: IOOp = 5;
pub const IOOp_IOOP_WRITE: IOOp = 6;
pub const IOOp_IOOP_WRITEBACK: IOOp = 7;
pub type IOOp = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_BktypeIO {
    pub counts: [[[PgStat_Counter; 8usize]; 4usize]; 2usize],
    pub times: [[[PgStat_Counter; 8usize]; 4usize]; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_IO {
    pub stat_reset_timestamp: TimestampTz,
    pub stats: [PgStat_BktypeIO; 14usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_StatDBEntry {
    pub xact_commit: PgStat_Counter,
    pub xact_rollback: PgStat_Counter,
    pub blocks_fetched: PgStat_Counter,
    pub blocks_hit: PgStat_Counter,
    pub tuples_returned: PgStat_Counter,
    pub tuples_fetched: PgStat_Counter,
    pub tuples_inserted: PgStat_Counter,
    pub tuples_updated: PgStat_Counter,
    pub tuples_deleted: PgStat_Counter,
    pub last_autovac_time: TimestampTz,
    pub conflict_tablespace: PgStat_Counter,
    pub conflict_lock: PgStat_Counter,
    pub conflict_snapshot: PgStat_Counter,
    pub conflict_logicalslot: PgStat_Counter,
    pub conflict_bufferpin: PgStat_Counter,
    pub conflict_startup_deadlock: PgStat_Counter,
    pub temp_files: PgStat_Counter,
    pub temp_bytes: PgStat_Counter,
    pub deadlocks: PgStat_Counter,
    pub checksum_failures: PgStat_Counter,
    pub last_checksum_failure: TimestampTz,
    pub blk_read_time: PgStat_Counter,
    pub blk_write_time: PgStat_Counter,
    pub sessions: PgStat_Counter,
    pub session_time: PgStat_Counter,
    pub active_time: PgStat_Counter,
    pub idle_in_transaction_time: PgStat_Counter,
    pub sessions_abandoned: PgStat_Counter,
    pub sessions_fatal: PgStat_Counter,
    pub sessions_killed: PgStat_Counter,
    pub stat_reset_timestamp: TimestampTz,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_StatFuncEntry {
    pub numcalls: PgStat_Counter,
    pub total_time: PgStat_Counter,
    pub self_time: PgStat_Counter,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_StatReplSlotEntry {
    pub spill_txns: PgStat_Counter,
    pub spill_count: PgStat_Counter,
    pub spill_bytes: PgStat_Counter,
    pub stream_txns: PgStat_Counter,
    pub stream_count: PgStat_Counter,
    pub stream_bytes: PgStat_Counter,
    pub total_txns: PgStat_Counter,
    pub total_bytes: PgStat_Counter,
    pub stat_reset_timestamp: TimestampTz,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_SLRUStats {
    pub blocks_zeroed: PgStat_Counter,
    pub blocks_hit: PgStat_Counter,
    pub blocks_read: PgStat_Counter,
    pub blocks_written: PgStat_Counter,
    pub blocks_exists: PgStat_Counter,
    pub flush: PgStat_Counter,
    pub truncate: PgStat_Counter,
    pub stat_reset_timestamp: TimestampTz,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_StatSubEntry {
    pub apply_error_count: PgStat_Counter,
    pub sync_error_count: PgStat_Counter,
    pub stat_reset_timestamp: TimestampTz,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_StatTabEntry {
    pub numscans: PgStat_Counter,
    pub lastscan: TimestampTz,
    pub tuples_returned: PgStat_Counter,
    pub tuples_fetched: PgStat_Counter,
    pub tuples_inserted: PgStat_Counter,
    pub tuples_updated: PgStat_Counter,
    pub tuples_deleted: PgStat_Counter,
    pub tuples_hot_updated: PgStat_Counter,
    pub tuples_newpage_updated: PgStat_Counter,
    pub live_tuples: PgStat_Counter,
    pub dead_tuples: PgStat_Counter,
    pub mod_since_analyze: PgStat_Counter,
    pub ins_since_vacuum: PgStat_Counter,
    pub blocks_fetched: PgStat_Counter,
    pub blocks_hit: PgStat_Counter,
    pub last_vacuum_time: TimestampTz,
    pub vacuum_count: PgStat_Counter,
    pub last_autovacuum_time: TimestampTz,
    pub autovacuum_count: PgStat_Counter,
    pub last_analyze_time: TimestampTz,
    pub analyze_count: PgStat_Counter,
    pub last_autoanalyze_time: TimestampTz,
    pub autoanalyze_count: PgStat_Counter,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_WalStats {
    pub wal_records: PgStat_Counter,
    pub wal_fpi: PgStat_Counter,
    pub wal_bytes: uint64,
    pub wal_buffers_full: PgStat_Counter,
    pub wal_write: PgStat_Counter,
    pub wal_sync: PgStat_Counter,
    pub wal_write_time: PgStat_Counter,
    pub wal_sync_time: PgStat_Counter,
    pub stat_reset_timestamp: TimestampTz,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_PendingWalStats {
    pub wal_buffers_full: PgStat_Counter,
    pub wal_write: PgStat_Counter,
    pub wal_sync: PgStat_Counter,
    pub wal_write_time: instr_time,
    pub wal_sync_time: instr_time,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScanKeyData {
    pub sk_flags: ::std::os::raw::c_int,
    pub sk_attno: AttrNumber,
    pub sk_strategy: StrategyNumber,
    pub sk_subtype: Oid,
    pub sk_collation: Oid,
    pub sk_func: FmgrInfo,
    pub sk_argument: Datum,
}
impl Default for ScanKeyData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ScanKey = *mut ScanKeyData;
pub type LOCKMASK = ::std::os::raw::c_int;
pub type LOCKMODE = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xl_standby_lock {
    pub xid: TransactionId,
    pub dbOid: Oid,
    pub relOid: Oid,
}
impl Default for xl_standby_lock {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IndexBuildResult {
    pub heap_tuples: f64,
    pub index_tuples: f64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexVacuumInfo {
    pub index: Relation,
    pub heaprel: Relation,
    pub analyze_only: bool,
    pub report_progress: bool,
    pub estimated_count: bool,
    pub message_level: ::std::os::raw::c_int,
    pub num_heap_tuples: f64,
    pub strategy: BufferAccessStrategy,
}
impl Default for IndexVacuumInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IndexBulkDeleteResult {
    pub num_pages: BlockNumber,
    pub estimated_count: bool,
    pub num_index_tuples: f64,
    pub tuples_removed: f64,
    pub pages_newly_deleted: BlockNumber,
    pub pages_deleted: BlockNumber,
    pub pages_free: BlockNumber,
}
pub type IndexBulkDeleteCallback = ::std::option::Option<
    unsafe extern "C" fn(itemptr: ItemPointer, state: *mut ::std::os::raw::c_void) -> bool,
>;
pub type IndexScanDesc = *mut IndexScanDescData;
pub type SysScanDesc = *mut SysScanDescData;
pub type ParallelIndexScanDesc = *mut ParallelIndexScanDescData;
pub const IndexUniqueCheck_UNIQUE_CHECK_NO: IndexUniqueCheck = 0;
pub const IndexUniqueCheck_UNIQUE_CHECK_YES: IndexUniqueCheck = 1;
pub const IndexUniqueCheck_UNIQUE_CHECK_PARTIAL: IndexUniqueCheck = 2;
pub const IndexUniqueCheck_UNIQUE_CHECK_EXISTING: IndexUniqueCheck = 3;
pub type IndexUniqueCheck = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IndexOrderByDistance {
    pub value: f64,
    pub isnull: bool,
}
pub const IndexAMProperty_AMPROP_UNKNOWN: IndexAMProperty = 0;
pub const IndexAMProperty_AMPROP_ASC: IndexAMProperty = 1;
pub const IndexAMProperty_AMPROP_DESC: IndexAMProperty = 2;
pub const IndexAMProperty_AMPROP_NULLS_FIRST: IndexAMProperty = 3;
pub const IndexAMProperty_AMPROP_NULLS_LAST: IndexAMProperty = 4;
pub const IndexAMProperty_AMPROP_ORDERABLE: IndexAMProperty = 5;
pub const IndexAMProperty_AMPROP_DISTANCE_ORDERABLE: IndexAMProperty = 6;
pub const IndexAMProperty_AMPROP_RETURNABLE: IndexAMProperty = 7;
pub const IndexAMProperty_AMPROP_SEARCH_ARRAY: IndexAMProperty = 8;
pub const IndexAMProperty_AMPROP_SEARCH_NULLS: IndexAMProperty = 9;
pub const IndexAMProperty_AMPROP_CLUSTERABLE: IndexAMProperty = 10;
pub const IndexAMProperty_AMPROP_INDEX_SCAN: IndexAMProperty = 11;
pub const IndexAMProperty_AMPROP_BITMAP_SCAN: IndexAMProperty = 12;
pub const IndexAMProperty_AMPROP_BACKWARD_SCAN: IndexAMProperty = 13;
pub const IndexAMProperty_AMPROP_CAN_ORDER: IndexAMProperty = 14;
pub const IndexAMProperty_AMPROP_CAN_UNIQUE: IndexAMProperty = 15;
pub const IndexAMProperty_AMPROP_CAN_MULTI_COL: IndexAMProperty = 16;
pub const IndexAMProperty_AMPROP_CAN_EXCLUDE: IndexAMProperty = 17;
pub const IndexAMProperty_AMPROP_CAN_INCLUDE: IndexAMProperty = 18;
pub type IndexAMProperty = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpFamilyMember {
    pub is_func: bool,
    pub object: Oid,
    pub number: ::std::os::raw::c_int,
    pub lefttype: Oid,
    pub righttype: Oid,
    pub sortfamily: Oid,
    pub ref_is_hard: bool,
    pub ref_is_family: bool,
    pub refobjid: Oid,
}
impl Default for OpFamilyMember {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ambuild_function = ::std::option::Option<
    unsafe extern "C" fn(
        heapRelation: Relation,
        indexRelation: Relation,
        indexInfo: *mut IndexInfo,
    ) -> *mut IndexBuildResult,
>;
pub type ambuildempty_function =
    ::std::option::Option<unsafe extern "C" fn(indexRelation: Relation)>;
pub type aminsert_function = ::std::option::Option<
    unsafe extern "C" fn(
        indexRelation: Relation,
        values: *mut Datum,
        isnull: *mut bool,
        heap_tid: ItemPointer,
        heapRelation: Relation,
        checkUnique: IndexUniqueCheck,
        indexUnchanged: bool,
        indexInfo: *mut IndexInfo,
    ) -> bool,
>;
pub type ambulkdelete_function = ::std::option::Option<
    unsafe extern "C" fn(
        info: *mut IndexVacuumInfo,
        stats: *mut IndexBulkDeleteResult,
        callback: IndexBulkDeleteCallback,
        callback_state: *mut ::std::os::raw::c_void,
    ) -> *mut IndexBulkDeleteResult,
>;
pub type amvacuumcleanup_function = ::std::option::Option<
    unsafe extern "C" fn(
        info: *mut IndexVacuumInfo,
        stats: *mut IndexBulkDeleteResult,
    ) -> *mut IndexBulkDeleteResult,
>;
pub type amcanreturn_function = ::std::option::Option<
    unsafe extern "C" fn(indexRelation: Relation, attno: ::std::os::raw::c_int) -> bool,
>;
pub type amcostestimate_function = ::std::option::Option<
    unsafe extern "C" fn(
        root: *mut PlannerInfo,
        path: *mut IndexPath,
        loop_count: f64,
        indexStartupCost: *mut Cost,
        indexTotalCost: *mut Cost,
        indexSelectivity: *mut Selectivity,
        indexCorrelation: *mut f64,
        indexPages: *mut f64,
    ),
>;
pub type amoptions_function =
    ::std::option::Option<unsafe extern "C" fn(reloptions: Datum, validate: bool) -> *mut bytea>;
pub type amproperty_function = ::std::option::Option<
    unsafe extern "C" fn(
        index_oid: Oid,
        attno: ::std::os::raw::c_int,
        prop: IndexAMProperty,
        propname: *const ::std::os::raw::c_char,
        res: *mut bool,
        isnull: *mut bool,
    ) -> bool,
>;
pub type ambuildphasename_function =
    ::std::option::Option<unsafe extern "C" fn(phasenum: int64) -> *mut ::std::os::raw::c_char>;
pub type amvalidate_function = ::std::option::Option<unsafe extern "C" fn(opclassoid: Oid) -> bool>;
pub type amadjustmembers_function = ::std::option::Option<
    unsafe extern "C" fn(
        opfamilyoid: Oid,
        opclassoid: Oid,
        operators: *mut List,
        functions: *mut List,
    ),
>;
pub type ambeginscan_function = ::std::option::Option<
    unsafe extern "C" fn(
        indexRelation: Relation,
        nkeys: ::std::os::raw::c_int,
        norderbys: ::std::os::raw::c_int,
    ) -> IndexScanDesc,
>;
pub type amrescan_function = ::std::option::Option<
    unsafe extern "C" fn(
        scan: IndexScanDesc,
        keys: ScanKey,
        nkeys: ::std::os::raw::c_int,
        orderbys: ScanKey,
        norderbys: ::std::os::raw::c_int,
    ),
>;
pub type amgettuple_function = ::std::option::Option<
    unsafe extern "C" fn(scan: IndexScanDesc, direction: ScanDirection) -> bool,
>;
pub type amgetbitmap_function =
    ::std::option::Option<unsafe extern "C" fn(scan: IndexScanDesc, tbm: *mut TIDBitmap) -> int64>;
pub type amendscan_function = ::std::option::Option<unsafe extern "C" fn(scan: IndexScanDesc)>;
pub type ammarkpos_function = ::std::option::Option<unsafe extern "C" fn(scan: IndexScanDesc)>;
pub type amrestrpos_function = ::std::option::Option<unsafe extern "C" fn(scan: IndexScanDesc)>;
pub type amestimateparallelscan_function = ::std::option::Option<unsafe extern "C" fn() -> Size>;
pub type aminitparallelscan_function =
    ::std::option::Option<unsafe extern "C" fn(target: *mut ::std::os::raw::c_void)>;
pub type amparallelrescan_function =
    ::std::option::Option<unsafe extern "C" fn(scan: IndexScanDesc)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexAmRoutine {
    pub type_: NodeTag,
    pub amstrategies: uint16,
    pub amsupport: uint16,
    pub amoptsprocnum: uint16,
    pub amcanorder: bool,
    pub amcanorderbyop: bool,
    pub amcanbackward: bool,
    pub amcanunique: bool,
    pub amcanmulticol: bool,
    pub amoptionalkey: bool,
    pub amsearcharray: bool,
    pub amsearchnulls: bool,
    pub amstorage: bool,
    pub amclusterable: bool,
    pub ampredlocks: bool,
    pub amcanparallel: bool,
    pub amcaninclude: bool,
    pub amusemaintenanceworkmem: bool,
    pub amsummarizing: bool,
    pub amparallelvacuumoptions: uint8,
    pub amkeytype: Oid,
    pub ambuild: ambuild_function,
    pub ambuildempty: ambuildempty_function,
    pub aminsert: aminsert_function,
    pub ambulkdelete: ambulkdelete_function,
    pub amvacuumcleanup: amvacuumcleanup_function,
    pub amcanreturn: amcanreturn_function,
    pub amcostestimate: amcostestimate_function,
    pub amoptions: amoptions_function,
    pub amproperty: amproperty_function,
    pub ambuildphasename: ambuildphasename_function,
    pub amvalidate: amvalidate_function,
    pub amadjustmembers: amadjustmembers_function,
    pub ambeginscan: ambeginscan_function,
    pub amrescan: amrescan_function,
    pub amgettuple: amgettuple_function,
    pub amgetbitmap: amgetbitmap_function,
    pub amendscan: amendscan_function,
    pub ammarkpos: ammarkpos_function,
    pub amrestrpos: amrestrpos_function,
    pub amestimateparallelscan: amestimateparallelscan_function,
    pub aminitparallelscan: aminitparallelscan_function,
    pub amparallelrescan: amparallelrescan_function,
}
impl Default for IndexAmRoutine {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BackupState {
    pub name: [::std::os::raw::c_char; 1025usize],
    pub startpoint: XLogRecPtr,
    pub starttli: TimeLineID,
    pub checkpointloc: XLogRecPtr,
    pub starttime: pg_time_t,
    pub started_in_recovery: bool,
    pub stoppoint: XLogRecPtr,
    pub stoptli: TimeLineID,
    pub stoptime: pg_time_t,
}
impl Default for BackupState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ArchiveMode_ARCHIVE_MODE_OFF: ArchiveMode = 0;
pub const ArchiveMode_ARCHIVE_MODE_ON: ArchiveMode = 1;
pub const ArchiveMode_ARCHIVE_MODE_ALWAYS: ArchiveMode = 2;
pub type ArchiveMode = ::std::os::raw::c_uint;
pub const WalLevel_WAL_LEVEL_MINIMAL: WalLevel = 0;
pub const WalLevel_WAL_LEVEL_REPLICA: WalLevel = 1;
pub const WalLevel_WAL_LEVEL_LOGICAL: WalLevel = 2;
pub type WalLevel = ::std::os::raw::c_uint;
pub const WalCompression_WAL_COMPRESSION_NONE: WalCompression = 0;
pub const WalCompression_WAL_COMPRESSION_PGLZ: WalCompression = 1;
pub const WalCompression_WAL_COMPRESSION_LZ4: WalCompression = 2;
pub const WalCompression_WAL_COMPRESSION_ZSTD: WalCompression = 3;
pub type WalCompression = ::std::os::raw::c_uint;
pub const RecoveryState_RECOVERY_STATE_CRASH: RecoveryState = 0;
pub const RecoveryState_RECOVERY_STATE_ARCHIVE: RecoveryState = 1;
pub const RecoveryState_RECOVERY_STATE_DONE: RecoveryState = 2;
pub type RecoveryState = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CheckpointStatsData {
    pub ckpt_start_t: TimestampTz,
    pub ckpt_write_t: TimestampTz,
    pub ckpt_sync_t: TimestampTz,
    pub ckpt_sync_end_t: TimestampTz,
    pub ckpt_end_t: TimestampTz,
    pub ckpt_bufs_written: ::std::os::raw::c_int,
    pub ckpt_segs_added: ::std::os::raw::c_int,
    pub ckpt_segs_removed: ::std::os::raw::c_int,
    pub ckpt_segs_recycled: ::std::os::raw::c_int,
    pub ckpt_sync_rels: ::std::os::raw::c_int,
    pub ckpt_longest_sync: uint64,
    pub ckpt_agg_sync_time: uint64,
}
pub const WALAvailability_WALAVAIL_INVALID_LSN: WALAvailability = 0;
pub const WALAvailability_WALAVAIL_RESERVED: WALAvailability = 1;
pub const WALAvailability_WALAVAIL_EXTENDED: WALAvailability = 2;
pub const WALAvailability_WALAVAIL_UNRESERVED: WALAvailability = 3;
pub const WALAvailability_WALAVAIL_REMOVED: WALAvailability = 4;
pub type WALAvailability = ::std::os::raw::c_uint;
pub const SessionBackupState_SESSION_BACKUP_NONE: SessionBackupState = 0;
pub const SessionBackupState_SESSION_BACKUP_RUNNING: SessionBackupState = 1;
pub type SessionBackupState = ::std::os::raw::c_uint;
pub type RmgrId = uint8;
pub const RmgrIds_RM_XLOG_ID: RmgrIds = 0;
pub const RmgrIds_RM_XACT_ID: RmgrIds = 1;
pub const RmgrIds_RM_SMGR_ID: RmgrIds = 2;
pub const RmgrIds_RM_CLOG_ID: RmgrIds = 3;
pub const RmgrIds_RM_DBASE_ID: RmgrIds = 4;
pub const RmgrIds_RM_TBLSPC_ID: RmgrIds = 5;
pub const RmgrIds_RM_MULTIXACT_ID: RmgrIds = 6;
pub const RmgrIds_RM_RELMAP_ID: RmgrIds = 7;
pub const RmgrIds_RM_STANDBY_ID: RmgrIds = 8;
pub const RmgrIds_RM_HEAP2_ID: RmgrIds = 9;
pub const RmgrIds_RM_HEAP_ID: RmgrIds = 10;
pub const RmgrIds_RM_BTREE_ID: RmgrIds = 11;
pub const RmgrIds_RM_HASH_ID: RmgrIds = 12;
pub const RmgrIds_RM_GIN_ID: RmgrIds = 13;
pub const RmgrIds_RM_GIST_ID: RmgrIds = 14;
pub const RmgrIds_RM_SEQ_ID: RmgrIds = 15;
pub const RmgrIds_RM_SPGIST_ID: RmgrIds = 16;
pub const RmgrIds_RM_BRIN_ID: RmgrIds = 17;
pub const RmgrIds_RM_COMMIT_TS_ID: RmgrIds = 18;
pub const RmgrIds_RM_REPLORIGIN_ID: RmgrIds = 19;
pub const RmgrIds_RM_GENERIC_ID: RmgrIds = 20;
pub const RmgrIds_RM_LOGICALMSG_ID: RmgrIds = 21;
pub const RmgrIds_RM_NEXT_ID: RmgrIds = 22;
pub type RmgrIds = ::std::os::raw::c_uint;
pub type pg_crc32c = uint32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RelFileLocator {
    pub spcOid: Oid,
    pub dbOid: Oid,
    pub relNumber: RelFileNumber,
}
impl Default for RelFileLocator {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RelFileLocatorBackend {
    pub locator: RelFileLocator,
    pub backend: BackendId,
}
impl Default for RelFileLocatorBackend {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct XLogRecord {
    pub xl_tot_len: uint32,
    pub xl_xid: TransactionId,
    pub xl_prev: XLogRecPtr,
    pub xl_info: uint8,
    pub xl_rmid: RmgrId,
    pub xl_crc: pg_crc32c,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct XLogRecordBlockHeader {
    pub id: uint8,
    pub fork_flags: uint8,
    pub data_length: uint16,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct XLogRecordBlockImageHeader {
    pub length: uint16,
    pub hole_offset: uint16,
    pub bimg_info: uint8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct XLogRecordBlockCompressHeader {
    pub hole_length: uint16,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct XLogRecordDataHeaderShort {
    pub id: uint8,
    pub data_length: uint8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct XLogRecordDataHeaderLong {
    pub id: uint8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WALOpenSegment {
    pub ws_file: ::std::os::raw::c_int,
    pub ws_segno: XLogSegNo,
    pub ws_tli: TimeLineID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WALSegmentContext {
    pub ws_dir: [::std::os::raw::c_char; 1024usize],
    pub ws_segsize: ::std::os::raw::c_int,
}
impl Default for WALSegmentContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type XLogPageReadCB = ::std::option::Option<
    unsafe extern "C" fn(
        xlogreader: *mut XLogReaderState,
        targetPagePtr: XLogRecPtr,
        reqLen: ::std::os::raw::c_int,
        targetRecPtr: XLogRecPtr,
        readBuf: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
pub type WALSegmentOpenCB = ::std::option::Option<
    unsafe extern "C" fn(
        xlogreader: *mut XLogReaderState,
        nextSegNo: XLogSegNo,
        tli_p: *mut TimeLineID,
    ),
>;
pub type WALSegmentCloseCB =
    ::std::option::Option<unsafe extern "C" fn(xlogreader: *mut XLogReaderState)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct XLogReaderRoutine {
    pub page_read: XLogPageReadCB,
    pub segment_open: WALSegmentOpenCB,
    pub segment_close: WALSegmentCloseCB,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DecodedBkpBlock {
    pub in_use: bool,
    pub rlocator: RelFileLocator,
    pub forknum: ForkNumber,
    pub blkno: BlockNumber,
    pub prefetch_buffer: Buffer,
    pub flags: uint8,
    pub has_image: bool,
    pub apply_image: bool,
    pub bkp_image: *mut ::std::os::raw::c_char,
    pub hole_offset: uint16,
    pub hole_length: uint16,
    pub bimg_len: uint16,
    pub bimg_info: uint8,
    pub has_data: bool,
    pub data: *mut ::std::os::raw::c_char,
    pub data_len: uint16,
    pub data_bufsz: uint16,
}
impl Default for DecodedBkpBlock {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct DecodedXLogRecord {
    pub size: usize,
    pub oversized: bool,
    pub next: *mut DecodedXLogRecord,
    pub lsn: XLogRecPtr,
    pub next_lsn: XLogRecPtr,
    pub header: XLogRecord,
    pub record_origin: RepOriginId,
    pub toplevel_xid: TransactionId,
    pub main_data: *mut ::std::os::raw::c_char,
    pub main_data_len: uint32,
    pub max_block_id: ::std::os::raw::c_int,
    pub blocks: __IncompleteArrayField<DecodedBkpBlock>,
}
impl Default for DecodedXLogRecord {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLogReaderState {
    pub routine: XLogReaderRoutine,
    pub system_identifier: uint64,
    pub private_data: *mut ::std::os::raw::c_void,
    pub ReadRecPtr: XLogRecPtr,
    pub EndRecPtr: XLogRecPtr,
    pub abortedRecPtr: XLogRecPtr,
    pub missingContrecPtr: XLogRecPtr,
    pub overwrittenRecPtr: XLogRecPtr,
    pub DecodeRecPtr: XLogRecPtr,
    pub NextRecPtr: XLogRecPtr,
    pub PrevRecPtr: XLogRecPtr,
    pub record: *mut DecodedXLogRecord,
    pub decode_buffer: *mut ::std::os::raw::c_char,
    pub decode_buffer_size: usize,
    pub free_decode_buffer: bool,
    pub decode_buffer_head: *mut ::std::os::raw::c_char,
    pub decode_buffer_tail: *mut ::std::os::raw::c_char,
    pub decode_queue_head: *mut DecodedXLogRecord,
    pub decode_queue_tail: *mut DecodedXLogRecord,
    pub readBuf: *mut ::std::os::raw::c_char,
    pub readLen: uint32,
    pub segcxt: WALSegmentContext,
    pub seg: WALOpenSegment,
    pub segoff: uint32,
    pub latestPagePtr: XLogRecPtr,
    pub latestPageTLI: TimeLineID,
    pub currRecPtr: XLogRecPtr,
    pub currTLI: TimeLineID,
    pub currTLIValidUntil: XLogRecPtr,
    pub nextTLI: TimeLineID,
    pub readRecordBuf: *mut ::std::os::raw::c_char,
    pub readRecordBufSize: uint32,
    pub errormsg_buf: *mut ::std::os::raw::c_char,
    pub errormsg_deferred: bool,
    pub nonblocking: bool,
}
impl Default for XLogReaderState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const XLogPageReadResult_XLREAD_SUCCESS: XLogPageReadResult = 0;
pub const XLogPageReadResult_XLREAD_FAIL: XLogPageReadResult = -1;
pub const XLogPageReadResult_XLREAD_WOULDBLOCK: XLogPageReadResult = -2;
pub type XLogPageReadResult = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WALReadError {
    pub wre_errno: ::std::os::raw::c_int,
    pub wre_off: ::std::os::raw::c_int,
    pub wre_req: ::std::os::raw::c_int,
    pub wre_read: ::std::os::raw::c_int,
    pub wre_seg: WALOpenSegment,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct XLogPageHeaderData {
    pub xlp_magic: uint16,
    pub xlp_info: uint16,
    pub xlp_tli: TimeLineID,
    pub xlp_pageaddr: XLogRecPtr,
    pub xlp_rem_len: uint32,
}
pub type XLogPageHeader = *mut XLogPageHeaderData;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct XLogLongPageHeaderData {
    pub std: XLogPageHeaderData,
    pub xlp_sysid: uint64,
    pub xlp_seg_size: uint32,
    pub xlp_xlog_blcksz: uint32,
}
pub type XLogLongPageHeader = *mut XLogLongPageHeaderData;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xl_parameter_change {
    pub MaxConnections: ::std::os::raw::c_int,
    pub max_worker_processes: ::std::os::raw::c_int,
    pub max_wal_senders: ::std::os::raw::c_int,
    pub max_prepared_xacts: ::std::os::raw::c_int,
    pub max_locks_per_xact: ::std::os::raw::c_int,
    pub wal_level: ::std::os::raw::c_int,
    pub wal_log_hints: bool,
    pub track_commit_timestamp: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xl_restore_point {
    pub rp_time: TimestampTz,
    pub rp_name: [::std::os::raw::c_char; 64usize],
}
impl Default for xl_restore_point {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xl_overwrite_contrecord {
    pub overwritten_lsn: XLogRecPtr,
    pub overwrite_time: TimestampTz,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xl_end_of_recovery {
    pub end_time: TimestampTz,
    pub ThisTimeLineID: TimeLineID,
    pub PrevTimeLineID: TimeLineID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLogRecData {
    pub next: *mut XLogRecData,
    pub data: *mut ::std::os::raw::c_char,
    pub len: uint32,
}
impl Default for XLogRecData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const RecoveryTargetAction_RECOVERY_TARGET_ACTION_PAUSE: RecoveryTargetAction = 0;
pub const RecoveryTargetAction_RECOVERY_TARGET_ACTION_PROMOTE: RecoveryTargetAction = 1;
pub const RecoveryTargetAction_RECOVERY_TARGET_ACTION_SHUTDOWN: RecoveryTargetAction = 2;
pub type RecoveryTargetAction = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLogRecordBuffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RmgrData {
    pub rm_name: *const ::std::os::raw::c_char,
    pub rm_redo: ::std::option::Option<unsafe extern "C" fn(record: *mut XLogReaderState)>,
    pub rm_desc:
        ::std::option::Option<unsafe extern "C" fn(buf: StringInfo, record: *mut XLogReaderState)>,
    pub rm_identify:
        ::std::option::Option<unsafe extern "C" fn(info: uint8) -> *const ::std::os::raw::c_char>,
    pub rm_startup: ::std::option::Option<unsafe extern "C" fn()>,
    pub rm_cleanup: ::std::option::Option<unsafe extern "C" fn()>,
    pub rm_mask: ::std::option::Option<
        unsafe extern "C" fn(pagedata: *mut ::std::os::raw::c_char, blkno: BlockNumber),
    >,
    pub rm_decode: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut LogicalDecodingContext, buf: *mut XLogRecordBuffer),
    >,
}
impl Default for RmgrData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_class {
    pub oid: Oid,
    pub relname: NameData,
    pub relnamespace: Oid,
    pub reltype: Oid,
    pub reloftype: Oid,
    pub relowner: Oid,
    pub relam: Oid,
    pub relfilenode: Oid,
    pub reltablespace: Oid,
    pub relpages: int32,
    pub reltuples: float4,
    pub relallvisible: int32,
    pub reltoastrelid: Oid,
    pub relhasindex: bool,
    pub relisshared: bool,
    pub relpersistence: ::std::os::raw::c_char,
    pub relkind: ::std::os::raw::c_char,
    pub relnatts: int16,
    pub relchecks: int16,
    pub relhasrules: bool,
    pub relhastriggers: bool,
    pub relhassubclass: bool,
    pub relrowsecurity: bool,
    pub relforcerowsecurity: bool,
    pub relispopulated: bool,
    pub relreplident: ::std::os::raw::c_char,
    pub relispartition: bool,
    pub relrewrite: Oid,
    pub relfrozenxid: TransactionId,
    pub relminmxid: TransactionId,
}
impl Default for FormData_pg_class {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_class = *mut FormData_pg_class;
#[repr(C)]
#[derive(Debug)]
pub struct FormData_pg_index {
    pub indexrelid: Oid,
    pub indrelid: Oid,
    pub indnatts: int16,
    pub indnkeyatts: int16,
    pub indisunique: bool,
    pub indnullsnotdistinct: bool,
    pub indisprimary: bool,
    pub indisexclusion: bool,
    pub indimmediate: bool,
    pub indisclustered: bool,
    pub indisvalid: bool,
    pub indcheckxmin: bool,
    pub indisready: bool,
    pub indislive: bool,
    pub indisreplident: bool,
    pub indkey: int2vector,
}
impl Default for FormData_pg_index {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_index = *mut FormData_pg_index;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjectAddress {
    pub classId: Oid,
    pub objectId: Oid,
    pub objectSubId: int32,
}
impl Default for ObjectAddress {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_publication {
    pub oid: Oid,
    pub pubname: NameData,
    pub pubowner: Oid,
    pub puballtables: bool,
    pub pubinsert: bool,
    pub pubupdate: bool,
    pub pubdelete: bool,
    pub pubtruncate: bool,
    pub pubviaroot: bool,
}
impl Default for FormData_pg_publication {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_publication = *mut FormData_pg_publication;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PublicationActions {
    pub pubinsert: bool,
    pub pubupdate: bool,
    pub pubdelete: bool,
    pub pubtruncate: bool,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PublicationDesc {
    pub pubactions: PublicationActions,
    pub rf_valid_for_update: bool,
    pub rf_valid_for_delete: bool,
    pub cols_valid_for_update: bool,
    pub cols_valid_for_delete: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Publication {
    pub oid: Oid,
    pub name: *mut ::std::os::raw::c_char,
    pub alltables: bool,
    pub pubviaroot: bool,
    pub pubactions: PublicationActions,
}
impl Default for Publication {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PublicationRelInfo {
    pub relation: Relation,
    pub whereClause: *mut Node,
    pub columns: *mut List,
}
impl Default for PublicationRelInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const PublicationPartOpt_PUBLICATION_PART_ROOT: PublicationPartOpt = 0;
pub const PublicationPartOpt_PUBLICATION_PART_LEAF: PublicationPartOpt = 1;
pub const PublicationPartOpt_PUBLICATION_PART_ALL: PublicationPartOpt = 2;
pub type PublicationPartOpt = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RewriteRule {
    pub ruleId: Oid,
    pub event: CmdType,
    pub qual: *mut Node,
    pub actions: *mut List,
    pub enabled: ::std::os::raw::c_char,
    pub isInstead: bool,
}
impl Default for RewriteRule {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RuleLock {
    pub numLocks: ::std::os::raw::c_int,
    pub rules: *mut *mut RewriteRule,
}
impl Default for RuleLock {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMgrRelationData {
    pub smgr_rlocator: RelFileLocatorBackend,
    pub smgr_owner: *mut *mut SMgrRelationData,
    pub smgr_targblock: BlockNumber,
    pub smgr_cached_nblocks: [BlockNumber; 4usize],
    pub smgr_which: ::std::os::raw::c_int,
    pub md_num_open_segs: [::std::os::raw::c_int; 4usize],
    pub md_seg_fds: [*mut _MdfdVec; 4usize],
    pub node: dlist_node,
}
impl Default for SMgrRelationData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SMgrRelation = *mut SMgrRelationData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LockRelId {
    pub relId: Oid,
    pub dbId: Oid,
}
impl Default for LockRelId {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LockInfoData {
    pub lockRelId: LockRelId,
}
impl Default for LockInfoData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type LockInfo = *mut LockInfoData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RelationData {
    pub rd_locator: RelFileLocator,
    pub rd_smgr: SMgrRelation,
    pub rd_refcnt: ::std::os::raw::c_int,
    pub rd_backend: BackendId,
    pub rd_islocaltemp: bool,
    pub rd_isnailed: bool,
    pub rd_isvalid: bool,
    pub rd_indexvalid: bool,
    pub rd_statvalid: bool,
    pub rd_createSubid: SubTransactionId,
    pub rd_newRelfilelocatorSubid: SubTransactionId,
    pub rd_firstRelfilelocatorSubid: SubTransactionId,
    pub rd_droppedSubid: SubTransactionId,
    pub rd_rel: Form_pg_class,
    pub rd_att: TupleDesc,
    pub rd_id: Oid,
    pub rd_lockInfo: LockInfoData,
    pub rd_rules: *mut RuleLock,
    pub rd_rulescxt: MemoryContext,
    pub trigdesc: *mut TriggerDesc,
    pub rd_rsdesc: *mut RowSecurityDesc,
    pub rd_fkeylist: *mut List,
    pub rd_fkeyvalid: bool,
    pub rd_partkey: PartitionKey,
    pub rd_partkeycxt: MemoryContext,
    pub rd_partdesc: PartitionDesc,
    pub rd_pdcxt: MemoryContext,
    pub rd_partdesc_nodetached: PartitionDesc,
    pub rd_pddcxt: MemoryContext,
    pub rd_partdesc_nodetached_xmin: TransactionId,
    pub rd_partcheck: *mut List,
    pub rd_partcheckvalid: bool,
    pub rd_partcheckcxt: MemoryContext,
    pub rd_indexlist: *mut List,
    pub rd_pkindex: Oid,
    pub rd_replidindex: Oid,
    pub rd_statlist: *mut List,
    pub rd_attrsvalid: bool,
    pub rd_keyattr: *mut Bitmapset,
    pub rd_pkattr: *mut Bitmapset,
    pub rd_idattr: *mut Bitmapset,
    pub rd_hotblockingattr: *mut Bitmapset,
    pub rd_summarizedattr: *mut Bitmapset,
    pub rd_pubdesc: *mut PublicationDesc,
    pub rd_options: *mut bytea,
    pub rd_amhandler: Oid,
    pub rd_tableam: *const TableAmRoutine,
    pub rd_index: Form_pg_index,
    pub rd_indextuple: *mut HeapTupleData,
    pub rd_indexcxt: MemoryContext,
    pub rd_indam: *mut IndexAmRoutine,
    pub rd_opfamily: *mut Oid,
    pub rd_opcintype: *mut Oid,
    pub rd_support: *mut RegProcedure,
    pub rd_supportinfo: *mut FmgrInfo,
    pub rd_indoption: *mut int16,
    pub rd_indexprs: *mut List,
    pub rd_indpred: *mut List,
    pub rd_exclops: *mut Oid,
    pub rd_exclprocs: *mut Oid,
    pub rd_exclstrats: *mut uint16,
    pub rd_indcollation: *mut Oid,
    pub rd_opcoptions: *mut *mut bytea,
    pub rd_amcache: *mut ::std::os::raw::c_void,
    pub rd_fdwroutine: *mut FdwRoutine,
    pub rd_toastoid: Oid,
    pub pgstat_enabled: bool,
    pub pgstat_info: *mut PgStat_TableStatus,
}
impl Default for RelationData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForeignKeyCacheInfo {
    pub type_: NodeTag,
    pub conoid: Oid,
    pub conrelid: Oid,
    pub confrelid: Oid,
    pub nkeys: ::std::os::raw::c_int,
    pub conkey: [AttrNumber; 32usize],
    pub confkey: [AttrNumber; 32usize],
    pub conpfeqop: [Oid; 32usize],
}
impl Default for ForeignKeyCacheInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AutoVacOpts {
    pub enabled: bool,
    pub vacuum_threshold: ::std::os::raw::c_int,
    pub vacuum_ins_threshold: ::std::os::raw::c_int,
    pub analyze_threshold: ::std::os::raw::c_int,
    pub vacuum_cost_limit: ::std::os::raw::c_int,
    pub freeze_min_age: ::std::os::raw::c_int,
    pub freeze_max_age: ::std::os::raw::c_int,
    pub freeze_table_age: ::std::os::raw::c_int,
    pub multixact_freeze_min_age: ::std::os::raw::c_int,
    pub multixact_freeze_max_age: ::std::os::raw::c_int,
    pub multixact_freeze_table_age: ::std::os::raw::c_int,
    pub log_min_duration: ::std::os::raw::c_int,
    pub vacuum_cost_delay: float8,
    pub vacuum_scale_factor: float8,
    pub vacuum_ins_scale_factor: float8,
    pub analyze_scale_factor: float8,
}
pub const StdRdOptIndexCleanup_STDRD_OPTION_VACUUM_INDEX_CLEANUP_AUTO: StdRdOptIndexCleanup = 0;
pub const StdRdOptIndexCleanup_STDRD_OPTION_VACUUM_INDEX_CLEANUP_OFF: StdRdOptIndexCleanup = 1;
pub const StdRdOptIndexCleanup_STDRD_OPTION_VACUUM_INDEX_CLEANUP_ON: StdRdOptIndexCleanup = 2;
pub type StdRdOptIndexCleanup = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StdRdOptions {
    pub vl_len_: int32,
    pub fillfactor: ::std::os::raw::c_int,
    pub toast_tuple_target: ::std::os::raw::c_int,
    pub autovacuum: AutoVacOpts,
    pub user_catalog_table: bool,
    pub parallel_workers: ::std::os::raw::c_int,
    pub vacuum_index_cleanup: StdRdOptIndexCleanup,
    pub vacuum_truncate: bool,
}
impl Default for StdRdOptions {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ViewOptCheckOption_VIEW_OPTION_CHECK_OPTION_NOT_SET: ViewOptCheckOption = 0;
pub const ViewOptCheckOption_VIEW_OPTION_CHECK_OPTION_LOCAL: ViewOptCheckOption = 1;
pub const ViewOptCheckOption_VIEW_OPTION_CHECK_OPTION_CASCADED: ViewOptCheckOption = 2;
pub type ViewOptCheckOption = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ViewOptions {
    pub vl_len_: int32,
    pub security_barrier: bool,
    pub security_invoker: bool,
    pub check_option: ViewOptCheckOption,
}
impl Default for ViewOptions {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GenericXLogState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GinStatsData {
    pub nPendingPages: BlockNumber,
    pub nTotalPages: BlockNumber,
    pub nEntryPages: BlockNumber,
    pub nDataPages: BlockNumber,
    pub nEntries: int64,
    pub ginVersion: int32,
}
pub type GinTernaryValue = ::std::os::raw::c_char;
pub type GistNSN = XLogRecPtr;
pub type PageGistNSN = PageXLogRecPtr;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GISTPageOpaqueData {
    pub nsn: PageGistNSN,
    pub rightlink: BlockNumber,
    pub flags: uint16,
    pub gist_page_id: uint16,
}
pub type GISTPageOpaque = *mut GISTPageOpaqueData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GIST_SPLITVEC {
    pub spl_left: *mut OffsetNumber,
    pub spl_nleft: ::std::os::raw::c_int,
    pub spl_ldatum: Datum,
    pub spl_ldatum_exists: bool,
    pub spl_right: *mut OffsetNumber,
    pub spl_nright: ::std::os::raw::c_int,
    pub spl_rdatum: Datum,
    pub spl_rdatum_exists: bool,
}
impl Default for GIST_SPLITVEC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GISTENTRY {
    pub key: Datum,
    pub rel: Relation,
    pub page: Page,
    pub offset: OffsetNumber,
    pub leafkey: bool,
}
impl Default for GISTENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GISTDeletedPageContents {
    pub deleteXid: FullTransactionId,
}
#[repr(C)]
#[derive(Debug)]
pub struct GistEntryVector {
    pub n: int32,
    pub vector: __IncompleteArrayField<GISTENTRY>,
}
impl Default for GistEntryVector {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TableScanDescData {
    pub rs_rd: Relation,
    pub rs_snapshot: *mut SnapshotData,
    pub rs_nkeys: ::std::os::raw::c_int,
    pub rs_key: *mut ScanKeyData,
    pub rs_mintid: ItemPointerData,
    pub rs_maxtid: ItemPointerData,
    pub rs_flags: uint32,
    pub rs_parallel: *mut ParallelTableScanDescData,
}
impl Default for TableScanDescData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TableScanDesc = *mut TableScanDescData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParallelTableScanDescData {
    pub phs_relid: Oid,
    pub phs_syncscan: bool,
    pub phs_snapshot_any: bool,
    pub phs_snapshot_off: Size,
}
impl Default for ParallelTableScanDescData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ParallelTableScanDesc = *mut ParallelTableScanDescData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParallelBlockTableScanDescData {
    pub base: ParallelTableScanDescData,
    pub phs_nblocks: BlockNumber,
    pub phs_mutex: slock_t,
    pub phs_startblock: BlockNumber,
    pub phs_nallocated: pg_atomic_uint64,
}
impl Default for ParallelBlockTableScanDescData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ParallelBlockTableScanDesc = *mut ParallelBlockTableScanDescData;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ParallelBlockTableScanWorkerData {
    pub phsw_nallocated: uint64,
    pub phsw_chunk_remaining: uint32,
    pub phsw_chunk_size: uint32,
}
pub type ParallelBlockTableScanWorker = *mut ParallelBlockTableScanWorkerData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexFetchTableData {
    pub rel: Relation,
}
impl Default for IndexFetchTableData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexScanDescData {
    pub heapRelation: Relation,
    pub indexRelation: Relation,
    pub xs_snapshot: *mut SnapshotData,
    pub numberOfKeys: ::std::os::raw::c_int,
    pub numberOfOrderBys: ::std::os::raw::c_int,
    pub keyData: *mut ScanKeyData,
    pub orderByData: *mut ScanKeyData,
    pub xs_want_itup: bool,
    pub xs_temp_snap: bool,
    pub kill_prior_tuple: bool,
    pub ignore_killed_tuples: bool,
    pub xactStartedInRecovery: bool,
    pub opaque: *mut ::std::os::raw::c_void,
    pub xs_itup: IndexTuple,
    pub xs_itupdesc: *mut TupleDescData,
    pub xs_hitup: HeapTuple,
    pub xs_hitupdesc: *mut TupleDescData,
    pub xs_heaptid: ItemPointerData,
    pub xs_heap_continue: bool,
    pub xs_heapfetch: *mut IndexFetchTableData,
    pub xs_recheck: bool,
    pub xs_orderbyvals: *mut Datum,
    pub xs_orderbynulls: *mut bool,
    pub xs_recheckorderby: bool,
    pub parallel_scan: *mut ParallelIndexScanDescData,
}
impl Default for IndexScanDescData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct ParallelIndexScanDescData {
    pub ps_relid: Oid,
    pub ps_indexid: Oid,
    pub ps_offset: Size,
    pub ps_snapshot_data: __IncompleteArrayField<::std::os::raw::c_char>,
}
impl Default for ParallelIndexScanDescData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysScanDescData {
    pub heap_rel: Relation,
    pub irel: Relation,
    pub scan: *mut TableScanDescData,
    pub iscan: *mut IndexScanDescData,
    pub snapshot: *mut SnapshotData,
    pub slot: *mut TupleTableSlot,
}
impl Default for SysScanDescData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SharedInvalCatcacheMsg {
    pub id: int8,
    pub dbId: Oid,
    pub hashValue: uint32,
}
impl Default for SharedInvalCatcacheMsg {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SharedInvalCatalogMsg {
    pub id: int8,
    pub dbId: Oid,
    pub catId: Oid,
}
impl Default for SharedInvalCatalogMsg {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SharedInvalRelcacheMsg {
    pub id: int8,
    pub dbId: Oid,
    pub relId: Oid,
}
impl Default for SharedInvalRelcacheMsg {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SharedInvalSmgrMsg {
    pub id: int8,
    pub backend_hi: int8,
    pub backend_lo: uint16,
    pub rlocator: RelFileLocator,
}
impl Default for SharedInvalSmgrMsg {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SharedInvalRelmapMsg {
    pub id: int8,
    pub dbId: Oid,
}
impl Default for SharedInvalRelmapMsg {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SharedInvalSnapshotMsg {
    pub id: int8,
    pub dbId: Oid,
    pub relId: Oid,
}
impl Default for SharedInvalSnapshotMsg {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SharedInvalidationMessage {
    pub id: int8,
    pub cc: SharedInvalCatcacheMsg,
    pub cat: SharedInvalCatalogMsg,
    pub rc: SharedInvalRelcacheMsg,
    pub sm: SharedInvalSmgrMsg,
    pub rm: SharedInvalRelmapMsg,
    pub sn: SharedInvalSnapshotMsg,
}
impl Default for SharedInvalidationMessage {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const SyncCommitLevel_SYNCHRONOUS_COMMIT_OFF: SyncCommitLevel = 0;
pub const SyncCommitLevel_SYNCHRONOUS_COMMIT_LOCAL_FLUSH: SyncCommitLevel = 1;
pub const SyncCommitLevel_SYNCHRONOUS_COMMIT_REMOTE_WRITE: SyncCommitLevel = 2;
pub const SyncCommitLevel_SYNCHRONOUS_COMMIT_REMOTE_FLUSH: SyncCommitLevel = 3;
pub const SyncCommitLevel_SYNCHRONOUS_COMMIT_REMOTE_APPLY: SyncCommitLevel = 4;
pub type SyncCommitLevel = ::std::os::raw::c_uint;
pub const XactEvent_XACT_EVENT_COMMIT: XactEvent = 0;
pub const XactEvent_XACT_EVENT_PARALLEL_COMMIT: XactEvent = 1;
pub const XactEvent_XACT_EVENT_ABORT: XactEvent = 2;
pub const XactEvent_XACT_EVENT_PARALLEL_ABORT: XactEvent = 3;
pub const XactEvent_XACT_EVENT_PREPARE: XactEvent = 4;
pub const XactEvent_XACT_EVENT_PRE_COMMIT: XactEvent = 5;
pub const XactEvent_XACT_EVENT_PARALLEL_PRE_COMMIT: XactEvent = 6;
pub const XactEvent_XACT_EVENT_PRE_PREPARE: XactEvent = 7;
pub type XactEvent = ::std::os::raw::c_uint;
pub type XactCallback =
    ::std::option::Option<unsafe extern "C" fn(event: XactEvent, arg: *mut ::std::os::raw::c_void)>;
pub const SubXactEvent_SUBXACT_EVENT_START_SUB: SubXactEvent = 0;
pub const SubXactEvent_SUBXACT_EVENT_COMMIT_SUB: SubXactEvent = 1;
pub const SubXactEvent_SUBXACT_EVENT_ABORT_SUB: SubXactEvent = 2;
pub const SubXactEvent_SUBXACT_EVENT_PRE_COMMIT_SUB: SubXactEvent = 3;
pub type SubXactEvent = ::std::os::raw::c_uint;
pub type SubXactCallback = ::std::option::Option<
    unsafe extern "C" fn(
        event: SubXactEvent,
        mySubid: SubTransactionId,
        parentSubid: SubTransactionId,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SavedTransactionCharacteristics {
    pub save_XactIsoLevel: ::std::os::raw::c_int,
    pub save_XactReadOnly: bool,
    pub save_XactDeferrable: bool,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct xl_xact_assignment {
    pub xtop: TransactionId,
    pub nsubxacts: ::std::os::raw::c_int,
    pub xsub: __IncompleteArrayField<TransactionId>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xl_xact_xinfo {
    pub xinfo: uint32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xl_xact_dbinfo {
    pub dbId: Oid,
    pub tsId: Oid,
}
impl Default for xl_xact_dbinfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct xl_xact_subxacts {
    pub nsubxacts: ::std::os::raw::c_int,
    pub subxacts: __IncompleteArrayField<TransactionId>,
}
#[repr(C)]
#[derive(Debug)]
pub struct xl_xact_relfilelocators {
    pub nrels: ::std::os::raw::c_int,
    pub xlocators: __IncompleteArrayField<RelFileLocator>,
}
impl Default for xl_xact_relfilelocators {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xl_xact_stats_item {
    pub kind: ::std::os::raw::c_int,
    pub dboid: Oid,
    pub objoid: Oid,
}
impl Default for xl_xact_stats_item {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct xl_xact_stats_items {
    pub nitems: ::std::os::raw::c_int,
    pub items: __IncompleteArrayField<xl_xact_stats_item>,
}
impl Default for xl_xact_stats_items {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct xl_xact_invals {
    pub nmsgs: ::std::os::raw::c_int,
    pub msgs: __IncompleteArrayField<SharedInvalidationMessage>,
}
impl Default for xl_xact_invals {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xl_xact_twophase {
    pub xid: TransactionId,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xl_xact_origin {
    pub origin_lsn: XLogRecPtr,
    pub origin_timestamp: TimestampTz,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xl_xact_commit {
    pub xact_time: TimestampTz,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xl_xact_abort {
    pub xact_time: TimestampTz,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xl_xact_prepare {
    pub magic: uint32,
    pub total_len: uint32,
    pub xid: TransactionId,
    pub database: Oid,
    pub prepared_at: TimestampTz,
    pub owner: Oid,
    pub nsubxacts: int32,
    pub ncommitrels: int32,
    pub nabortrels: int32,
    pub ncommitstats: int32,
    pub nabortstats: int32,
    pub ninvalmsgs: int32,
    pub initfileinval: bool,
    pub gidlen: uint16,
    pub origin_lsn: XLogRecPtr,
    pub origin_timestamp: TimestampTz,
}
impl Default for xl_xact_prepare {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xl_xact_parsed_commit {
    pub xact_time: TimestampTz,
    pub xinfo: uint32,
    pub dbId: Oid,
    pub tsId: Oid,
    pub nsubxacts: ::std::os::raw::c_int,
    pub subxacts: *mut TransactionId,
    pub nrels: ::std::os::raw::c_int,
    pub xlocators: *mut RelFileLocator,
    pub nstats: ::std::os::raw::c_int,
    pub stats: *mut xl_xact_stats_item,
    pub nmsgs: ::std::os::raw::c_int,
    pub msgs: *mut SharedInvalidationMessage,
    pub twophase_xid: TransactionId,
    pub twophase_gid: [::std::os::raw::c_char; 200usize],
    pub nabortrels: ::std::os::raw::c_int,
    pub abortlocators: *mut RelFileLocator,
    pub nabortstats: ::std::os::raw::c_int,
    pub abortstats: *mut xl_xact_stats_item,
    pub origin_lsn: XLogRecPtr,
    pub origin_timestamp: TimestampTz,
}
impl Default for xl_xact_parsed_commit {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type xl_xact_parsed_prepare = xl_xact_parsed_commit;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xl_xact_parsed_abort {
    pub xact_time: TimestampTz,
    pub xinfo: uint32,
    pub dbId: Oid,
    pub tsId: Oid,
    pub nsubxacts: ::std::os::raw::c_int,
    pub subxacts: *mut TransactionId,
    pub nrels: ::std::os::raw::c_int,
    pub xlocators: *mut RelFileLocator,
    pub nstats: ::std::os::raw::c_int,
    pub stats: *mut xl_xact_stats_item,
    pub twophase_xid: TransactionId,
    pub twophase_gid: [::std::os::raw::c_char; 200usize],
    pub origin_lsn: XLogRecPtr,
    pub origin_timestamp: TimestampTz,
}
impl Default for xl_xact_parsed_abort {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BulkInsertStateData {
    _unused: [u8; 0],
}
pub const ScanOptions_SO_TYPE_SEQSCAN: ScanOptions = 1;
pub const ScanOptions_SO_TYPE_BITMAPSCAN: ScanOptions = 2;
pub const ScanOptions_SO_TYPE_SAMPLESCAN: ScanOptions = 4;
pub const ScanOptions_SO_TYPE_TIDSCAN: ScanOptions = 8;
pub const ScanOptions_SO_TYPE_TIDRANGESCAN: ScanOptions = 16;
pub const ScanOptions_SO_TYPE_ANALYZE: ScanOptions = 32;
pub const ScanOptions_SO_ALLOW_STRAT: ScanOptions = 64;
pub const ScanOptions_SO_ALLOW_SYNC: ScanOptions = 128;
pub const ScanOptions_SO_ALLOW_PAGEMODE: ScanOptions = 256;
pub const ScanOptions_SO_TEMP_SNAPSHOT: ScanOptions = 512;
pub type ScanOptions = ::std::os::raw::c_uint;
pub const TM_Result_TM_Ok: TM_Result = 0;
pub const TM_Result_TM_Invisible: TM_Result = 1;
pub const TM_Result_TM_SelfModified: TM_Result = 2;
pub const TM_Result_TM_Updated: TM_Result = 3;
pub const TM_Result_TM_Deleted: TM_Result = 4;
pub const TM_Result_TM_BeingModified: TM_Result = 5;
pub const TM_Result_TM_WouldBlock: TM_Result = 6;
pub type TM_Result = ::std::os::raw::c_uint;
pub const TU_UpdateIndexes_TU_None: TU_UpdateIndexes = 0;
pub const TU_UpdateIndexes_TU_All: TU_UpdateIndexes = 1;
pub const TU_UpdateIndexes_TU_Summarizing: TU_UpdateIndexes = 2;
pub type TU_UpdateIndexes = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TM_FailureData {
    pub ctid: ItemPointerData,
    pub xmax: TransactionId,
    pub cmax: CommandId,
    pub traversed: bool,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TM_IndexDelete {
    pub tid: ItemPointerData,
    pub id: int16,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TM_IndexStatus {
    pub idxoffnum: OffsetNumber,
    pub knowndeletable: bool,
    pub promising: bool,
    pub freespace: int16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TM_IndexDeleteOp {
    pub irel: Relation,
    pub iblknum: BlockNumber,
    pub bottomup: bool,
    pub bottomupfreespace: ::std::os::raw::c_int,
    pub ndeltids: ::std::os::raw::c_int,
    pub deltids: *mut TM_IndexDelete,
    pub status: *mut TM_IndexStatus,
}
impl Default for TM_IndexDeleteOp {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type IndexBuildCallback = ::std::option::Option<
    unsafe extern "C" fn(
        index: Relation,
        tid: ItemPointer,
        values: *mut Datum,
        isnull: *mut bool,
        tupleIsAlive: bool,
        state: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TableAmRoutine {
    pub type_: NodeTag,
    pub slot_callbacks:
        ::std::option::Option<unsafe extern "C" fn(rel: Relation) -> *const TupleTableSlotOps>,
    pub scan_begin: ::std::option::Option<
        unsafe extern "C" fn(
            rel: Relation,
            snapshot: Snapshot,
            nkeys: ::std::os::raw::c_int,
            key: *mut ScanKeyData,
            pscan: ParallelTableScanDesc,
            flags: uint32,
        ) -> TableScanDesc,
    >,
    pub scan_end: ::std::option::Option<unsafe extern "C" fn(scan: TableScanDesc)>,
    pub scan_rescan: ::std::option::Option<
        unsafe extern "C" fn(
            scan: TableScanDesc,
            key: *mut ScanKeyData,
            set_params: bool,
            allow_strat: bool,
            allow_sync: bool,
            allow_pagemode: bool,
        ),
    >,
    pub scan_getnextslot: ::std::option::Option<
        unsafe extern "C" fn(
            scan: TableScanDesc,
            direction: ScanDirection,
            slot: *mut TupleTableSlot,
        ) -> bool,
    >,
    pub scan_set_tidrange: ::std::option::Option<
        unsafe extern "C" fn(scan: TableScanDesc, mintid: ItemPointer, maxtid: ItemPointer),
    >,
    pub scan_getnextslot_tidrange: ::std::option::Option<
        unsafe extern "C" fn(
            scan: TableScanDesc,
            direction: ScanDirection,
            slot: *mut TupleTableSlot,
        ) -> bool,
    >,
    pub parallelscan_estimate: ::std::option::Option<unsafe extern "C" fn(rel: Relation) -> Size>,
    pub parallelscan_initialize: ::std::option::Option<
        unsafe extern "C" fn(rel: Relation, pscan: ParallelTableScanDesc) -> Size,
    >,
    pub parallelscan_reinitialize:
        ::std::option::Option<unsafe extern "C" fn(rel: Relation, pscan: ParallelTableScanDesc)>,
    pub index_fetch_begin:
        ::std::option::Option<unsafe extern "C" fn(rel: Relation) -> *mut IndexFetchTableData>,
    pub index_fetch_reset:
        ::std::option::Option<unsafe extern "C" fn(data: *mut IndexFetchTableData)>,
    pub index_fetch_end:
        ::std::option::Option<unsafe extern "C" fn(data: *mut IndexFetchTableData)>,
    pub index_fetch_tuple: ::std::option::Option<
        unsafe extern "C" fn(
            scan: *mut IndexFetchTableData,
            tid: ItemPointer,
            snapshot: Snapshot,
            slot: *mut TupleTableSlot,
            call_again: *mut bool,
            all_dead: *mut bool,
        ) -> bool,
    >,
    pub tuple_fetch_row_version: ::std::option::Option<
        unsafe extern "C" fn(
            rel: Relation,
            tid: ItemPointer,
            snapshot: Snapshot,
            slot: *mut TupleTableSlot,
        ) -> bool,
    >,
    pub tuple_tid_valid:
        ::std::option::Option<unsafe extern "C" fn(scan: TableScanDesc, tid: ItemPointer) -> bool>,
    pub tuple_get_latest_tid:
        ::std::option::Option<unsafe extern "C" fn(scan: TableScanDesc, tid: ItemPointer)>,
    pub tuple_satisfies_snapshot: ::std::option::Option<
        unsafe extern "C" fn(rel: Relation, slot: *mut TupleTableSlot, snapshot: Snapshot) -> bool,
    >,
    pub index_delete_tuples: ::std::option::Option<
        unsafe extern "C" fn(rel: Relation, delstate: *mut TM_IndexDeleteOp) -> TransactionId,
    >,
    pub tuple_insert: ::std::option::Option<
        unsafe extern "C" fn(
            rel: Relation,
            slot: *mut TupleTableSlot,
            cid: CommandId,
            options: ::std::os::raw::c_int,
            bistate: *mut BulkInsertStateData,
        ),
    >,
    pub tuple_insert_speculative: ::std::option::Option<
        unsafe extern "C" fn(
            rel: Relation,
            slot: *mut TupleTableSlot,
            cid: CommandId,
            options: ::std::os::raw::c_int,
            bistate: *mut BulkInsertStateData,
            specToken: uint32,
        ),
    >,
    pub tuple_complete_speculative: ::std::option::Option<
        unsafe extern "C" fn(
            rel: Relation,
            slot: *mut TupleTableSlot,
            specToken: uint32,
            succeeded: bool,
        ),
    >,
    pub multi_insert: ::std::option::Option<
        unsafe extern "C" fn(
            rel: Relation,
            slots: *mut *mut TupleTableSlot,
            nslots: ::std::os::raw::c_int,
            cid: CommandId,
            options: ::std::os::raw::c_int,
            bistate: *mut BulkInsertStateData,
        ),
    >,
    pub tuple_delete: ::std::option::Option<
        unsafe extern "C" fn(
            rel: Relation,
            tid: ItemPointer,
            cid: CommandId,
            snapshot: Snapshot,
            crosscheck: Snapshot,
            wait: bool,
            tmfd: *mut TM_FailureData,
            changingPart: bool,
        ) -> TM_Result,
    >,
    pub tuple_update: ::std::option::Option<
        unsafe extern "C" fn(
            rel: Relation,
            otid: ItemPointer,
            slot: *mut TupleTableSlot,
            cid: CommandId,
            snapshot: Snapshot,
            crosscheck: Snapshot,
            wait: bool,
            tmfd: *mut TM_FailureData,
            lockmode: *mut LockTupleMode,
            update_indexes: *mut TU_UpdateIndexes,
        ) -> TM_Result,
    >,
    pub tuple_lock: ::std::option::Option<
        unsafe extern "C" fn(
            rel: Relation,
            tid: ItemPointer,
            snapshot: Snapshot,
            slot: *mut TupleTableSlot,
            cid: CommandId,
            mode: LockTupleMode,
            wait_policy: LockWaitPolicy,
            flags: uint8,
            tmfd: *mut TM_FailureData,
        ) -> TM_Result,
    >,
    pub finish_bulk_insert:
        ::std::option::Option<unsafe extern "C" fn(rel: Relation, options: ::std::os::raw::c_int)>,
    pub relation_set_new_filelocator: ::std::option::Option<
        unsafe extern "C" fn(
            rel: Relation,
            newrlocator: *const RelFileLocator,
            persistence: ::std::os::raw::c_char,
            freezeXid: *mut TransactionId,
            minmulti: *mut MultiXactId,
        ),
    >,
    pub relation_nontransactional_truncate:
        ::std::option::Option<unsafe extern "C" fn(rel: Relation)>,
    pub relation_copy_data: ::std::option::Option<
        unsafe extern "C" fn(rel: Relation, newrlocator: *const RelFileLocator),
    >,
    pub relation_copy_for_cluster: ::std::option::Option<
        unsafe extern "C" fn(
            NewTable: Relation,
            OldTable: Relation,
            OldIndex: Relation,
            use_sort: bool,
            OldestXmin: TransactionId,
            xid_cutoff: *mut TransactionId,
            multi_cutoff: *mut MultiXactId,
            num_tuples: *mut f64,
            tups_vacuumed: *mut f64,
            tups_recently_dead: *mut f64,
        ),
    >,
    pub relation_vacuum: ::std::option::Option<
        unsafe extern "C" fn(
            rel: Relation,
            params: *mut VacuumParams,
            bstrategy: BufferAccessStrategy,
        ),
    >,
    pub scan_analyze_next_block: ::std::option::Option<
        unsafe extern "C" fn(
            scan: TableScanDesc,
            blockno: BlockNumber,
            bstrategy: BufferAccessStrategy,
        ) -> bool,
    >,
    pub scan_analyze_next_tuple: ::std::option::Option<
        unsafe extern "C" fn(
            scan: TableScanDesc,
            OldestXmin: TransactionId,
            liverows: *mut f64,
            deadrows: *mut f64,
            slot: *mut TupleTableSlot,
        ) -> bool,
    >,
    pub index_build_range_scan: ::std::option::Option<
        unsafe extern "C" fn(
            table_rel: Relation,
            index_rel: Relation,
            index_info: *mut IndexInfo,
            allow_sync: bool,
            anyvisible: bool,
            progress: bool,
            start_blockno: BlockNumber,
            numblocks: BlockNumber,
            callback: IndexBuildCallback,
            callback_state: *mut ::std::os::raw::c_void,
            scan: TableScanDesc,
        ) -> f64,
    >,
    pub index_validate_scan: ::std::option::Option<
        unsafe extern "C" fn(
            table_rel: Relation,
            index_rel: Relation,
            index_info: *mut IndexInfo,
            snapshot: Snapshot,
            state: *mut ValidateIndexState,
        ),
    >,
    pub relation_size: ::std::option::Option<
        unsafe extern "C" fn(rel: Relation, forkNumber: ForkNumber) -> uint64,
    >,
    pub relation_needs_toast_table:
        ::std::option::Option<unsafe extern "C" fn(rel: Relation) -> bool>,
    pub relation_toast_am: ::std::option::Option<unsafe extern "C" fn(rel: Relation) -> Oid>,
    pub relation_fetch_toast_slice: ::std::option::Option<
        unsafe extern "C" fn(
            toastrel: Relation,
            valueid: Oid,
            attrsize: int32,
            sliceoffset: int32,
            slicelength: int32,
            result: *mut varlena,
        ),
    >,
    pub relation_estimate_size: ::std::option::Option<
        unsafe extern "C" fn(
            rel: Relation,
            attr_widths: *mut int32,
            pages: *mut BlockNumber,
            tuples: *mut f64,
            allvisfrac: *mut f64,
        ),
    >,
    pub scan_bitmap_next_block: ::std::option::Option<
        unsafe extern "C" fn(scan: TableScanDesc, tbmres: *mut TBMIterateResult) -> bool,
    >,
    pub scan_bitmap_next_tuple: ::std::option::Option<
        unsafe extern "C" fn(
            scan: TableScanDesc,
            tbmres: *mut TBMIterateResult,
            slot: *mut TupleTableSlot,
        ) -> bool,
    >,
    pub scan_sample_next_block: ::std::option::Option<
        unsafe extern "C" fn(scan: TableScanDesc, scanstate: *mut SampleScanState) -> bool,
    >,
    pub scan_sample_next_tuple: ::std::option::Option<
        unsafe extern "C" fn(
            scan: TableScanDesc,
            scanstate: *mut SampleScanState,
            slot: *mut TupleTableSlot,
        ) -> bool,
    >,
}
impl Default for TableAmRoutine {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ShmemIndexEnt {
    pub key: [::std::os::raw::c_char; 48usize],
    pub location: *mut ::std::os::raw::c_void,
    pub size: Size,
    pub allocated_size: Size,
}
impl Default for ShmemIndexEnt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shm_toc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct shm_toc_estimator {
    pub space_for_chunks: Size,
    pub number_of_keys: Size,
}
pub type BulkInsertState = *mut BulkInsertStateData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HeapScanDescData {
    pub rs_base: TableScanDescData,
    pub rs_nblocks: BlockNumber,
    pub rs_startblock: BlockNumber,
    pub rs_numblocks: BlockNumber,
    pub rs_inited: bool,
    pub rs_coffset: OffsetNumber,
    pub rs_cblock: BlockNumber,
    pub rs_cbuf: Buffer,
    pub rs_strategy: BufferAccessStrategy,
    pub rs_ctup: HeapTupleData,
    pub rs_parallelworkerdata: *mut ParallelBlockTableScanWorkerData,
    pub rs_cindex: ::std::os::raw::c_int,
    pub rs_ntuples: ::std::os::raw::c_int,
    pub rs_vistuples: [OffsetNumber; 291usize],
}
impl Default for HeapScanDescData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type HeapScanDesc = *mut HeapScanDescData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexFetchHeapData {
    pub xs_base: IndexFetchTableData,
    pub xs_cbuf: Buffer,
}
impl Default for IndexFetchHeapData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const HTSV_Result_HEAPTUPLE_DEAD: HTSV_Result = 0;
pub const HTSV_Result_HEAPTUPLE_LIVE: HTSV_Result = 1;
pub const HTSV_Result_HEAPTUPLE_RECENTLY_DEAD: HTSV_Result = 2;
pub const HTSV_Result_HEAPTUPLE_INSERT_IN_PROGRESS: HTSV_Result = 3;
pub const HTSV_Result_HEAPTUPLE_DELETE_IN_PROGRESS: HTSV_Result = 4;
pub type HTSV_Result = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HeapTupleFreeze {
    pub xmax: TransactionId,
    pub t_infomask2: uint16,
    pub t_infomask: uint16,
    pub frzflags: uint8,
    pub checkflags: uint8,
    pub offset: OffsetNumber,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HeapPageFreeze {
    pub freeze_required: bool,
    pub FreezePageRelfrozenXid: TransactionId,
    pub FreezePageRelminMxid: MultiXactId,
    pub NoFreezePageRelfrozenXid: TransactionId,
    pub NoFreezePageRelminMxid: MultiXactId,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GlobalVisState {
    _unused: [u8; 0],
}
pub const LWLockWaitState_LW_WS_NOT_WAITING: LWLockWaitState = 0;
pub const LWLockWaitState_LW_WS_WAITING: LWLockWaitState = 1;
pub const LWLockWaitState_LW_WS_PENDING_WAKEUP: LWLockWaitState = 2;
pub type LWLockWaitState = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LWLock {
    pub tranche: uint16,
    pub state: pg_atomic_uint32,
    pub waiters: proclist_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union LWLockPadded {
    pub lock: LWLock,
    pub pad: [::std::os::raw::c_char; 128usize],
}
impl Default for LWLockPadded {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NamedLWLockTranche {
    pub trancheId: ::std::os::raw::c_int,
    pub trancheName: *mut ::std::os::raw::c_char,
}
impl Default for NamedLWLockTranche {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const LWLockMode_LW_EXCLUSIVE: LWLockMode = 0;
pub const LWLockMode_LW_SHARED: LWLockMode = 1;
pub const LWLockMode_LW_WAIT_UNTIL_FREE: LWLockMode = 2;
pub type LWLockMode = ::std::os::raw::c_uint;
pub const BuiltinTrancheIds_LWTRANCHE_XACT_BUFFER: BuiltinTrancheIds = 48;
pub const BuiltinTrancheIds_LWTRANCHE_COMMITTS_BUFFER: BuiltinTrancheIds = 49;
pub const BuiltinTrancheIds_LWTRANCHE_SUBTRANS_BUFFER: BuiltinTrancheIds = 50;
pub const BuiltinTrancheIds_LWTRANCHE_MULTIXACTOFFSET_BUFFER: BuiltinTrancheIds = 51;
pub const BuiltinTrancheIds_LWTRANCHE_MULTIXACTMEMBER_BUFFER: BuiltinTrancheIds = 52;
pub const BuiltinTrancheIds_LWTRANCHE_NOTIFY_BUFFER: BuiltinTrancheIds = 53;
pub const BuiltinTrancheIds_LWTRANCHE_SERIAL_BUFFER: BuiltinTrancheIds = 54;
pub const BuiltinTrancheIds_LWTRANCHE_WAL_INSERT: BuiltinTrancheIds = 55;
pub const BuiltinTrancheIds_LWTRANCHE_BUFFER_CONTENT: BuiltinTrancheIds = 56;
pub const BuiltinTrancheIds_LWTRANCHE_REPLICATION_ORIGIN_STATE: BuiltinTrancheIds = 57;
pub const BuiltinTrancheIds_LWTRANCHE_REPLICATION_SLOT_IO: BuiltinTrancheIds = 58;
pub const BuiltinTrancheIds_LWTRANCHE_LOCK_FASTPATH: BuiltinTrancheIds = 59;
pub const BuiltinTrancheIds_LWTRANCHE_BUFFER_MAPPING: BuiltinTrancheIds = 60;
pub const BuiltinTrancheIds_LWTRANCHE_LOCK_MANAGER: BuiltinTrancheIds = 61;
pub const BuiltinTrancheIds_LWTRANCHE_PREDICATE_LOCK_MANAGER: BuiltinTrancheIds = 62;
pub const BuiltinTrancheIds_LWTRANCHE_PARALLEL_HASH_JOIN: BuiltinTrancheIds = 63;
pub const BuiltinTrancheIds_LWTRANCHE_PARALLEL_QUERY_DSA: BuiltinTrancheIds = 64;
pub const BuiltinTrancheIds_LWTRANCHE_PER_SESSION_DSA: BuiltinTrancheIds = 65;
pub const BuiltinTrancheIds_LWTRANCHE_PER_SESSION_RECORD_TYPE: BuiltinTrancheIds = 66;
pub const BuiltinTrancheIds_LWTRANCHE_PER_SESSION_RECORD_TYPMOD: BuiltinTrancheIds = 67;
pub const BuiltinTrancheIds_LWTRANCHE_SHARED_TUPLESTORE: BuiltinTrancheIds = 68;
pub const BuiltinTrancheIds_LWTRANCHE_SHARED_TIDBITMAP: BuiltinTrancheIds = 69;
pub const BuiltinTrancheIds_LWTRANCHE_PARALLEL_APPEND: BuiltinTrancheIds = 70;
pub const BuiltinTrancheIds_LWTRANCHE_PER_XACT_PREDICATE_LIST: BuiltinTrancheIds = 71;
pub const BuiltinTrancheIds_LWTRANCHE_PGSTATS_DSA: BuiltinTrancheIds = 72;
pub const BuiltinTrancheIds_LWTRANCHE_PGSTATS_HASH: BuiltinTrancheIds = 73;
pub const BuiltinTrancheIds_LWTRANCHE_PGSTATS_DATA: BuiltinTrancheIds = 74;
pub const BuiltinTrancheIds_LWTRANCHE_LAUNCHER_DSA: BuiltinTrancheIds = 75;
pub const BuiltinTrancheIds_LWTRANCHE_LAUNCHER_HASH: BuiltinTrancheIds = 76;
pub const BuiltinTrancheIds_LWTRANCHE_FIRST_USER_DEFINED: BuiltinTrancheIds = 77;
pub type BuiltinTrancheIds = ::std::os::raw::c_uint;
pub type LWLockId = *mut LWLock;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VirtualTransactionId {
    pub backendId: BackendId,
    pub localTransactionId: LocalTransactionId,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LockMethodData {
    pub numLockModes: ::std::os::raw::c_int,
    pub conflictTab: *const LOCKMASK,
    pub lockModeNames: *const *const ::std::os::raw::c_char,
    pub trace_flag: *const bool,
}
impl Default for LockMethodData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type LockMethod = *const LockMethodData;
pub type LOCKMETHODID = uint16;
pub const LockTagType_LOCKTAG_RELATION: LockTagType = 0;
pub const LockTagType_LOCKTAG_RELATION_EXTEND: LockTagType = 1;
pub const LockTagType_LOCKTAG_DATABASE_FROZEN_IDS: LockTagType = 2;
pub const LockTagType_LOCKTAG_PAGE: LockTagType = 3;
pub const LockTagType_LOCKTAG_TUPLE: LockTagType = 4;
pub const LockTagType_LOCKTAG_TRANSACTION: LockTagType = 5;
pub const LockTagType_LOCKTAG_VIRTUALTRANSACTION: LockTagType = 6;
pub const LockTagType_LOCKTAG_SPECULATIVE_TOKEN: LockTagType = 7;
pub const LockTagType_LOCKTAG_OBJECT: LockTagType = 8;
pub const LockTagType_LOCKTAG_USERLOCK: LockTagType = 9;
pub const LockTagType_LOCKTAG_ADVISORY: LockTagType = 10;
pub const LockTagType_LOCKTAG_APPLY_TRANSACTION: LockTagType = 11;
pub type LockTagType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LOCKTAG {
    pub locktag_field1: uint32,
    pub locktag_field2: uint32,
    pub locktag_field3: uint32,
    pub locktag_field4: uint16,
    pub locktag_type: uint8,
    pub locktag_lockmethodid: uint8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LOCK {
    pub tag: LOCKTAG,
    pub grantMask: LOCKMASK,
    pub waitMask: LOCKMASK,
    pub procLocks: dlist_head,
    pub waitProcs: dclist_head,
    pub requested: [::std::os::raw::c_int; 10usize],
    pub nRequested: ::std::os::raw::c_int,
    pub granted: [::std::os::raw::c_int; 10usize],
    pub nGranted: ::std::os::raw::c_int,
}
impl Default for LOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PROCLOCKTAG {
    pub myLock: *mut LOCK,
    pub myProc: *mut PGPROC,
}
impl Default for PROCLOCKTAG {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PROCLOCK {
    pub tag: PROCLOCKTAG,
    pub groupLeader: *mut PGPROC,
    pub holdMask: LOCKMASK,
    pub releaseMask: LOCKMASK,
    pub lockLink: dlist_node,
    pub procLink: dlist_node,
}
impl Default for PROCLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LOCALLOCKTAG {
    pub lock: LOCKTAG,
    pub mode: LOCKMODE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LOCALLOCKOWNER {
    pub owner: *mut ResourceOwnerData,
    pub nLocks: int64,
}
impl Default for LOCALLOCKOWNER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LOCALLOCK {
    pub tag: LOCALLOCKTAG,
    pub hashcode: uint32,
    pub lock: *mut LOCK,
    pub proclock: *mut PROCLOCK,
    pub nLocks: int64,
    pub numLockOwners: ::std::os::raw::c_int,
    pub maxLockOwners: ::std::os::raw::c_int,
    pub lockOwners: *mut LOCALLOCKOWNER,
    pub holdsStrongLockCount: bool,
    pub lockCleared: bool,
}
impl Default for LOCALLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LockInstanceData {
    pub locktag: LOCKTAG,
    pub holdMask: LOCKMASK,
    pub waitLockMode: LOCKMODE,
    pub backend: BackendId,
    pub lxid: LocalTransactionId,
    pub waitStart: TimestampTz,
    pub pid: ::std::os::raw::c_int,
    pub leaderPid: ::std::os::raw::c_int,
    pub fastpath: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LockData {
    pub nelements: ::std::os::raw::c_int,
    pub locks: *mut LockInstanceData,
}
impl Default for LockData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct BlockedProcData {
    pub pid: ::std::os::raw::c_int,
    pub first_lock: ::std::os::raw::c_int,
    pub num_locks: ::std::os::raw::c_int,
    pub first_waiter: ::std::os::raw::c_int,
    pub num_waiters: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BlockedProcsData {
    pub procs: *mut BlockedProcData,
    pub locks: *mut LockInstanceData,
    pub waiter_pids: *mut ::std::os::raw::c_int,
    pub nprocs: ::std::os::raw::c_int,
    pub maxprocs: ::std::os::raw::c_int,
    pub nlocks: ::std::os::raw::c_int,
    pub maxlocks: ::std::os::raw::c_int,
    pub npids: ::std::os::raw::c_int,
    pub maxpids: ::std::os::raw::c_int,
}
impl Default for BlockedProcsData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const LockAcquireResult_LOCKACQUIRE_NOT_AVAIL: LockAcquireResult = 0;
pub const LockAcquireResult_LOCKACQUIRE_OK: LockAcquireResult = 1;
pub const LockAcquireResult_LOCKACQUIRE_ALREADY_HELD: LockAcquireResult = 2;
pub const LockAcquireResult_LOCKACQUIRE_ALREADY_CLEAR: LockAcquireResult = 3;
pub type LockAcquireResult = ::std::os::raw::c_uint;
pub const DeadLockState_DS_NOT_YET_CHECKED: DeadLockState = 0;
pub const DeadLockState_DS_NO_DEADLOCK: DeadLockState = 1;
pub const DeadLockState_DS_SOFT_DEADLOCK: DeadLockState = 2;
pub const DeadLockState_DS_HARD_DEADLOCK: DeadLockState = 3;
pub const DeadLockState_DS_BLOCKED_BY_AUTOVACUUM: DeadLockState = 4;
pub type DeadLockState = ::std::os::raw::c_uint;
pub const relopt_type_RELOPT_TYPE_BOOL: relopt_type = 0;
pub const relopt_type_RELOPT_TYPE_INT: relopt_type = 1;
pub const relopt_type_RELOPT_TYPE_REAL: relopt_type = 2;
pub const relopt_type_RELOPT_TYPE_ENUM: relopt_type = 3;
pub const relopt_type_RELOPT_TYPE_STRING: relopt_type = 4;
pub type relopt_type = ::std::os::raw::c_uint;
pub const relopt_kind_RELOPT_KIND_LOCAL: relopt_kind = 0;
pub const relopt_kind_RELOPT_KIND_HEAP: relopt_kind = 1;
pub const relopt_kind_RELOPT_KIND_TOAST: relopt_kind = 2;
pub const relopt_kind_RELOPT_KIND_BTREE: relopt_kind = 4;
pub const relopt_kind_RELOPT_KIND_HASH: relopt_kind = 8;
pub const relopt_kind_RELOPT_KIND_GIN: relopt_kind = 16;
pub const relopt_kind_RELOPT_KIND_GIST: relopt_kind = 32;
pub const relopt_kind_RELOPT_KIND_ATTRIBUTE: relopt_kind = 64;
pub const relopt_kind_RELOPT_KIND_TABLESPACE: relopt_kind = 128;
pub const relopt_kind_RELOPT_KIND_SPGIST: relopt_kind = 256;
pub const relopt_kind_RELOPT_KIND_VIEW: relopt_kind = 512;
pub const relopt_kind_RELOPT_KIND_BRIN: relopt_kind = 1024;
pub const relopt_kind_RELOPT_KIND_PARTITIONED: relopt_kind = 2048;
pub const relopt_kind_RELOPT_KIND_LAST_DEFAULT: relopt_kind = 2048;
pub const relopt_kind_RELOPT_KIND_MAX: relopt_kind = 1073741824;
pub type relopt_kind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct relopt_gen {
    pub name: *const ::std::os::raw::c_char,
    pub desc: *const ::std::os::raw::c_char,
    pub kinds: bits32,
    pub lockmode: LOCKMODE,
    pub namelen: ::std::os::raw::c_int,
    pub type_: relopt_type,
}
impl Default for relopt_gen {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct relopt_value {
    pub gen: *mut relopt_gen,
    pub isset: bool,
    pub values: relopt_value__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union relopt_value__bindgen_ty_1 {
    pub bool_val: bool,
    pub int_val: ::std::os::raw::c_int,
    pub real_val: f64,
    pub enum_val: ::std::os::raw::c_int,
    pub string_val: *mut ::std::os::raw::c_char,
}
impl Default for relopt_value__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for relopt_value {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct relopt_bool {
    pub gen: relopt_gen,
    pub default_val: bool,
}
impl Default for relopt_bool {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct relopt_int {
    pub gen: relopt_gen,
    pub default_val: ::std::os::raw::c_int,
    pub min: ::std::os::raw::c_int,
    pub max: ::std::os::raw::c_int,
}
impl Default for relopt_int {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct relopt_real {
    pub gen: relopt_gen,
    pub default_val: f64,
    pub min: f64,
    pub max: f64,
}
impl Default for relopt_real {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct relopt_enum_elt_def {
    pub string_val: *const ::std::os::raw::c_char,
    pub symbol_val: ::std::os::raw::c_int,
}
impl Default for relopt_enum_elt_def {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct relopt_enum {
    pub gen: relopt_gen,
    pub members: *mut relopt_enum_elt_def,
    pub default_val: ::std::os::raw::c_int,
    pub detailmsg: *const ::std::os::raw::c_char,
}
impl Default for relopt_enum {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type validate_string_relopt =
    ::std::option::Option<unsafe extern "C" fn(value: *const ::std::os::raw::c_char)>;
pub type fill_string_relopt = ::std::option::Option<
    unsafe extern "C" fn(
        value: *const ::std::os::raw::c_char,
        ptr: *mut ::std::os::raw::c_void,
    ) -> Size,
>;
pub type relopts_validator = ::std::option::Option<
    unsafe extern "C" fn(
        parsed_options: *mut ::std::os::raw::c_void,
        vals: *mut relopt_value,
        nvals: ::std::os::raw::c_int,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct relopt_string {
    pub gen: relopt_gen,
    pub default_len: ::std::os::raw::c_int,
    pub default_isnull: bool,
    pub validate_cb: validate_string_relopt,
    pub fill_cb: fill_string_relopt,
    pub default_val: *mut ::std::os::raw::c_char,
}
impl Default for relopt_string {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct relopt_parse_elt {
    pub optname: *const ::std::os::raw::c_char,
    pub opttype: relopt_type,
    pub offset: ::std::os::raw::c_int,
}
impl Default for relopt_parse_elt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_relopt {
    pub option: *mut relopt_gen,
    pub offset: ::std::os::raw::c_int,
}
impl Default for local_relopt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_relopts {
    pub options: *mut List,
    pub validators: *mut List,
    pub relopt_struct_size: Size,
}
impl Default for local_relopts {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CheckPoint {
    pub redo: XLogRecPtr,
    pub ThisTimeLineID: TimeLineID,
    pub PrevTimeLineID: TimeLineID,
    pub fullPageWrites: bool,
    pub nextXid: FullTransactionId,
    pub nextOid: Oid,
    pub nextMulti: MultiXactId,
    pub nextMultiOffset: MultiXactOffset,
    pub oldestXid: TransactionId,
    pub oldestXidDB: Oid,
    pub oldestMulti: MultiXactId,
    pub oldestMultiDB: Oid,
    pub time: pg_time_t,
    pub oldestCommitTsXid: TransactionId,
    pub newestCommitTsXid: TransactionId,
    pub oldestActiveXid: TransactionId,
}
impl Default for CheckPoint {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const DBState_DB_STARTUP: DBState = 0;
pub const DBState_DB_SHUTDOWNED: DBState = 1;
pub const DBState_DB_SHUTDOWNED_IN_RECOVERY: DBState = 2;
pub const DBState_DB_SHUTDOWNING: DBState = 3;
pub const DBState_DB_IN_CRASH_RECOVERY: DBState = 4;
pub const DBState_DB_IN_ARCHIVE_RECOVERY: DBState = 5;
pub const DBState_DB_IN_PRODUCTION: DBState = 6;
pub type DBState = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ControlFileData {
    pub system_identifier: uint64,
    pub pg_control_version: uint32,
    pub catalog_version_no: uint32,
    pub state: DBState,
    pub time: pg_time_t,
    pub checkPoint: XLogRecPtr,
    pub checkPointCopy: CheckPoint,
    pub unloggedLSN: XLogRecPtr,
    pub minRecoveryPoint: XLogRecPtr,
    pub minRecoveryPointTLI: TimeLineID,
    pub backupStartPoint: XLogRecPtr,
    pub backupEndPoint: XLogRecPtr,
    pub backupEndRequired: bool,
    pub wal_level: ::std::os::raw::c_int,
    pub wal_log_hints: bool,
    pub MaxConnections: ::std::os::raw::c_int,
    pub max_worker_processes: ::std::os::raw::c_int,
    pub max_wal_senders: ::std::os::raw::c_int,
    pub max_prepared_xacts: ::std::os::raw::c_int,
    pub max_locks_per_xact: ::std::os::raw::c_int,
    pub track_commit_timestamp: bool,
    pub maxAlign: uint32,
    pub floatFormat: f64,
    pub blcksz: uint32,
    pub relseg_size: uint32,
    pub xlog_blcksz: uint32,
    pub xlog_seg_size: uint32,
    pub nameDataLen: uint32,
    pub indexMaxKeys: uint32,
    pub toast_max_chunk_size: uint32,
    pub loblksize: uint32,
    pub float8ByVal: bool,
    pub data_checksum_version: uint32,
    pub mock_authentication_nonce: [::std::os::raw::c_char; 32usize],
    pub crc: pg_crc32c,
}
impl Default for ControlFileData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const RecoveryTargetType_RECOVERY_TARGET_UNSET: RecoveryTargetType = 0;
pub const RecoveryTargetType_RECOVERY_TARGET_XID: RecoveryTargetType = 1;
pub const RecoveryTargetType_RECOVERY_TARGET_TIME: RecoveryTargetType = 2;
pub const RecoveryTargetType_RECOVERY_TARGET_NAME: RecoveryTargetType = 3;
pub const RecoveryTargetType_RECOVERY_TARGET_LSN: RecoveryTargetType = 4;
pub const RecoveryTargetType_RECOVERY_TARGET_IMMEDIATE: RecoveryTargetType = 5;
pub type RecoveryTargetType = ::std::os::raw::c_uint;
pub const RecoveryTargetTimeLineGoal_RECOVERY_TARGET_TIMELINE_CONTROLFILE:
    RecoveryTargetTimeLineGoal = 0;
pub const RecoveryTargetTimeLineGoal_RECOVERY_TARGET_TIMELINE_LATEST: RecoveryTargetTimeLineGoal =
    1;
pub const RecoveryTargetTimeLineGoal_RECOVERY_TARGET_TIMELINE_NUMERIC: RecoveryTargetTimeLineGoal =
    2;
pub type RecoveryTargetTimeLineGoal = ::std::os::raw::c_uint;
pub const RecoveryPauseState_RECOVERY_NOT_PAUSED: RecoveryPauseState = 0;
pub const RecoveryPauseState_RECOVERY_PAUSE_REQUESTED: RecoveryPauseState = 1;
pub const RecoveryPauseState_RECOVERY_PAUSED: RecoveryPauseState = 2;
pub type RecoveryPauseState = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EndOfWalRecoveryInfo {
    pub lastRec: XLogRecPtr,
    pub lastRecTLI: TimeLineID,
    pub endOfLog: XLogRecPtr,
    pub endOfLogTLI: TimeLineID,
    pub lastPageBeginPtr: XLogRecPtr,
    pub lastPage: *mut ::std::os::raw::c_char,
    pub abortedRecPtr: XLogRecPtr,
    pub missingContrecPtr: XLogRecPtr,
    pub recoveryStopReason: *mut ::std::os::raw::c_char,
    pub standby_signal_file_found: bool,
    pub recovery_signal_file_found: bool,
}
impl Default for EndOfWalRecoveryInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const DependencyType_DEPENDENCY_NORMAL: DependencyType = 110;
pub const DependencyType_DEPENDENCY_AUTO: DependencyType = 97;
pub const DependencyType_DEPENDENCY_INTERNAL: DependencyType = 105;
pub const DependencyType_DEPENDENCY_PARTITION_PRI: DependencyType = 80;
pub const DependencyType_DEPENDENCY_PARTITION_SEC: DependencyType = 83;
pub const DependencyType_DEPENDENCY_EXTENSION: DependencyType = 101;
pub const DependencyType_DEPENDENCY_AUTO_EXTENSION: DependencyType = 120;
pub type DependencyType = ::std::os::raw::c_uint;
pub const SharedDependencyType_SHARED_DEPENDENCY_OWNER: SharedDependencyType = 111;
pub const SharedDependencyType_SHARED_DEPENDENCY_ACL: SharedDependencyType = 97;
pub const SharedDependencyType_SHARED_DEPENDENCY_POLICY: SharedDependencyType = 114;
pub const SharedDependencyType_SHARED_DEPENDENCY_TABLESPACE: SharedDependencyType = 116;
pub const SharedDependencyType_SHARED_DEPENDENCY_INVALID: SharedDependencyType = 0;
pub type SharedDependencyType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjectAddresses {
    _unused: [u8; 0],
}
pub const ObjectClass_OCLASS_CLASS: ObjectClass = 0;
pub const ObjectClass_OCLASS_PROC: ObjectClass = 1;
pub const ObjectClass_OCLASS_TYPE: ObjectClass = 2;
pub const ObjectClass_OCLASS_CAST: ObjectClass = 3;
pub const ObjectClass_OCLASS_COLLATION: ObjectClass = 4;
pub const ObjectClass_OCLASS_CONSTRAINT: ObjectClass = 5;
pub const ObjectClass_OCLASS_CONVERSION: ObjectClass = 6;
pub const ObjectClass_OCLASS_DEFAULT: ObjectClass = 7;
pub const ObjectClass_OCLASS_LANGUAGE: ObjectClass = 8;
pub const ObjectClass_OCLASS_LARGEOBJECT: ObjectClass = 9;
pub const ObjectClass_OCLASS_OPERATOR: ObjectClass = 10;
pub const ObjectClass_OCLASS_OPCLASS: ObjectClass = 11;
pub const ObjectClass_OCLASS_OPFAMILY: ObjectClass = 12;
pub const ObjectClass_OCLASS_AM: ObjectClass = 13;
pub const ObjectClass_OCLASS_AMOP: ObjectClass = 14;
pub const ObjectClass_OCLASS_AMPROC: ObjectClass = 15;
pub const ObjectClass_OCLASS_REWRITE: ObjectClass = 16;
pub const ObjectClass_OCLASS_TRIGGER: ObjectClass = 17;
pub const ObjectClass_OCLASS_SCHEMA: ObjectClass = 18;
pub const ObjectClass_OCLASS_STATISTIC_EXT: ObjectClass = 19;
pub const ObjectClass_OCLASS_TSPARSER: ObjectClass = 20;
pub const ObjectClass_OCLASS_TSDICT: ObjectClass = 21;
pub const ObjectClass_OCLASS_TSTEMPLATE: ObjectClass = 22;
pub const ObjectClass_OCLASS_TSCONFIG: ObjectClass = 23;
pub const ObjectClass_OCLASS_ROLE: ObjectClass = 24;
pub const ObjectClass_OCLASS_ROLE_MEMBERSHIP: ObjectClass = 25;
pub const ObjectClass_OCLASS_DATABASE: ObjectClass = 26;
pub const ObjectClass_OCLASS_TBLSPACE: ObjectClass = 27;
pub const ObjectClass_OCLASS_FDW: ObjectClass = 28;
pub const ObjectClass_OCLASS_FOREIGN_SERVER: ObjectClass = 29;
pub const ObjectClass_OCLASS_USER_MAPPING: ObjectClass = 30;
pub const ObjectClass_OCLASS_DEFACL: ObjectClass = 31;
pub const ObjectClass_OCLASS_EXTENSION: ObjectClass = 32;
pub const ObjectClass_OCLASS_EVENT_TRIGGER: ObjectClass = 33;
pub const ObjectClass_OCLASS_PARAMETER_ACL: ObjectClass = 34;
pub const ObjectClass_OCLASS_POLICY: ObjectClass = 35;
pub const ObjectClass_OCLASS_PUBLICATION: ObjectClass = 36;
pub const ObjectClass_OCLASS_PUBLICATION_NAMESPACE: ObjectClass = 37;
pub const ObjectClass_OCLASS_PUBLICATION_REL: ObjectClass = 38;
pub const ObjectClass_OCLASS_SUBSCRIPTION: ObjectClass = 39;
pub const ObjectClass_OCLASS_TRANSFORM: ObjectClass = 40;
pub type ObjectClass = ::std::os::raw::c_uint;
pub const IndexStateFlagsAction_INDEX_CREATE_SET_READY: IndexStateFlagsAction = 0;
pub const IndexStateFlagsAction_INDEX_CREATE_SET_VALID: IndexStateFlagsAction = 1;
pub const IndexStateFlagsAction_INDEX_DROP_CLEAR_VALID: IndexStateFlagsAction = 2;
pub const IndexStateFlagsAction_INDEX_DROP_SET_DEAD: IndexStateFlagsAction = 3;
pub type IndexStateFlagsAction = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReindexParams {
    pub options: bits32,
    pub tablespaceOid: Oid,
}
impl Default for ReindexParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ValidateIndexState {
    pub tuplesort: *mut Tuplesortstate,
    pub htups: f64,
    pub itups: f64,
    pub tups_inserted: f64,
}
impl Default for ValidateIndexState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CatalogIndexState = *mut ResultRelInfo;
#[repr(C)]
#[derive(Debug)]
pub struct _FuncCandidateList {
    pub next: *mut _FuncCandidateList,
    pub pathpos: ::std::os::raw::c_int,
    pub oid: Oid,
    pub nominalnargs: ::std::os::raw::c_int,
    pub nargs: ::std::os::raw::c_int,
    pub nvargs: ::std::os::raw::c_int,
    pub ndargs: ::std::os::raw::c_int,
    pub argnumbers: *mut ::std::os::raw::c_int,
    pub args: __IncompleteArrayField<Oid>,
}
impl Default for _FuncCandidateList {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FuncCandidateList = *mut _FuncCandidateList;
pub const TempNamespaceStatus_TEMP_NAMESPACE_NOT_TEMP: TempNamespaceStatus = 0;
pub const TempNamespaceStatus_TEMP_NAMESPACE_IDLE: TempNamespaceStatus = 1;
pub const TempNamespaceStatus_TEMP_NAMESPACE_IN_USE: TempNamespaceStatus = 2;
pub type TempNamespaceStatus = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OverrideSearchPath {
    pub schemas: *mut List,
    pub addCatalog: bool,
    pub addTemp: bool,
    pub generation: uint64,
}
impl Default for OverrideSearchPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const RVROption_RVR_MISSING_OK: RVROption = 1;
pub const RVROption_RVR_NOWAIT: RVROption = 2;
pub const RVROption_RVR_SKIP_LOCKED: RVROption = 4;
pub type RVROption = ::std::os::raw::c_uint;
pub type RangeVarGetRelidCallback = ::std::option::Option<
    unsafe extern "C" fn(
        relation: *const RangeVar,
        relId: Oid,
        oldRelId: Oid,
        callback_arg: *mut ::std::os::raw::c_void,
    ),
>;
pub const ObjectAccessType_OAT_POST_CREATE: ObjectAccessType = 0;
pub const ObjectAccessType_OAT_DROP: ObjectAccessType = 1;
pub const ObjectAccessType_OAT_POST_ALTER: ObjectAccessType = 2;
pub const ObjectAccessType_OAT_NAMESPACE_SEARCH: ObjectAccessType = 3;
pub const ObjectAccessType_OAT_FUNCTION_EXECUTE: ObjectAccessType = 4;
pub const ObjectAccessType_OAT_TRUNCATE: ObjectAccessType = 5;
pub type ObjectAccessType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ObjectAccessPostCreate {
    pub is_internal: bool,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ObjectAccessDrop {
    pub dropflags: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjectAccessPostAlter {
    pub auxiliary_id: Oid,
    pub is_internal: bool,
}
impl Default for ObjectAccessPostAlter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ObjectAccessNamespaceSearch {
    pub ereport_on_violation: bool,
    pub result: bool,
}
pub type object_access_hook_type = ::std::option::Option<
    unsafe extern "C" fn(
        access: ObjectAccessType,
        classId: Oid,
        objectId: Oid,
        subId: ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
pub type object_access_hook_type_str = ::std::option::Option<
    unsafe extern "C" fn(
        access: ObjectAccessType,
        classId: Oid,
        objectStr: *const ::std::os::raw::c_char,
        subId: ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_am {
    pub oid: Oid,
    pub amname: NameData,
    pub amhandler: regproc,
    pub amtype: ::std::os::raw::c_char,
}
impl Default for FormData_pg_am {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_am = *mut FormData_pg_am;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_amop {
    pub oid: Oid,
    pub amopfamily: Oid,
    pub amoplefttype: Oid,
    pub amoprighttype: Oid,
    pub amopstrategy: int16,
    pub amoppurpose: ::std::os::raw::c_char,
    pub amopopr: Oid,
    pub amopmethod: Oid,
    pub amopsortfamily: Oid,
}
impl Default for FormData_pg_amop {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_amop = *mut FormData_pg_amop;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_amproc {
    pub oid: Oid,
    pub amprocfamily: Oid,
    pub amproclefttype: Oid,
    pub amprocrighttype: Oid,
    pub amprocnum: int16,
    pub amproc: regproc,
}
impl Default for FormData_pg_amproc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_amproc = *mut FormData_pg_amproc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_authid {
    pub oid: Oid,
    pub rolname: NameData,
    pub rolsuper: bool,
    pub rolinherit: bool,
    pub rolcreaterole: bool,
    pub rolcreatedb: bool,
    pub rolcanlogin: bool,
    pub rolreplication: bool,
    pub rolbypassrls: bool,
    pub rolconnlimit: int32,
}
impl Default for FormData_pg_authid {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_authid = *mut FormData_pg_authid;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_collation {
    pub oid: Oid,
    pub collname: NameData,
    pub collnamespace: Oid,
    pub collowner: Oid,
    pub collprovider: ::std::os::raw::c_char,
    pub collisdeterministic: bool,
    pub collencoding: int32,
}
impl Default for FormData_pg_collation {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_collation = *mut FormData_pg_collation;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_database {
    pub oid: Oid,
    pub datname: NameData,
    pub datdba: Oid,
    pub encoding: int32,
    pub datlocprovider: ::std::os::raw::c_char,
    pub datistemplate: bool,
    pub datallowconn: bool,
    pub datconnlimit: int32,
    pub datfrozenxid: TransactionId,
    pub datminmxid: TransactionId,
    pub dattablespace: Oid,
}
impl Default for FormData_pg_database {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_database = *mut FormData_pg_database;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_enum {
    pub oid: Oid,
    pub enumtypid: Oid,
    pub enumsortorder: float4,
    pub enumlabel: NameData,
}
impl Default for FormData_pg_enum {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_enum = *mut FormData_pg_enum;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_extension {
    pub oid: Oid,
    pub extname: NameData,
    pub extowner: Oid,
    pub extnamespace: Oid,
    pub extrelocatable: bool,
}
impl Default for FormData_pg_extension {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_extension = *mut FormData_pg_extension;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_foreign_server {
    pub oid: Oid,
    pub srvname: NameData,
    pub srvowner: Oid,
    pub srvfdw: Oid,
}
impl Default for FormData_pg_foreign_server {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_foreign_server = *mut FormData_pg_foreign_server;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_foreign_table {
    pub ftrelid: Oid,
    pub ftserver: Oid,
}
impl Default for FormData_pg_foreign_table {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_foreign_table = *mut FormData_pg_foreign_table;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_operator {
    pub oid: Oid,
    pub oprname: NameData,
    pub oprnamespace: Oid,
    pub oprowner: Oid,
    pub oprkind: ::std::os::raw::c_char,
    pub oprcanmerge: bool,
    pub oprcanhash: bool,
    pub oprleft: Oid,
    pub oprright: Oid,
    pub oprresult: Oid,
    pub oprcom: Oid,
    pub oprnegate: Oid,
    pub oprcode: regproc,
    pub oprrest: regproc,
    pub oprjoin: regproc,
}
impl Default for FormData_pg_operator {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_operator = *mut FormData_pg_operator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_opclass {
    pub oid: Oid,
    pub opcmethod: Oid,
    pub opcname: NameData,
    pub opcnamespace: Oid,
    pub opcowner: Oid,
    pub opcfamily: Oid,
    pub opcintype: Oid,
    pub opcdefault: bool,
    pub opckeytype: Oid,
}
impl Default for FormData_pg_opclass {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_opclass = *mut FormData_pg_opclass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_opfamily {
    pub oid: Oid,
    pub opfmethod: Oid,
    pub opfname: NameData,
    pub opfnamespace: Oid,
    pub opfowner: Oid,
}
impl Default for FormData_pg_opfamily {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_opfamily = *mut FormData_pg_opfamily;
#[repr(C)]
#[derive(Debug)]
pub struct FormData_pg_proc {
    pub oid: Oid,
    pub proname: NameData,
    pub pronamespace: Oid,
    pub proowner: Oid,
    pub prolang: Oid,
    pub procost: float4,
    pub prorows: float4,
    pub provariadic: Oid,
    pub prosupport: regproc,
    pub prokind: ::std::os::raw::c_char,
    pub prosecdef: bool,
    pub proleakproof: bool,
    pub proisstrict: bool,
    pub proretset: bool,
    pub provolatile: ::std::os::raw::c_char,
    pub proparallel: ::std::os::raw::c_char,
    pub pronargs: int16,
    pub pronargdefaults: int16,
    pub prorettype: Oid,
    pub proargtypes: oidvector,
}
impl Default for FormData_pg_proc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_proc = *mut FormData_pg_proc;
pub const ParseExprKind_EXPR_KIND_NONE: ParseExprKind = 0;
pub const ParseExprKind_EXPR_KIND_OTHER: ParseExprKind = 1;
pub const ParseExprKind_EXPR_KIND_JOIN_ON: ParseExprKind = 2;
pub const ParseExprKind_EXPR_KIND_JOIN_USING: ParseExprKind = 3;
pub const ParseExprKind_EXPR_KIND_FROM_SUBSELECT: ParseExprKind = 4;
pub const ParseExprKind_EXPR_KIND_FROM_FUNCTION: ParseExprKind = 5;
pub const ParseExprKind_EXPR_KIND_WHERE: ParseExprKind = 6;
pub const ParseExprKind_EXPR_KIND_HAVING: ParseExprKind = 7;
pub const ParseExprKind_EXPR_KIND_FILTER: ParseExprKind = 8;
pub const ParseExprKind_EXPR_KIND_WINDOW_PARTITION: ParseExprKind = 9;
pub const ParseExprKind_EXPR_KIND_WINDOW_ORDER: ParseExprKind = 10;
pub const ParseExprKind_EXPR_KIND_WINDOW_FRAME_RANGE: ParseExprKind = 11;
pub const ParseExprKind_EXPR_KIND_WINDOW_FRAME_ROWS: ParseExprKind = 12;
pub const ParseExprKind_EXPR_KIND_WINDOW_FRAME_GROUPS: ParseExprKind = 13;
pub const ParseExprKind_EXPR_KIND_SELECT_TARGET: ParseExprKind = 14;
pub const ParseExprKind_EXPR_KIND_INSERT_TARGET: ParseExprKind = 15;
pub const ParseExprKind_EXPR_KIND_UPDATE_SOURCE: ParseExprKind = 16;
pub const ParseExprKind_EXPR_KIND_UPDATE_TARGET: ParseExprKind = 17;
pub const ParseExprKind_EXPR_KIND_MERGE_WHEN: ParseExprKind = 18;
pub const ParseExprKind_EXPR_KIND_GROUP_BY: ParseExprKind = 19;
pub const ParseExprKind_EXPR_KIND_ORDER_BY: ParseExprKind = 20;
pub const ParseExprKind_EXPR_KIND_DISTINCT_ON: ParseExprKind = 21;
pub const ParseExprKind_EXPR_KIND_LIMIT: ParseExprKind = 22;
pub const ParseExprKind_EXPR_KIND_OFFSET: ParseExprKind = 23;
pub const ParseExprKind_EXPR_KIND_RETURNING: ParseExprKind = 24;
pub const ParseExprKind_EXPR_KIND_VALUES: ParseExprKind = 25;
pub const ParseExprKind_EXPR_KIND_VALUES_SINGLE: ParseExprKind = 26;
pub const ParseExprKind_EXPR_KIND_CHECK_CONSTRAINT: ParseExprKind = 27;
pub const ParseExprKind_EXPR_KIND_DOMAIN_CHECK: ParseExprKind = 28;
pub const ParseExprKind_EXPR_KIND_COLUMN_DEFAULT: ParseExprKind = 29;
pub const ParseExprKind_EXPR_KIND_FUNCTION_DEFAULT: ParseExprKind = 30;
pub const ParseExprKind_EXPR_KIND_INDEX_EXPRESSION: ParseExprKind = 31;
pub const ParseExprKind_EXPR_KIND_INDEX_PREDICATE: ParseExprKind = 32;
pub const ParseExprKind_EXPR_KIND_STATS_EXPRESSION: ParseExprKind = 33;
pub const ParseExprKind_EXPR_KIND_ALTER_COL_TRANSFORM: ParseExprKind = 34;
pub const ParseExprKind_EXPR_KIND_EXECUTE_PARAMETER: ParseExprKind = 35;
pub const ParseExprKind_EXPR_KIND_TRIGGER_WHEN: ParseExprKind = 36;
pub const ParseExprKind_EXPR_KIND_POLICY: ParseExprKind = 37;
pub const ParseExprKind_EXPR_KIND_PARTITION_BOUND: ParseExprKind = 38;
pub const ParseExprKind_EXPR_KIND_PARTITION_EXPRESSION: ParseExprKind = 39;
pub const ParseExprKind_EXPR_KIND_CALL_ARGUMENT: ParseExprKind = 40;
pub const ParseExprKind_EXPR_KIND_COPY_WHERE: ParseExprKind = 41;
pub const ParseExprKind_EXPR_KIND_GENERATED_COLUMN: ParseExprKind = 42;
pub const ParseExprKind_EXPR_KIND_CYCLE_MARK: ParseExprKind = 43;
pub type ParseExprKind = ::std::os::raw::c_uint;
pub type PreParseColumnRefHook = ::std::option::Option<
    unsafe extern "C" fn(pstate: *mut ParseState, cref: *mut ColumnRef) -> *mut Node,
>;
pub type PostParseColumnRefHook = ::std::option::Option<
    unsafe extern "C" fn(
        pstate: *mut ParseState,
        cref: *mut ColumnRef,
        var: *mut Node,
    ) -> *mut Node,
>;
pub type ParseParamRefHook = ::std::option::Option<
    unsafe extern "C" fn(pstate: *mut ParseState, pref: *mut ParamRef) -> *mut Node,
>;
pub type CoerceParamHook = ::std::option::Option<
    unsafe extern "C" fn(
        pstate: *mut ParseState,
        param: *mut Param,
        targetTypeId: Oid,
        targetTypeMod: int32,
        location: ::std::os::raw::c_int,
    ) -> *mut Node,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParseState {
    pub parentParseState: *mut ParseState,
    pub p_sourcetext: *const ::std::os::raw::c_char,
    pub p_rtable: *mut List,
    pub p_rteperminfos: *mut List,
    pub p_joinexprs: *mut List,
    pub p_nullingrels: *mut List,
    pub p_joinlist: *mut List,
    pub p_namespace: *mut List,
    pub p_lateral_active: bool,
    pub p_ctenamespace: *mut List,
    pub p_future_ctes: *mut List,
    pub p_parent_cte: *mut CommonTableExpr,
    pub p_target_relation: Relation,
    pub p_target_nsitem: *mut ParseNamespaceItem,
    pub p_is_insert: bool,
    pub p_windowdefs: *mut List,
    pub p_expr_kind: ParseExprKind,
    pub p_next_resno: ::std::os::raw::c_int,
    pub p_multiassign_exprs: *mut List,
    pub p_locking_clause: *mut List,
    pub p_locked_from_parent: bool,
    pub p_resolve_unknowns: bool,
    pub p_queryEnv: *mut QueryEnvironment,
    pub p_hasAggs: bool,
    pub p_hasWindowFuncs: bool,
    pub p_hasTargetSRFs: bool,
    pub p_hasSubLinks: bool,
    pub p_hasModifyingCTE: bool,
    pub p_last_srf: *mut Node,
    pub p_pre_columnref_hook: PreParseColumnRefHook,
    pub p_post_columnref_hook: PostParseColumnRefHook,
    pub p_paramref_hook: ParseParamRefHook,
    pub p_coerce_param_hook: CoerceParamHook,
    pub p_ref_hook_state: *mut ::std::os::raw::c_void,
}
impl Default for ParseState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParseNamespaceItem {
    pub p_names: *mut Alias,
    pub p_rte: *mut RangeTblEntry,
    pub p_rtindex: ::std::os::raw::c_int,
    pub p_perminfo: *mut RTEPermissionInfo,
    pub p_nscolumns: *mut ParseNamespaceColumn,
    pub p_rel_visible: bool,
    pub p_cols_visible: bool,
    pub p_lateral_only: bool,
    pub p_lateral_ok: bool,
}
impl Default for ParseNamespaceItem {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParseNamespaceColumn {
    pub p_varno: Index,
    pub p_varattno: AttrNumber,
    pub p_vartype: Oid,
    pub p_vartypmod: int32,
    pub p_varcollid: Oid,
    pub p_varnosyn: Index,
    pub p_varattnosyn: AttrNumber,
    pub p_dontexpand: bool,
}
impl Default for ParseNamespaceColumn {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParseCallbackState {
    pub pstate: *mut ParseState,
    pub location: ::std::os::raw::c_int,
    pub errcallback: ErrorContextCallback,
}
impl Default for ParseCallbackState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AclItem {
    pub ai_grantee: Oid,
    pub ai_grantor: Oid,
    pub ai_privs: AclMode,
}
impl Default for AclItem {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Acl = ArrayType;
pub const AclMaskHow_ACLMASK_ALL: AclMaskHow = 0;
pub const AclMaskHow_ACLMASK_ANY: AclMaskHow = 1;
pub type AclMaskHow = ::std::os::raw::c_uint;
pub const AclResult_ACLCHECK_OK: AclResult = 0;
pub const AclResult_ACLCHECK_NO_PRIV: AclResult = 1;
pub const AclResult_ACLCHECK_NOT_OWNER: AclResult = 2;
pub type AclResult = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_namespace {
    pub oid: Oid,
    pub nspname: NameData,
    pub nspowner: Oid,
}
impl Default for FormData_pg_namespace {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_namespace = *mut FormData_pg_namespace;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_tablespace {
    pub oid: Oid,
    pub spcname: NameData,
    pub spcowner: Oid,
}
impl Default for FormData_pg_tablespace {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_tablespace = *mut FormData_pg_tablespace;
#[repr(C)]
#[derive(Debug)]
pub struct FormData_pg_trigger {
    pub oid: Oid,
    pub tgrelid: Oid,
    pub tgparentid: Oid,
    pub tgname: NameData,
    pub tgfoid: Oid,
    pub tgtype: int16,
    pub tgenabled: ::std::os::raw::c_char,
    pub tgisinternal: bool,
    pub tgconstrrelid: Oid,
    pub tgconstrindid: Oid,
    pub tgconstraint: Oid,
    pub tgdeferrable: bool,
    pub tginitdeferred: bool,
    pub tgnargs: int16,
    pub tgattr: int2vector,
}
impl Default for FormData_pg_trigger {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_trigger = *mut FormData_pg_trigger;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_type {
    pub oid: Oid,
    pub typname: NameData,
    pub typnamespace: Oid,
    pub typowner: Oid,
    pub typlen: int16,
    pub typbyval: bool,
    pub typtype: ::std::os::raw::c_char,
    pub typcategory: ::std::os::raw::c_char,
    pub typispreferred: bool,
    pub typisdefined: bool,
    pub typdelim: ::std::os::raw::c_char,
    pub typrelid: Oid,
    pub typsubscript: regproc,
    pub typelem: Oid,
    pub typarray: Oid,
    pub typinput: regproc,
    pub typoutput: regproc,
    pub typreceive: regproc,
    pub typsend: regproc,
    pub typmodin: regproc,
    pub typmodout: regproc,
    pub typanalyze: regproc,
    pub typalign: ::std::os::raw::c_char,
    pub typstorage: ::std::os::raw::c_char,
    pub typnotnull: bool,
    pub typbasetype: Oid,
    pub typtypmod: int32,
    pub typndims: int32,
    pub typcollation: Oid,
}
impl Default for FormData_pg_type {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_type = *mut FormData_pg_type;
pub type EOM_get_flat_size_method =
    ::std::option::Option<unsafe extern "C" fn(eohptr: *mut ExpandedObjectHeader) -> Size>;
pub type EOM_flatten_into_method = ::std::option::Option<
    unsafe extern "C" fn(
        eohptr: *mut ExpandedObjectHeader,
        result: *mut ::std::os::raw::c_void,
        allocated_size: Size,
    ),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ExpandedObjectMethods {
    pub get_flat_size: EOM_get_flat_size_method,
    pub flatten_into: EOM_flatten_into_method,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExpandedObjectHeader {
    pub vl_len_: int32,
    pub eoh_methods: *const ExpandedObjectMethods,
    pub eoh_context: MemoryContext,
    pub eoh_rw_ptr: [::std::os::raw::c_char; 10usize],
    pub eoh_ro_ptr: [::std::os::raw::c_char; 10usize],
}
impl Default for ExpandedObjectHeader {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayType {
    pub vl_len_: int32,
    pub ndim: ::std::os::raw::c_int,
    pub dataoffset: int32,
    pub elemtype: Oid,
}
impl Default for ArrayType {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExpandedArrayHeader {
    pub hdr: ExpandedObjectHeader,
    pub ea_magic: ::std::os::raw::c_int,
    pub ndims: ::std::os::raw::c_int,
    pub dims: *mut ::std::os::raw::c_int,
    pub lbound: *mut ::std::os::raw::c_int,
    pub element_type: Oid,
    pub typlen: int16,
    pub typbyval: bool,
    pub typalign: ::std::os::raw::c_char,
    pub dvalues: *mut Datum,
    pub dnulls: *mut bool,
    pub dvalueslen: ::std::os::raw::c_int,
    pub nelems: ::std::os::raw::c_int,
    pub flat_size: Size,
    pub fvalue: *mut ArrayType,
    pub fstartptr: *mut ::std::os::raw::c_char,
    pub fendptr: *mut ::std::os::raw::c_char,
}
impl Default for ExpandedArrayHeader {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AnyArrayType {
    pub flt: ArrayType,
    pub xpn: ExpandedArrayHeader,
}
impl Default for AnyArrayType {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayBuildState {
    pub mcontext: MemoryContext,
    pub dvalues: *mut Datum,
    pub dnulls: *mut bool,
    pub alen: ::std::os::raw::c_int,
    pub nelems: ::std::os::raw::c_int,
    pub element_type: Oid,
    pub typlen: int16,
    pub typbyval: bool,
    pub typalign: ::std::os::raw::c_char,
    pub private_cxt: bool,
}
impl Default for ArrayBuildState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayBuildStateArr {
    pub mcontext: MemoryContext,
    pub data: *mut ::std::os::raw::c_char,
    pub nullbitmap: *mut bits8,
    pub abytes: ::std::os::raw::c_int,
    pub nbytes: ::std::os::raw::c_int,
    pub aitems: ::std::os::raw::c_int,
    pub nitems: ::std::os::raw::c_int,
    pub ndims: ::std::os::raw::c_int,
    pub dims: [::std::os::raw::c_int; 6usize],
    pub lbs: [::std::os::raw::c_int; 6usize],
    pub array_type: Oid,
    pub element_type: Oid,
    pub private_cxt: bool,
}
impl Default for ArrayBuildStateArr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayBuildStateAny {
    pub scalarstate: *mut ArrayBuildState,
    pub arraystate: *mut ArrayBuildStateArr,
}
impl Default for ArrayBuildStateAny {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayMetaState {
    pub element_type: Oid,
    pub typlen: int16,
    pub typbyval: bool,
    pub typalign: ::std::os::raw::c_char,
    pub typdelim: ::std::os::raw::c_char,
    pub typioparam: Oid,
    pub typiofunc: Oid,
    pub proc_: FmgrInfo,
}
impl Default for ArrayMetaState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayMapState {
    pub inp_extra: ArrayMetaState,
    pub ret_extra: ArrayMetaState,
}
impl Default for ArrayMapState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayIteratorData {
    _unused: [u8; 0],
}
pub type ArrayIterator = *mut ArrayIteratorData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_event_trigger {
    pub oid: Oid,
    pub evtname: NameData,
    pub evtevent: NameData,
    pub evtowner: Oid,
    pub evtfoid: Oid,
    pub evtenabled: ::std::os::raw::c_char,
}
impl Default for FormData_pg_event_trigger {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_event_trigger = *mut FormData_pg_event_trigger;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InternalGrant {
    pub is_grant: bool,
    pub objtype: ObjectType,
    pub objects: *mut List,
    pub all_privs: bool,
    pub privileges: AclMode,
    pub col_privs: *mut List,
    pub grantees: *mut List,
    pub grant_option: bool,
    pub behavior: DropBehavior,
}
impl Default for InternalGrant {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const CollectedCommandType_SCT_Simple: CollectedCommandType = 0;
pub const CollectedCommandType_SCT_AlterTable: CollectedCommandType = 1;
pub const CollectedCommandType_SCT_Grant: CollectedCommandType = 2;
pub const CollectedCommandType_SCT_AlterOpFamily: CollectedCommandType = 3;
pub const CollectedCommandType_SCT_AlterDefaultPrivileges: CollectedCommandType = 4;
pub const CollectedCommandType_SCT_CreateOpClass: CollectedCommandType = 5;
pub const CollectedCommandType_SCT_AlterTSConfig: CollectedCommandType = 6;
pub type CollectedCommandType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CollectedATSubcmd {
    pub address: ObjectAddress,
    pub parsetree: *mut Node,
}
impl Default for CollectedATSubcmd {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CollectedCommand {
    pub type_: CollectedCommandType,
    pub in_extension: bool,
    pub parsetree: *mut Node,
    pub d: CollectedCommand__bindgen_ty_1,
    pub parent: *mut CollectedCommand,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CollectedCommand__bindgen_ty_1 {
    pub simple: CollectedCommand__bindgen_ty_1__bindgen_ty_1,
    pub alterTable: CollectedCommand__bindgen_ty_1__bindgen_ty_2,
    pub grant: CollectedCommand__bindgen_ty_1__bindgen_ty_3,
    pub opfam: CollectedCommand__bindgen_ty_1__bindgen_ty_4,
    pub createopc: CollectedCommand__bindgen_ty_1__bindgen_ty_5,
    pub atscfg: CollectedCommand__bindgen_ty_1__bindgen_ty_6,
    pub defprivs: CollectedCommand__bindgen_ty_1__bindgen_ty_7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CollectedCommand__bindgen_ty_1__bindgen_ty_1 {
    pub address: ObjectAddress,
    pub secondaryObject: ObjectAddress,
}
impl Default for CollectedCommand__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CollectedCommand__bindgen_ty_1__bindgen_ty_2 {
    pub objectId: Oid,
    pub classId: Oid,
    pub subcmds: *mut List,
}
impl Default for CollectedCommand__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CollectedCommand__bindgen_ty_1__bindgen_ty_3 {
    pub istmt: *mut InternalGrant,
}
impl Default for CollectedCommand__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CollectedCommand__bindgen_ty_1__bindgen_ty_4 {
    pub address: ObjectAddress,
    pub operators: *mut List,
    pub procedures: *mut List,
}
impl Default for CollectedCommand__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CollectedCommand__bindgen_ty_1__bindgen_ty_5 {
    pub address: ObjectAddress,
    pub operators: *mut List,
    pub procedures: *mut List,
}
impl Default for CollectedCommand__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CollectedCommand__bindgen_ty_1__bindgen_ty_6 {
    pub address: ObjectAddress,
    pub dictIds: *mut Oid,
    pub ndicts: ::std::os::raw::c_int,
}
impl Default for CollectedCommand__bindgen_ty_1__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CollectedCommand__bindgen_ty_1__bindgen_ty_7 {
    pub objtype: ObjectType,
}
impl Default for CollectedCommand__bindgen_ty_1__bindgen_ty_7 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for CollectedCommand__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for CollectedCommand {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EventTriggerData {
    pub type_: NodeTag,
    pub event: *const ::std::os::raw::c_char,
    pub parsetree: *mut Node,
    pub tag: CommandTag,
}
impl Default for EventTriggerData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ExplainFormat_EXPLAIN_FORMAT_TEXT: ExplainFormat = 0;
pub const ExplainFormat_EXPLAIN_FORMAT_XML: ExplainFormat = 1;
pub const ExplainFormat_EXPLAIN_FORMAT_JSON: ExplainFormat = 2;
pub const ExplainFormat_EXPLAIN_FORMAT_YAML: ExplainFormat = 3;
pub type ExplainFormat = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExplainWorkersState {
    pub num_workers: ::std::os::raw::c_int,
    pub worker_inited: *mut bool,
    pub worker_str: *mut StringInfoData,
    pub worker_state_save: *mut ::std::os::raw::c_int,
    pub prev_str: StringInfo,
}
impl Default for ExplainWorkersState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExplainState {
    pub str_: StringInfo,
    pub verbose: bool,
    pub analyze: bool,
    pub costs: bool,
    pub buffers: bool,
    pub wal: bool,
    pub timing: bool,
    pub summary: bool,
    pub settings: bool,
    pub generic: bool,
    pub format: ExplainFormat,
    pub indent: ::std::os::raw::c_int,
    pub grouping_stack: *mut List,
    pub pstmt: *mut PlannedStmt,
    pub rtable: *mut List,
    pub rtable_names: *mut List,
    pub deparse_cxt: *mut List,
    pub printed_subplans: *mut Bitmapset,
    pub hide_workers: bool,
    pub workers_state: *mut ExplainWorkersState,
}
impl Default for ExplainState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ExplainOneQuery_hook_type = ::std::option::Option<
    unsafe extern "C" fn(
        query: *mut Query,
        cursorOptions: ::std::os::raw::c_int,
        into: *mut IntoClause,
        es: *mut ExplainState,
        queryString: *const ::std::os::raw::c_char,
        params: ParamListInfo,
        queryEnv: *mut QueryEnvironment,
    ),
>;
pub type explain_get_index_name_hook_type =
    ::std::option::Option<unsafe extern "C" fn(indexId: Oid) -> *const ::std::os::raw::c_char>;
pub type check_object_relabel_type = ::std::option::Option<
    unsafe extern "C" fn(object: *const ObjectAddress, seclabel: *const ::std::os::raw::c_char),
>;
#[repr(C)]
#[derive(Debug)]
pub struct xl_tblspc_create_rec {
    pub ts_id: Oid,
    pub ts_path: __IncompleteArrayField<::std::os::raw::c_char>,
}
impl Default for xl_tblspc_create_rec {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xl_tblspc_drop_rec {
    pub ts_id: Oid,
}
impl Default for xl_tblspc_drop_rec {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TableSpaceOpts {
    pub vl_len_: int32,
    pub random_page_cost: float8,
    pub seq_page_cost: float8,
    pub effective_io_concurrency: ::std::os::raw::c_int,
    pub maintenance_io_concurrency: ::std::os::raw::c_int,
}
pub type TriggerEvent = uint32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TriggerData {
    pub type_: NodeTag,
    pub tg_event: TriggerEvent,
    pub tg_relation: Relation,
    pub tg_trigtuple: HeapTuple,
    pub tg_newtuple: HeapTuple,
    pub tg_trigger: *mut Trigger,
    pub tg_trigslot: *mut TupleTableSlot,
    pub tg_newslot: *mut TupleTableSlot,
    pub tg_oldtable: *mut Tuplestorestate,
    pub tg_newtable: *mut Tuplestorestate,
    pub tg_updatedcols: *const Bitmapset,
}
impl Default for TriggerData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AfterTriggersTableData {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TransitionCaptureState {
    pub tcs_delete_old_table: bool,
    pub tcs_update_old_table: bool,
    pub tcs_update_new_table: bool,
    pub tcs_insert_new_table: bool,
    pub tcs_original_insert_tuple: *mut TupleTableSlot,
    pub tcs_private: *mut AfterTriggersTableData,
}
impl Default for TransitionCaptureState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const PasswordType_PASSWORD_TYPE_PLAINTEXT: PasswordType = 0;
pub const PasswordType_PASSWORD_TYPE_MD5: PasswordType = 1;
pub const PasswordType_PASSWORD_TYPE_SCRAM_SHA_256: PasswordType = 2;
pub type PasswordType = ::std::os::raw::c_uint;
pub const GucContext_PGC_INTERNAL: GucContext = 0;
pub const GucContext_PGC_POSTMASTER: GucContext = 1;
pub const GucContext_PGC_SIGHUP: GucContext = 2;
pub const GucContext_PGC_SU_BACKEND: GucContext = 3;
pub const GucContext_PGC_BACKEND: GucContext = 4;
pub const GucContext_PGC_SUSET: GucContext = 5;
pub const GucContext_PGC_USERSET: GucContext = 6;
pub type GucContext = ::std::os::raw::c_uint;
pub const GucSource_PGC_S_DEFAULT: GucSource = 0;
pub const GucSource_PGC_S_DYNAMIC_DEFAULT: GucSource = 1;
pub const GucSource_PGC_S_ENV_VAR: GucSource = 2;
pub const GucSource_PGC_S_FILE: GucSource = 3;
pub const GucSource_PGC_S_ARGV: GucSource = 4;
pub const GucSource_PGC_S_GLOBAL: GucSource = 5;
pub const GucSource_PGC_S_DATABASE: GucSource = 6;
pub const GucSource_PGC_S_USER: GucSource = 7;
pub const GucSource_PGC_S_DATABASE_USER: GucSource = 8;
pub const GucSource_PGC_S_CLIENT: GucSource = 9;
pub const GucSource_PGC_S_OVERRIDE: GucSource = 10;
pub const GucSource_PGC_S_INTERACTIVE: GucSource = 11;
pub const GucSource_PGC_S_TEST: GucSource = 12;
pub const GucSource_PGC_S_SESSION: GucSource = 13;
pub type GucSource = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConfigVariable {
    pub name: *mut ::std::os::raw::c_char,
    pub value: *mut ::std::os::raw::c_char,
    pub errmsg: *mut ::std::os::raw::c_char,
    pub filename: *mut ::std::os::raw::c_char,
    pub sourceline: ::std::os::raw::c_int,
    pub ignore: bool,
    pub applied: bool,
    pub next: *mut ConfigVariable,
}
impl Default for ConfigVariable {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct config_enum_entry {
    pub name: *const ::std::os::raw::c_char,
    pub val: ::std::os::raw::c_int,
    pub hidden: bool,
}
impl Default for config_enum_entry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type GucBoolCheckHook = ::std::option::Option<
    unsafe extern "C" fn(
        newval: *mut bool,
        extra: *mut *mut ::std::os::raw::c_void,
        source: GucSource,
    ) -> bool,
>;
pub type GucIntCheckHook = ::std::option::Option<
    unsafe extern "C" fn(
        newval: *mut ::std::os::raw::c_int,
        extra: *mut *mut ::std::os::raw::c_void,
        source: GucSource,
    ) -> bool,
>;
pub type GucRealCheckHook = ::std::option::Option<
    unsafe extern "C" fn(
        newval: *mut f64,
        extra: *mut *mut ::std::os::raw::c_void,
        source: GucSource,
    ) -> bool,
>;
pub type GucStringCheckHook = ::std::option::Option<
    unsafe extern "C" fn(
        newval: *mut *mut ::std::os::raw::c_char,
        extra: *mut *mut ::std::os::raw::c_void,
        source: GucSource,
    ) -> bool,
>;
pub type GucEnumCheckHook = ::std::option::Option<
    unsafe extern "C" fn(
        newval: *mut ::std::os::raw::c_int,
        extra: *mut *mut ::std::os::raw::c_void,
        source: GucSource,
    ) -> bool,
>;
pub type GucBoolAssignHook =
    ::std::option::Option<unsafe extern "C" fn(newval: bool, extra: *mut ::std::os::raw::c_void)>;
pub type GucIntAssignHook = ::std::option::Option<
    unsafe extern "C" fn(newval: ::std::os::raw::c_int, extra: *mut ::std::os::raw::c_void),
>;
pub type GucRealAssignHook =
    ::std::option::Option<unsafe extern "C" fn(newval: f64, extra: *mut ::std::os::raw::c_void)>;
pub type GucStringAssignHook = ::std::option::Option<
    unsafe extern "C" fn(newval: *const ::std::os::raw::c_char, extra: *mut ::std::os::raw::c_void),
>;
pub type GucEnumAssignHook = ::std::option::Option<
    unsafe extern "C" fn(newval: ::std::os::raw::c_int, extra: *mut ::std::os::raw::c_void),
>;
pub type GucShowHook =
    ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_char>;
pub const GucAction_GUC_ACTION_SET: GucAction = 0;
pub const GucAction_GUC_ACTION_LOCAL: GucAction = 1;
pub const GucAction_GUC_ACTION_SAVE: GucAction = 2;
pub type GucAction = ::std::os::raw::c_uint;
pub type check_password_hook_type = ::std::option::Option<
    unsafe extern "C" fn(
        username: *const ::std::os::raw::c_char,
        shadow_pass: *const ::std::os::raw::c_char,
        password_type: PasswordType,
        validuntil_time: Datum,
        validuntil_null: bool,
    ),
>;
pub type bgworker_main_type = ::std::option::Option<unsafe extern "C" fn(main_arg: Datum)>;
pub const BgWorkerStartTime_BgWorkerStart_PostmasterStart: BgWorkerStartTime = 0;
pub const BgWorkerStartTime_BgWorkerStart_ConsistentState: BgWorkerStartTime = 1;
pub const BgWorkerStartTime_BgWorkerStart_RecoveryFinished: BgWorkerStartTime = 2;
pub type BgWorkerStartTime = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BackgroundWorker {
    pub bgw_name: [::std::os::raw::c_char; 96usize],
    pub bgw_type: [::std::os::raw::c_char; 96usize],
    pub bgw_flags: ::std::os::raw::c_int,
    pub bgw_start_time: BgWorkerStartTime,
    pub bgw_restart_time: ::std::os::raw::c_int,
    pub bgw_library_name: [::std::os::raw::c_char; 96usize],
    pub bgw_function_name: [::std::os::raw::c_char; 96usize],
    pub bgw_main_arg: Datum,
    pub bgw_extra: [::std::os::raw::c_char; 128usize],
    pub bgw_notify_pid: pid_t,
}
impl Default for BackgroundWorker {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const BgwHandleStatus_BGWH_STARTED: BgwHandleStatus = 0;
pub const BgwHandleStatus_BGWH_NOT_YET_STARTED: BgwHandleStatus = 1;
pub const BgwHandleStatus_BGWH_STOPPED: BgwHandleStatus = 2;
pub const BgwHandleStatus_BGWH_POSTMASTER_DIED: BgwHandleStatus = 3;
pub type BgwHandleStatus = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BackgroundWorkerHandle {
    _unused: [u8; 0],
}
pub const SyncRequestType_SYNC_REQUEST: SyncRequestType = 0;
pub const SyncRequestType_SYNC_UNLINK_REQUEST: SyncRequestType = 1;
pub const SyncRequestType_SYNC_FORGET_REQUEST: SyncRequestType = 2;
pub const SyncRequestType_SYNC_FILTER_REQUEST: SyncRequestType = 3;
pub type SyncRequestType = ::std::os::raw::c_uint;
pub const SyncRequestHandler_SYNC_HANDLER_MD: SyncRequestHandler = 0;
pub const SyncRequestHandler_SYNC_HANDLER_CLOG: SyncRequestHandler = 1;
pub const SyncRequestHandler_SYNC_HANDLER_COMMIT_TS: SyncRequestHandler = 2;
pub const SyncRequestHandler_SYNC_HANDLER_MULTIXACT_OFFSET: SyncRequestHandler = 3;
pub const SyncRequestHandler_SYNC_HANDLER_MULTIXACT_MEMBER: SyncRequestHandler = 4;
pub const SyncRequestHandler_SYNC_HANDLER_NONE: SyncRequestHandler = 5;
pub type SyncRequestHandler = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FileTag {
    pub handler: int16,
    pub forknum: int16,
    pub rlocator: RelFileLocator,
    pub segno: uint32,
}
impl Default for FileTag {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type XidStatus = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xl_clog_truncate {
    pub pageno: ::std::os::raw::c_int,
    pub oldestXact: TransactionId,
    pub oldestXactDb: Oid,
}
impl Default for xl_clog_truncate {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Latch {
    pub is_set: sig_atomic_t,
    pub maybe_sleeping: sig_atomic_t,
    pub is_shared: bool,
    pub owner_pid: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WaitEvent {
    pub pos: ::std::os::raw::c_int,
    pub events: uint32,
    pub fd: pgsocket,
    pub user_data: *mut ::std::os::raw::c_void,
}
impl Default for WaitEvent {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PGSemaphoreData {
    _unused: [u8; 0],
}
pub type PGSemaphore = *mut PGSemaphoreData;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct XidCacheStatus {
    pub count: uint8,
    pub overflowed: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XidCache {
    pub xids: [TransactionId; 64usize],
}
impl Default for XidCache {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ProcWaitStatus_PROC_WAIT_STATUS_OK: ProcWaitStatus = 0;
pub const ProcWaitStatus_PROC_WAIT_STATUS_WAITING: ProcWaitStatus = 1;
pub const ProcWaitStatus_PROC_WAIT_STATUS_ERROR: ProcWaitStatus = 2;
pub type ProcWaitStatus = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PGPROC {
    pub links: dlist_node,
    pub procgloballist: *mut dlist_head,
    pub sem: PGSemaphore,
    pub waitStatus: ProcWaitStatus,
    pub procLatch: Latch,
    pub xid: TransactionId,
    pub xmin: TransactionId,
    pub lxid: LocalTransactionId,
    pub pid: ::std::os::raw::c_int,
    pub pgxactoff: ::std::os::raw::c_int,
    pub pgprocno: ::std::os::raw::c_int,
    pub backendId: BackendId,
    pub databaseId: Oid,
    pub roleId: Oid,
    pub tempNamespaceId: Oid,
    pub isBackgroundWorker: bool,
    pub recoveryConflictPending: bool,
    pub lwWaiting: uint8,
    pub lwWaitMode: uint8,
    pub lwWaitLink: proclist_node,
    pub cvWaitLink: proclist_node,
    pub waitLock: *mut LOCK,
    pub waitProcLock: *mut PROCLOCK,
    pub waitLockMode: LOCKMODE,
    pub heldLocks: LOCKMASK,
    pub waitStart: pg_atomic_uint64,
    pub delayChkptFlags: ::std::os::raw::c_int,
    pub statusFlags: uint8,
    pub waitLSN: XLogRecPtr,
    pub syncRepState: ::std::os::raw::c_int,
    pub syncRepLinks: dlist_node,
    pub myProcLocks: [dlist_head; 16usize],
    pub subxidStatus: XidCacheStatus,
    pub subxids: XidCache,
    pub procArrayGroupMember: bool,
    pub procArrayGroupNext: pg_atomic_uint32,
    pub procArrayGroupMemberXid: TransactionId,
    pub wait_event_info: uint32,
    pub clogGroupMember: bool,
    pub clogGroupNext: pg_atomic_uint32,
    pub clogGroupMemberXid: TransactionId,
    pub clogGroupMemberXidStatus: XidStatus,
    pub clogGroupMemberPage: ::std::os::raw::c_int,
    pub clogGroupMemberLsn: XLogRecPtr,
    pub fpInfoLock: LWLock,
    pub fpLockBits: uint64,
    pub fpRelId: [Oid; 16usize],
    pub fpVXIDLock: bool,
    pub fpLocalTransactionId: LocalTransactionId,
    pub lockGroupLeader: *mut PGPROC,
    pub lockGroupMembers: dlist_head,
    pub lockGroupLink: dlist_node,
}
impl Default for PGPROC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PROC_HDR {
    pub allProcs: *mut PGPROC,
    pub xids: *mut TransactionId,
    pub subxidStates: *mut XidCacheStatus,
    pub statusFlags: *mut uint8,
    pub allProcCount: uint32,
    pub freeProcs: dlist_head,
    pub autovacFreeProcs: dlist_head,
    pub bgworkerFreeProcs: dlist_head,
    pub walsenderFreeProcs: dlist_head,
    pub procArrayGroupFirst: pg_atomic_uint32,
    pub clogGroupFirst: pg_atomic_uint32,
    pub walwriterLatch: *mut Latch,
    pub checkpointerLatch: *mut Latch,
    pub spins_per_delay: ::std::os::raw::c_int,
    pub startupBufferPinWaitBufId: ::std::os::raw::c_int,
}
impl Default for PROC_HDR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shm_mq {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shm_mq_handle {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shm_mq_iovec {
    pub data: *const ::std::os::raw::c_char,
    pub len: Size,
}
impl Default for shm_mq_iovec {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const shm_mq_result_SHM_MQ_SUCCESS: shm_mq_result = 0;
pub const shm_mq_result_SHM_MQ_WOULD_BLOCK: shm_mq_result = 1;
pub const shm_mq_result_SHM_MQ_DETACHED: shm_mq_result = 2;
pub type shm_mq_result = ::std::os::raw::c_uint;
pub type parallel_worker_main_type =
    ::std::option::Option<unsafe extern "C" fn(seg: *mut dsm_segment, toc: *mut shm_toc)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParallelWorkerInfo {
    pub bgwhandle: *mut BackgroundWorkerHandle,
    pub error_mqh: *mut shm_mq_handle,
    pub pid: int32,
}
impl Default for ParallelWorkerInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParallelContext {
    pub node: dlist_node,
    pub subid: SubTransactionId,
    pub nworkers: ::std::os::raw::c_int,
    pub nworkers_to_launch: ::std::os::raw::c_int,
    pub nworkers_launched: ::std::os::raw::c_int,
    pub library_name: *mut ::std::os::raw::c_char,
    pub function_name: *mut ::std::os::raw::c_char,
    pub error_context_stack: *mut ErrorContextCallback,
    pub estimator: shm_toc_estimator,
    pub seg: *mut dsm_segment,
    pub private_memory: *mut ::std::os::raw::c_void,
    pub toc: *mut shm_toc,
    pub worker: *mut ParallelWorkerInfo,
    pub nknown_attached_workers: ::std::os::raw::c_int,
    pub known_attached_workers: *mut bool,
}
impl Default for ParallelContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParallelWorkerContext {
    pub seg: *mut dsm_segment,
    pub toc: *mut shm_toc,
}
impl Default for ParallelWorkerContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_statistic {
    pub starelid: Oid,
    pub staattnum: int16,
    pub stainherit: bool,
    pub stanullfrac: float4,
    pub stawidth: int32,
    pub stadistinct: float4,
    pub stakind1: int16,
    pub stakind2: int16,
    pub stakind3: int16,
    pub stakind4: int16,
    pub stakind5: int16,
    pub staop1: Oid,
    pub staop2: Oid,
    pub staop3: Oid,
    pub staop4: Oid,
    pub staop5: Oid,
    pub stacoll1: Oid,
    pub stacoll2: Oid,
    pub stacoll3: Oid,
    pub stacoll4: Oid,
    pub stacoll5: Oid,
}
impl Default for FormData_pg_statistic {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_statistic = *mut FormData_pg_statistic;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParallelVacuumState {
    _unused: [u8; 0],
}
pub type VacAttrStatsP = *mut VacAttrStats;
pub type AnalyzeAttrFetchFunc = ::std::option::Option<
    unsafe extern "C" fn(
        stats: VacAttrStatsP,
        rownum: ::std::os::raw::c_int,
        isNull: *mut bool,
    ) -> Datum,
>;
pub type AnalyzeAttrComputeStatsFunc = ::std::option::Option<
    unsafe extern "C" fn(
        stats: VacAttrStatsP,
        fetchfunc: AnalyzeAttrFetchFunc,
        samplerows: ::std::os::raw::c_int,
        totalrows: f64,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VacAttrStats {
    pub attr: Form_pg_attribute,
    pub attrtypid: Oid,
    pub attrtypmod: int32,
    pub attrtype: Form_pg_type,
    pub attrcollid: Oid,
    pub anl_context: MemoryContext,
    pub compute_stats: AnalyzeAttrComputeStatsFunc,
    pub minrows: ::std::os::raw::c_int,
    pub extra_data: *mut ::std::os::raw::c_void,
    pub stats_valid: bool,
    pub stanullfrac: float4,
    pub stawidth: int32,
    pub stadistinct: float4,
    pub stakind: [int16; 5usize],
    pub staop: [Oid; 5usize],
    pub stacoll: [Oid; 5usize],
    pub numnumbers: [::std::os::raw::c_int; 5usize],
    pub stanumbers: [*mut float4; 5usize],
    pub numvalues: [::std::os::raw::c_int; 5usize],
    pub stavalues: [*mut Datum; 5usize],
    pub statypid: [Oid; 5usize],
    pub statyplen: [int16; 5usize],
    pub statypbyval: [bool; 5usize],
    pub statypalign: [::std::os::raw::c_char; 5usize],
    pub tupattnum: ::std::os::raw::c_int,
    pub rows: *mut HeapTuple,
    pub tupDesc: TupleDesc,
    pub exprvals: *mut Datum,
    pub exprnulls: *mut bool,
    pub rowstride: ::std::os::raw::c_int,
}
impl Default for VacAttrStats {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const VacOptValue_VACOPTVALUE_UNSPECIFIED: VacOptValue = 0;
pub const VacOptValue_VACOPTVALUE_AUTO: VacOptValue = 1;
pub const VacOptValue_VACOPTVALUE_DISABLED: VacOptValue = 2;
pub const VacOptValue_VACOPTVALUE_ENABLED: VacOptValue = 3;
pub type VacOptValue = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VacuumParams {
    pub options: bits32,
    pub freeze_min_age: ::std::os::raw::c_int,
    pub freeze_table_age: ::std::os::raw::c_int,
    pub multixact_freeze_min_age: ::std::os::raw::c_int,
    pub multixact_freeze_table_age: ::std::os::raw::c_int,
    pub is_wraparound: bool,
    pub log_min_duration: ::std::os::raw::c_int,
    pub index_cleanup: VacOptValue,
    pub truncate: VacOptValue,
    pub nworkers: ::std::os::raw::c_int,
}
impl Default for VacuumParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VacuumCutoffs {
    pub relfrozenxid: TransactionId,
    pub relminmxid: MultiXactId,
    pub OldestXmin: TransactionId,
    pub OldestMxact: MultiXactId,
    pub FreezeLimit: TransactionId,
    pub MultiXactCutoff: MultiXactId,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct VacDeadItems {
    pub max_items: ::std::os::raw::c_int,
    pub num_items: ::std::os::raw::c_int,
    pub items: __IncompleteArrayField<ItemPointerData>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConfigData {
    pub name: *mut ::std::os::raw::c_char,
    pub setting: *mut ::std::os::raw::c_char,
}
impl Default for ConfigData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const RawParseMode_RAW_PARSE_DEFAULT: RawParseMode = 0;
pub const RawParseMode_RAW_PARSE_TYPE_NAME: RawParseMode = 1;
pub const RawParseMode_RAW_PARSE_PLPGSQL_EXPR: RawParseMode = 2;
pub const RawParseMode_RAW_PARSE_PLPGSQL_ASSIGN1: RawParseMode = 3;
pub const RawParseMode_RAW_PARSE_PLPGSQL_ASSIGN2: RawParseMode = 4;
pub const RawParseMode_RAW_PARSE_PLPGSQL_ASSIGN3: RawParseMode = 5;
pub type RawParseMode = ::std::os::raw::c_uint;
pub const BackslashQuoteType_BACKSLASH_QUOTE_OFF: BackslashQuoteType = 0;
pub const BackslashQuoteType_BACKSLASH_QUOTE_ON: BackslashQuoteType = 1;
pub const BackslashQuoteType_BACKSLASH_QUOTE_SAFE_ENCODING: BackslashQuoteType = 2;
pub type BackslashQuoteType = ::std::os::raw::c_uint;
pub type ResourceOwner = *mut ResourceOwnerData;
pub const ResourceReleasePhase_RESOURCE_RELEASE_BEFORE_LOCKS: ResourceReleasePhase = 0;
pub const ResourceReleasePhase_RESOURCE_RELEASE_LOCKS: ResourceReleasePhase = 1;
pub const ResourceReleasePhase_RESOURCE_RELEASE_AFTER_LOCKS: ResourceReleasePhase = 2;
pub type ResourceReleasePhase = ::std::os::raw::c_uint;
pub type ResourceReleaseCallback = ::std::option::Option<
    unsafe extern "C" fn(
        phase: ResourceReleasePhase,
        isCommit: bool,
        isTopLevel: bool,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
pub const PlanCacheMode_PLAN_CACHE_MODE_AUTO: PlanCacheMode = 0;
pub const PlanCacheMode_PLAN_CACHE_MODE_FORCE_GENERIC_PLAN: PlanCacheMode = 1;
pub const PlanCacheMode_PLAN_CACHE_MODE_FORCE_CUSTOM_PLAN: PlanCacheMode = 2;
pub type PlanCacheMode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CachedPlanSource {
    pub magic: ::std::os::raw::c_int,
    pub raw_parse_tree: *mut RawStmt,
    pub query_string: *const ::std::os::raw::c_char,
    pub commandTag: CommandTag,
    pub param_types: *mut Oid,
    pub num_params: ::std::os::raw::c_int,
    pub parserSetup: ParserSetupHook,
    pub parserSetupArg: *mut ::std::os::raw::c_void,
    pub cursor_options: ::std::os::raw::c_int,
    pub fixed_result: bool,
    pub resultDesc: TupleDesc,
    pub context: MemoryContext,
    pub query_list: *mut List,
    pub relationOids: *mut List,
    pub invalItems: *mut List,
    pub search_path: *mut OverrideSearchPath,
    pub query_context: MemoryContext,
    pub rewriteRoleId: Oid,
    pub rewriteRowSecurity: bool,
    pub dependsOnRLS: bool,
    pub gplan: *mut CachedPlan,
    pub is_oneshot: bool,
    pub is_complete: bool,
    pub is_saved: bool,
    pub is_valid: bool,
    pub generation: ::std::os::raw::c_int,
    pub node: dlist_node,
    pub generic_cost: f64,
    pub total_custom_cost: f64,
    pub num_custom_plans: int64,
    pub num_generic_plans: int64,
}
impl Default for CachedPlanSource {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CachedPlan {
    pub magic: ::std::os::raw::c_int,
    pub stmt_list: *mut List,
    pub is_oneshot: bool,
    pub is_saved: bool,
    pub is_valid: bool,
    pub planRoleId: Oid,
    pub dependsOnRole: bool,
    pub saved_xmin: TransactionId,
    pub generation: ::std::os::raw::c_int,
    pub refcount: ::std::os::raw::c_int,
    pub context: MemoryContext,
}
impl Default for CachedPlan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CachedExpression {
    pub magic: ::std::os::raw::c_int,
    pub expr: *mut Node,
    pub is_valid: bool,
    pub relationOids: *mut List,
    pub invalItems: *mut List,
    pub context: MemoryContext,
    pub node: dlist_node,
}
impl Default for CachedExpression {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const PortalStrategy_PORTAL_ONE_SELECT: PortalStrategy = 0;
pub const PortalStrategy_PORTAL_ONE_RETURNING: PortalStrategy = 1;
pub const PortalStrategy_PORTAL_ONE_MOD_WITH: PortalStrategy = 2;
pub const PortalStrategy_PORTAL_UTIL_SELECT: PortalStrategy = 3;
pub const PortalStrategy_PORTAL_MULTI_QUERY: PortalStrategy = 4;
pub type PortalStrategy = ::std::os::raw::c_uint;
pub const PortalStatus_PORTAL_NEW: PortalStatus = 0;
pub const PortalStatus_PORTAL_DEFINED: PortalStatus = 1;
pub const PortalStatus_PORTAL_READY: PortalStatus = 2;
pub const PortalStatus_PORTAL_ACTIVE: PortalStatus = 3;
pub const PortalStatus_PORTAL_DONE: PortalStatus = 4;
pub const PortalStatus_PORTAL_FAILED: PortalStatus = 5;
pub type PortalStatus = ::std::os::raw::c_uint;
pub type Portal = *mut PortalData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PortalData {
    pub name: *const ::std::os::raw::c_char,
    pub prepStmtName: *const ::std::os::raw::c_char,
    pub portalContext: MemoryContext,
    pub resowner: ResourceOwner,
    pub cleanup: ::std::option::Option<unsafe extern "C" fn(portal: Portal)>,
    pub createSubid: SubTransactionId,
    pub activeSubid: SubTransactionId,
    pub createLevel: ::std::os::raw::c_int,
    pub sourceText: *const ::std::os::raw::c_char,
    pub commandTag: CommandTag,
    pub qc: QueryCompletion,
    pub stmts: *mut List,
    pub cplan: *mut CachedPlan,
    pub portalParams: ParamListInfo,
    pub queryEnv: *mut QueryEnvironment,
    pub strategy: PortalStrategy,
    pub cursorOptions: ::std::os::raw::c_int,
    pub run_once: bool,
    pub status: PortalStatus,
    pub portalPinned: bool,
    pub autoHeld: bool,
    pub queryDesc: *mut QueryDesc,
    pub tupDesc: TupleDesc,
    pub formats: *mut int16,
    pub portalSnapshot: Snapshot,
    pub holdStore: *mut Tuplestorestate,
    pub holdContext: MemoryContext,
    pub holdSnapshot: Snapshot,
    pub atStart: bool,
    pub atEnd: bool,
    pub portalPos: uint64,
    pub creation_time: TimestampTz,
    pub visible: bool,
}
impl Default for PortalData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPITupleTable {
    pub tupdesc: TupleDesc,
    pub vals: *mut HeapTuple,
    pub numvals: uint64,
    pub alloced: uint64,
    pub tuptabcxt: MemoryContext,
    pub next: slist_node,
    pub subid: SubTransactionId,
}
impl Default for SPITupleTable {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPIPrepareOptions {
    pub parserSetup: ParserSetupHook,
    pub parserSetupArg: *mut ::std::os::raw::c_void,
    pub parseMode: RawParseMode,
    pub cursorOptions: ::std::os::raw::c_int,
}
impl Default for SPIPrepareOptions {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPIExecuteOptions {
    pub params: ParamListInfo,
    pub read_only: bool,
    pub allow_nonatomic: bool,
    pub must_return_tuples: bool,
    pub tcount: uint64,
    pub dest: *mut DestReceiver,
    pub owner: ResourceOwner,
}
impl Default for SPIExecuteOptions {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPIParseOpenOptions {
    pub params: ParamListInfo,
    pub cursorOptions: ::std::os::raw::c_int,
    pub read_only: bool,
}
impl Default for SPIParseOpenOptions {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SPI_plan {
    _unused: [u8; 0],
}
pub type SPIPlanPtr = *mut _SPI_plan;
pub type Relids = *mut Bitmapset;
pub const CostSelector_STARTUP_COST: CostSelector = 0;
pub const CostSelector_TOTAL_COST: CostSelector = 1;
pub type CostSelector = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct QualCost {
    pub startup: Cost,
    pub per_tuple: Cost,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AggClauseCosts {
    pub transCost: QualCost,
    pub finalCost: QualCost,
    pub transitionSpace: Size,
}
pub const UpperRelationKind_UPPERREL_SETOP: UpperRelationKind = 0;
pub const UpperRelationKind_UPPERREL_PARTIAL_GROUP_AGG: UpperRelationKind = 1;
pub const UpperRelationKind_UPPERREL_GROUP_AGG: UpperRelationKind = 2;
pub const UpperRelationKind_UPPERREL_WINDOW: UpperRelationKind = 3;
pub const UpperRelationKind_UPPERREL_PARTIAL_DISTINCT: UpperRelationKind = 4;
pub const UpperRelationKind_UPPERREL_DISTINCT: UpperRelationKind = 5;
pub const UpperRelationKind_UPPERREL_ORDERED: UpperRelationKind = 6;
pub const UpperRelationKind_UPPERREL_FINAL: UpperRelationKind = 7;
pub type UpperRelationKind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PlannerGlobal {
    pub type_: NodeTag,
    pub boundParams: ParamListInfo,
    pub subplans: *mut List,
    pub subroots: *mut List,
    pub rewindPlanIDs: *mut Bitmapset,
    pub finalrtable: *mut List,
    pub finalrteperminfos: *mut List,
    pub finalrowmarks: *mut List,
    pub resultRelations: *mut List,
    pub appendRelations: *mut List,
    pub relationOids: *mut List,
    pub invalItems: *mut List,
    pub paramExecTypes: *mut List,
    pub lastPHId: Index,
    pub lastRowMarkId: Index,
    pub lastPlanNodeId: ::std::os::raw::c_int,
    pub transientPlan: bool,
    pub dependsOnRole: bool,
    pub parallelModeOK: bool,
    pub parallelModeNeeded: bool,
    pub maxParallelHazard: ::std::os::raw::c_char,
    pub partition_directory: PartitionDirectory,
}
impl Default for PlannerGlobal {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PlannerInfo {
    pub type_: NodeTag,
    pub parse: *mut Query,
    pub glob: *mut PlannerGlobal,
    pub query_level: Index,
    pub parent_root: *mut PlannerInfo,
    pub plan_params: *mut List,
    pub outer_params: *mut Bitmapset,
    pub simple_rel_array: *mut *mut RelOptInfo,
    pub simple_rel_array_size: ::std::os::raw::c_int,
    pub simple_rte_array: *mut *mut RangeTblEntry,
    pub append_rel_array: *mut *mut AppendRelInfo,
    pub all_baserels: Relids,
    pub outer_join_rels: Relids,
    pub all_query_rels: Relids,
    pub join_rel_list: *mut List,
    pub join_rel_hash: *mut HTAB,
    pub join_rel_level: *mut *mut List,
    pub join_cur_level: ::std::os::raw::c_int,
    pub init_plans: *mut List,
    pub cte_plan_ids: *mut List,
    pub multiexpr_params: *mut List,
    pub join_domains: *mut List,
    pub eq_classes: *mut List,
    pub ec_merging_done: bool,
    pub canon_pathkeys: *mut List,
    pub left_join_clauses: *mut List,
    pub right_join_clauses: *mut List,
    pub full_join_clauses: *mut List,
    pub join_info_list: *mut List,
    pub last_rinfo_serial: ::std::os::raw::c_int,
    pub all_result_relids: Relids,
    pub leaf_result_relids: Relids,
    pub append_rel_list: *mut List,
    pub row_identity_vars: *mut List,
    pub rowMarks: *mut List,
    pub placeholder_list: *mut List,
    pub placeholder_array: *mut *mut PlaceHolderInfo,
    pub placeholder_array_size: ::std::os::raw::c_int,
    pub fkey_list: *mut List,
    pub query_pathkeys: *mut List,
    pub group_pathkeys: *mut List,
    pub num_groupby_pathkeys: ::std::os::raw::c_int,
    pub window_pathkeys: *mut List,
    pub distinct_pathkeys: *mut List,
    pub sort_pathkeys: *mut List,
    pub part_schemes: *mut List,
    pub initial_rels: *mut List,
    pub upper_rels: [*mut List; 8usize],
    pub upper_targets: [*mut PathTarget; 8usize],
    pub processed_groupClause: *mut List,
    pub processed_distinctClause: *mut List,
    pub processed_tlist: *mut List,
    pub update_colnos: *mut List,
    pub grouping_map: *mut AttrNumber,
    pub minmax_aggs: *mut List,
    pub planner_cxt: MemoryContext,
    pub total_table_pages: Cardinality,
    pub tuple_fraction: Selectivity,
    pub limit_tuples: Cardinality,
    pub qual_security_level: Index,
    pub hasJoinRTEs: bool,
    pub hasLateralRTEs: bool,
    pub hasHavingQual: bool,
    pub hasPseudoConstantQuals: bool,
    pub hasAlternativeSubPlans: bool,
    pub placeholdersFrozen: bool,
    pub hasRecursion: bool,
    pub agginfos: *mut List,
    pub aggtransinfos: *mut List,
    pub numOrderedAggs: ::std::os::raw::c_int,
    pub hasNonPartialAggs: bool,
    pub hasNonSerialAggs: bool,
    pub wt_param_id: ::std::os::raw::c_int,
    pub non_recursive_path: *mut Path,
    pub curOuterRels: Relids,
    pub curOuterParams: *mut List,
    pub isAltSubplan: *mut bool,
    pub isUsedSubplan: *mut bool,
    pub join_search_private: *mut ::std::os::raw::c_void,
    pub partColsUpdated: bool,
}
impl Default for PlannerInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionSchemeData {
    pub strategy: ::std::os::raw::c_char,
    pub partnatts: int16,
    pub partopfamily: *mut Oid,
    pub partopcintype: *mut Oid,
    pub partcollation: *mut Oid,
    pub parttyplen: *mut int16,
    pub parttypbyval: *mut bool,
    pub partsupfunc: *mut FmgrInfo,
}
impl Default for PartitionSchemeData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PartitionScheme = *mut PartitionSchemeData;
pub const RelOptKind_RELOPT_BASEREL: RelOptKind = 0;
pub const RelOptKind_RELOPT_JOINREL: RelOptKind = 1;
pub const RelOptKind_RELOPT_OTHER_MEMBER_REL: RelOptKind = 2;
pub const RelOptKind_RELOPT_OTHER_JOINREL: RelOptKind = 3;
pub const RelOptKind_RELOPT_UPPER_REL: RelOptKind = 4;
pub const RelOptKind_RELOPT_OTHER_UPPER_REL: RelOptKind = 5;
pub type RelOptKind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RelOptInfo {
    pub type_: NodeTag,
    pub reloptkind: RelOptKind,
    pub relids: Relids,
    pub rows: Cardinality,
    pub consider_startup: bool,
    pub consider_param_startup: bool,
    pub consider_parallel: bool,
    pub reltarget: *mut PathTarget,
    pub pathlist: *mut List,
    pub ppilist: *mut List,
    pub partial_pathlist: *mut List,
    pub cheapest_startup_path: *mut Path,
    pub cheapest_total_path: *mut Path,
    pub cheapest_unique_path: *mut Path,
    pub cheapest_parameterized_paths: *mut List,
    pub direct_lateral_relids: Relids,
    pub lateral_relids: Relids,
    pub relid: Index,
    pub reltablespace: Oid,
    pub rtekind: RTEKind,
    pub min_attr: AttrNumber,
    pub max_attr: AttrNumber,
    pub attr_needed: *mut Relids,
    pub attr_widths: *mut int32,
    pub nulling_relids: Relids,
    pub lateral_vars: *mut List,
    pub lateral_referencers: Relids,
    pub indexlist: *mut List,
    pub statlist: *mut List,
    pub pages: BlockNumber,
    pub tuples: Cardinality,
    pub allvisfrac: f64,
    pub eclass_indexes: *mut Bitmapset,
    pub subroot: *mut PlannerInfo,
    pub subplan_params: *mut List,
    pub rel_parallel_workers: ::std::os::raw::c_int,
    pub amflags: uint32,
    pub serverid: Oid,
    pub userid: Oid,
    pub useridiscurrent: bool,
    pub fdwroutine: *mut FdwRoutine,
    pub fdw_private: *mut ::std::os::raw::c_void,
    pub unique_for_rels: *mut List,
    pub non_unique_for_rels: *mut List,
    pub baserestrictinfo: *mut List,
    pub baserestrictcost: QualCost,
    pub baserestrict_min_security: Index,
    pub joininfo: *mut List,
    pub has_eclass_joins: bool,
    pub consider_partitionwise_join: bool,
    pub parent: *mut RelOptInfo,
    pub top_parent: *mut RelOptInfo,
    pub top_parent_relids: Relids,
    pub part_scheme: PartitionScheme,
    pub nparts: ::std::os::raw::c_int,
    pub boundinfo: *mut PartitionBoundInfoData,
    pub partbounds_merged: bool,
    pub partition_qual: *mut List,
    pub part_rels: *mut *mut RelOptInfo,
    pub live_parts: *mut Bitmapset,
    pub all_partrels: Relids,
    pub partexprs: *mut *mut List,
    pub nullable_partexprs: *mut *mut List,
}
impl Default for RelOptInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexOptInfo {
    pub type_: NodeTag,
    pub indexoid: Oid,
    pub reltablespace: Oid,
    pub rel: *mut RelOptInfo,
    pub pages: BlockNumber,
    pub tuples: Cardinality,
    pub tree_height: ::std::os::raw::c_int,
    pub ncolumns: ::std::os::raw::c_int,
    pub nkeycolumns: ::std::os::raw::c_int,
    pub indexkeys: *mut ::std::os::raw::c_int,
    pub indexcollations: *mut Oid,
    pub opfamily: *mut Oid,
    pub opcintype: *mut Oid,
    pub sortopfamily: *mut Oid,
    pub reverse_sort: *mut bool,
    pub nulls_first: *mut bool,
    pub opclassoptions: *mut *mut bytea,
    pub canreturn: *mut bool,
    pub relam: Oid,
    pub indexprs: *mut List,
    pub indpred: *mut List,
    pub indextlist: *mut List,
    pub indrestrictinfo: *mut List,
    pub predOK: bool,
    pub unique: bool,
    pub immediate: bool,
    pub hypothetical: bool,
    pub amcanorderbyop: bool,
    pub amoptionalkey: bool,
    pub amsearcharray: bool,
    pub amsearchnulls: bool,
    pub amhasgettuple: bool,
    pub amhasgetbitmap: bool,
    pub amcanparallel: bool,
    pub amcanmarkpos: bool,
    pub amcostestimate: ::std::option::Option<unsafe extern "C" fn()>,
}
impl Default for IndexOptInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForeignKeyOptInfo {
    pub type_: NodeTag,
    pub con_relid: Index,
    pub ref_relid: Index,
    pub nkeys: ::std::os::raw::c_int,
    pub conkey: [AttrNumber; 32usize],
    pub confkey: [AttrNumber; 32usize],
    pub conpfeqop: [Oid; 32usize],
    pub nmatched_ec: ::std::os::raw::c_int,
    pub nconst_ec: ::std::os::raw::c_int,
    pub nmatched_rcols: ::std::os::raw::c_int,
    pub nmatched_ri: ::std::os::raw::c_int,
    pub eclass: [*mut EquivalenceClass; 32usize],
    pub fk_eclass_member: [*mut EquivalenceMember; 32usize],
    pub rinfos: [*mut List; 32usize],
}
impl Default for ForeignKeyOptInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StatisticExtInfo {
    pub type_: NodeTag,
    pub statOid: Oid,
    pub inherit: bool,
    pub rel: *mut RelOptInfo,
    pub kind: ::std::os::raw::c_char,
    pub keys: *mut Bitmapset,
    pub exprs: *mut List,
}
impl Default for StatisticExtInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JoinDomain {
    pub type_: NodeTag,
    pub jd_relids: Relids,
}
impl Default for JoinDomain {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EquivalenceClass {
    pub type_: NodeTag,
    pub ec_opfamilies: *mut List,
    pub ec_collation: Oid,
    pub ec_members: *mut List,
    pub ec_sources: *mut List,
    pub ec_derives: *mut List,
    pub ec_relids: Relids,
    pub ec_has_const: bool,
    pub ec_has_volatile: bool,
    pub ec_broken: bool,
    pub ec_sortref: Index,
    pub ec_min_security: Index,
    pub ec_max_security: Index,
    pub ec_merged: *mut EquivalenceClass,
}
impl Default for EquivalenceClass {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EquivalenceMember {
    pub type_: NodeTag,
    pub em_expr: *mut Expr,
    pub em_relids: Relids,
    pub em_is_const: bool,
    pub em_is_child: bool,
    pub em_datatype: Oid,
    pub em_jdomain: *mut JoinDomain,
    pub em_parent: *mut EquivalenceMember,
}
impl Default for EquivalenceMember {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PathKey {
    pub type_: NodeTag,
    pub pk_eclass: *mut EquivalenceClass,
    pub pk_opfamily: Oid,
    pub pk_strategy: ::std::os::raw::c_int,
    pub pk_nulls_first: bool,
}
impl Default for PathKey {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const VolatileFunctionStatus_VOLATILITY_UNKNOWN: VolatileFunctionStatus = 0;
pub const VolatileFunctionStatus_VOLATILITY_VOLATILE: VolatileFunctionStatus = 1;
pub const VolatileFunctionStatus_VOLATILITY_NOVOLATILE: VolatileFunctionStatus = 2;
pub type VolatileFunctionStatus = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PathTarget {
    pub type_: NodeTag,
    pub exprs: *mut List,
    pub sortgrouprefs: *mut Index,
    pub cost: QualCost,
    pub width: ::std::os::raw::c_int,
    pub has_volatile_expr: VolatileFunctionStatus,
}
impl Default for PathTarget {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParamPathInfo {
    pub type_: NodeTag,
    pub ppi_req_outer: Relids,
    pub ppi_rows: Cardinality,
    pub ppi_clauses: *mut List,
    pub ppi_serials: *mut Bitmapset,
}
impl Default for ParamPathInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Path {
    pub type_: NodeTag,
    pub pathtype: NodeTag,
    pub parent: *mut RelOptInfo,
    pub pathtarget: *mut PathTarget,
    pub param_info: *mut ParamPathInfo,
    pub parallel_aware: bool,
    pub parallel_safe: bool,
    pub parallel_workers: ::std::os::raw::c_int,
    pub rows: Cardinality,
    pub startup_cost: Cost,
    pub total_cost: Cost,
    pub pathkeys: *mut List,
}
impl Default for Path {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexPath {
    pub path: Path,
    pub indexinfo: *mut IndexOptInfo,
    pub indexclauses: *mut List,
    pub indexorderbys: *mut List,
    pub indexorderbycols: *mut List,
    pub indexscandir: ScanDirection,
    pub indextotalcost: Cost,
    pub indexselectivity: Selectivity,
}
impl Default for IndexPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexClause {
    pub type_: NodeTag,
    pub rinfo: *mut RestrictInfo,
    pub indexquals: *mut List,
    pub lossy: bool,
    pub indexcol: AttrNumber,
    pub indexcols: *mut List,
}
impl Default for IndexClause {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapHeapPath {
    pub path: Path,
    pub bitmapqual: *mut Path,
}
impl Default for BitmapHeapPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapAndPath {
    pub path: Path,
    pub bitmapquals: *mut List,
    pub bitmapselectivity: Selectivity,
}
impl Default for BitmapAndPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapOrPath {
    pub path: Path,
    pub bitmapquals: *mut List,
    pub bitmapselectivity: Selectivity,
}
impl Default for BitmapOrPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TidPath {
    pub path: Path,
    pub tidquals: *mut List,
}
impl Default for TidPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TidRangePath {
    pub path: Path,
    pub tidrangequals: *mut List,
}
impl Default for TidRangePath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubqueryScanPath {
    pub path: Path,
    pub subpath: *mut Path,
}
impl Default for SubqueryScanPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForeignPath {
    pub path: Path,
    pub fdw_outerpath: *mut Path,
    pub fdw_private: *mut List,
}
impl Default for ForeignPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CustomPath {
    pub path: Path,
    pub flags: uint32,
    pub custom_paths: *mut List,
    pub custom_private: *mut List,
    pub methods: *const CustomPathMethods,
}
impl Default for CustomPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AppendPath {
    pub path: Path,
    pub subpaths: *mut List,
    pub first_partial_path: ::std::os::raw::c_int,
    pub limit_tuples: Cardinality,
}
impl Default for AppendPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeAppendPath {
    pub path: Path,
    pub subpaths: *mut List,
    pub limit_tuples: Cardinality,
}
impl Default for MergeAppendPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GroupResultPath {
    pub path: Path,
    pub quals: *mut List,
}
impl Default for GroupResultPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MaterialPath {
    pub path: Path,
    pub subpath: *mut Path,
}
impl Default for MaterialPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoizePath {
    pub path: Path,
    pub subpath: *mut Path,
    pub hash_operators: *mut List,
    pub param_exprs: *mut List,
    pub singlerow: bool,
    pub binary_mode: bool,
    pub calls: Cardinality,
    pub est_entries: uint32,
}
impl Default for MemoizePath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const UniquePathMethod_UNIQUE_PATH_NOOP: UniquePathMethod = 0;
pub const UniquePathMethod_UNIQUE_PATH_HASH: UniquePathMethod = 1;
pub const UniquePathMethod_UNIQUE_PATH_SORT: UniquePathMethod = 2;
pub type UniquePathMethod = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UniquePath {
    pub path: Path,
    pub subpath: *mut Path,
    pub umethod: UniquePathMethod,
    pub in_operators: *mut List,
    pub uniq_exprs: *mut List,
}
impl Default for UniquePath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GatherPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub single_copy: bool,
    pub num_workers: ::std::os::raw::c_int,
}
impl Default for GatherPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GatherMergePath {
    pub path: Path,
    pub subpath: *mut Path,
    pub num_workers: ::std::os::raw::c_int,
}
impl Default for GatherMergePath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JoinPath {
    pub path: Path,
    pub jointype: JoinType,
    pub inner_unique: bool,
    pub outerjoinpath: *mut Path,
    pub innerjoinpath: *mut Path,
    pub joinrestrictinfo: *mut List,
}
impl Default for JoinPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NestPath {
    pub jpath: JoinPath,
}
impl Default for NestPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergePath {
    pub jpath: JoinPath,
    pub path_mergeclauses: *mut List,
    pub outersortkeys: *mut List,
    pub innersortkeys: *mut List,
    pub skip_mark_restore: bool,
    pub materialize_inner: bool,
}
impl Default for MergePath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HashPath {
    pub jpath: JoinPath,
    pub path_hashclauses: *mut List,
    pub num_batches: ::std::os::raw::c_int,
    pub inner_rows_total: Cardinality,
}
impl Default for HashPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProjectionPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub dummypp: bool,
}
impl Default for ProjectionPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProjectSetPath {
    pub path: Path,
    pub subpath: *mut Path,
}
impl Default for ProjectSetPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SortPath {
    pub path: Path,
    pub subpath: *mut Path,
}
impl Default for SortPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IncrementalSortPath {
    pub spath: SortPath,
    pub nPresortedCols: ::std::os::raw::c_int,
}
impl Default for IncrementalSortPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GroupPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub groupClause: *mut List,
    pub qual: *mut List,
}
impl Default for GroupPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UpperUniquePath {
    pub path: Path,
    pub subpath: *mut Path,
    pub numkeys: ::std::os::raw::c_int,
}
impl Default for UpperUniquePath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub aggstrategy: AggStrategy,
    pub aggsplit: AggSplit,
    pub numGroups: Cardinality,
    pub transitionSpace: uint64,
    pub groupClause: *mut List,
    pub qual: *mut List,
}
impl Default for AggPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GroupingSetData {
    pub type_: NodeTag,
    pub set: *mut List,
    pub numGroups: Cardinality,
}
impl Default for GroupingSetData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RollupData {
    pub type_: NodeTag,
    pub groupClause: *mut List,
    pub gsets: *mut List,
    pub gsets_data: *mut List,
    pub numGroups: Cardinality,
    pub hashable: bool,
    pub is_hashed: bool,
}
impl Default for RollupData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GroupingSetsPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub aggstrategy: AggStrategy,
    pub rollups: *mut List,
    pub qual: *mut List,
    pub transitionSpace: uint64,
}
impl Default for GroupingSetsPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MinMaxAggPath {
    pub path: Path,
    pub mmaggregates: *mut List,
    pub quals: *mut List,
}
impl Default for MinMaxAggPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowAggPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub winclause: *mut WindowClause,
    pub qual: *mut List,
    pub topwindow: bool,
}
impl Default for WindowAggPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SetOpPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub cmd: SetOpCmd,
    pub strategy: SetOpStrategy,
    pub distinctList: *mut List,
    pub flagColIdx: AttrNumber,
    pub firstFlag: ::std::os::raw::c_int,
    pub numGroups: Cardinality,
}
impl Default for SetOpPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RecursiveUnionPath {
    pub path: Path,
    pub leftpath: *mut Path,
    pub rightpath: *mut Path,
    pub distinctList: *mut List,
    pub wtParam: ::std::os::raw::c_int,
    pub numGroups: Cardinality,
}
impl Default for RecursiveUnionPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LockRowsPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub rowMarks: *mut List,
    pub epqParam: ::std::os::raw::c_int,
}
impl Default for LockRowsPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ModifyTablePath {
    pub path: Path,
    pub subpath: *mut Path,
    pub operation: CmdType,
    pub canSetTag: bool,
    pub nominalRelation: Index,
    pub rootRelation: Index,
    pub partColsUpdated: bool,
    pub resultRelations: *mut List,
    pub updateColnosLists: *mut List,
    pub withCheckOptionLists: *mut List,
    pub returningLists: *mut List,
    pub rowMarks: *mut List,
    pub onconflict: *mut OnConflictExpr,
    pub epqParam: ::std::os::raw::c_int,
    pub mergeActionLists: *mut List,
}
impl Default for ModifyTablePath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LimitPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub limitOffset: *mut Node,
    pub limitCount: *mut Node,
    pub limitOption: LimitOption,
}
impl Default for LimitPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RestrictInfo {
    pub type_: NodeTag,
    pub clause: *mut Expr,
    pub is_pushed_down: bool,
    pub can_join: bool,
    pub pseudoconstant: bool,
    pub has_clone: bool,
    pub is_clone: bool,
    pub leakproof: bool,
    pub has_volatile: VolatileFunctionStatus,
    pub security_level: Index,
    pub num_base_rels: ::std::os::raw::c_int,
    pub clause_relids: Relids,
    pub required_relids: Relids,
    pub incompatible_relids: Relids,
    pub outer_relids: Relids,
    pub left_relids: Relids,
    pub right_relids: Relids,
    pub orclause: *mut Expr,
    pub rinfo_serial: ::std::os::raw::c_int,
    pub parent_ec: *mut EquivalenceClass,
    pub eval_cost: QualCost,
    pub norm_selec: Selectivity,
    pub outer_selec: Selectivity,
    pub mergeopfamilies: *mut List,
    pub left_ec: *mut EquivalenceClass,
    pub right_ec: *mut EquivalenceClass,
    pub left_em: *mut EquivalenceMember,
    pub right_em: *mut EquivalenceMember,
    pub scansel_cache: *mut List,
    pub outer_is_left: bool,
    pub hashjoinoperator: Oid,
    pub left_bucketsize: Selectivity,
    pub right_bucketsize: Selectivity,
    pub left_mcvfreq: Selectivity,
    pub right_mcvfreq: Selectivity,
    pub left_hasheqoperator: Oid,
    pub right_hasheqoperator: Oid,
}
impl Default for RestrictInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeScanSelCache {
    pub opfamily: Oid,
    pub collation: Oid,
    pub strategy: ::std::os::raw::c_int,
    pub nulls_first: bool,
    pub leftstartsel: Selectivity,
    pub leftendsel: Selectivity,
    pub rightstartsel: Selectivity,
    pub rightendsel: Selectivity,
}
impl Default for MergeScanSelCache {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PlaceHolderVar {
    pub xpr: Expr,
    pub phexpr: *mut Expr,
    pub phrels: Relids,
    pub phnullingrels: Relids,
    pub phid: Index,
    pub phlevelsup: Index,
}
impl Default for PlaceHolderVar {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SpecialJoinInfo {
    pub type_: NodeTag,
    pub min_lefthand: Relids,
    pub min_righthand: Relids,
    pub syn_lefthand: Relids,
    pub syn_righthand: Relids,
    pub jointype: JoinType,
    pub ojrelid: Index,
    pub commute_above_l: Relids,
    pub commute_above_r: Relids,
    pub commute_below_l: Relids,
    pub commute_below_r: Relids,
    pub lhs_strict: bool,
    pub semi_can_btree: bool,
    pub semi_can_hash: bool,
    pub semi_operators: *mut List,
    pub semi_rhs_exprs: *mut List,
}
impl Default for SpecialJoinInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OuterJoinClauseInfo {
    pub type_: NodeTag,
    pub rinfo: *mut RestrictInfo,
    pub sjinfo: *mut SpecialJoinInfo,
}
impl Default for OuterJoinClauseInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AppendRelInfo {
    pub type_: NodeTag,
    pub parent_relid: Index,
    pub child_relid: Index,
    pub parent_reltype: Oid,
    pub child_reltype: Oid,
    pub translated_vars: *mut List,
    pub num_child_cols: ::std::os::raw::c_int,
    pub parent_colnos: *mut AttrNumber,
    pub parent_reloid: Oid,
}
impl Default for AppendRelInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RowIdentityVarInfo {
    pub type_: NodeTag,
    pub rowidvar: *mut Var,
    pub rowidwidth: int32,
    pub rowidname: *mut ::std::os::raw::c_char,
    pub rowidrels: Relids,
}
impl Default for RowIdentityVarInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PlaceHolderInfo {
    pub type_: NodeTag,
    pub phid: Index,
    pub ph_var: *mut PlaceHolderVar,
    pub ph_eval_at: Relids,
    pub ph_lateral: Relids,
    pub ph_needed: Relids,
    pub ph_width: int32,
}
impl Default for PlaceHolderInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MinMaxAggInfo {
    pub type_: NodeTag,
    pub aggfnoid: Oid,
    pub aggsortop: Oid,
    pub target: *mut Expr,
    pub subroot: *mut PlannerInfo,
    pub path: *mut Path,
    pub pathcost: Cost,
    pub param: *mut Param,
}
impl Default for MinMaxAggInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PlannerParamItem {
    pub type_: NodeTag,
    pub item: *mut Node,
    pub paramId: ::std::os::raw::c_int,
}
impl Default for PlannerParamItem {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SemiAntiJoinFactors {
    pub outer_match_frac: Selectivity,
    pub match_count: Selectivity,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JoinPathExtraData {
    pub restrictlist: *mut List,
    pub mergeclause_list: *mut List,
    pub inner_unique: bool,
    pub sjinfo: *mut SpecialJoinInfo,
    pub semifactors: SemiAntiJoinFactors,
    pub param_source_rels: Relids,
}
impl Default for JoinPathExtraData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const PartitionwiseAggregateType_PARTITIONWISE_AGGREGATE_NONE: PartitionwiseAggregateType = 0;
pub const PartitionwiseAggregateType_PARTITIONWISE_AGGREGATE_FULL: PartitionwiseAggregateType = 1;
pub const PartitionwiseAggregateType_PARTITIONWISE_AGGREGATE_PARTIAL: PartitionwiseAggregateType =
    2;
pub type PartitionwiseAggregateType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GroupPathExtraData {
    pub flags: ::std::os::raw::c_int,
    pub partial_costs_set: bool,
    pub agg_partial_costs: AggClauseCosts,
    pub agg_final_costs: AggClauseCosts,
    pub target_parallel_safe: bool,
    pub havingQual: *mut Node,
    pub targetList: *mut List,
    pub patype: PartitionwiseAggregateType,
}
impl Default for GroupPathExtraData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FinalPathExtraData {
    pub limit_needed: bool,
    pub limit_tuples: Cardinality,
    pub count_est: int64,
    pub offset_est: int64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct JoinCostWorkspace {
    pub startup_cost: Cost,
    pub total_cost: Cost,
    pub run_cost: Cost,
    pub inner_run_cost: Cost,
    pub inner_rescan_run_cost: Cost,
    pub outer_rows: Cardinality,
    pub inner_rows: Cardinality,
    pub outer_skip_rows: Cardinality,
    pub inner_skip_rows: Cardinality,
    pub numbuckets: ::std::os::raw::c_int,
    pub numbatches: ::std::os::raw::c_int,
    pub inner_rows_total: Cardinality,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggInfo {
    pub type_: NodeTag,
    pub aggrefs: *mut List,
    pub transno: ::std::os::raw::c_int,
    pub shareable: bool,
    pub finalfn_oid: Oid,
}
impl Default for AggInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggTransInfo {
    pub type_: NodeTag,
    pub args: *mut List,
    pub aggfilter: *mut Expr,
    pub transfn_oid: Oid,
    pub serialfn_oid: Oid,
    pub deserialfn_oid: Oid,
    pub combinefn_oid: Oid,
    pub aggtranstype: Oid,
    pub aggtranstypmod: int32,
    pub transtypeLen: ::std::os::raw::c_int,
    pub transtypeByVal: bool,
    pub aggtransspace: int32,
    pub initValue: Datum,
    pub initValueIsNull: bool,
}
impl Default for AggTransInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type GetForeignRelSize_function = ::std::option::Option<
    unsafe extern "C" fn(root: *mut PlannerInfo, baserel: *mut RelOptInfo, foreigntableid: Oid),
>;
pub type GetForeignPaths_function = ::std::option::Option<
    unsafe extern "C" fn(root: *mut PlannerInfo, baserel: *mut RelOptInfo, foreigntableid: Oid),
>;
pub type GetForeignPlan_function = ::std::option::Option<
    unsafe extern "C" fn(
        root: *mut PlannerInfo,
        baserel: *mut RelOptInfo,
        foreigntableid: Oid,
        best_path: *mut ForeignPath,
        tlist: *mut List,
        scan_clauses: *mut List,
        outer_plan: *mut Plan,
    ) -> *mut ForeignScan,
>;
pub type BeginForeignScan_function = ::std::option::Option<
    unsafe extern "C" fn(node: *mut ForeignScanState, eflags: ::std::os::raw::c_int),
>;
pub type IterateForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState) -> *mut TupleTableSlot>;
pub type RecheckForeignScan_function = ::std::option::Option<
    unsafe extern "C" fn(node: *mut ForeignScanState, slot: *mut TupleTableSlot) -> bool,
>;
pub type ReScanForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState)>;
pub type EndForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState)>;
pub type GetForeignJoinPaths_function = ::std::option::Option<
    unsafe extern "C" fn(
        root: *mut PlannerInfo,
        joinrel: *mut RelOptInfo,
        outerrel: *mut RelOptInfo,
        innerrel: *mut RelOptInfo,
        jointype: JoinType,
        extra: *mut JoinPathExtraData,
    ),
>;
pub type GetForeignUpperPaths_function = ::std::option::Option<
    unsafe extern "C" fn(
        root: *mut PlannerInfo,
        stage: UpperRelationKind,
        input_rel: *mut RelOptInfo,
        output_rel: *mut RelOptInfo,
        extra: *mut ::std::os::raw::c_void,
    ),
>;
pub type AddForeignUpdateTargets_function = ::std::option::Option<
    unsafe extern "C" fn(
        root: *mut PlannerInfo,
        rtindex: Index,
        target_rte: *mut RangeTblEntry,
        target_relation: Relation,
    ),
>;
pub type PlanForeignModify_function = ::std::option::Option<
    unsafe extern "C" fn(
        root: *mut PlannerInfo,
        plan: *mut ModifyTable,
        resultRelation: Index,
        subplan_index: ::std::os::raw::c_int,
    ) -> *mut List,
>;
pub type BeginForeignModify_function = ::std::option::Option<
    unsafe extern "C" fn(
        mtstate: *mut ModifyTableState,
        rinfo: *mut ResultRelInfo,
        fdw_private: *mut List,
        subplan_index: ::std::os::raw::c_int,
        eflags: ::std::os::raw::c_int,
    ),
>;
pub type ExecForeignInsert_function = ::std::option::Option<
    unsafe extern "C" fn(
        estate: *mut EState,
        rinfo: *mut ResultRelInfo,
        slot: *mut TupleTableSlot,
        planSlot: *mut TupleTableSlot,
    ) -> *mut TupleTableSlot,
>;
pub type ExecForeignBatchInsert_function = ::std::option::Option<
    unsafe extern "C" fn(
        estate: *mut EState,
        rinfo: *mut ResultRelInfo,
        slots: *mut *mut TupleTableSlot,
        planSlots: *mut *mut TupleTableSlot,
        numSlots: *mut ::std::os::raw::c_int,
    ) -> *mut *mut TupleTableSlot,
>;
pub type GetForeignModifyBatchSize_function =
    ::std::option::Option<unsafe extern "C" fn(rinfo: *mut ResultRelInfo) -> ::std::os::raw::c_int>;
pub type ExecForeignUpdate_function = ::std::option::Option<
    unsafe extern "C" fn(
        estate: *mut EState,
        rinfo: *mut ResultRelInfo,
        slot: *mut TupleTableSlot,
        planSlot: *mut TupleTableSlot,
    ) -> *mut TupleTableSlot,
>;
pub type ExecForeignDelete_function = ::std::option::Option<
    unsafe extern "C" fn(
        estate: *mut EState,
        rinfo: *mut ResultRelInfo,
        slot: *mut TupleTableSlot,
        planSlot: *mut TupleTableSlot,
    ) -> *mut TupleTableSlot,
>;
pub type EndForeignModify_function =
    ::std::option::Option<unsafe extern "C" fn(estate: *mut EState, rinfo: *mut ResultRelInfo)>;
pub type BeginForeignInsert_function = ::std::option::Option<
    unsafe extern "C" fn(mtstate: *mut ModifyTableState, rinfo: *mut ResultRelInfo),
>;
pub type EndForeignInsert_function =
    ::std::option::Option<unsafe extern "C" fn(estate: *mut EState, rinfo: *mut ResultRelInfo)>;
pub type IsForeignRelUpdatable_function =
    ::std::option::Option<unsafe extern "C" fn(rel: Relation) -> ::std::os::raw::c_int>;
pub type PlanDirectModify_function = ::std::option::Option<
    unsafe extern "C" fn(
        root: *mut PlannerInfo,
        plan: *mut ModifyTable,
        resultRelation: Index,
        subplan_index: ::std::os::raw::c_int,
    ) -> bool,
>;
pub type BeginDirectModify_function = ::std::option::Option<
    unsafe extern "C" fn(node: *mut ForeignScanState, eflags: ::std::os::raw::c_int),
>;
pub type IterateDirectModify_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState) -> *mut TupleTableSlot>;
pub type EndDirectModify_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState)>;
pub type GetForeignRowMarkType_function = ::std::option::Option<
    unsafe extern "C" fn(rte: *mut RangeTblEntry, strength: LockClauseStrength) -> RowMarkType,
>;
pub type RefetchForeignRow_function = ::std::option::Option<
    unsafe extern "C" fn(
        estate: *mut EState,
        erm: *mut ExecRowMark,
        rowid: Datum,
        slot: *mut TupleTableSlot,
        updated: *mut bool,
    ),
>;
pub type ExplainForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState, es: *mut ExplainState)>;
pub type ExplainForeignModify_function = ::std::option::Option<
    unsafe extern "C" fn(
        mtstate: *mut ModifyTableState,
        rinfo: *mut ResultRelInfo,
        fdw_private: *mut List,
        subplan_index: ::std::os::raw::c_int,
        es: *mut ExplainState,
    ),
>;
pub type ExplainDirectModify_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState, es: *mut ExplainState)>;
pub type AcquireSampleRowsFunc = ::std::option::Option<
    unsafe extern "C" fn(
        relation: Relation,
        elevel: ::std::os::raw::c_int,
        rows: *mut HeapTuple,
        targrows: ::std::os::raw::c_int,
        totalrows: *mut f64,
        totaldeadrows: *mut f64,
    ) -> ::std::os::raw::c_int,
>;
pub type AnalyzeForeignTable_function = ::std::option::Option<
    unsafe extern "C" fn(
        relation: Relation,
        func: *mut AcquireSampleRowsFunc,
        totalpages: *mut BlockNumber,
    ) -> bool,
>;
pub type ImportForeignSchema_function = ::std::option::Option<
    unsafe extern "C" fn(stmt: *mut ImportForeignSchemaStmt, serverOid: Oid) -> *mut List,
>;
pub type ExecForeignTruncate_function = ::std::option::Option<
    unsafe extern "C" fn(rels: *mut List, behavior: DropBehavior, restart_seqs: bool),
>;
pub type EstimateDSMForeignScan_function = ::std::option::Option<
    unsafe extern "C" fn(node: *mut ForeignScanState, pcxt: *mut ParallelContext) -> Size,
>;
pub type InitializeDSMForeignScan_function = ::std::option::Option<
    unsafe extern "C" fn(
        node: *mut ForeignScanState,
        pcxt: *mut ParallelContext,
        coordinate: *mut ::std::os::raw::c_void,
    ),
>;
pub type ReInitializeDSMForeignScan_function = ::std::option::Option<
    unsafe extern "C" fn(
        node: *mut ForeignScanState,
        pcxt: *mut ParallelContext,
        coordinate: *mut ::std::os::raw::c_void,
    ),
>;
pub type InitializeWorkerForeignScan_function = ::std::option::Option<
    unsafe extern "C" fn(
        node: *mut ForeignScanState,
        toc: *mut shm_toc,
        coordinate: *mut ::std::os::raw::c_void,
    ),
>;
pub type ShutdownForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState)>;
pub type IsForeignScanParallelSafe_function = ::std::option::Option<
    unsafe extern "C" fn(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        rte: *mut RangeTblEntry,
    ) -> bool,
>;
pub type ReparameterizeForeignPathByChild_function = ::std::option::Option<
    unsafe extern "C" fn(
        root: *mut PlannerInfo,
        fdw_private: *mut List,
        child_rel: *mut RelOptInfo,
    ) -> *mut List,
>;
pub type IsForeignPathAsyncCapable_function =
    ::std::option::Option<unsafe extern "C" fn(path: *mut ForeignPath) -> bool>;
pub type ForeignAsyncRequest_function =
    ::std::option::Option<unsafe extern "C" fn(areq: *mut AsyncRequest)>;
pub type ForeignAsyncConfigureWait_function =
    ::std::option::Option<unsafe extern "C" fn(areq: *mut AsyncRequest)>;
pub type ForeignAsyncNotify_function =
    ::std::option::Option<unsafe extern "C" fn(areq: *mut AsyncRequest)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FdwRoutine {
    pub type_: NodeTag,
    pub GetForeignRelSize: GetForeignRelSize_function,
    pub GetForeignPaths: GetForeignPaths_function,
    pub GetForeignPlan: GetForeignPlan_function,
    pub BeginForeignScan: BeginForeignScan_function,
    pub IterateForeignScan: IterateForeignScan_function,
    pub ReScanForeignScan: ReScanForeignScan_function,
    pub EndForeignScan: EndForeignScan_function,
    pub GetForeignJoinPaths: GetForeignJoinPaths_function,
    pub GetForeignUpperPaths: GetForeignUpperPaths_function,
    pub AddForeignUpdateTargets: AddForeignUpdateTargets_function,
    pub PlanForeignModify: PlanForeignModify_function,
    pub BeginForeignModify: BeginForeignModify_function,
    pub ExecForeignInsert: ExecForeignInsert_function,
    pub ExecForeignBatchInsert: ExecForeignBatchInsert_function,
    pub GetForeignModifyBatchSize: GetForeignModifyBatchSize_function,
    pub ExecForeignUpdate: ExecForeignUpdate_function,
    pub ExecForeignDelete: ExecForeignDelete_function,
    pub EndForeignModify: EndForeignModify_function,
    pub BeginForeignInsert: BeginForeignInsert_function,
    pub EndForeignInsert: EndForeignInsert_function,
    pub IsForeignRelUpdatable: IsForeignRelUpdatable_function,
    pub PlanDirectModify: PlanDirectModify_function,
    pub BeginDirectModify: BeginDirectModify_function,
    pub IterateDirectModify: IterateDirectModify_function,
    pub EndDirectModify: EndDirectModify_function,
    pub GetForeignRowMarkType: GetForeignRowMarkType_function,
    pub RefetchForeignRow: RefetchForeignRow_function,
    pub RecheckForeignScan: RecheckForeignScan_function,
    pub ExplainForeignScan: ExplainForeignScan_function,
    pub ExplainForeignModify: ExplainForeignModify_function,
    pub ExplainDirectModify: ExplainDirectModify_function,
    pub AnalyzeForeignTable: AnalyzeForeignTable_function,
    pub ImportForeignSchema: ImportForeignSchema_function,
    pub ExecForeignTruncate: ExecForeignTruncate_function,
    pub IsForeignScanParallelSafe: IsForeignScanParallelSafe_function,
    pub EstimateDSMForeignScan: EstimateDSMForeignScan_function,
    pub InitializeDSMForeignScan: InitializeDSMForeignScan_function,
    pub ReInitializeDSMForeignScan: ReInitializeDSMForeignScan_function,
    pub InitializeWorkerForeignScan: InitializeWorkerForeignScan_function,
    pub ShutdownForeignScan: ShutdownForeignScan_function,
    pub ReparameterizeForeignPathByChild: ReparameterizeForeignPathByChild_function,
    pub IsForeignPathAsyncCapable: IsForeignPathAsyncCapable_function,
    pub ForeignAsyncRequest: ForeignAsyncRequest_function,
    pub ForeignAsyncConfigureWait: ForeignAsyncConfigureWait_function,
    pub ForeignAsyncNotify: ForeignAsyncNotify_function,
}
impl Default for FdwRoutine {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForeignDataWrapper {
    pub fdwid: Oid,
    pub owner: Oid,
    pub fdwname: *mut ::std::os::raw::c_char,
    pub fdwhandler: Oid,
    pub fdwvalidator: Oid,
    pub options: *mut List,
}
impl Default for ForeignDataWrapper {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForeignServer {
    pub serverid: Oid,
    pub fdwid: Oid,
    pub owner: Oid,
    pub servername: *mut ::std::os::raw::c_char,
    pub servertype: *mut ::std::os::raw::c_char,
    pub serverversion: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl Default for ForeignServer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UserMapping {
    pub umid: Oid,
    pub userid: Oid,
    pub serverid: Oid,
    pub options: *mut List,
}
impl Default for UserMapping {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForeignTable {
    pub relid: Oid,
    pub serverid: Oid,
    pub options: *mut List,
}
impl Default for ForeignTable {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __m64 = [::std::os::raw::c_longlong; 1usize];
pub type __v1di = [::std::os::raw::c_longlong; 1usize];
pub type __v2si = [::std::os::raw::c_int; 2usize];
pub type __v4hi = [::std::os::raw::c_short; 4usize];
pub type __v8qi = [::std::os::raw::c_char; 8usize];
pub type __v4si = [::std::os::raw::c_int; 4usize];
pub type __v4sf = [f32; 4usize];
pub type __m128 = [f32; 4usize];
pub type __m128_u = [f32; 4usize];
pub type __v4su = [::std::os::raw::c_uint; 4usize];
pub type __m128d = [f64; 2usize];
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
pub type __m128d_u = [f64; 2usize];
pub type __m128i_u = [::std::os::raw::c_longlong; 2usize];
pub type __v2df = [f64; 2usize];
pub type __v2di = [::std::os::raw::c_longlong; 2usize];
pub type __v8hi = [::std::os::raw::c_short; 8usize];
pub type __v16qi = [::std::os::raw::c_char; 16usize];
pub type __v2du = [::std::os::raw::c_ulonglong; 2usize];
pub type __v8hu = [::std::os::raw::c_ushort; 8usize];
pub type __v16qu = [::std::os::raw::c_uchar; 16usize];
pub type __v16qs = [::std::os::raw::c_schar; 16usize];
pub type Vector8 = __m128i;
pub type Vector32 = __m128i;
pub type pg_wchar = ::std::os::raw::c_uint;
pub const pg_enc_PG_SQL_ASCII: pg_enc = 0;
pub const pg_enc_PG_EUC_JP: pg_enc = 1;
pub const pg_enc_PG_EUC_CN: pg_enc = 2;
pub const pg_enc_PG_EUC_KR: pg_enc = 3;
pub const pg_enc_PG_EUC_TW: pg_enc = 4;
pub const pg_enc_PG_EUC_JIS_2004: pg_enc = 5;
pub const pg_enc_PG_UTF8: pg_enc = 6;
pub const pg_enc_PG_MULE_INTERNAL: pg_enc = 7;
pub const pg_enc_PG_LATIN1: pg_enc = 8;
pub const pg_enc_PG_LATIN2: pg_enc = 9;
pub const pg_enc_PG_LATIN3: pg_enc = 10;
pub const pg_enc_PG_LATIN4: pg_enc = 11;
pub const pg_enc_PG_LATIN5: pg_enc = 12;
pub const pg_enc_PG_LATIN6: pg_enc = 13;
pub const pg_enc_PG_LATIN7: pg_enc = 14;
pub const pg_enc_PG_LATIN8: pg_enc = 15;
pub const pg_enc_PG_LATIN9: pg_enc = 16;
pub const pg_enc_PG_LATIN10: pg_enc = 17;
pub const pg_enc_PG_WIN1256: pg_enc = 18;
pub const pg_enc_PG_WIN1258: pg_enc = 19;
pub const pg_enc_PG_WIN866: pg_enc = 20;
pub const pg_enc_PG_WIN874: pg_enc = 21;
pub const pg_enc_PG_KOI8R: pg_enc = 22;
pub const pg_enc_PG_WIN1251: pg_enc = 23;
pub const pg_enc_PG_WIN1252: pg_enc = 24;
pub const pg_enc_PG_ISO_8859_5: pg_enc = 25;
pub const pg_enc_PG_ISO_8859_6: pg_enc = 26;
pub const pg_enc_PG_ISO_8859_7: pg_enc = 27;
pub const pg_enc_PG_ISO_8859_8: pg_enc = 28;
pub const pg_enc_PG_WIN1250: pg_enc = 29;
pub const pg_enc_PG_WIN1253: pg_enc = 30;
pub const pg_enc_PG_WIN1254: pg_enc = 31;
pub const pg_enc_PG_WIN1255: pg_enc = 32;
pub const pg_enc_PG_WIN1257: pg_enc = 33;
pub const pg_enc_PG_KOI8U: pg_enc = 34;
pub const pg_enc_PG_SJIS: pg_enc = 35;
pub const pg_enc_PG_BIG5: pg_enc = 36;
pub const pg_enc_PG_GBK: pg_enc = 37;
pub const pg_enc_PG_UHC: pg_enc = 38;
pub const pg_enc_PG_GB18030: pg_enc = 39;
pub const pg_enc_PG_JOHAB: pg_enc = 40;
pub const pg_enc_PG_SHIFT_JIS_2004: pg_enc = 41;
pub const pg_enc__PG_LAST_ENCODING_: pg_enc = 42;
pub type pg_enc = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pg_enc2name {
    pub name: *const ::std::os::raw::c_char,
    pub encoding: pg_enc,
}
impl Default for pg_enc2name {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pg_enc2gettext {
    pub encoding: pg_enc,
    pub name: *const ::std::os::raw::c_char,
}
impl Default for pg_enc2gettext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type mb2wchar_with_len_converter = ::std::option::Option<
    unsafe extern "C" fn(
        from: *const ::std::os::raw::c_uchar,
        to: *mut pg_wchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type wchar2mb_with_len_converter = ::std::option::Option<
    unsafe extern "C" fn(
        from: *const pg_wchar,
        to: *mut ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type mblen_converter = ::std::option::Option<
    unsafe extern "C" fn(mbstr: *const ::std::os::raw::c_uchar) -> ::std::os::raw::c_int,
>;
pub type mbdisplaylen_converter = ::std::option::Option<
    unsafe extern "C" fn(mbstr: *const ::std::os::raw::c_uchar) -> ::std::os::raw::c_int,
>;
pub type mbcharacter_incrementer = ::std::option::Option<
    unsafe extern "C" fn(mbstr: *mut ::std::os::raw::c_uchar, len: ::std::os::raw::c_int) -> bool,
>;
pub type mbchar_verifier = ::std::option::Option<
    unsafe extern "C" fn(
        mbstr: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type mbstr_verifier = ::std::option::Option<
    unsafe extern "C" fn(
        mbstr: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pg_wchar_tbl {
    pub mb2wchar_with_len: mb2wchar_with_len_converter,
    pub wchar2mb_with_len: wchar2mb_with_len_converter,
    pub mblen: mblen_converter,
    pub dsplen: mbdisplaylen_converter,
    pub mbverifychar: mbchar_verifier,
    pub mbverifystr: mbstr_verifier,
    pub maxmblen: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pg_mb_radix_tree {
    pub chars16: *const uint16,
    pub chars32: *const uint32,
    pub b1root: uint32,
    pub b1_lower: uint8,
    pub b1_upper: uint8,
    pub b2root: uint32,
    pub b2_1_lower: uint8,
    pub b2_1_upper: uint8,
    pub b2_2_lower: uint8,
    pub b2_2_upper: uint8,
    pub b3root: uint32,
    pub b3_1_lower: uint8,
    pub b3_1_upper: uint8,
    pub b3_2_lower: uint8,
    pub b3_2_upper: uint8,
    pub b3_3_lower: uint8,
    pub b3_3_upper: uint8,
    pub b4root: uint32,
    pub b4_1_lower: uint8,
    pub b4_1_upper: uint8,
    pub b4_2_lower: uint8,
    pub b4_2_upper: uint8,
    pub b4_3_lower: uint8,
    pub b4_3_upper: uint8,
    pub b4_4_lower: uint8,
    pub b4_4_upper: uint8,
}
impl Default for pg_mb_radix_tree {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pg_utf_to_local_combined {
    pub utf1: uint32,
    pub utf2: uint32,
    pub code: uint32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pg_local_to_utf_combined {
    pub code: uint32,
    pub utf1: uint32,
    pub utf2: uint32,
}
pub type utf_local_conversion_func =
    ::std::option::Option<unsafe extern "C" fn(code: uint32) -> uint32>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExtensibleNode {
    pub type_: NodeTag,
    pub extnodename: *const ::std::os::raw::c_char,
}
impl Default for ExtensibleNode {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExtensibleNodeMethods {
    pub extnodename: *const ::std::os::raw::c_char,
    pub node_size: Size,
    pub nodeCopy: ::std::option::Option<
        unsafe extern "C" fn(newnode: *mut ExtensibleNode, oldnode: *const ExtensibleNode),
    >,
    pub nodeEqual: ::std::option::Option<
        unsafe extern "C" fn(a: *const ExtensibleNode, b: *const ExtensibleNode) -> bool,
    >,
    pub nodeOut: ::std::option::Option<
        unsafe extern "C" fn(str_: *mut StringInfoData, node: *const ExtensibleNode),
    >,
    pub nodeRead: ::std::option::Option<unsafe extern "C" fn(node: *mut ExtensibleNode)>,
}
impl Default for ExtensibleNodeMethods {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CustomPathMethods {
    pub CustomName: *const ::std::os::raw::c_char,
    pub PlanCustomPath: ::std::option::Option<
        unsafe extern "C" fn(
            root: *mut PlannerInfo,
            rel: *mut RelOptInfo,
            best_path: *mut CustomPath,
            tlist: *mut List,
            clauses: *mut List,
            custom_plans: *mut List,
        ) -> *mut Plan,
    >,
    pub ReparameterizeCustomPathByChild: ::std::option::Option<
        unsafe extern "C" fn(
            root: *mut PlannerInfo,
            custom_private: *mut List,
            child_rel: *mut RelOptInfo,
        ) -> *mut List,
    >,
}
impl Default for CustomPathMethods {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CustomScanMethods {
    pub CustomName: *const ::std::os::raw::c_char,
    pub CreateCustomScanState:
        ::std::option::Option<unsafe extern "C" fn(cscan: *mut CustomScan) -> *mut Node>,
}
impl Default for CustomScanMethods {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CustomExecMethods {
    pub CustomName: *const ::std::os::raw::c_char,
    pub BeginCustomScan: ::std::option::Option<
        unsafe extern "C" fn(
            node: *mut CustomScanState,
            estate: *mut EState,
            eflags: ::std::os::raw::c_int,
        ),
    >,
    pub ExecCustomScan: ::std::option::Option<
        unsafe extern "C" fn(node: *mut CustomScanState) -> *mut TupleTableSlot,
    >,
    pub EndCustomScan: ::std::option::Option<unsafe extern "C" fn(node: *mut CustomScanState)>,
    pub ReScanCustomScan: ::std::option::Option<unsafe extern "C" fn(node: *mut CustomScanState)>,
    pub MarkPosCustomScan: ::std::option::Option<unsafe extern "C" fn(node: *mut CustomScanState)>,
    pub RestrPosCustomScan: ::std::option::Option<unsafe extern "C" fn(node: *mut CustomScanState)>,
    pub EstimateDSMCustomScan: ::std::option::Option<
        unsafe extern "C" fn(node: *mut CustomScanState, pcxt: *mut ParallelContext) -> Size,
    >,
    pub InitializeDSMCustomScan: ::std::option::Option<
        unsafe extern "C" fn(
            node: *mut CustomScanState,
            pcxt: *mut ParallelContext,
            coordinate: *mut ::std::os::raw::c_void,
        ),
    >,
    pub ReInitializeDSMCustomScan: ::std::option::Option<
        unsafe extern "C" fn(
            node: *mut CustomScanState,
            pcxt: *mut ParallelContext,
            coordinate: *mut ::std::os::raw::c_void,
        ),
    >,
    pub InitializeWorkerCustomScan: ::std::option::Option<
        unsafe extern "C" fn(
            node: *mut CustomScanState,
            toc: *mut shm_toc,
            coordinate: *mut ::std::os::raw::c_void,
        ),
    >,
    pub ShutdownCustomScan: ::std::option::Option<unsafe extern "C" fn(node: *mut CustomScanState)>,
    pub ExplainCustomScan: ::std::option::Option<
        unsafe extern "C" fn(
            node: *mut CustomScanState,
            ancestors: *mut List,
            es: *mut ExplainState,
        ),
    >,
}
impl Default for CustomExecMethods {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type check_function_callback = ::std::option::Option<
    unsafe extern "C" fn(func_id: Oid, context: *mut ::std::os::raw::c_void) -> bool,
>;
pub type tree_walker_callback = ::std::option::Option<
    unsafe extern "C" fn(node: *mut Node, context: *mut ::std::os::raw::c_void) -> bool,
>;
pub type planstate_tree_walker_callback = ::std::option::Option<
    unsafe extern "C" fn(planstate: *mut PlanState, context: *mut ::std::os::raw::c_void) -> bool,
>;
pub type tree_mutator_callback = ::std::option::Option<
    unsafe extern "C" fn(node: *mut Node, context: *mut ::std::os::raw::c_void) -> *mut Node,
>;
pub const ReplicationKind_REPLICATION_KIND_PHYSICAL: ReplicationKind = 0;
pub const ReplicationKind_REPLICATION_KIND_LOGICAL: ReplicationKind = 1;
pub type ReplicationKind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IdentifySystemCmd {
    pub type_: NodeTag,
}
impl Default for IdentifySystemCmd {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BaseBackupCmd {
    pub type_: NodeTag,
    pub options: *mut List,
}
impl Default for BaseBackupCmd {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateReplicationSlotCmd {
    pub type_: NodeTag,
    pub slotname: *mut ::std::os::raw::c_char,
    pub kind: ReplicationKind,
    pub plugin: *mut ::std::os::raw::c_char,
    pub temporary: bool,
    pub options: *mut List,
}
impl Default for CreateReplicationSlotCmd {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DropReplicationSlotCmd {
    pub type_: NodeTag,
    pub slotname: *mut ::std::os::raw::c_char,
    pub wait: bool,
}
impl Default for DropReplicationSlotCmd {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StartReplicationCmd {
    pub type_: NodeTag,
    pub kind: ReplicationKind,
    pub slotname: *mut ::std::os::raw::c_char,
    pub timeline: TimeLineID,
    pub startpoint: XLogRecPtr,
    pub options: *mut List,
}
impl Default for StartReplicationCmd {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReadReplicationSlotCmd {
    pub type_: NodeTag,
    pub slotname: *mut ::std::os::raw::c_char,
}
impl Default for ReadReplicationSlotCmd {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TimeLineHistoryCmd {
    pub type_: NodeTag,
    pub timeline: TimeLineID,
}
impl Default for TimeLineHistoryCmd {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SupportRequestSimplify {
    pub type_: NodeTag,
    pub root: *mut PlannerInfo,
    pub fcall: *mut FuncExpr,
}
impl Default for SupportRequestSimplify {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SupportRequestSelectivity {
    pub type_: NodeTag,
    pub root: *mut PlannerInfo,
    pub funcid: Oid,
    pub args: *mut List,
    pub inputcollid: Oid,
    pub is_join: bool,
    pub varRelid: ::std::os::raw::c_int,
    pub jointype: JoinType,
    pub sjinfo: *mut SpecialJoinInfo,
    pub selectivity: Selectivity,
}
impl Default for SupportRequestSelectivity {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SupportRequestCost {
    pub type_: NodeTag,
    pub root: *mut PlannerInfo,
    pub funcid: Oid,
    pub node: *mut Node,
    pub startup: Cost,
    pub per_tuple: Cost,
}
impl Default for SupportRequestCost {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SupportRequestRows {
    pub type_: NodeTag,
    pub root: *mut PlannerInfo,
    pub funcid: Oid,
    pub node: *mut Node,
    pub rows: f64,
}
impl Default for SupportRequestRows {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SupportRequestIndexCondition {
    pub type_: NodeTag,
    pub root: *mut PlannerInfo,
    pub funcid: Oid,
    pub node: *mut Node,
    pub indexarg: ::std::os::raw::c_int,
    pub index: *mut IndexOptInfo,
    pub indexcol: ::std::os::raw::c_int,
    pub opfamily: Oid,
    pub indexcollation: Oid,
    pub lossy: bool,
}
impl Default for SupportRequestIndexCondition {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SupportRequestWFuncMonotonic {
    pub type_: NodeTag,
    pub window_func: *mut WindowFunc,
    pub window_clause: *mut WindowClause,
    pub monotonic: MonotonicFunction,
}
impl Default for SupportRequestWFuncMonotonic {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SupportRequestOptimizeWindowClause {
    pub type_: NodeTag,
    pub window_func: *mut WindowFunc,
    pub window_clause: *mut WindowClause,
    pub frameOptions: ::std::os::raw::c_int,
}
impl Default for SupportRequestOptimizeWindowClause {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowFuncLists {
    pub numWindowFuncs: ::std::os::raw::c_int,
    pub maxWinRef: Index,
    pub windowFuncs: *mut *mut List,
}
impl Default for WindowFuncLists {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ConstraintExclusionType_CONSTRAINT_EXCLUSION_OFF: ConstraintExclusionType = 0;
pub const ConstraintExclusionType_CONSTRAINT_EXCLUSION_ON: ConstraintExclusionType = 1;
pub const ConstraintExclusionType_CONSTRAINT_EXCLUSION_PARTITION: ConstraintExclusionType = 2;
pub type ConstraintExclusionType = ::std::os::raw::c_uint;
pub const DebugParallelMode_DEBUG_PARALLEL_OFF: DebugParallelMode = 0;
pub const DebugParallelMode_DEBUG_PARALLEL_ON: DebugParallelMode = 1;
pub const DebugParallelMode_DEBUG_PARALLEL_REGRESS: DebugParallelMode = 2;
pub type DebugParallelMode = ::std::os::raw::c_uint;
pub type set_rel_pathlist_hook_type = ::std::option::Option<
    unsafe extern "C" fn(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        rti: Index,
        rte: *mut RangeTblEntry,
    ),
>;
pub type set_join_pathlist_hook_type = ::std::option::Option<
    unsafe extern "C" fn(
        root: *mut PlannerInfo,
        joinrel: *mut RelOptInfo,
        outerrel: *mut RelOptInfo,
        innerrel: *mut RelOptInfo,
        jointype: JoinType,
        extra: *mut JoinPathExtraData,
    ),
>;
pub type join_search_hook_type = ::std::option::Option<
    unsafe extern "C" fn(
        root: *mut PlannerInfo,
        levels_needed: ::std::os::raw::c_int,
        initial_rels: *mut List,
    ) -> *mut RelOptInfo,
>;
pub type ec_matches_callback_type = ::std::option::Option<
    unsafe extern "C" fn(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        ec: *mut EquivalenceClass,
        em: *mut EquivalenceMember,
        arg: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
pub const PathKeysComparison_PATHKEYS_EQUAL: PathKeysComparison = 0;
pub const PathKeysComparison_PATHKEYS_BETTER1: PathKeysComparison = 1;
pub const PathKeysComparison_PATHKEYS_BETTER2: PathKeysComparison = 2;
pub const PathKeysComparison_PATHKEYS_DIFFERENT: PathKeysComparison = 3;
pub type PathKeysComparison = ::std::os::raw::c_uint;
pub type get_relation_info_hook_type = ::std::option::Option<
    unsafe extern "C" fn(
        root: *mut PlannerInfo,
        relationObjectId: Oid,
        inhparent: bool,
        rel: *mut RelOptInfo,
    ),
>;
pub type query_pathkeys_callback = ::std::option::Option<
    unsafe extern "C" fn(root: *mut PlannerInfo, extra: *mut ::std::os::raw::c_void),
>;
pub type planner_hook_type = ::std::option::Option<
    unsafe extern "C" fn(
        parse: *mut Query,
        query_string: *const ::std::os::raw::c_char,
        cursorOptions: ::std::os::raw::c_int,
        boundParams: ParamListInfo,
    ) -> *mut PlannedStmt,
>;
pub type create_upper_paths_hook_type = ::std::option::Option<
    unsafe extern "C" fn(
        root: *mut PlannerInfo,
        stage: UpperRelationKind,
        input_rel: *mut RelOptInfo,
        output_rel: *mut RelOptInfo,
        extra: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LocationLen {
    pub location: ::std::os::raw::c_int,
    pub length: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JumbleState {
    pub jumble: *mut ::std::os::raw::c_uchar,
    pub jumble_len: Size,
    pub clocations: *mut LocationLen,
    pub clocations_buf_size: ::std::os::raw::c_int,
    pub clocations_count: ::std::os::raw::c_int,
    pub highest_extern_param_id: ::std::os::raw::c_int,
}
impl Default for JumbleState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ComputeQueryIdType_COMPUTE_QUERY_ID_OFF: ComputeQueryIdType = 0;
pub const ComputeQueryIdType_COMPUTE_QUERY_ID_ON: ComputeQueryIdType = 1;
pub const ComputeQueryIdType_COMPUTE_QUERY_ID_AUTO: ComputeQueryIdType = 2;
pub const ComputeQueryIdType_COMPUTE_QUERY_ID_REGRESS: ComputeQueryIdType = 3;
pub type ComputeQueryIdType = ::std::os::raw::c_uint;
pub type post_parse_analyze_hook_type = ::std::option::Option<
    unsafe extern "C" fn(pstate: *mut ParseState, query: *mut Query, jstate: *mut JumbleState),
>;
pub const FuncDetailCode_FUNCDETAIL_NOTFOUND: FuncDetailCode = 0;
pub const FuncDetailCode_FUNCDETAIL_MULTIPLE: FuncDetailCode = 1;
pub const FuncDetailCode_FUNCDETAIL_NORMAL: FuncDetailCode = 2;
pub const FuncDetailCode_FUNCDETAIL_PROCEDURE: FuncDetailCode = 3;
pub const FuncDetailCode_FUNCDETAIL_AGGREGATE: FuncDetailCode = 4;
pub const FuncDetailCode_FUNCDETAIL_WINDOWFUNC: FuncDetailCode = 5;
pub const FuncDetailCode_FUNCDETAIL_COERCION: FuncDetailCode = 6;
pub type FuncDetailCode = ::std::os::raw::c_uint;
pub type Operator = HeapTuple;
pub type Type = HeapTuple;
pub type TYPCATEGORY = ::std::os::raw::c_char;
pub const CoercionPathType_COERCION_PATH_NONE: CoercionPathType = 0;
pub const CoercionPathType_COERCION_PATH_FUNC: CoercionPathType = 1;
pub const CoercionPathType_COERCION_PATH_RELABELTYPE: CoercionPathType = 2;
pub const CoercionPathType_COERCION_PATH_ARRAYCOERCE: CoercionPathType = 3;
pub const CoercionPathType_COERCION_PATH_COERCEVIAIO: CoercionPathType = 4;
pub type CoercionPathType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExpandedRecordHeader {
    pub hdr: ExpandedObjectHeader,
    pub er_magic: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
    pub er_decltypeid: Oid,
    pub er_typeid: Oid,
    pub er_typmod: int32,
    pub er_tupdesc: TupleDesc,
    pub er_tupdesc_id: uint64,
    pub dvalues: *mut Datum,
    pub dnulls: *mut bool,
    pub nfields: ::std::os::raw::c_int,
    pub flat_size: Size,
    pub data_len: Size,
    pub hoff: ::std::os::raw::c_int,
    pub hasnull: bool,
    pub fvalue: HeapTuple,
    pub fstartptr: *mut ::std::os::raw::c_char,
    pub fendptr: *mut ::std::os::raw::c_char,
    pub er_short_term_cxt: MemoryContext,
    pub er_dummy_header: *mut ExpandedRecordHeader,
    pub er_domaininfo: *mut ::std::os::raw::c_void,
    pub er_mcb: MemoryContextCallback,
}
impl Default for ExpandedRecordHeader {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExpandedRecordFieldInfo {
    pub fnumber: ::std::os::raw::c_int,
    pub ftypeid: Oid,
    pub ftypmod: int32,
    pub fcollation: Oid,
}
impl Default for ExpandedRecordFieldInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DomainConstraintCache {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TypeCacheEnumData {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TypeCacheEntry {
    pub type_id: Oid,
    pub type_id_hash: uint32,
    pub typlen: int16,
    pub typbyval: bool,
    pub typalign: ::std::os::raw::c_char,
    pub typstorage: ::std::os::raw::c_char,
    pub typtype: ::std::os::raw::c_char,
    pub typrelid: Oid,
    pub typsubscript: Oid,
    pub typelem: Oid,
    pub typcollation: Oid,
    pub btree_opf: Oid,
    pub btree_opintype: Oid,
    pub hash_opf: Oid,
    pub hash_opintype: Oid,
    pub eq_opr: Oid,
    pub lt_opr: Oid,
    pub gt_opr: Oid,
    pub cmp_proc: Oid,
    pub hash_proc: Oid,
    pub hash_extended_proc: Oid,
    pub eq_opr_finfo: FmgrInfo,
    pub cmp_proc_finfo: FmgrInfo,
    pub hash_proc_finfo: FmgrInfo,
    pub hash_extended_proc_finfo: FmgrInfo,
    pub tupDesc: TupleDesc,
    pub tupDesc_identifier: uint64,
    pub rngelemtype: *mut TypeCacheEntry,
    pub rng_collation: Oid,
    pub rng_cmp_proc_finfo: FmgrInfo,
    pub rng_canonical_finfo: FmgrInfo,
    pub rng_subdiff_finfo: FmgrInfo,
    pub rngtype: *mut TypeCacheEntry,
    pub domainBaseType: Oid,
    pub domainBaseTypmod: int32,
    pub domainData: *mut DomainConstraintCache,
    pub flags: ::std::os::raw::c_int,
    pub enumData: *mut TypeCacheEnumData,
    pub nextDomain: *mut TypeCacheEntry,
}
impl Default for TypeCacheEntry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DomainConstraintRef {
    pub constraints: *mut List,
    pub refctx: MemoryContext,
    pub tcache: *mut TypeCacheEntry,
    pub need_exprstate: bool,
    pub dcc: *mut DomainConstraintCache,
    pub callback: MemoryContextCallback,
}
impl Default for DomainConstraintRef {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SharedRecordTypmodRegistry {
    _unused: [u8; 0],
}
pub const PLpgSQL_nsitem_type_PLPGSQL_NSTYPE_LABEL: PLpgSQL_nsitem_type = 0;
pub const PLpgSQL_nsitem_type_PLPGSQL_NSTYPE_VAR: PLpgSQL_nsitem_type = 1;
pub const PLpgSQL_nsitem_type_PLPGSQL_NSTYPE_REC: PLpgSQL_nsitem_type = 2;
pub type PLpgSQL_nsitem_type = ::std::os::raw::c_uint;
pub const PLpgSQL_label_type_PLPGSQL_LABEL_BLOCK: PLpgSQL_label_type = 0;
pub const PLpgSQL_label_type_PLPGSQL_LABEL_LOOP: PLpgSQL_label_type = 1;
pub const PLpgSQL_label_type_PLPGSQL_LABEL_OTHER: PLpgSQL_label_type = 2;
pub type PLpgSQL_label_type = ::std::os::raw::c_uint;
pub const PLpgSQL_datum_type_PLPGSQL_DTYPE_VAR: PLpgSQL_datum_type = 0;
pub const PLpgSQL_datum_type_PLPGSQL_DTYPE_ROW: PLpgSQL_datum_type = 1;
pub const PLpgSQL_datum_type_PLPGSQL_DTYPE_REC: PLpgSQL_datum_type = 2;
pub const PLpgSQL_datum_type_PLPGSQL_DTYPE_RECFIELD: PLpgSQL_datum_type = 3;
pub const PLpgSQL_datum_type_PLPGSQL_DTYPE_PROMISE: PLpgSQL_datum_type = 4;
pub type PLpgSQL_datum_type = ::std::os::raw::c_uint;
pub const PLpgSQL_promise_type_PLPGSQL_PROMISE_NONE: PLpgSQL_promise_type = 0;
pub const PLpgSQL_promise_type_PLPGSQL_PROMISE_TG_NAME: PLpgSQL_promise_type = 1;
pub const PLpgSQL_promise_type_PLPGSQL_PROMISE_TG_WHEN: PLpgSQL_promise_type = 2;
pub const PLpgSQL_promise_type_PLPGSQL_PROMISE_TG_LEVEL: PLpgSQL_promise_type = 3;
pub const PLpgSQL_promise_type_PLPGSQL_PROMISE_TG_OP: PLpgSQL_promise_type = 4;
pub const PLpgSQL_promise_type_PLPGSQL_PROMISE_TG_RELID: PLpgSQL_promise_type = 5;
pub const PLpgSQL_promise_type_PLPGSQL_PROMISE_TG_TABLE_NAME: PLpgSQL_promise_type = 6;
pub const PLpgSQL_promise_type_PLPGSQL_PROMISE_TG_TABLE_SCHEMA: PLpgSQL_promise_type = 7;
pub const PLpgSQL_promise_type_PLPGSQL_PROMISE_TG_NARGS: PLpgSQL_promise_type = 8;
pub const PLpgSQL_promise_type_PLPGSQL_PROMISE_TG_ARGV: PLpgSQL_promise_type = 9;
pub const PLpgSQL_promise_type_PLPGSQL_PROMISE_TG_EVENT: PLpgSQL_promise_type = 10;
pub const PLpgSQL_promise_type_PLPGSQL_PROMISE_TG_TAG: PLpgSQL_promise_type = 11;
pub type PLpgSQL_promise_type = ::std::os::raw::c_uint;
pub const PLpgSQL_type_type_PLPGSQL_TTYPE_SCALAR: PLpgSQL_type_type = 0;
pub const PLpgSQL_type_type_PLPGSQL_TTYPE_REC: PLpgSQL_type_type = 1;
pub const PLpgSQL_type_type_PLPGSQL_TTYPE_PSEUDO: PLpgSQL_type_type = 2;
pub type PLpgSQL_type_type = ::std::os::raw::c_uint;
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_BLOCK: PLpgSQL_stmt_type = 0;
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_ASSIGN: PLpgSQL_stmt_type = 1;
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_IF: PLpgSQL_stmt_type = 2;
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_CASE: PLpgSQL_stmt_type = 3;
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_LOOP: PLpgSQL_stmt_type = 4;
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_WHILE: PLpgSQL_stmt_type = 5;
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_FORI: PLpgSQL_stmt_type = 6;
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_FORS: PLpgSQL_stmt_type = 7;
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_FORC: PLpgSQL_stmt_type = 8;
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_FOREACH_A: PLpgSQL_stmt_type = 9;
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_EXIT: PLpgSQL_stmt_type = 10;
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_RETURN: PLpgSQL_stmt_type = 11;
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_RETURN_NEXT: PLpgSQL_stmt_type = 12;
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_RETURN_QUERY: PLpgSQL_stmt_type = 13;
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_RAISE: PLpgSQL_stmt_type = 14;
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_ASSERT: PLpgSQL_stmt_type = 15;
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_EXECSQL: PLpgSQL_stmt_type = 16;
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_DYNEXECUTE: PLpgSQL_stmt_type = 17;
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_DYNFORS: PLpgSQL_stmt_type = 18;
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_GETDIAG: PLpgSQL_stmt_type = 19;
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_OPEN: PLpgSQL_stmt_type = 20;
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_FETCH: PLpgSQL_stmt_type = 21;
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_CLOSE: PLpgSQL_stmt_type = 22;
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_PERFORM: PLpgSQL_stmt_type = 23;
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_CALL: PLpgSQL_stmt_type = 24;
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_COMMIT: PLpgSQL_stmt_type = 25;
pub const PLpgSQL_stmt_type_PLPGSQL_STMT_ROLLBACK: PLpgSQL_stmt_type = 26;
pub type PLpgSQL_stmt_type = ::std::os::raw::c_uint;
pub const PLPGSQL_RC_OK: _bindgen_ty_19 = 0;
pub const PLPGSQL_RC_EXIT: _bindgen_ty_19 = 1;
pub const PLPGSQL_RC_RETURN: _bindgen_ty_19 = 2;
pub const PLPGSQL_RC_CONTINUE: _bindgen_ty_19 = 3;
pub type _bindgen_ty_19 = ::std::os::raw::c_uint;
pub const PLpgSQL_getdiag_kind_PLPGSQL_GETDIAG_ROW_COUNT: PLpgSQL_getdiag_kind = 0;
pub const PLpgSQL_getdiag_kind_PLPGSQL_GETDIAG_ROUTINE_OID: PLpgSQL_getdiag_kind = 1;
pub const PLpgSQL_getdiag_kind_PLPGSQL_GETDIAG_CONTEXT: PLpgSQL_getdiag_kind = 2;
pub const PLpgSQL_getdiag_kind_PLPGSQL_GETDIAG_ERROR_CONTEXT: PLpgSQL_getdiag_kind = 3;
pub const PLpgSQL_getdiag_kind_PLPGSQL_GETDIAG_ERROR_DETAIL: PLpgSQL_getdiag_kind = 4;
pub const PLpgSQL_getdiag_kind_PLPGSQL_GETDIAG_ERROR_HINT: PLpgSQL_getdiag_kind = 5;
pub const PLpgSQL_getdiag_kind_PLPGSQL_GETDIAG_RETURNED_SQLSTATE: PLpgSQL_getdiag_kind = 6;
pub const PLpgSQL_getdiag_kind_PLPGSQL_GETDIAG_COLUMN_NAME: PLpgSQL_getdiag_kind = 7;
pub const PLpgSQL_getdiag_kind_PLPGSQL_GETDIAG_CONSTRAINT_NAME: PLpgSQL_getdiag_kind = 8;
pub const PLpgSQL_getdiag_kind_PLPGSQL_GETDIAG_DATATYPE_NAME: PLpgSQL_getdiag_kind = 9;
pub const PLpgSQL_getdiag_kind_PLPGSQL_GETDIAG_MESSAGE_TEXT: PLpgSQL_getdiag_kind = 10;
pub const PLpgSQL_getdiag_kind_PLPGSQL_GETDIAG_TABLE_NAME: PLpgSQL_getdiag_kind = 11;
pub const PLpgSQL_getdiag_kind_PLPGSQL_GETDIAG_SCHEMA_NAME: PLpgSQL_getdiag_kind = 12;
pub type PLpgSQL_getdiag_kind = ::std::os::raw::c_uint;
pub const PLpgSQL_raise_option_type_PLPGSQL_RAISEOPTION_ERRCODE: PLpgSQL_raise_option_type = 0;
pub const PLpgSQL_raise_option_type_PLPGSQL_RAISEOPTION_MESSAGE: PLpgSQL_raise_option_type = 1;
pub const PLpgSQL_raise_option_type_PLPGSQL_RAISEOPTION_DETAIL: PLpgSQL_raise_option_type = 2;
pub const PLpgSQL_raise_option_type_PLPGSQL_RAISEOPTION_HINT: PLpgSQL_raise_option_type = 3;
pub const PLpgSQL_raise_option_type_PLPGSQL_RAISEOPTION_COLUMN: PLpgSQL_raise_option_type = 4;
pub const PLpgSQL_raise_option_type_PLPGSQL_RAISEOPTION_CONSTRAINT: PLpgSQL_raise_option_type = 5;
pub const PLpgSQL_raise_option_type_PLPGSQL_RAISEOPTION_DATATYPE: PLpgSQL_raise_option_type = 6;
pub const PLpgSQL_raise_option_type_PLPGSQL_RAISEOPTION_TABLE: PLpgSQL_raise_option_type = 7;
pub const PLpgSQL_raise_option_type_PLPGSQL_RAISEOPTION_SCHEMA: PLpgSQL_raise_option_type = 8;
pub type PLpgSQL_raise_option_type = ::std::os::raw::c_uint;
pub const PLpgSQL_resolve_option_PLPGSQL_RESOLVE_ERROR: PLpgSQL_resolve_option = 0;
pub const PLpgSQL_resolve_option_PLPGSQL_RESOLVE_VARIABLE: PLpgSQL_resolve_option = 1;
pub const PLpgSQL_resolve_option_PLPGSQL_RESOLVE_COLUMN: PLpgSQL_resolve_option = 2;
pub type PLpgSQL_resolve_option = ::std::os::raw::c_uint;
#[doc = " Node and structure definitions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_type {
    pub typname: *mut ::std::os::raw::c_char,
    pub typoid: Oid,
    pub ttype: PLpgSQL_type_type,
    pub typlen: int16,
    pub typbyval: bool,
    pub typtype: ::std::os::raw::c_char,
    pub collation: Oid,
    pub typisarray: bool,
    pub atttypmod: int32,
    pub origtypname: *mut TypeName,
    pub tcache: *mut TypeCacheEntry,
    pub tupdesc_id: uint64,
}
impl Default for PLpgSQL_type {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_expr {
    pub query: *mut ::std::os::raw::c_char,
    pub parseMode: RawParseMode,
    pub plan: SPIPlanPtr,
    pub paramnos: *mut Bitmapset,
    pub func: *mut PLpgSQL_function,
    pub ns: *mut PLpgSQL_nsitem,
    pub expr_simple_expr: *mut Expr,
    pub expr_simple_type: Oid,
    pub expr_simple_typmod: int32,
    pub expr_simple_mutable: bool,
    pub target_param: ::std::os::raw::c_int,
    pub expr_rw_param: *mut Param,
    pub expr_simple_plansource: *mut CachedPlanSource,
    pub expr_simple_plan: *mut CachedPlan,
    pub expr_simple_plan_lxid: LocalTransactionId,
    pub expr_simple_state: *mut ExprState,
    pub expr_simple_in_use: bool,
    pub expr_simple_lxid: LocalTransactionId,
}
impl Default for PLpgSQL_expr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_datum {
    pub dtype: PLpgSQL_datum_type,
    pub dno: ::std::os::raw::c_int,
}
impl Default for PLpgSQL_datum {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_variable {
    pub dtype: PLpgSQL_datum_type,
    pub dno: ::std::os::raw::c_int,
    pub refname: *mut ::std::os::raw::c_char,
    pub lineno: ::std::os::raw::c_int,
    pub isconst: bool,
    pub notnull: bool,
    pub default_val: *mut PLpgSQL_expr,
}
impl Default for PLpgSQL_variable {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_var {
    pub dtype: PLpgSQL_datum_type,
    pub dno: ::std::os::raw::c_int,
    pub refname: *mut ::std::os::raw::c_char,
    pub lineno: ::std::os::raw::c_int,
    pub isconst: bool,
    pub notnull: bool,
    pub default_val: *mut PLpgSQL_expr,
    pub datatype: *mut PLpgSQL_type,
    pub cursor_explicit_expr: *mut PLpgSQL_expr,
    pub cursor_explicit_argrow: ::std::os::raw::c_int,
    pub cursor_options: ::std::os::raw::c_int,
    pub value: Datum,
    pub isnull: bool,
    pub freeval: bool,
    pub promise: PLpgSQL_promise_type,
}
impl Default for PLpgSQL_var {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_row {
    pub dtype: PLpgSQL_datum_type,
    pub dno: ::std::os::raw::c_int,
    pub refname: *mut ::std::os::raw::c_char,
    pub lineno: ::std::os::raw::c_int,
    pub isconst: bool,
    pub notnull: bool,
    pub default_val: *mut PLpgSQL_expr,
    pub rowtupdesc: TupleDesc,
    pub nfields: ::std::os::raw::c_int,
    pub fieldnames: *mut *mut ::std::os::raw::c_char,
    pub varnos: *mut ::std::os::raw::c_int,
}
impl Default for PLpgSQL_row {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_rec {
    pub dtype: PLpgSQL_datum_type,
    pub dno: ::std::os::raw::c_int,
    pub refname: *mut ::std::os::raw::c_char,
    pub lineno: ::std::os::raw::c_int,
    pub isconst: bool,
    pub notnull: bool,
    pub default_val: *mut PLpgSQL_expr,
    pub datatype: *mut PLpgSQL_type,
    pub rectypeid: Oid,
    pub firstfield: ::std::os::raw::c_int,
    pub erh: *mut ExpandedRecordHeader,
}
impl Default for PLpgSQL_rec {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_recfield {
    pub dtype: PLpgSQL_datum_type,
    pub dno: ::std::os::raw::c_int,
    pub fieldname: *mut ::std::os::raw::c_char,
    pub recparentno: ::std::os::raw::c_int,
    pub nextfield: ::std::os::raw::c_int,
    pub rectupledescid: uint64,
    pub finfo: ExpandedRecordFieldInfo,
}
impl Default for PLpgSQL_recfield {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct PLpgSQL_nsitem {
    pub itemtype: PLpgSQL_nsitem_type,
    pub itemno: ::std::os::raw::c_int,
    pub prev: *mut PLpgSQL_nsitem,
    pub name: __IncompleteArrayField<::std::os::raw::c_char>,
}
impl Default for PLpgSQL_nsitem {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt {
    pub cmd_type: PLpgSQL_stmt_type,
    pub lineno: ::std::os::raw::c_int,
    pub stmtid: ::std::os::raw::c_uint,
}
impl Default for PLpgSQL_stmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_condition {
    pub sqlerrstate: ::std::os::raw::c_int,
    pub condname: *mut ::std::os::raw::c_char,
    pub next: *mut PLpgSQL_condition,
}
impl Default for PLpgSQL_condition {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_exception_block {
    pub sqlstate_varno: ::std::os::raw::c_int,
    pub sqlerrm_varno: ::std::os::raw::c_int,
    pub exc_list: *mut List,
}
impl Default for PLpgSQL_exception_block {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_exception {
    pub lineno: ::std::os::raw::c_int,
    pub conditions: *mut PLpgSQL_condition,
    pub action: *mut List,
}
impl Default for PLpgSQL_exception {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_block {
    pub cmd_type: PLpgSQL_stmt_type,
    pub lineno: ::std::os::raw::c_int,
    pub stmtid: ::std::os::raw::c_uint,
    pub label: *mut ::std::os::raw::c_char,
    pub body: *mut List,
    pub n_initvars: ::std::os::raw::c_int,
    pub initvarnos: *mut ::std::os::raw::c_int,
    pub exceptions: *mut PLpgSQL_exception_block,
}
impl Default for PLpgSQL_stmt_block {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_assign {
    pub cmd_type: PLpgSQL_stmt_type,
    pub lineno: ::std::os::raw::c_int,
    pub stmtid: ::std::os::raw::c_uint,
    pub varno: ::std::os::raw::c_int,
    pub expr: *mut PLpgSQL_expr,
}
impl Default for PLpgSQL_stmt_assign {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_perform {
    pub cmd_type: PLpgSQL_stmt_type,
    pub lineno: ::std::os::raw::c_int,
    pub stmtid: ::std::os::raw::c_uint,
    pub expr: *mut PLpgSQL_expr,
}
impl Default for PLpgSQL_stmt_perform {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_call {
    pub cmd_type: PLpgSQL_stmt_type,
    pub lineno: ::std::os::raw::c_int,
    pub stmtid: ::std::os::raw::c_uint,
    pub expr: *mut PLpgSQL_expr,
    pub is_call: bool,
    pub target: *mut PLpgSQL_variable,
}
impl Default for PLpgSQL_stmt_call {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_commit {
    pub cmd_type: PLpgSQL_stmt_type,
    pub lineno: ::std::os::raw::c_int,
    pub stmtid: ::std::os::raw::c_uint,
    pub chain: bool,
}
impl Default for PLpgSQL_stmt_commit {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_rollback {
    pub cmd_type: PLpgSQL_stmt_type,
    pub lineno: ::std::os::raw::c_int,
    pub stmtid: ::std::os::raw::c_uint,
    pub chain: bool,
}
impl Default for PLpgSQL_stmt_rollback {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_diag_item {
    pub kind: PLpgSQL_getdiag_kind,
    pub target: ::std::os::raw::c_int,
}
impl Default for PLpgSQL_diag_item {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_getdiag {
    pub cmd_type: PLpgSQL_stmt_type,
    pub lineno: ::std::os::raw::c_int,
    pub stmtid: ::std::os::raw::c_uint,
    pub is_stacked: bool,
    pub diag_items: *mut List,
}
impl Default for PLpgSQL_stmt_getdiag {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_if {
    pub cmd_type: PLpgSQL_stmt_type,
    pub lineno: ::std::os::raw::c_int,
    pub stmtid: ::std::os::raw::c_uint,
    pub cond: *mut PLpgSQL_expr,
    pub then_body: *mut List,
    pub elsif_list: *mut List,
    pub else_body: *mut List,
}
impl Default for PLpgSQL_stmt_if {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_if_elsif {
    pub lineno: ::std::os::raw::c_int,
    pub cond: *mut PLpgSQL_expr,
    pub stmts: *mut List,
}
impl Default for PLpgSQL_if_elsif {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_case {
    pub cmd_type: PLpgSQL_stmt_type,
    pub lineno: ::std::os::raw::c_int,
    pub stmtid: ::std::os::raw::c_uint,
    pub t_expr: *mut PLpgSQL_expr,
    pub t_varno: ::std::os::raw::c_int,
    pub case_when_list: *mut List,
    pub have_else: bool,
    pub else_stmts: *mut List,
}
impl Default for PLpgSQL_stmt_case {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_case_when {
    pub lineno: ::std::os::raw::c_int,
    pub expr: *mut PLpgSQL_expr,
    pub stmts: *mut List,
}
impl Default for PLpgSQL_case_when {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_loop {
    pub cmd_type: PLpgSQL_stmt_type,
    pub lineno: ::std::os::raw::c_int,
    pub stmtid: ::std::os::raw::c_uint,
    pub label: *mut ::std::os::raw::c_char,
    pub body: *mut List,
}
impl Default for PLpgSQL_stmt_loop {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_while {
    pub cmd_type: PLpgSQL_stmt_type,
    pub lineno: ::std::os::raw::c_int,
    pub stmtid: ::std::os::raw::c_uint,
    pub label: *mut ::std::os::raw::c_char,
    pub cond: *mut PLpgSQL_expr,
    pub body: *mut List,
}
impl Default for PLpgSQL_stmt_while {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_fori {
    pub cmd_type: PLpgSQL_stmt_type,
    pub lineno: ::std::os::raw::c_int,
    pub stmtid: ::std::os::raw::c_uint,
    pub label: *mut ::std::os::raw::c_char,
    pub var: *mut PLpgSQL_var,
    pub lower: *mut PLpgSQL_expr,
    pub upper: *mut PLpgSQL_expr,
    pub step: *mut PLpgSQL_expr,
    pub reverse: ::std::os::raw::c_int,
    pub body: *mut List,
}
impl Default for PLpgSQL_stmt_fori {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_forq {
    pub cmd_type: PLpgSQL_stmt_type,
    pub lineno: ::std::os::raw::c_int,
    pub stmtid: ::std::os::raw::c_uint,
    pub label: *mut ::std::os::raw::c_char,
    pub var: *mut PLpgSQL_variable,
    pub body: *mut List,
}
impl Default for PLpgSQL_stmt_forq {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_fors {
    pub cmd_type: PLpgSQL_stmt_type,
    pub lineno: ::std::os::raw::c_int,
    pub stmtid: ::std::os::raw::c_uint,
    pub label: *mut ::std::os::raw::c_char,
    pub var: *mut PLpgSQL_variable,
    pub body: *mut List,
    pub query: *mut PLpgSQL_expr,
}
impl Default for PLpgSQL_stmt_fors {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_forc {
    pub cmd_type: PLpgSQL_stmt_type,
    pub lineno: ::std::os::raw::c_int,
    pub stmtid: ::std::os::raw::c_uint,
    pub label: *mut ::std::os::raw::c_char,
    pub var: *mut PLpgSQL_variable,
    pub body: *mut List,
    pub curvar: ::std::os::raw::c_int,
    pub argquery: *mut PLpgSQL_expr,
}
impl Default for PLpgSQL_stmt_forc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_dynfors {
    pub cmd_type: PLpgSQL_stmt_type,
    pub lineno: ::std::os::raw::c_int,
    pub stmtid: ::std::os::raw::c_uint,
    pub label: *mut ::std::os::raw::c_char,
    pub var: *mut PLpgSQL_variable,
    pub body: *mut List,
    pub query: *mut PLpgSQL_expr,
    pub params: *mut List,
}
impl Default for PLpgSQL_stmt_dynfors {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_foreach_a {
    pub cmd_type: PLpgSQL_stmt_type,
    pub lineno: ::std::os::raw::c_int,
    pub stmtid: ::std::os::raw::c_uint,
    pub label: *mut ::std::os::raw::c_char,
    pub varno: ::std::os::raw::c_int,
    pub slice: ::std::os::raw::c_int,
    pub expr: *mut PLpgSQL_expr,
    pub body: *mut List,
}
impl Default for PLpgSQL_stmt_foreach_a {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_open {
    pub cmd_type: PLpgSQL_stmt_type,
    pub lineno: ::std::os::raw::c_int,
    pub stmtid: ::std::os::raw::c_uint,
    pub curvar: ::std::os::raw::c_int,
    pub cursor_options: ::std::os::raw::c_int,
    pub argquery: *mut PLpgSQL_expr,
    pub query: *mut PLpgSQL_expr,
    pub dynquery: *mut PLpgSQL_expr,
    pub params: *mut List,
}
impl Default for PLpgSQL_stmt_open {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_fetch {
    pub cmd_type: PLpgSQL_stmt_type,
    pub lineno: ::std::os::raw::c_int,
    pub stmtid: ::std::os::raw::c_uint,
    pub target: *mut PLpgSQL_variable,
    pub curvar: ::std::os::raw::c_int,
    pub direction: FetchDirection,
    pub how_many: ::std::os::raw::c_long,
    pub expr: *mut PLpgSQL_expr,
    pub is_move: bool,
    pub returns_multiple_rows: bool,
}
impl Default for PLpgSQL_stmt_fetch {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_close {
    pub cmd_type: PLpgSQL_stmt_type,
    pub lineno: ::std::os::raw::c_int,
    pub stmtid: ::std::os::raw::c_uint,
    pub curvar: ::std::os::raw::c_int,
}
impl Default for PLpgSQL_stmt_close {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_exit {
    pub cmd_type: PLpgSQL_stmt_type,
    pub lineno: ::std::os::raw::c_int,
    pub stmtid: ::std::os::raw::c_uint,
    pub is_exit: bool,
    pub label: *mut ::std::os::raw::c_char,
    pub cond: *mut PLpgSQL_expr,
}
impl Default for PLpgSQL_stmt_exit {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_return {
    pub cmd_type: PLpgSQL_stmt_type,
    pub lineno: ::std::os::raw::c_int,
    pub stmtid: ::std::os::raw::c_uint,
    pub expr: *mut PLpgSQL_expr,
    pub retvarno: ::std::os::raw::c_int,
}
impl Default for PLpgSQL_stmt_return {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_return_next {
    pub cmd_type: PLpgSQL_stmt_type,
    pub lineno: ::std::os::raw::c_int,
    pub stmtid: ::std::os::raw::c_uint,
    pub expr: *mut PLpgSQL_expr,
    pub retvarno: ::std::os::raw::c_int,
}
impl Default for PLpgSQL_stmt_return_next {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_return_query {
    pub cmd_type: PLpgSQL_stmt_type,
    pub lineno: ::std::os::raw::c_int,
    pub stmtid: ::std::os::raw::c_uint,
    pub query: *mut PLpgSQL_expr,
    pub dynquery: *mut PLpgSQL_expr,
    pub params: *mut List,
}
impl Default for PLpgSQL_stmt_return_query {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_raise {
    pub cmd_type: PLpgSQL_stmt_type,
    pub lineno: ::std::os::raw::c_int,
    pub stmtid: ::std::os::raw::c_uint,
    pub elog_level: ::std::os::raw::c_int,
    pub condname: *mut ::std::os::raw::c_char,
    pub message: *mut ::std::os::raw::c_char,
    pub params: *mut List,
    pub options: *mut List,
}
impl Default for PLpgSQL_stmt_raise {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_raise_option {
    pub opt_type: PLpgSQL_raise_option_type,
    pub expr: *mut PLpgSQL_expr,
}
impl Default for PLpgSQL_raise_option {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_assert {
    pub cmd_type: PLpgSQL_stmt_type,
    pub lineno: ::std::os::raw::c_int,
    pub stmtid: ::std::os::raw::c_uint,
    pub cond: *mut PLpgSQL_expr,
    pub message: *mut PLpgSQL_expr,
}
impl Default for PLpgSQL_stmt_assert {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_execsql {
    pub cmd_type: PLpgSQL_stmt_type,
    pub lineno: ::std::os::raw::c_int,
    pub stmtid: ::std::os::raw::c_uint,
    pub sqlstmt: *mut PLpgSQL_expr,
    pub mod_stmt: bool,
    pub mod_stmt_set: bool,
    pub into: bool,
    pub strict: bool,
    pub target: *mut PLpgSQL_variable,
}
impl Default for PLpgSQL_stmt_execsql {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_stmt_dynexecute {
    pub cmd_type: PLpgSQL_stmt_type,
    pub lineno: ::std::os::raw::c_int,
    pub stmtid: ::std::os::raw::c_uint,
    pub query: *mut PLpgSQL_expr,
    pub into: bool,
    pub strict: bool,
    pub target: *mut PLpgSQL_variable,
    pub params: *mut List,
}
impl Default for PLpgSQL_stmt_dynexecute {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_func_hashkey {
    pub funcOid: Oid,
    pub isTrigger: bool,
    pub isEventTrigger: bool,
    pub trigOid: Oid,
    pub inputCollation: Oid,
    pub argtypes: [Oid; 100usize],
}
impl Default for PLpgSQL_func_hashkey {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const PLpgSQL_trigtype_PLPGSQL_DML_TRIGGER: PLpgSQL_trigtype = 0;
pub const PLpgSQL_trigtype_PLPGSQL_EVENT_TRIGGER: PLpgSQL_trigtype = 1;
pub const PLpgSQL_trigtype_PLPGSQL_NOT_TRIGGER: PLpgSQL_trigtype = 2;
pub type PLpgSQL_trigtype = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_function {
    pub fn_signature: *mut ::std::os::raw::c_char,
    pub fn_oid: Oid,
    pub fn_xmin: TransactionId,
    pub fn_tid: ItemPointerData,
    pub fn_is_trigger: PLpgSQL_trigtype,
    pub fn_input_collation: Oid,
    pub fn_hashkey: *mut PLpgSQL_func_hashkey,
    pub fn_cxt: MemoryContext,
    pub fn_rettype: Oid,
    pub fn_rettyplen: ::std::os::raw::c_int,
    pub fn_retbyval: bool,
    pub fn_retistuple: bool,
    pub fn_retisdomain: bool,
    pub fn_retset: bool,
    pub fn_readonly: bool,
    pub fn_prokind: ::std::os::raw::c_char,
    pub fn_nargs: ::std::os::raw::c_int,
    pub fn_argvarnos: [::std::os::raw::c_int; 100usize],
    pub out_param_varno: ::std::os::raw::c_int,
    pub found_varno: ::std::os::raw::c_int,
    pub new_varno: ::std::os::raw::c_int,
    pub old_varno: ::std::os::raw::c_int,
    pub resolve_option: PLpgSQL_resolve_option,
    pub print_strict_params: bool,
    pub extra_warnings: ::std::os::raw::c_int,
    pub extra_errors: ::std::os::raw::c_int,
    pub ndatums: ::std::os::raw::c_int,
    pub datums: *mut *mut PLpgSQL_datum,
    pub copiable_size: Size,
    pub action: *mut PLpgSQL_stmt_block,
    pub nstatements: ::std::os::raw::c_uint,
    pub requires_procedure_resowner: bool,
    pub cur_estate: *mut PLpgSQL_execstate,
    pub use_count: ::std::os::raw::c_ulong,
}
impl Default for PLpgSQL_function {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLpgSQL_execstate {
    pub func: *mut PLpgSQL_function,
    pub trigdata: *mut TriggerData,
    pub evtrigdata: *mut EventTriggerData,
    pub retval: Datum,
    pub retisnull: bool,
    pub rettype: Oid,
    pub fn_rettype: Oid,
    pub retistuple: bool,
    pub retisset: bool,
    pub readonly_func: bool,
    pub atomic: bool,
    pub exitlabel: *mut ::std::os::raw::c_char,
    pub cur_error: *mut ErrorData,
    pub tuple_store: *mut Tuplestorestate,
    pub tuple_store_desc: TupleDesc,
    pub tuple_store_cxt: MemoryContext,
    pub tuple_store_owner: ResourceOwner,
    pub rsi: *mut ReturnSetInfo,
    pub found_varno: ::std::os::raw::c_int,
    pub ndatums: ::std::os::raw::c_int,
    pub datums: *mut *mut PLpgSQL_datum,
    pub datum_context: MemoryContext,
    pub paramLI: ParamListInfo,
    pub simple_eval_estate: *mut EState,
    pub simple_eval_resowner: ResourceOwner,
    pub procedure_resowner: ResourceOwner,
    pub cast_hash: *mut HTAB,
    pub stmt_mcontext: MemoryContext,
    pub stmt_mcontext_parent: MemoryContext,
    pub eval_tuptable: *mut SPITupleTable,
    pub eval_processed: uint64,
    pub eval_econtext: *mut ExprContext,
    pub err_stmt: *mut PLpgSQL_stmt,
    pub err_var: *mut PLpgSQL_variable,
    pub err_text: *const ::std::os::raw::c_char,
    pub plugin_info: *mut ::std::os::raw::c_void,
}
impl Default for PLpgSQL_execstate {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PLpgSQL_plugin {
    pub func_setup: ::std::option::Option<
        unsafe extern "C" fn(estate: *mut PLpgSQL_execstate, func: *mut PLpgSQL_function),
    >,
    pub func_beg: ::std::option::Option<
        unsafe extern "C" fn(estate: *mut PLpgSQL_execstate, func: *mut PLpgSQL_function),
    >,
    pub func_end: ::std::option::Option<
        unsafe extern "C" fn(estate: *mut PLpgSQL_execstate, func: *mut PLpgSQL_function),
    >,
    pub stmt_beg: ::std::option::Option<
        unsafe extern "C" fn(estate: *mut PLpgSQL_execstate, stmt: *mut PLpgSQL_stmt),
    >,
    pub stmt_end: ::std::option::Option<
        unsafe extern "C" fn(estate: *mut PLpgSQL_execstate, stmt: *mut PLpgSQL_stmt),
    >,
    pub error_callback:
        ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void)>,
    pub assign_expr: ::std::option::Option<
        unsafe extern "C" fn(
            estate: *mut PLpgSQL_execstate,
            target: *mut PLpgSQL_datum,
            expr: *mut PLpgSQL_expr,
        ),
    >,
    pub assign_value: ::std::option::Option<
        unsafe extern "C" fn(
            estate: *mut PLpgSQL_execstate,
            target: *mut PLpgSQL_datum,
            value: Datum,
            isNull: bool,
            valtype: Oid,
            valtypmod: int32,
        ),
    >,
    pub eval_datum: ::std::option::Option<
        unsafe extern "C" fn(
            estate: *mut PLpgSQL_execstate,
            datum: *mut PLpgSQL_datum,
            typeId: *mut Oid,
            typetypmod: *mut int32,
            value: *mut Datum,
            isnull: *mut bool,
        ),
    >,
    pub cast_value: ::std::option::Option<
        unsafe extern "C" fn(
            estate: *mut PLpgSQL_execstate,
            value: Datum,
            isnull: *mut bool,
            valtype: Oid,
            valtypmod: int32,
            reqtype: Oid,
            reqtypmod: int32,
        ) -> Datum,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLword {
    pub ident: *mut ::std::os::raw::c_char,
    pub quoted: bool,
}
impl Default for PLword {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLcword {
    pub idents: *mut List,
}
impl Default for PLcword {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PLwdatum {
    pub datum: *mut PLpgSQL_datum,
    pub ident: *mut ::std::os::raw::c_char,
    pub quoted: bool,
    pub idents: *mut List,
}
impl Default for PLwdatum {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const IdentifierLookup_IDENTIFIER_LOOKUP_NORMAL: IdentifierLookup = 0;
pub const IdentifierLookup_IDENTIFIER_LOOKUP_DECLARE: IdentifierLookup = 1;
pub const IdentifierLookup_IDENTIFIER_LOOKUP_EXPR: IdentifierLookup = 2;
#[doc = " Global variable declarations"]
pub type IdentifierLookup = ::std::os::raw::c_uint;
pub const DebugLogicalRepStreamingMode_DEBUG_LOGICAL_REP_STREAMING_BUFFERED:
    DebugLogicalRepStreamingMode = 0;
pub const DebugLogicalRepStreamingMode_DEBUG_LOGICAL_REP_STREAMING_IMMEDIATE:
    DebugLogicalRepStreamingMode = 1;
pub type DebugLogicalRepStreamingMode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReorderBufferTupleBuf {
    pub node: slist_node,
    pub tuple: HeapTupleData,
    pub alloc_tuple_size: Size,
}
impl Default for ReorderBufferTupleBuf {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_INSERT: ReorderBufferChangeType = 0;
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_UPDATE: ReorderBufferChangeType = 1;
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_DELETE: ReorderBufferChangeType = 2;
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_MESSAGE: ReorderBufferChangeType = 3;
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_INVALIDATION: ReorderBufferChangeType = 4;
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT: ReorderBufferChangeType =
    5;
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID:
    ReorderBufferChangeType = 6;
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID: ReorderBufferChangeType =
    7;
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_INTERNAL_SPEC_INSERT:
    ReorderBufferChangeType = 8;
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_INTERNAL_SPEC_CONFIRM:
    ReorderBufferChangeType = 9;
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_INTERNAL_SPEC_ABORT:
    ReorderBufferChangeType = 10;
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_TRUNCATE: ReorderBufferChangeType = 11;
pub type ReorderBufferChangeType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ReorderBufferChange {
    pub lsn: XLogRecPtr,
    pub action: ReorderBufferChangeType,
    pub txn: *mut ReorderBufferTXN,
    pub origin_id: RepOriginId,
    pub data: ReorderBufferChange__bindgen_ty_1,
    pub node: dlist_node,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ReorderBufferChange__bindgen_ty_1 {
    pub tp: ReorderBufferChange__bindgen_ty_1__bindgen_ty_1,
    pub truncate: ReorderBufferChange__bindgen_ty_1__bindgen_ty_2,
    pub msg: ReorderBufferChange__bindgen_ty_1__bindgen_ty_3,
    pub snapshot: Snapshot,
    pub command_id: CommandId,
    pub tuplecid: ReorderBufferChange__bindgen_ty_1__bindgen_ty_4,
    pub inval: ReorderBufferChange__bindgen_ty_1__bindgen_ty_5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReorderBufferChange__bindgen_ty_1__bindgen_ty_1 {
    pub rlocator: RelFileLocator,
    pub clear_toast_afterwards: bool,
    pub oldtuple: *mut ReorderBufferTupleBuf,
    pub newtuple: *mut ReorderBufferTupleBuf,
}
impl Default for ReorderBufferChange__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReorderBufferChange__bindgen_ty_1__bindgen_ty_2 {
    pub nrelids: Size,
    pub cascade: bool,
    pub restart_seqs: bool,
    pub relids: *mut Oid,
}
impl Default for ReorderBufferChange__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReorderBufferChange__bindgen_ty_1__bindgen_ty_3 {
    pub prefix: *mut ::std::os::raw::c_char,
    pub message_size: Size,
    pub message: *mut ::std::os::raw::c_char,
}
impl Default for ReorderBufferChange__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReorderBufferChange__bindgen_ty_1__bindgen_ty_4 {
    pub locator: RelFileLocator,
    pub tid: ItemPointerData,
    pub cmin: CommandId,
    pub cmax: CommandId,
    pub combocid: CommandId,
}
impl Default for ReorderBufferChange__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReorderBufferChange__bindgen_ty_1__bindgen_ty_5 {
    pub ninvalidations: uint32,
    pub invalidations: *mut SharedInvalidationMessage,
}
impl Default for ReorderBufferChange__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ReorderBufferChange__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ReorderBufferChange {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ReorderBufferTXN {
    pub txn_flags: bits32,
    pub xid: TransactionId,
    pub toplevel_xid: TransactionId,
    pub gid: *mut ::std::os::raw::c_char,
    pub first_lsn: XLogRecPtr,
    pub final_lsn: XLogRecPtr,
    pub end_lsn: XLogRecPtr,
    pub toptxn: *mut ReorderBufferTXN,
    pub restart_decoding_lsn: XLogRecPtr,
    pub origin_id: RepOriginId,
    pub origin_lsn: XLogRecPtr,
    pub xact_time: ReorderBufferTXN__bindgen_ty_1,
    pub base_snapshot: Snapshot,
    pub base_snapshot_lsn: XLogRecPtr,
    pub base_snapshot_node: dlist_node,
    pub snapshot_now: Snapshot,
    pub command_id: CommandId,
    pub nentries: uint64,
    pub nentries_mem: uint64,
    pub changes: dlist_head,
    pub tuplecids: dlist_head,
    pub ntuplecids: uint64,
    pub tuplecid_hash: *mut HTAB,
    pub toast_hash: *mut HTAB,
    pub subtxns: dlist_head,
    pub nsubtxns: uint32,
    pub ninvalidations: uint32,
    pub invalidations: *mut SharedInvalidationMessage,
    pub node: dlist_node,
    pub catchange_node: dlist_node,
    pub size: Size,
    pub total_size: Size,
    pub concurrent_abort: bool,
    pub output_plugin_private: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ReorderBufferTXN__bindgen_ty_1 {
    pub commit_time: TimestampTz,
    pub prepare_time: TimestampTz,
    pub abort_time: TimestampTz,
}
impl Default for ReorderBufferTXN__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ReorderBufferTXN {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ReorderBufferApplyChangeCB = ::std::option::Option<
    unsafe extern "C" fn(
        rb: *mut ReorderBuffer,
        txn: *mut ReorderBufferTXN,
        relation: Relation,
        change: *mut ReorderBufferChange,
    ),
>;
pub type ReorderBufferApplyTruncateCB = ::std::option::Option<
    unsafe extern "C" fn(
        rb: *mut ReorderBuffer,
        txn: *mut ReorderBufferTXN,
        nrelations: ::std::os::raw::c_int,
        relations: *mut Relation,
        change: *mut ReorderBufferChange,
    ),
>;
pub type ReorderBufferBeginCB =
    ::std::option::Option<unsafe extern "C" fn(rb: *mut ReorderBuffer, txn: *mut ReorderBufferTXN)>;
pub type ReorderBufferCommitCB = ::std::option::Option<
    unsafe extern "C" fn(
        rb: *mut ReorderBuffer,
        txn: *mut ReorderBufferTXN,
        commit_lsn: XLogRecPtr,
    ),
>;
pub type ReorderBufferMessageCB = ::std::option::Option<
    unsafe extern "C" fn(
        rb: *mut ReorderBuffer,
        txn: *mut ReorderBufferTXN,
        message_lsn: XLogRecPtr,
        transactional: bool,
        prefix: *const ::std::os::raw::c_char,
        sz: Size,
        message: *const ::std::os::raw::c_char,
    ),
>;
pub type ReorderBufferBeginPrepareCB =
    ::std::option::Option<unsafe extern "C" fn(rb: *mut ReorderBuffer, txn: *mut ReorderBufferTXN)>;
pub type ReorderBufferPrepareCB = ::std::option::Option<
    unsafe extern "C" fn(
        rb: *mut ReorderBuffer,
        txn: *mut ReorderBufferTXN,
        prepare_lsn: XLogRecPtr,
    ),
>;
pub type ReorderBufferCommitPreparedCB = ::std::option::Option<
    unsafe extern "C" fn(
        rb: *mut ReorderBuffer,
        txn: *mut ReorderBufferTXN,
        commit_lsn: XLogRecPtr,
    ),
>;
pub type ReorderBufferRollbackPreparedCB = ::std::option::Option<
    unsafe extern "C" fn(
        rb: *mut ReorderBuffer,
        txn: *mut ReorderBufferTXN,
        prepare_end_lsn: XLogRecPtr,
        prepare_time: TimestampTz,
    ),
>;
pub type ReorderBufferStreamStartCB = ::std::option::Option<
    unsafe extern "C" fn(rb: *mut ReorderBuffer, txn: *mut ReorderBufferTXN, first_lsn: XLogRecPtr),
>;
pub type ReorderBufferStreamStopCB = ::std::option::Option<
    unsafe extern "C" fn(rb: *mut ReorderBuffer, txn: *mut ReorderBufferTXN, last_lsn: XLogRecPtr),
>;
pub type ReorderBufferStreamAbortCB = ::std::option::Option<
    unsafe extern "C" fn(rb: *mut ReorderBuffer, txn: *mut ReorderBufferTXN, abort_lsn: XLogRecPtr),
>;
pub type ReorderBufferStreamPrepareCB = ::std::option::Option<
    unsafe extern "C" fn(
        rb: *mut ReorderBuffer,
        txn: *mut ReorderBufferTXN,
        prepare_lsn: XLogRecPtr,
    ),
>;
pub type ReorderBufferStreamCommitCB = ::std::option::Option<
    unsafe extern "C" fn(
        rb: *mut ReorderBuffer,
        txn: *mut ReorderBufferTXN,
        commit_lsn: XLogRecPtr,
    ),
>;
pub type ReorderBufferStreamChangeCB = ::std::option::Option<
    unsafe extern "C" fn(
        rb: *mut ReorderBuffer,
        txn: *mut ReorderBufferTXN,
        relation: Relation,
        change: *mut ReorderBufferChange,
    ),
>;
pub type ReorderBufferStreamMessageCB = ::std::option::Option<
    unsafe extern "C" fn(
        rb: *mut ReorderBuffer,
        txn: *mut ReorderBufferTXN,
        message_lsn: XLogRecPtr,
        transactional: bool,
        prefix: *const ::std::os::raw::c_char,
        sz: Size,
        message: *const ::std::os::raw::c_char,
    ),
>;
pub type ReorderBufferStreamTruncateCB = ::std::option::Option<
    unsafe extern "C" fn(
        rb: *mut ReorderBuffer,
        txn: *mut ReorderBufferTXN,
        nrelations: ::std::os::raw::c_int,
        relations: *mut Relation,
        change: *mut ReorderBufferChange,
    ),
>;
pub type ReorderBufferUpdateProgressTxnCB = ::std::option::Option<
    unsafe extern "C" fn(rb: *mut ReorderBuffer, txn: *mut ReorderBufferTXN, lsn: XLogRecPtr),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReorderBuffer {
    pub by_txn: *mut HTAB,
    pub toplevel_by_lsn: dlist_head,
    pub txns_by_base_snapshot_lsn: dlist_head,
    pub catchange_txns: dclist_head,
    pub by_txn_last_xid: TransactionId,
    pub by_txn_last_txn: *mut ReorderBufferTXN,
    pub begin: ReorderBufferBeginCB,
    pub apply_change: ReorderBufferApplyChangeCB,
    pub apply_truncate: ReorderBufferApplyTruncateCB,
    pub commit: ReorderBufferCommitCB,
    pub message: ReorderBufferMessageCB,
    pub begin_prepare: ReorderBufferBeginCB,
    pub prepare: ReorderBufferPrepareCB,
    pub commit_prepared: ReorderBufferCommitPreparedCB,
    pub rollback_prepared: ReorderBufferRollbackPreparedCB,
    pub stream_start: ReorderBufferStreamStartCB,
    pub stream_stop: ReorderBufferStreamStopCB,
    pub stream_abort: ReorderBufferStreamAbortCB,
    pub stream_prepare: ReorderBufferStreamPrepareCB,
    pub stream_commit: ReorderBufferStreamCommitCB,
    pub stream_change: ReorderBufferStreamChangeCB,
    pub stream_message: ReorderBufferStreamMessageCB,
    pub stream_truncate: ReorderBufferStreamTruncateCB,
    pub update_progress_txn: ReorderBufferUpdateProgressTxnCB,
    pub private_data: *mut ::std::os::raw::c_void,
    pub output_rewrites: bool,
    pub context: MemoryContext,
    pub change_context: MemoryContext,
    pub txn_context: MemoryContext,
    pub tup_context: MemoryContext,
    pub current_restart_decoding_lsn: XLogRecPtr,
    pub outbuf: *mut ::std::os::raw::c_char,
    pub outbufsize: Size,
    pub size: Size,
    pub spillTxns: int64,
    pub spillCount: int64,
    pub spillBytes: int64,
    pub streamTxns: int64,
    pub streamCount: int64,
    pub streamBytes: int64,
    pub totalTxns: int64,
    pub totalBytes: int64,
}
impl Default for ReorderBuffer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const OutputPluginOutputType_OUTPUT_PLUGIN_BINARY_OUTPUT: OutputPluginOutputType = 0;
pub const OutputPluginOutputType_OUTPUT_PLUGIN_TEXTUAL_OUTPUT: OutputPluginOutputType = 1;
pub type OutputPluginOutputType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OutputPluginOptions {
    pub output_type: OutputPluginOutputType,
    pub receive_rewrites: bool,
}
impl Default for OutputPluginOptions {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type LogicalOutputPluginInit =
    ::std::option::Option<unsafe extern "C" fn(cb: *mut OutputPluginCallbacks)>;
pub type LogicalDecodeStartupCB = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut LogicalDecodingContext,
        options: *mut OutputPluginOptions,
        is_init: bool,
    ),
>;
pub type LogicalDecodeBeginCB = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut LogicalDecodingContext, txn: *mut ReorderBufferTXN),
>;
pub type LogicalDecodeChangeCB = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut LogicalDecodingContext,
        txn: *mut ReorderBufferTXN,
        relation: Relation,
        change: *mut ReorderBufferChange,
    ),
>;
pub type LogicalDecodeTruncateCB = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut LogicalDecodingContext,
        txn: *mut ReorderBufferTXN,
        nrelations: ::std::os::raw::c_int,
        relations: *mut Relation,
        change: *mut ReorderBufferChange,
    ),
>;
pub type LogicalDecodeCommitCB = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut LogicalDecodingContext,
        txn: *mut ReorderBufferTXN,
        commit_lsn: XLogRecPtr,
    ),
>;
pub type LogicalDecodeMessageCB = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut LogicalDecodingContext,
        txn: *mut ReorderBufferTXN,
        message_lsn: XLogRecPtr,
        transactional: bool,
        prefix: *const ::std::os::raw::c_char,
        message_size: Size,
        message: *const ::std::os::raw::c_char,
    ),
>;
pub type LogicalDecodeFilterByOriginCB = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut LogicalDecodingContext, origin_id: RepOriginId) -> bool,
>;
pub type LogicalDecodeShutdownCB =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut LogicalDecodingContext)>;
pub type LogicalDecodeFilterPrepareCB = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut LogicalDecodingContext,
        xid: TransactionId,
        gid: *const ::std::os::raw::c_char,
    ) -> bool,
>;
pub type LogicalDecodeBeginPrepareCB = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut LogicalDecodingContext, txn: *mut ReorderBufferTXN),
>;
pub type LogicalDecodePrepareCB = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut LogicalDecodingContext,
        txn: *mut ReorderBufferTXN,
        prepare_lsn: XLogRecPtr,
    ),
>;
pub type LogicalDecodeCommitPreparedCB = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut LogicalDecodingContext,
        txn: *mut ReorderBufferTXN,
        commit_lsn: XLogRecPtr,
    ),
>;
pub type LogicalDecodeRollbackPreparedCB = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut LogicalDecodingContext,
        txn: *mut ReorderBufferTXN,
        prepare_end_lsn: XLogRecPtr,
        prepare_time: TimestampTz,
    ),
>;
pub type LogicalDecodeStreamStartCB = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut LogicalDecodingContext, txn: *mut ReorderBufferTXN),
>;
pub type LogicalDecodeStreamStopCB = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut LogicalDecodingContext, txn: *mut ReorderBufferTXN),
>;
pub type LogicalDecodeStreamAbortCB = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut LogicalDecodingContext,
        txn: *mut ReorderBufferTXN,
        abort_lsn: XLogRecPtr,
    ),
>;
pub type LogicalDecodeStreamPrepareCB = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut LogicalDecodingContext,
        txn: *mut ReorderBufferTXN,
        prepare_lsn: XLogRecPtr,
    ),
>;
pub type LogicalDecodeStreamCommitCB = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut LogicalDecodingContext,
        txn: *mut ReorderBufferTXN,
        commit_lsn: XLogRecPtr,
    ),
>;
pub type LogicalDecodeStreamChangeCB = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut LogicalDecodingContext,
        txn: *mut ReorderBufferTXN,
        relation: Relation,
        change: *mut ReorderBufferChange,
    ),
>;
pub type LogicalDecodeStreamMessageCB = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut LogicalDecodingContext,
        txn: *mut ReorderBufferTXN,
        message_lsn: XLogRecPtr,
        transactional: bool,
        prefix: *const ::std::os::raw::c_char,
        message_size: Size,
        message: *const ::std::os::raw::c_char,
    ),
>;
pub type LogicalDecodeStreamTruncateCB = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut LogicalDecodingContext,
        txn: *mut ReorderBufferTXN,
        nrelations: ::std::os::raw::c_int,
        relations: *mut Relation,
        change: *mut ReorderBufferChange,
    ),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct OutputPluginCallbacks {
    pub startup_cb: LogicalDecodeStartupCB,
    pub begin_cb: LogicalDecodeBeginCB,
    pub change_cb: LogicalDecodeChangeCB,
    pub truncate_cb: LogicalDecodeTruncateCB,
    pub commit_cb: LogicalDecodeCommitCB,
    pub message_cb: LogicalDecodeMessageCB,
    pub filter_by_origin_cb: LogicalDecodeFilterByOriginCB,
    pub shutdown_cb: LogicalDecodeShutdownCB,
    pub filter_prepare_cb: LogicalDecodeFilterPrepareCB,
    pub begin_prepare_cb: LogicalDecodeBeginPrepareCB,
    pub prepare_cb: LogicalDecodePrepareCB,
    pub commit_prepared_cb: LogicalDecodeCommitPreparedCB,
    pub rollback_prepared_cb: LogicalDecodeRollbackPreparedCB,
    pub stream_start_cb: LogicalDecodeStreamStartCB,
    pub stream_stop_cb: LogicalDecodeStreamStopCB,
    pub stream_abort_cb: LogicalDecodeStreamAbortCB,
    pub stream_prepare_cb: LogicalDecodeStreamPrepareCB,
    pub stream_commit_cb: LogicalDecodeStreamCommitCB,
    pub stream_change_cb: LogicalDecodeStreamChangeCB,
    pub stream_message_cb: LogicalDecodeStreamMessageCB,
    pub stream_truncate_cb: LogicalDecodeStreamTruncateCB,
}
pub const LogicalRepMsgType_LOGICAL_REP_MSG_BEGIN: LogicalRepMsgType = 66;
pub const LogicalRepMsgType_LOGICAL_REP_MSG_COMMIT: LogicalRepMsgType = 67;
pub const LogicalRepMsgType_LOGICAL_REP_MSG_ORIGIN: LogicalRepMsgType = 79;
pub const LogicalRepMsgType_LOGICAL_REP_MSG_INSERT: LogicalRepMsgType = 73;
pub const LogicalRepMsgType_LOGICAL_REP_MSG_UPDATE: LogicalRepMsgType = 85;
pub const LogicalRepMsgType_LOGICAL_REP_MSG_DELETE: LogicalRepMsgType = 68;
pub const LogicalRepMsgType_LOGICAL_REP_MSG_TRUNCATE: LogicalRepMsgType = 84;
pub const LogicalRepMsgType_LOGICAL_REP_MSG_RELATION: LogicalRepMsgType = 82;
pub const LogicalRepMsgType_LOGICAL_REP_MSG_TYPE: LogicalRepMsgType = 89;
pub const LogicalRepMsgType_LOGICAL_REP_MSG_MESSAGE: LogicalRepMsgType = 77;
pub const LogicalRepMsgType_LOGICAL_REP_MSG_BEGIN_PREPARE: LogicalRepMsgType = 98;
pub const LogicalRepMsgType_LOGICAL_REP_MSG_PREPARE: LogicalRepMsgType = 80;
pub const LogicalRepMsgType_LOGICAL_REP_MSG_COMMIT_PREPARED: LogicalRepMsgType = 75;
pub const LogicalRepMsgType_LOGICAL_REP_MSG_ROLLBACK_PREPARED: LogicalRepMsgType = 114;
pub const LogicalRepMsgType_LOGICAL_REP_MSG_STREAM_START: LogicalRepMsgType = 83;
pub const LogicalRepMsgType_LOGICAL_REP_MSG_STREAM_STOP: LogicalRepMsgType = 69;
pub const LogicalRepMsgType_LOGICAL_REP_MSG_STREAM_COMMIT: LogicalRepMsgType = 99;
pub const LogicalRepMsgType_LOGICAL_REP_MSG_STREAM_ABORT: LogicalRepMsgType = 65;
pub const LogicalRepMsgType_LOGICAL_REP_MSG_STREAM_PREPARE: LogicalRepMsgType = 112;
pub type LogicalRepMsgType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LogicalRepTupleData {
    pub colvalues: *mut StringInfoData,
    pub colstatus: *mut ::std::os::raw::c_char,
    pub ncols: ::std::os::raw::c_int,
}
impl Default for LogicalRepTupleData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type LogicalRepRelId = uint32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LogicalRepRelation {
    pub remoteid: LogicalRepRelId,
    pub nspname: *mut ::std::os::raw::c_char,
    pub relname: *mut ::std::os::raw::c_char,
    pub natts: ::std::os::raw::c_int,
    pub attnames: *mut *mut ::std::os::raw::c_char,
    pub atttyps: *mut Oid,
    pub replident: ::std::os::raw::c_char,
    pub relkind: ::std::os::raw::c_char,
    pub attkeys: *mut Bitmapset,
}
impl Default for LogicalRepRelation {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LogicalRepTyp {
    pub remoteid: Oid,
    pub nspname: *mut ::std::os::raw::c_char,
    pub typname: *mut ::std::os::raw::c_char,
}
impl Default for LogicalRepTyp {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LogicalRepBeginData {
    pub final_lsn: XLogRecPtr,
    pub committime: TimestampTz,
    pub xid: TransactionId,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LogicalRepCommitData {
    pub commit_lsn: XLogRecPtr,
    pub end_lsn: XLogRecPtr,
    pub committime: TimestampTz,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LogicalRepPreparedTxnData {
    pub prepare_lsn: XLogRecPtr,
    pub end_lsn: XLogRecPtr,
    pub prepare_time: TimestampTz,
    pub xid: TransactionId,
    pub gid: [::std::os::raw::c_char; 200usize],
}
impl Default for LogicalRepPreparedTxnData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LogicalRepCommitPreparedTxnData {
    pub commit_lsn: XLogRecPtr,
    pub end_lsn: XLogRecPtr,
    pub commit_time: TimestampTz,
    pub xid: TransactionId,
    pub gid: [::std::os::raw::c_char; 200usize],
}
impl Default for LogicalRepCommitPreparedTxnData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LogicalRepRollbackPreparedTxnData {
    pub prepare_end_lsn: XLogRecPtr,
    pub rollback_end_lsn: XLogRecPtr,
    pub prepare_time: TimestampTz,
    pub rollback_time: TimestampTz,
    pub xid: TransactionId,
    pub gid: [::std::os::raw::c_char; 200usize],
}
impl Default for LogicalRepRollbackPreparedTxnData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LogicalRepStreamAbortData {
    pub xid: TransactionId,
    pub subxid: TransactionId,
    pub abort_lsn: XLogRecPtr,
    pub abort_time: TimestampTz,
}
pub const CRSSnapshotAction_CRS_EXPORT_SNAPSHOT: CRSSnapshotAction = 0;
pub const CRSSnapshotAction_CRS_NOEXPORT_SNAPSHOT: CRSSnapshotAction = 1;
pub const CRSSnapshotAction_CRS_USE_SNAPSHOT: CRSSnapshotAction = 2;
pub type CRSSnapshotAction = ::std::os::raw::c_uint;
pub const WalRcvState_WALRCV_STOPPED: WalRcvState = 0;
pub const WalRcvState_WALRCV_STARTING: WalRcvState = 1;
pub const WalRcvState_WALRCV_STREAMING: WalRcvState = 2;
pub const WalRcvState_WALRCV_WAITING: WalRcvState = 3;
pub const WalRcvState_WALRCV_RESTARTING: WalRcvState = 4;
pub const WalRcvState_WALRCV_STOPPING: WalRcvState = 5;
pub type WalRcvState = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WalRcvData {
    pub pid: pid_t,
    pub walRcvState: WalRcvState,
    pub walRcvStoppedCV: ConditionVariable,
    pub startTime: pg_time_t,
    pub receiveStart: XLogRecPtr,
    pub receiveStartTLI: TimeLineID,
    pub flushedUpto: XLogRecPtr,
    pub receivedTLI: TimeLineID,
    pub latestChunkStart: XLogRecPtr,
    pub lastMsgSendTime: TimestampTz,
    pub lastMsgReceiptTime: TimestampTz,
    pub latestWalEnd: XLogRecPtr,
    pub latestWalEndTime: TimestampTz,
    pub conninfo: [::std::os::raw::c_char; 1024usize],
    pub sender_host: [::std::os::raw::c_char; 1025usize],
    pub sender_port: ::std::os::raw::c_int,
    pub slotname: [::std::os::raw::c_char; 64usize],
    pub is_temp_slot: bool,
    pub ready_to_display: bool,
    pub latch: *mut Latch,
    pub mutex: slock_t,
    pub writtenUpto: pg_atomic_uint64,
    pub force_reply: sig_atomic_t,
}
impl Default for WalRcvData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WalRcvStreamOptions {
    pub logical: bool,
    pub slotname: *mut ::std::os::raw::c_char,
    pub startpoint: XLogRecPtr,
    pub proto: WalRcvStreamOptions__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WalRcvStreamOptions__bindgen_ty_1 {
    pub physical: WalRcvStreamOptions__bindgen_ty_1__bindgen_ty_1,
    pub logical: WalRcvStreamOptions__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WalRcvStreamOptions__bindgen_ty_1__bindgen_ty_1 {
    pub startpointTLI: TimeLineID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WalRcvStreamOptions__bindgen_ty_1__bindgen_ty_2 {
    pub proto_version: uint32,
    pub publication_names: *mut List,
    pub binary: bool,
    pub streaming_str: *mut ::std::os::raw::c_char,
    pub twophase: bool,
    pub origin: *mut ::std::os::raw::c_char,
}
impl Default for WalRcvStreamOptions__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for WalRcvStreamOptions__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for WalRcvStreamOptions {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WalReceiverConn {
    _unused: [u8; 0],
}
pub const WalRcvExecStatus_WALRCV_ERROR: WalRcvExecStatus = 0;
pub const WalRcvExecStatus_WALRCV_OK_COMMAND: WalRcvExecStatus = 1;
pub const WalRcvExecStatus_WALRCV_OK_TUPLES: WalRcvExecStatus = 2;
pub const WalRcvExecStatus_WALRCV_OK_COPY_IN: WalRcvExecStatus = 3;
pub const WalRcvExecStatus_WALRCV_OK_COPY_OUT: WalRcvExecStatus = 4;
pub const WalRcvExecStatus_WALRCV_OK_COPY_BOTH: WalRcvExecStatus = 5;
pub type WalRcvExecStatus = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WalRcvExecResult {
    pub status: WalRcvExecStatus,
    pub sqlstate: ::std::os::raw::c_int,
    pub err: *mut ::std::os::raw::c_char,
    pub tuplestore: *mut Tuplestorestate,
    pub tupledesc: TupleDesc,
}
impl Default for WalRcvExecResult {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type walrcv_connect_fn = ::std::option::Option<
    unsafe extern "C" fn(
        conninfo: *const ::std::os::raw::c_char,
        logical: bool,
        must_use_password: bool,
        appname: *const ::std::os::raw::c_char,
        err: *mut *mut ::std::os::raw::c_char,
    ) -> *mut WalReceiverConn,
>;
pub type walrcv_check_conninfo_fn = ::std::option::Option<
    unsafe extern "C" fn(conninfo: *const ::std::os::raw::c_char, must_use_password: bool),
>;
pub type walrcv_get_conninfo_fn = ::std::option::Option<
    unsafe extern "C" fn(conn: *mut WalReceiverConn) -> *mut ::std::os::raw::c_char,
>;
pub type walrcv_get_senderinfo_fn = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut WalReceiverConn,
        sender_host: *mut *mut ::std::os::raw::c_char,
        sender_port: *mut ::std::os::raw::c_int,
    ),
>;
pub type walrcv_identify_system_fn = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut WalReceiverConn,
        primary_tli: *mut TimeLineID,
    ) -> *mut ::std::os::raw::c_char,
>;
pub type walrcv_server_version_fn = ::std::option::Option<
    unsafe extern "C" fn(conn: *mut WalReceiverConn) -> ::std::os::raw::c_int,
>;
pub type walrcv_readtimelinehistoryfile_fn = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut WalReceiverConn,
        tli: TimeLineID,
        filename: *mut *mut ::std::os::raw::c_char,
        content: *mut *mut ::std::os::raw::c_char,
        size: *mut ::std::os::raw::c_int,
    ),
>;
pub type walrcv_startstreaming_fn = ::std::option::Option<
    unsafe extern "C" fn(conn: *mut WalReceiverConn, options: *const WalRcvStreamOptions) -> bool,
>;
pub type walrcv_endstreaming_fn = ::std::option::Option<
    unsafe extern "C" fn(conn: *mut WalReceiverConn, next_tli: *mut TimeLineID),
>;
pub type walrcv_receive_fn = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut WalReceiverConn,
        buffer: *mut *mut ::std::os::raw::c_char,
        wait_fd: *mut pgsocket,
    ) -> ::std::os::raw::c_int,
>;
pub type walrcv_send_fn = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut WalReceiverConn,
        buffer: *const ::std::os::raw::c_char,
        nbytes: ::std::os::raw::c_int,
    ),
>;
pub type walrcv_create_slot_fn = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut WalReceiverConn,
        slotname: *const ::std::os::raw::c_char,
        temporary: bool,
        two_phase: bool,
        snapshot_action: CRSSnapshotAction,
        lsn: *mut XLogRecPtr,
    ) -> *mut ::std::os::raw::c_char,
>;
pub type walrcv_get_backend_pid_fn =
    ::std::option::Option<unsafe extern "C" fn(conn: *mut WalReceiverConn) -> pid_t>;
pub type walrcv_exec_fn = ::std::option::Option<
    unsafe extern "C" fn(
        conn: *mut WalReceiverConn,
        query: *const ::std::os::raw::c_char,
        nRetTypes: ::std::os::raw::c_int,
        retTypes: *const Oid,
    ) -> *mut WalRcvExecResult,
>;
pub type walrcv_disconnect_fn =
    ::std::option::Option<unsafe extern "C" fn(conn: *mut WalReceiverConn)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WalReceiverFunctionsType {
    pub walrcv_connect: walrcv_connect_fn,
    pub walrcv_check_conninfo: walrcv_check_conninfo_fn,
    pub walrcv_get_conninfo: walrcv_get_conninfo_fn,
    pub walrcv_get_senderinfo: walrcv_get_senderinfo_fn,
    pub walrcv_identify_system: walrcv_identify_system_fn,
    pub walrcv_server_version: walrcv_server_version_fn,
    pub walrcv_readtimelinehistoryfile: walrcv_readtimelinehistoryfile_fn,
    pub walrcv_startstreaming: walrcv_startstreaming_fn,
    pub walrcv_endstreaming: walrcv_endstreaming_fn,
    pub walrcv_receive: walrcv_receive_fn,
    pub walrcv_send: walrcv_send_fn,
    pub walrcv_create_slot: walrcv_create_slot_fn,
    pub walrcv_get_backend_pid: walrcv_get_backend_pid_fn,
    pub walrcv_exec: walrcv_exec_fn,
    pub walrcv_disconnect: walrcv_disconnect_fn,
}
pub const ReplicationSlotPersistency_RS_PERSISTENT: ReplicationSlotPersistency = 0;
pub const ReplicationSlotPersistency_RS_EPHEMERAL: ReplicationSlotPersistency = 1;
pub const ReplicationSlotPersistency_RS_TEMPORARY: ReplicationSlotPersistency = 2;
pub type ReplicationSlotPersistency = ::std::os::raw::c_uint;
pub const ReplicationSlotInvalidationCause_RS_INVAL_NONE: ReplicationSlotInvalidationCause = 0;
pub const ReplicationSlotInvalidationCause_RS_INVAL_WAL_REMOVED: ReplicationSlotInvalidationCause =
    1;
pub const ReplicationSlotInvalidationCause_RS_INVAL_HORIZON: ReplicationSlotInvalidationCause = 2;
pub const ReplicationSlotInvalidationCause_RS_INVAL_WAL_LEVEL: ReplicationSlotInvalidationCause = 3;
pub type ReplicationSlotInvalidationCause = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReplicationSlotPersistentData {
    pub name: NameData,
    pub database: Oid,
    pub persistency: ReplicationSlotPersistency,
    pub xmin: TransactionId,
    pub catalog_xmin: TransactionId,
    pub restart_lsn: XLogRecPtr,
    pub invalidated: ReplicationSlotInvalidationCause,
    pub confirmed_flush: XLogRecPtr,
    pub two_phase_at: XLogRecPtr,
    pub two_phase: bool,
    pub plugin: NameData,
}
impl Default for ReplicationSlotPersistentData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReplicationSlot {
    pub mutex: slock_t,
    pub in_use: bool,
    pub active_pid: pid_t,
    pub just_dirtied: bool,
    pub dirty: bool,
    pub effective_xmin: TransactionId,
    pub effective_catalog_xmin: TransactionId,
    pub data: ReplicationSlotPersistentData,
    pub io_in_progress_lock: LWLock,
    pub active_cv: ConditionVariable,
    pub candidate_catalog_xmin: TransactionId,
    pub candidate_xmin_lsn: XLogRecPtr,
    pub candidate_restart_valid: XLogRecPtr,
    pub candidate_restart_lsn: XLogRecPtr,
}
impl Default for ReplicationSlot {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReplicationSlotCtlData {
    pub replication_slots: [ReplicationSlot; 1usize],
}
impl Default for ReplicationSlotCtlData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type LogicalOutputPluginWriterWrite = ::std::option::Option<
    unsafe extern "C" fn(
        lr: *mut LogicalDecodingContext,
        Ptr: XLogRecPtr,
        xid: TransactionId,
        last_write: bool,
    ),
>;
pub type LogicalOutputPluginWriterPrepareWrite = LogicalOutputPluginWriterWrite;
pub type LogicalOutputPluginWriterUpdateProgress = ::std::option::Option<
    unsafe extern "C" fn(
        lr: *mut LogicalDecodingContext,
        Ptr: XLogRecPtr,
        xid: TransactionId,
        skipped_xact: bool,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LogicalDecodingContext {
    pub context: MemoryContext,
    pub slot: *mut ReplicationSlot,
    pub reader: *mut XLogReaderState,
    pub reorder: *mut ReorderBuffer,
    pub snapshot_builder: *mut SnapBuild,
    pub fast_forward: bool,
    pub callbacks: OutputPluginCallbacks,
    pub options: OutputPluginOptions,
    pub output_plugin_options: *mut List,
    pub prepare_write: LogicalOutputPluginWriterPrepareWrite,
    pub write: LogicalOutputPluginWriterWrite,
    pub update_progress: LogicalOutputPluginWriterUpdateProgress,
    pub out: StringInfo,
    pub output_plugin_private: *mut ::std::os::raw::c_void,
    pub output_writer_private: *mut ::std::os::raw::c_void,
    pub streaming: bool,
    pub twophase: bool,
    pub twophase_opt_given: bool,
    pub accept_writes: bool,
    pub prepared_write: bool,
    pub write_location: XLogRecPtr,
    pub write_xid: TransactionId,
    pub end_xact: bool,
}
impl Default for LogicalDecodingContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RowSecurityPolicy {
    pub policy_name: *mut ::std::os::raw::c_char,
    pub polcmd: ::std::os::raw::c_char,
    pub roles: *mut ArrayType,
    pub permissive: bool,
    pub qual: *mut Expr,
    pub with_check_qual: *mut Expr,
    pub hassublinks: bool,
}
impl Default for RowSecurityPolicy {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RowSecurityDesc {
    pub rscxt: MemoryContext,
    pub policies: *mut List,
}
impl Default for RowSecurityDesc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type row_security_policy_hook_type =
    ::std::option::Option<unsafe extern "C" fn(cmdtype: CmdType, relation: Relation) -> *mut List>;
pub type Block = *mut ::std::os::raw::c_void;
pub const BufferAccessStrategyType_BAS_NORMAL: BufferAccessStrategyType = 0;
pub const BufferAccessStrategyType_BAS_BULKREAD: BufferAccessStrategyType = 1;
pub const BufferAccessStrategyType_BAS_BULKWRITE: BufferAccessStrategyType = 2;
pub const BufferAccessStrategyType_BAS_VACUUM: BufferAccessStrategyType = 3;
pub type BufferAccessStrategyType = ::std::os::raw::c_uint;
pub const ReadBufferMode_RBM_NORMAL: ReadBufferMode = 0;
pub const ReadBufferMode_RBM_ZERO_AND_LOCK: ReadBufferMode = 1;
pub const ReadBufferMode_RBM_ZERO_AND_CLEANUP_LOCK: ReadBufferMode = 2;
pub const ReadBufferMode_RBM_ZERO_ON_ERROR: ReadBufferMode = 3;
pub const ReadBufferMode_RBM_NORMAL_NO_LOG: ReadBufferMode = 4;
pub type ReadBufferMode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PrefetchBufferResult {
    pub recent_buffer: Buffer,
    pub initiated_io: bool,
}
pub const ExtendBufferedFlags_EB_SKIP_EXTENSION_LOCK: ExtendBufferedFlags = 1;
pub const ExtendBufferedFlags_EB_PERFORMING_RECOVERY: ExtendBufferedFlags = 2;
pub const ExtendBufferedFlags_EB_CREATE_FORK_IF_NEEDED: ExtendBufferedFlags = 4;
pub const ExtendBufferedFlags_EB_LOCK_FIRST: ExtendBufferedFlags = 8;
pub const ExtendBufferedFlags_EB_CLEAR_SIZE_CACHE: ExtendBufferedFlags = 16;
pub const ExtendBufferedFlags_EB_LOCK_TARGET: ExtendBufferedFlags = 32;
pub type ExtendBufferedFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BufferManagerRelation {
    pub rel: Relation,
    pub smgr: *mut SMgrRelationData,
    pub relpersistence: ::std::os::raw::c_char,
}
impl Default for BufferManagerRelation {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WritebackContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BufFile {
    _unused: [u8; 0],
}
pub type pg_on_exit_callback =
    ::std::option::Option<unsafe extern "C" fn(code: ::std::os::raw::c_int, arg: Datum)>;
pub type shmem_startup_hook_type = ::std::option::Option<unsafe extern "C" fn()>;
pub const XLTW_Oper_XLTW_None: XLTW_Oper = 0;
pub const XLTW_Oper_XLTW_Update: XLTW_Oper = 1;
pub const XLTW_Oper_XLTW_Delete: XLTW_Oper = 2;
pub const XLTW_Oper_XLTW_Lock: XLTW_Oper = 3;
pub const XLTW_Oper_XLTW_LockUpdated: XLTW_Oper = 4;
pub const XLTW_Oper_XLTW_InsertIndex: XLTW_Oper = 5;
pub const XLTW_Oper_XLTW_InsertIndexUnique: XLTW_Oper = 6;
pub const XLTW_Oper_XLTW_FetchUpdated: XLTW_Oper = 7;
pub const XLTW_Oper_XLTW_RecheckExclusionConstr: XLTW_Oper = 8;
pub type XLTW_Oper = ::std::os::raw::c_uint;
pub const ProcSignalReason_PROCSIG_CATCHUP_INTERRUPT: ProcSignalReason = 0;
pub const ProcSignalReason_PROCSIG_NOTIFY_INTERRUPT: ProcSignalReason = 1;
pub const ProcSignalReason_PROCSIG_PARALLEL_MESSAGE: ProcSignalReason = 2;
pub const ProcSignalReason_PROCSIG_WALSND_INIT_STOPPING: ProcSignalReason = 3;
pub const ProcSignalReason_PROCSIG_BARRIER: ProcSignalReason = 4;
pub const ProcSignalReason_PROCSIG_LOG_MEMORY_CONTEXT: ProcSignalReason = 5;
pub const ProcSignalReason_PROCSIG_PARALLEL_APPLY_MESSAGE: ProcSignalReason = 6;
pub const ProcSignalReason_PROCSIG_RECOVERY_CONFLICT_DATABASE: ProcSignalReason = 7;
pub const ProcSignalReason_PROCSIG_RECOVERY_CONFLICT_TABLESPACE: ProcSignalReason = 8;
pub const ProcSignalReason_PROCSIG_RECOVERY_CONFLICT_LOCK: ProcSignalReason = 9;
pub const ProcSignalReason_PROCSIG_RECOVERY_CONFLICT_SNAPSHOT: ProcSignalReason = 10;
pub const ProcSignalReason_PROCSIG_RECOVERY_CONFLICT_LOGICALSLOT: ProcSignalReason = 11;
pub const ProcSignalReason_PROCSIG_RECOVERY_CONFLICT_BUFFERPIN: ProcSignalReason = 12;
pub const ProcSignalReason_PROCSIG_RECOVERY_CONFLICT_STARTUP_DEADLOCK: ProcSignalReason = 13;
pub const ProcSignalReason_NUM_PROCSIGNALS: ProcSignalReason = 14;
pub type ProcSignalReason = ::std::os::raw::c_uint;
pub const ProcSignalBarrierType_PROCSIGNAL_BARRIER_SMGRRELEASE: ProcSignalBarrierType = 0;
pub type ProcSignalBarrierType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct xl_standby_locks {
    pub nlocks: ::std::os::raw::c_int,
    pub locks: __IncompleteArrayField<xl_standby_lock>,
}
impl Default for xl_standby_locks {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct xl_running_xacts {
    pub xcnt: ::std::os::raw::c_int,
    pub subxcnt: ::std::os::raw::c_int,
    pub subxid_overflow: bool,
    pub nextXid: TransactionId,
    pub oldestRunningXid: TransactionId,
    pub latestCompletedXid: TransactionId,
    pub xids: __IncompleteArrayField<TransactionId>,
}
#[repr(C)]
pub struct xl_invalidations {
    pub dbId: Oid,
    pub tsId: Oid,
    pub relcacheInitFileInval: bool,
    pub nmsgs: ::std::os::raw::c_int,
    pub msgs: __IncompleteArrayField<SharedInvalidationMessage>,
}
impl Default for xl_invalidations {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RunningTransactionsData {
    pub xcnt: ::std::os::raw::c_int,
    pub subxcnt: ::std::os::raw::c_int,
    pub subxid_overflow: bool,
    pub nextXid: TransactionId,
    pub oldestRunningXid: TransactionId,
    pub latestCompletedXid: TransactionId,
    pub xids: *mut TransactionId,
}
impl Default for RunningTransactionsData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type RunningTransactions = *mut RunningTransactionsData;
pub const LogStmtLevel_LOGSTMT_NONE: LogStmtLevel = 0;
pub const LogStmtLevel_LOGSTMT_DDL: LogStmtLevel = 1;
pub const LogStmtLevel_LOGSTMT_MOD: LogStmtLevel = 2;
pub const LogStmtLevel_LOGSTMT_ALL: LogStmtLevel = 3;
pub type LogStmtLevel = ::std::os::raw::c_uint;
pub const ProcessUtilityContext_PROCESS_UTILITY_TOPLEVEL: ProcessUtilityContext = 0;
pub const ProcessUtilityContext_PROCESS_UTILITY_QUERY: ProcessUtilityContext = 1;
pub const ProcessUtilityContext_PROCESS_UTILITY_QUERY_NONATOMIC: ProcessUtilityContext = 2;
pub const ProcessUtilityContext_PROCESS_UTILITY_SUBCOMMAND: ProcessUtilityContext = 3;
pub type ProcessUtilityContext = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterTableUtilityContext {
    pub pstmt: *mut PlannedStmt,
    pub queryString: *const ::std::os::raw::c_char,
    pub relid: Oid,
    pub params: ParamListInfo,
    pub queryEnv: *mut QueryEnvironment,
}
impl Default for AlterTableUtilityContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ProcessUtility_hook_type = ::std::option::Option<
    unsafe extern "C" fn(
        pstmt: *mut PlannedStmt,
        queryString: *const ::std::os::raw::c_char,
        readOnlyTree: bool,
        context: ProcessUtilityContext,
        params: ParamListInfo,
        queryEnv: *mut QueryEnvironment,
        dest: *mut DestReceiver,
        qc: *mut QueryCompletion,
    ),
>;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct WordEntry {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl WordEntry {
    #[inline]
    pub fn haspos(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_haspos(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn len(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_len(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn pos(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_pos(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        haspos: uint32,
        len: uint32,
        pos: uint32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let haspos: u32 = unsafe { ::std::mem::transmute(haspos) };
            haspos as u64
        });
        __bindgen_bitfield_unit.set(1usize, 11u8, {
            let len: u32 = unsafe { ::std::mem::transmute(len) };
            len as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let pos: u32 = unsafe { ::std::mem::transmute(pos) };
            pos as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WordEntryPos = uint16;
#[repr(C)]
#[derive(Debug, Default)]
pub struct WordEntryPosVector {
    pub npos: uint16,
    pub pos: __IncompleteArrayField<WordEntryPos>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WordEntryPosVector1 {
    pub npos: uint16,
    pub pos: [WordEntryPos; 1usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct TSVectorData {
    pub vl_len_: int32,
    pub size: int32,
    pub entries: __IncompleteArrayField<WordEntry>,
}
pub type TSVector = *mut TSVectorData;
pub type QueryItemType = int8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct QueryOperand {
    pub type_: QueryItemType,
    pub weight: uint8,
    pub prefix: bool,
    pub valcrc: int32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl QueryOperand {
    #[inline]
    pub fn length(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_length(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn distance(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_distance(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(length: uint32, distance: uint32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let length: u32 = unsafe { ::std::mem::transmute(length) };
            length as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let distance: u32 = unsafe { ::std::mem::transmute(distance) };
            distance as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct QueryOperator {
    pub type_: QueryItemType,
    pub oper: int8,
    pub distance: int16,
    pub left: uint32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union QueryItem {
    pub type_: QueryItemType,
    pub qoperator: QueryOperator,
    pub qoperand: QueryOperand,
}
impl Default for QueryItem {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct TSQueryData {
    pub vl_len_: int32,
    pub size: int32,
    pub data: __IncompleteArrayField<::std::os::raw::c_char>,
}
pub type TSQuery = *mut TSQueryData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LexDescr {
    pub lexid: ::std::os::raw::c_int,
    pub alias: *mut ::std::os::raw::c_char,
    pub descr: *mut ::std::os::raw::c_char,
}
impl Default for LexDescr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HeadlineWordEntry {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub pos: WordEntryPos,
    pub word: *mut ::std::os::raw::c_char,
    pub item: *mut QueryOperand,
}
impl Default for HeadlineWordEntry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl HeadlineWordEntry {
    #[inline]
    pub fn selected(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_selected(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn replace(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_replace(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn repeated(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_repeated(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unused(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn len(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_len(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        selected: uint32,
        in_: uint32,
        replace: uint32,
        repeated: uint32,
        skip: uint32,
        unused: uint32,
        type_: uint32,
        len: uint32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let selected: u32 = unsafe { ::std::mem::transmute(selected) };
            selected as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let in_: u32 = unsafe { ::std::mem::transmute(in_) };
            in_ as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let replace: u32 = unsafe { ::std::mem::transmute(replace) };
            replace as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let repeated: u32 = unsafe { ::std::mem::transmute(repeated) };
            repeated as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let skip: u32 = unsafe { ::std::mem::transmute(skip) };
            skip as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let unused: u32 = unsafe { ::std::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let len: u32 = unsafe { ::std::mem::transmute(len) };
            len as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HeadlineParsedText {
    pub words: *mut HeadlineWordEntry,
    pub lenwords: int32,
    pub curwords: int32,
    pub vectorpos: int32,
    pub startsel: *mut ::std::os::raw::c_char,
    pub stopsel: *mut ::std::os::raw::c_char,
    pub fragdelim: *mut ::std::os::raw::c_char,
    pub startsellen: int16,
    pub stopsellen: int16,
    pub fragdelimlen: int16,
}
impl Default for HeadlineParsedText {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StopList {
    pub len: ::std::os::raw::c_int,
    pub stop: *mut *mut ::std::os::raw::c_char,
}
impl Default for StopList {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSLexeme {
    pub nvariant: uint16,
    pub flags: uint16,
    pub lexeme: *mut ::std::os::raw::c_char,
}
impl Default for TSLexeme {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DictSubState {
    pub isend: bool,
    pub getnext: bool,
    pub private_state: *mut ::std::os::raw::c_void,
}
impl Default for DictSubState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSVectorParseStateData {
    _unused: [u8; 0],
}
pub type TSVectorParseState = *mut TSVectorParseStateData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSQueryParserStateData {
    _unused: [u8; 0],
}
pub type TSQueryParserState = *mut TSQueryParserStateData;
pub type PushFunction = ::std::option::Option<
    unsafe extern "C" fn(
        opaque: Datum,
        state: TSQueryParserState,
        token: *mut ::std::os::raw::c_char,
        tokenlen: ::std::os::raw::c_int,
        tokenweights: int16,
        prefix: bool,
    ),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ParsedWord {
    pub len: uint16,
    pub nvariant: uint16,
    pub pos: ParsedWord__bindgen_ty_1,
    pub flags: uint16,
    pub word: *mut ::std::os::raw::c_char,
    pub alen: uint32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ParsedWord__bindgen_ty_1 {
    pub pos: uint16,
    pub apos: *mut uint16,
}
impl Default for ParsedWord__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ParsedWord {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParsedText {
    pub words: *mut ParsedWord,
    pub lenwords: int32,
    pub curwords: int32,
    pub pos: int32,
}
impl Default for ParsedText {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const TSTernaryValue_TS_NO: TSTernaryValue = 0;
pub const TSTernaryValue_TS_YES: TSTernaryValue = 1;
pub const TSTernaryValue_TS_MAYBE: TSTernaryValue = 2;
pub type TSTernaryValue = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExecPhraseData {
    pub npos: ::std::os::raw::c_int,
    pub allocated: bool,
    pub negate: bool,
    pub pos: *mut WordEntryPos,
    pub width: ::std::os::raw::c_int,
}
impl Default for ExecPhraseData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TSExecuteCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::std::os::raw::c_void,
        val: *mut QueryOperand,
        data: *mut ExecPhraseData,
    ) -> TSTernaryValue,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QTNode {
    pub valnode: *mut QueryItem,
    pub flags: uint32,
    pub nchild: int32,
    pub word: *mut ::std::os::raw::c_char,
    pub sign: uint32,
    pub child: *mut *mut QTNode,
}
impl Default for QTNode {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TSQuerySign = uint64;
pub type DateADT = int32;
pub type TimeADT = int64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TimeTzADT {
    pub time: TimeADT,
    pub zone: int32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tzEntry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct datetkn {
    pub token: [::std::os::raw::c_char; 11usize],
    pub type_: ::std::os::raw::c_char,
    pub value: int32,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct TimeZoneAbbrevTable {
    pub tblsize: Size,
    pub numabbrevs: ::std::os::raw::c_int,
    pub abbrevs: __IncompleteArrayField<datetkn>,
}
#[repr(C)]
#[derive(Debug)]
pub struct DynamicZoneAbbrev {
    pub tz: *mut pg_tz,
    pub zone: __IncompleteArrayField<::std::os::raw::c_char>,
}
impl Default for DynamicZoneAbbrev {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DateTimeErrorExtra {
    pub dtee_timezone: *const ::std::os::raw::c_char,
    pub dtee_abbrev: *const ::std::os::raw::c_char,
}
impl Default for DateTimeErrorExtra {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Point {
    pub x: float8,
    pub y: float8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LSEG {
    pub p: [Point; 2usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct PATH {
    pub vl_len_: int32,
    pub npts: int32,
    pub closed: int32,
    pub dummy: int32,
    pub p: __IncompleteArrayField<Point>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LINE {
    pub A: float8,
    pub B: float8,
    pub C: float8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct BOX {
    pub high: Point,
    pub low: Point,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct POLYGON {
    pub vl_len_: int32,
    pub npts: int32,
    pub boundbox: BOX,
    pub p: __IncompleteArrayField<Point>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CIRCLE {
    pub center: Point,
    pub radius: float8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NumericData {
    _unused: [u8; 0],
}
pub type Numeric = *mut NumericData;
pub const JsonbIteratorToken_WJB_DONE: JsonbIteratorToken = 0;
pub const JsonbIteratorToken_WJB_KEY: JsonbIteratorToken = 1;
pub const JsonbIteratorToken_WJB_VALUE: JsonbIteratorToken = 2;
pub const JsonbIteratorToken_WJB_ELEM: JsonbIteratorToken = 3;
pub const JsonbIteratorToken_WJB_BEGIN_ARRAY: JsonbIteratorToken = 4;
pub const JsonbIteratorToken_WJB_END_ARRAY: JsonbIteratorToken = 5;
pub const JsonbIteratorToken_WJB_BEGIN_OBJECT: JsonbIteratorToken = 6;
pub const JsonbIteratorToken_WJB_END_OBJECT: JsonbIteratorToken = 7;
pub type JsonbIteratorToken = ::std::os::raw::c_uint;
pub type JEntry = uint32;
#[repr(C)]
#[derive(Debug, Default)]
pub struct JsonbContainer {
    pub header: uint32,
    pub children: __IncompleteArrayField<JEntry>,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct Jsonb {
    pub vl_len_: int32,
    pub root: JsonbContainer,
}
pub const jbvType_jbvNull: jbvType = 0;
pub const jbvType_jbvString: jbvType = 1;
pub const jbvType_jbvNumeric: jbvType = 2;
pub const jbvType_jbvBool: jbvType = 3;
pub const jbvType_jbvArray: jbvType = 16;
pub const jbvType_jbvObject: jbvType = 17;
pub const jbvType_jbvBinary: jbvType = 18;
pub const jbvType_jbvDatetime: jbvType = 32;
pub type jbvType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct JsonbValue {
    pub type_: jbvType,
    pub val: JsonbValue__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union JsonbValue__bindgen_ty_1 {
    pub numeric: Numeric,
    pub boolean: bool,
    pub string: JsonbValue__bindgen_ty_1__bindgen_ty_1,
    pub array: JsonbValue__bindgen_ty_1__bindgen_ty_2,
    pub object: JsonbValue__bindgen_ty_1__bindgen_ty_3,
    pub binary: JsonbValue__bindgen_ty_1__bindgen_ty_4,
    pub datetime: JsonbValue__bindgen_ty_1__bindgen_ty_5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonbValue__bindgen_ty_1__bindgen_ty_1 {
    pub len: ::std::os::raw::c_int,
    pub val: *mut ::std::os::raw::c_char,
}
impl Default for JsonbValue__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonbValue__bindgen_ty_1__bindgen_ty_2 {
    pub nElems: ::std::os::raw::c_int,
    pub elems: *mut JsonbValue,
    pub rawScalar: bool,
}
impl Default for JsonbValue__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonbValue__bindgen_ty_1__bindgen_ty_3 {
    pub nPairs: ::std::os::raw::c_int,
    pub pairs: *mut JsonbPair,
}
impl Default for JsonbValue__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonbValue__bindgen_ty_1__bindgen_ty_4 {
    pub len: ::std::os::raw::c_int,
    pub data: *mut JsonbContainer,
}
impl Default for JsonbValue__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonbValue__bindgen_ty_1__bindgen_ty_5 {
    pub value: Datum,
    pub typid: Oid,
    pub typmod: int32,
    pub tz: ::std::os::raw::c_int,
}
impl Default for JsonbValue__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for JsonbValue__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for JsonbValue {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct JsonbPair {
    pub key: JsonbValue,
    pub value: JsonbValue,
    pub order: uint32,
}
impl Default for JsonbPair {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct JsonbParseState {
    pub contVal: JsonbValue,
    pub size: Size,
    pub next: *mut JsonbParseState,
    pub unique_keys: bool,
    pub skip_nulls: bool,
}
impl Default for JsonbParseState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const JsonbIterState_JBI_ARRAY_START: JsonbIterState = 0;
pub const JsonbIterState_JBI_ARRAY_ELEM: JsonbIterState = 1;
pub const JsonbIterState_JBI_OBJECT_START: JsonbIterState = 2;
pub const JsonbIterState_JBI_OBJECT_KEY: JsonbIterState = 3;
pub const JsonbIterState_JBI_OBJECT_VALUE: JsonbIterState = 4;
pub type JsonbIterState = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonbIterator {
    pub container: *mut JsonbContainer,
    pub nElems: uint32,
    pub isScalar: bool,
    pub children: *mut JEntry,
    pub dataProper: *mut ::std::os::raw::c_char,
    pub curIndex: ::std::os::raw::c_int,
    pub curDataOffset: uint32,
    pub curValueOffset: uint32,
    pub state: JsonbIterState,
    pub parent: *mut JsonbIterator,
}
impl Default for JsonbIterator {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubscriptRoutines {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpBtreeInterpretation {
    pub opfamily_id: Oid,
    pub strategy: ::std::os::raw::c_int,
    pub oplefttype: Oid,
    pub oprighttype: Oid,
}
impl Default for OpBtreeInterpretation {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const IOFuncSelector_IOFunc_input: IOFuncSelector = 0;
pub const IOFuncSelector_IOFunc_output: IOFuncSelector = 1;
pub const IOFuncSelector_IOFunc_receive: IOFuncSelector = 2;
pub const IOFuncSelector_IOFunc_send: IOFuncSelector = 3;
pub type IOFuncSelector = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AttStatsSlot {
    pub staop: Oid,
    pub stacoll: Oid,
    pub valuetype: Oid,
    pub values: *mut Datum,
    pub nvalues: ::std::os::raw::c_int,
    pub numbers: *mut float4,
    pub nnumbers: ::std::os::raw::c_int,
    pub values_arr: *mut ::std::os::raw::c_void,
    pub numbers_arr: *mut ::std::os::raw::c_void,
}
impl Default for AttStatsSlot {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type get_attavgwidth_hook_type =
    ::std::option::Option<unsafe extern "C" fn(relid: Oid, attnum: AttrNumber) -> int32>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pg_prng_state {
    pub s0: uint64,
    pub s1: uint64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct BlockSamplerData {
    pub N: BlockNumber,
    pub n: ::std::os::raw::c_int,
    pub t: BlockNumber,
    pub m: ::std::os::raw::c_int,
    pub randstate: pg_prng_state,
}
pub type BlockSampler = *mut BlockSamplerData;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ReservoirStateData {
    pub W: f64,
    pub randstate: pg_prng_state,
}
pub type ReservoirState = *mut ReservoirStateData;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct EstimationInfo {
    pub flags: uint32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VariableStatData {
    pub var: *mut Node,
    pub rel: *mut RelOptInfo,
    pub statsTuple: HeapTuple,
    pub freefunc: ::std::option::Option<unsafe extern "C" fn(tuple: HeapTuple)>,
    pub vartype: Oid,
    pub atttype: Oid,
    pub atttypmod: int32,
    pub isunique: bool,
    pub acl_ok: bool,
}
impl Default for VariableStatData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GenericCosts {
    pub indexStartupCost: Cost,
    pub indexTotalCost: Cost,
    pub indexSelectivity: Selectivity,
    pub indexCorrelation: f64,
    pub numIndexPages: f64,
    pub numIndexTuples: f64,
    pub spc_random_page_cost: f64,
    pub num_sa_scans: f64,
}
pub type get_relation_stats_hook_type = ::std::option::Option<
    unsafe extern "C" fn(
        root: *mut PlannerInfo,
        rte: *mut RangeTblEntry,
        attnum: AttrNumber,
        vardata: *mut VariableStatData,
    ) -> bool,
>;
pub type get_index_stats_hook_type = ::std::option::Option<
    unsafe extern "C" fn(
        root: *mut PlannerInfo,
        indexOid: Oid,
        indexattnum: AttrNumber,
        vardata: *mut VariableStatData,
    ) -> bool,
>;
pub type CCHashFN = ::std::option::Option<unsafe extern "C" fn(datum: Datum) -> uint32>;
pub type CCFastEqualFN = ::std::option::Option<unsafe extern "C" fn(a: Datum, b: Datum) -> bool>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct catcache {
    pub id: ::std::os::raw::c_int,
    pub cc_nbuckets: ::std::os::raw::c_int,
    pub cc_tupdesc: TupleDesc,
    pub cc_bucket: *mut dlist_head,
    pub cc_hashfunc: [CCHashFN; 4usize],
    pub cc_fastequal: [CCFastEqualFN; 4usize],
    pub cc_keyno: [::std::os::raw::c_int; 4usize],
    pub cc_lists: dlist_head,
    pub cc_ntup: ::std::os::raw::c_int,
    pub cc_nkeys: ::std::os::raw::c_int,
    pub cc_relname: *const ::std::os::raw::c_char,
    pub cc_reloid: Oid,
    pub cc_indexoid: Oid,
    pub cc_relisshared: bool,
    pub cc_next: slist_node,
    pub cc_skey: [ScanKeyData; 4usize],
}
impl Default for catcache {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CatCache = catcache;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct catctup {
    pub ct_magic: ::std::os::raw::c_int,
    pub hash_value: uint32,
    pub keys: [Datum; 4usize],
    pub cache_elem: dlist_node,
    pub refcount: ::std::os::raw::c_int,
    pub dead: bool,
    pub negative: bool,
    pub tuple: HeapTupleData,
    pub c_list: *mut catclist,
    pub my_cache: *mut CatCache,
}
impl Default for catctup {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CatCTup = catctup;
#[repr(C)]
#[derive(Debug)]
pub struct catclist {
    pub cl_magic: ::std::os::raw::c_int,
    pub hash_value: uint32,
    pub cache_elem: dlist_node,
    pub keys: [Datum; 4usize],
    pub refcount: ::std::os::raw::c_int,
    pub dead: bool,
    pub ordered: bool,
    pub nkeys: ::std::os::raw::c_short,
    pub n_members: ::std::os::raw::c_int,
    pub my_cache: *mut CatCache,
    pub members: __IncompleteArrayField<*mut CatCTup>,
}
impl Default for catclist {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CatCList = catclist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct catcacheheader {
    pub ch_caches: slist_head,
    pub ch_ntup: ::std::os::raw::c_int,
}
impl Default for catcacheheader {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type CatCacheHeader = catcacheheader;
pub const SysCacheIdentifier_AGGFNOID: SysCacheIdentifier = 0;
pub const SysCacheIdentifier_AMNAME: SysCacheIdentifier = 1;
pub const SysCacheIdentifier_AMOID: SysCacheIdentifier = 2;
pub const SysCacheIdentifier_AMOPOPID: SysCacheIdentifier = 3;
pub const SysCacheIdentifier_AMOPSTRATEGY: SysCacheIdentifier = 4;
pub const SysCacheIdentifier_AMPROCNUM: SysCacheIdentifier = 5;
pub const SysCacheIdentifier_ATTNAME: SysCacheIdentifier = 6;
pub const SysCacheIdentifier_ATTNUM: SysCacheIdentifier = 7;
pub const SysCacheIdentifier_AUTHMEMMEMROLE: SysCacheIdentifier = 8;
pub const SysCacheIdentifier_AUTHMEMROLEMEM: SysCacheIdentifier = 9;
pub const SysCacheIdentifier_AUTHNAME: SysCacheIdentifier = 10;
pub const SysCacheIdentifier_AUTHOID: SysCacheIdentifier = 11;
pub const SysCacheIdentifier_CASTSOURCETARGET: SysCacheIdentifier = 12;
pub const SysCacheIdentifier_CLAAMNAMENSP: SysCacheIdentifier = 13;
pub const SysCacheIdentifier_CLAOID: SysCacheIdentifier = 14;
pub const SysCacheIdentifier_COLLNAMEENCNSP: SysCacheIdentifier = 15;
pub const SysCacheIdentifier_COLLOID: SysCacheIdentifier = 16;
pub const SysCacheIdentifier_CONDEFAULT: SysCacheIdentifier = 17;
pub const SysCacheIdentifier_CONNAMENSP: SysCacheIdentifier = 18;
pub const SysCacheIdentifier_CONSTROID: SysCacheIdentifier = 19;
pub const SysCacheIdentifier_CONVOID: SysCacheIdentifier = 20;
pub const SysCacheIdentifier_DATABASEOID: SysCacheIdentifier = 21;
pub const SysCacheIdentifier_DEFACLROLENSPOBJ: SysCacheIdentifier = 22;
pub const SysCacheIdentifier_ENUMOID: SysCacheIdentifier = 23;
pub const SysCacheIdentifier_ENUMTYPOIDNAME: SysCacheIdentifier = 24;
pub const SysCacheIdentifier_EVENTTRIGGERNAME: SysCacheIdentifier = 25;
pub const SysCacheIdentifier_EVENTTRIGGEROID: SysCacheIdentifier = 26;
pub const SysCacheIdentifier_FOREIGNDATAWRAPPERNAME: SysCacheIdentifier = 27;
pub const SysCacheIdentifier_FOREIGNDATAWRAPPEROID: SysCacheIdentifier = 28;
pub const SysCacheIdentifier_FOREIGNSERVERNAME: SysCacheIdentifier = 29;
pub const SysCacheIdentifier_FOREIGNSERVEROID: SysCacheIdentifier = 30;
pub const SysCacheIdentifier_FOREIGNTABLEREL: SysCacheIdentifier = 31;
pub const SysCacheIdentifier_INDEXRELID: SysCacheIdentifier = 32;
pub const SysCacheIdentifier_LANGNAME: SysCacheIdentifier = 33;
pub const SysCacheIdentifier_LANGOID: SysCacheIdentifier = 34;
pub const SysCacheIdentifier_NAMESPACENAME: SysCacheIdentifier = 35;
pub const SysCacheIdentifier_NAMESPACEOID: SysCacheIdentifier = 36;
pub const SysCacheIdentifier_OPERNAMENSP: SysCacheIdentifier = 37;
pub const SysCacheIdentifier_OPEROID: SysCacheIdentifier = 38;
pub const SysCacheIdentifier_OPFAMILYAMNAMENSP: SysCacheIdentifier = 39;
pub const SysCacheIdentifier_OPFAMILYOID: SysCacheIdentifier = 40;
pub const SysCacheIdentifier_PARAMETERACLNAME: SysCacheIdentifier = 41;
pub const SysCacheIdentifier_PARAMETERACLOID: SysCacheIdentifier = 42;
pub const SysCacheIdentifier_PARTRELID: SysCacheIdentifier = 43;
pub const SysCacheIdentifier_PROCNAMEARGSNSP: SysCacheIdentifier = 44;
pub const SysCacheIdentifier_PROCOID: SysCacheIdentifier = 45;
pub const SysCacheIdentifier_PUBLICATIONNAME: SysCacheIdentifier = 46;
pub const SysCacheIdentifier_PUBLICATIONNAMESPACE: SysCacheIdentifier = 47;
pub const SysCacheIdentifier_PUBLICATIONNAMESPACEMAP: SysCacheIdentifier = 48;
pub const SysCacheIdentifier_PUBLICATIONOID: SysCacheIdentifier = 49;
pub const SysCacheIdentifier_PUBLICATIONREL: SysCacheIdentifier = 50;
pub const SysCacheIdentifier_PUBLICATIONRELMAP: SysCacheIdentifier = 51;
pub const SysCacheIdentifier_RANGEMULTIRANGE: SysCacheIdentifier = 52;
pub const SysCacheIdentifier_RANGETYPE: SysCacheIdentifier = 53;
pub const SysCacheIdentifier_RELNAMENSP: SysCacheIdentifier = 54;
pub const SysCacheIdentifier_RELOID: SysCacheIdentifier = 55;
pub const SysCacheIdentifier_REPLORIGIDENT: SysCacheIdentifier = 56;
pub const SysCacheIdentifier_REPLORIGNAME: SysCacheIdentifier = 57;
pub const SysCacheIdentifier_RULERELNAME: SysCacheIdentifier = 58;
pub const SysCacheIdentifier_SEQRELID: SysCacheIdentifier = 59;
pub const SysCacheIdentifier_STATEXTDATASTXOID: SysCacheIdentifier = 60;
pub const SysCacheIdentifier_STATEXTNAMENSP: SysCacheIdentifier = 61;
pub const SysCacheIdentifier_STATEXTOID: SysCacheIdentifier = 62;
pub const SysCacheIdentifier_STATRELATTINH: SysCacheIdentifier = 63;
pub const SysCacheIdentifier_SUBSCRIPTIONNAME: SysCacheIdentifier = 64;
pub const SysCacheIdentifier_SUBSCRIPTIONOID: SysCacheIdentifier = 65;
pub const SysCacheIdentifier_SUBSCRIPTIONRELMAP: SysCacheIdentifier = 66;
pub const SysCacheIdentifier_TABLESPACEOID: SysCacheIdentifier = 67;
pub const SysCacheIdentifier_TRFOID: SysCacheIdentifier = 68;
pub const SysCacheIdentifier_TRFTYPELANG: SysCacheIdentifier = 69;
pub const SysCacheIdentifier_TSCONFIGMAP: SysCacheIdentifier = 70;
pub const SysCacheIdentifier_TSCONFIGNAMENSP: SysCacheIdentifier = 71;
pub const SysCacheIdentifier_TSCONFIGOID: SysCacheIdentifier = 72;
pub const SysCacheIdentifier_TSDICTNAMENSP: SysCacheIdentifier = 73;
pub const SysCacheIdentifier_TSDICTOID: SysCacheIdentifier = 74;
pub const SysCacheIdentifier_TSPARSERNAMENSP: SysCacheIdentifier = 75;
pub const SysCacheIdentifier_TSPARSEROID: SysCacheIdentifier = 76;
pub const SysCacheIdentifier_TSTEMPLATENAMENSP: SysCacheIdentifier = 77;
pub const SysCacheIdentifier_TSTEMPLATEOID: SysCacheIdentifier = 78;
pub const SysCacheIdentifier_TYPENAMENSP: SysCacheIdentifier = 79;
pub const SysCacheIdentifier_TYPEOID: SysCacheIdentifier = 80;
pub const SysCacheIdentifier_USERMAPPINGOID: SysCacheIdentifier = 81;
pub const SysCacheIdentifier_USERMAPPINGUSERSERVER: SysCacheIdentifier = 82;
pub type SysCacheIdentifier = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeType {
    pub vl_len_: int32,
    pub rangetypid: Oid,
}
impl Default for RangeType {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeBound {
    pub val: Datum,
    pub infinite: bool,
    pub inclusive: bool,
    pub lower: bool,
}
impl Default for RangeBound {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
impl Default for __va_list_tag {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AttrMissing {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct JitContext {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct JitInstrumentation {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SharedJitInstrumentation {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PartitionTupleRouting {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WaitEventSet {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct binaryheap {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TsmRoutine {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TableFuncRoutine {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct memoize_hash {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HashAggSpill {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WindowObjectData {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ParallelExecutorInfo {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TupleQueueReader {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _MdfdVec {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ResourceOwnerData {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SnapBuild {
    pub _address: u8,
}
#[pgrx_macros::pg_guard]
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
    pub fn __memcmpeq(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
    pub fn ExceptionalCondition(
        conditionName: *const ::std::os::raw::c_char,
        fileName: *const ::std::os::raw::c_char,
        lineNumber: ::std::os::raw::c_int,
    ) -> !;
    pub fn pg_set_noblock(sock: pgsocket) -> bool;
    pub fn pg_set_block(sock: pgsocket) -> bool;
    pub fn has_drive_prefix(path: *const ::std::os::raw::c_char) -> bool;
    pub fn first_dir_separator(
        filename: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn last_dir_separator(
        filename: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn first_path_var_separator(
        pathlist: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn join_path_components(
        ret_path: *mut ::std::os::raw::c_char,
        head: *const ::std::os::raw::c_char,
        tail: *const ::std::os::raw::c_char,
    );
    pub fn canonicalize_path(path: *mut ::std::os::raw::c_char);
    pub fn make_native_path(filename: *mut ::std::os::raw::c_char);
    pub fn cleanup_path(path: *mut ::std::os::raw::c_char);
    pub fn path_contains_parent_reference(path: *const ::std::os::raw::c_char) -> bool;
    pub fn path_is_relative_and_below_cwd(path: *const ::std::os::raw::c_char) -> bool;
    pub fn path_is_prefix_of_path(
        path1: *const ::std::os::raw::c_char,
        path2: *const ::std::os::raw::c_char,
    ) -> bool;
    pub fn make_absolute_path(path: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    pub fn get_progname(argv0: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
    pub fn get_share_path(
        my_exec_path: *const ::std::os::raw::c_char,
        ret_path: *mut ::std::os::raw::c_char,
    );
    pub fn get_etc_path(
        my_exec_path: *const ::std::os::raw::c_char,
        ret_path: *mut ::std::os::raw::c_char,
    );
    pub fn get_include_path(
        my_exec_path: *const ::std::os::raw::c_char,
        ret_path: *mut ::std::os::raw::c_char,
    );
    pub fn get_pkginclude_path(
        my_exec_path: *const ::std::os::raw::c_char,
        ret_path: *mut ::std::os::raw::c_char,
    );
    pub fn get_includeserver_path(
        my_exec_path: *const ::std::os::raw::c_char,
        ret_path: *mut ::std::os::raw::c_char,
    );
    pub fn get_lib_path(
        my_exec_path: *const ::std::os::raw::c_char,
        ret_path: *mut ::std::os::raw::c_char,
    );
    pub fn get_pkglib_path(
        my_exec_path: *const ::std::os::raw::c_char,
        ret_path: *mut ::std::os::raw::c_char,
    );
    pub fn get_locale_path(
        my_exec_path: *const ::std::os::raw::c_char,
        ret_path: *mut ::std::os::raw::c_char,
    );
    pub fn get_doc_path(
        my_exec_path: *const ::std::os::raw::c_char,
        ret_path: *mut ::std::os::raw::c_char,
    );
    pub fn get_html_path(
        my_exec_path: *const ::std::os::raw::c_char,
        ret_path: *mut ::std::os::raw::c_char,
    );
    pub fn get_man_path(
        my_exec_path: *const ::std::os::raw::c_char,
        ret_path: *mut ::std::os::raw::c_char,
    );
    pub fn get_home_path(ret_path: *mut ::std::os::raw::c_char) -> bool;
    pub fn get_parent_directory(path: *mut ::std::os::raw::c_char);
    pub fn pgfnames(path: *const ::std::os::raw::c_char) -> *mut *mut ::std::os::raw::c_char;
    pub fn pgfnames_cleanup(filenames: *mut *mut ::std::os::raw::c_char);
    pub fn set_pglocale_pgservice(
        argv0: *const ::std::os::raw::c_char,
        app: *const ::std::os::raw::c_char,
    );
    pub fn validate_exec(path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn find_my_exec(
        argv0: *const ::std::os::raw::c_char,
        retpath: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn find_other_exec(
        argv0: *const ::std::os::raw::c_char,
        target: *const ::std::os::raw::c_char,
        versionstr: *const ::std::os::raw::c_char,
        retpath: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn pipe_read_line(
        cmd: *mut ::std::os::raw::c_char,
        line: *mut ::std::os::raw::c_char,
        maxsize: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
    pub fn pg_usleep(microsec: ::std::os::raw::c_long);
    pub fn pg_strcasecmp(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn pg_strncasecmp(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
        n: usize,
    ) -> ::std::os::raw::c_int;
    pub fn pg_toupper(ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_uchar;
    pub fn pg_tolower(ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_uchar;
    pub fn pg_ascii_toupper(ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_uchar;
    pub fn pg_ascii_tolower(ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_uchar;
    pub fn pg_snprintf(
        str_: *mut ::std::os::raw::c_char,
        count: usize,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
    pub fn pg_sprintf(
        str_: *mut ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
    pub fn pg_fprintf(
        stream: *mut FILE,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
    pub fn pg_printf(fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
    pub fn pg_strfromd(
        str_: *mut ::std::os::raw::c_char,
        count: usize,
        precision: ::std::os::raw::c_int,
        value: f64,
    ) -> ::std::os::raw::c_int;
    pub fn pg_strerror(errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
    pub fn pg_strerror_r(
        errnum: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> *mut ::std::os::raw::c_char;
    pub fn pg_strsignal(signum: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
    pub fn pclose_check(stream: *mut FILE) -> ::std::os::raw::c_int;
    pub fn rmtree(path: *const ::std::os::raw::c_char, rmtopdir: bool) -> bool;
    pub fn getpeereid(
        sock: ::std::os::raw::c_int,
        uid: *mut uid_t,
        gid: *mut gid_t,
    ) -> ::std::os::raw::c_int;
    pub fn __acos(__x: f64) -> f64;
    pub fn __asin(__x: f64) -> f64;
    pub fn __atan(__x: f64) -> f64;
    pub fn __atan2(__y: f64, __x: f64) -> f64;
    pub fn __cos(__x: f64) -> f64;
    pub fn __sin(__x: f64) -> f64;
    pub fn __tan(__x: f64) -> f64;
    pub fn __cosh(__x: f64) -> f64;
    pub fn __sinh(__x: f64) -> f64;
    pub fn __tanh(__x: f64) -> f64;
    pub fn __acosh(__x: f64) -> f64;
    pub fn __asinh(__x: f64) -> f64;
    pub fn __atanh(__x: f64) -> f64;
    pub fn __exp(__x: f64) -> f64;
    pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
    pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
    pub fn __log(__x: f64) -> f64;
    pub fn __log10(__x: f64) -> f64;
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
    pub fn __expm1(__x: f64) -> f64;
    pub fn __log1p(__x: f64) -> f64;
    pub fn __logb(__x: f64) -> f64;
    pub fn __exp2(__x: f64) -> f64;
    pub fn __log2(__x: f64) -> f64;
    pub fn __pow(__x: f64, __y: f64) -> f64;
    pub fn __sqrt(__x: f64) -> f64;
    pub fn __hypot(__x: f64, __y: f64) -> f64;
    pub fn __cbrt(__x: f64) -> f64;
    pub fn __ceil(__x: f64) -> f64;
    pub fn __fabs(__x: f64) -> f64;
    pub fn __floor(__x: f64) -> f64;
    pub fn __fmod(__x: f64, __y: f64) -> f64;
    pub fn __drem(__x: f64, __y: f64) -> f64;
    pub fn __significand(__x: f64) -> f64;
    pub fn __copysign(__x: f64, __y: f64) -> f64;
    pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
    pub fn __j0(arg1: f64) -> f64;
    pub fn __j1(arg1: f64) -> f64;
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
    pub fn __y0(arg1: f64) -> f64;
    pub fn __y1(arg1: f64) -> f64;
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
    pub fn __erf(arg1: f64) -> f64;
    pub fn __erfc(arg1: f64) -> f64;
    pub fn __lgamma(arg1: f64) -> f64;
    pub fn __tgamma(arg1: f64) -> f64;
    pub fn __gamma(arg1: f64) -> f64;
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
    pub fn __rint(__x: f64) -> f64;
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
    pub fn __nexttoward(__x: f64, __y: u128) -> f64;
    pub fn __remainder(__x: f64, __y: f64) -> f64;
    pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
    pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
    pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
    pub fn __nearbyint(__x: f64) -> f64;
    pub fn __round(__x: f64) -> f64;
    pub fn __trunc(__x: f64) -> f64;
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
    pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
    pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
    pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
    pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
    pub fn __fdim(__x: f64, __y: f64) -> f64;
    pub fn __fmax(__x: f64, __y: f64) -> f64;
    pub fn __fmin(__x: f64, __y: f64) -> f64;
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
    pub fn __scalb(__x: f64, __n: f64) -> f64;
    pub fn __acosf(__x: f32) -> f32;
    pub fn __asinf(__x: f32) -> f32;
    pub fn __atanf(__x: f32) -> f32;
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
    pub fn __cosf(__x: f32) -> f32;
    pub fn __sinf(__x: f32) -> f32;
    pub fn __tanf(__x: f32) -> f32;
    pub fn __coshf(__x: f32) -> f32;
    pub fn __sinhf(__x: f32) -> f32;
    pub fn __tanhf(__x: f32) -> f32;
    pub fn __acoshf(__x: f32) -> f32;
    pub fn __asinhf(__x: f32) -> f32;
    pub fn __atanhf(__x: f32) -> f32;
    pub fn __expf(__x: f32) -> f32;
    pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
    pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
    pub fn __logf(__x: f32) -> f32;
    pub fn __log10f(__x: f32) -> f32;
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
    pub fn __expm1f(__x: f32) -> f32;
    pub fn __log1pf(__x: f32) -> f32;
    pub fn __logbf(__x: f32) -> f32;
    pub fn __exp2f(__x: f32) -> f32;
    pub fn __log2f(__x: f32) -> f32;
    pub fn __powf(__x: f32, __y: f32) -> f32;
    pub fn __sqrtf(__x: f32) -> f32;
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
    pub fn __cbrtf(__x: f32) -> f32;
    pub fn __ceilf(__x: f32) -> f32;
    pub fn __fabsf(__x: f32) -> f32;
    pub fn __floorf(__x: f32) -> f32;
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
    pub fn __dremf(__x: f32, __y: f32) -> f32;
    pub fn __significandf(__x: f32) -> f32;
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
    pub fn __j0f(arg1: f32) -> f32;
    pub fn __j1f(arg1: f32) -> f32;
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
    pub fn __y0f(arg1: f32) -> f32;
    pub fn __y1f(arg1: f32) -> f32;
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
    pub fn __erff(arg1: f32) -> f32;
    pub fn __erfcf(arg1: f32) -> f32;
    pub fn __lgammaf(arg1: f32) -> f32;
    pub fn __tgammaf(arg1: f32) -> f32;
    pub fn __gammaf(arg1: f32) -> f32;
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
    pub fn __rintf(__x: f32) -> f32;
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
    pub fn __nexttowardf(__x: f32, __y: u128) -> f32;
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
    pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
    pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
    pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
    pub fn __nearbyintf(__x: f32) -> f32;
    pub fn __roundf(__x: f32) -> f32;
    pub fn __truncf(__x: f32) -> f32;
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
    pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
    pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
    pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
    pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
    pub fn __fminf(__x: f32, __y: f32) -> f32;
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
    pub fn __acosl(__x: u128) -> u128;
    pub fn __asinl(__x: u128) -> u128;
    pub fn __atanl(__x: u128) -> u128;
    pub fn __atan2l(__y: u128, __x: u128) -> u128;
    pub fn __cosl(__x: u128) -> u128;
    pub fn __sinl(__x: u128) -> u128;
    pub fn __tanl(__x: u128) -> u128;
    pub fn __coshl(__x: u128) -> u128;
    pub fn __sinhl(__x: u128) -> u128;
    pub fn __tanhl(__x: u128) -> u128;
    pub fn __acoshl(__x: u128) -> u128;
    pub fn __asinhl(__x: u128) -> u128;
    pub fn __atanhl(__x: u128) -> u128;
    pub fn __expl(__x: u128) -> u128;
    pub fn __frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
    pub fn __ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
    pub fn __logl(__x: u128) -> u128;
    pub fn __log10l(__x: u128) -> u128;
    pub fn __modfl(__x: u128, __iptr: *mut u128) -> u128;
    pub fn __expm1l(__x: u128) -> u128;
    pub fn __log1pl(__x: u128) -> u128;
    pub fn __logbl(__x: u128) -> u128;
    pub fn __exp2l(__x: u128) -> u128;
    pub fn __log2l(__x: u128) -> u128;
    pub fn __powl(__x: u128, __y: u128) -> u128;
    pub fn __sqrtl(__x: u128) -> u128;
    pub fn __hypotl(__x: u128, __y: u128) -> u128;
    pub fn __cbrtl(__x: u128) -> u128;
    pub fn __ceill(__x: u128) -> u128;
    pub fn __fabsl(__x: u128) -> u128;
    pub fn __floorl(__x: u128) -> u128;
    pub fn __fmodl(__x: u128, __y: u128) -> u128;
    pub fn __dreml(__x: u128, __y: u128) -> u128;
    pub fn __significandl(__x: u128) -> u128;
    pub fn __copysignl(__x: u128, __y: u128) -> u128;
    pub fn __nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
    pub fn __j0l(arg1: u128) -> u128;
    pub fn __j1l(arg1: u128) -> u128;
    pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
    pub fn __y0l(arg1: u128) -> u128;
    pub fn __y1l(arg1: u128) -> u128;
    pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
    pub fn __erfl(arg1: u128) -> u128;
    pub fn __erfcl(arg1: u128) -> u128;
    pub fn __lgammal(arg1: u128) -> u128;
    pub fn __tgammal(arg1: u128) -> u128;
    pub fn __gammal(arg1: u128) -> u128;
    pub fn __lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
    pub fn __rintl(__x: u128) -> u128;
    pub fn __nextafterl(__x: u128, __y: u128) -> u128;
    pub fn __nexttowardl(__x: u128, __y: u128) -> u128;
    pub fn __remainderl(__x: u128, __y: u128) -> u128;
    pub fn __scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
    pub fn __ilogbl(__x: u128) -> ::std::os::raw::c_int;
    pub fn __scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
    pub fn __nearbyintl(__x: u128) -> u128;
    pub fn __roundl(__x: u128) -> u128;
    pub fn __truncl(__x: u128) -> u128;
    pub fn __remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
    pub fn __lrintl(__x: u128) -> ::std::os::raw::c_long;
    pub fn __llrintl(__x: u128) -> ::std::os::raw::c_longlong;
    pub fn __lroundl(__x: u128) -> ::std::os::raw::c_long;
    pub fn __llroundl(__x: u128) -> ::std::os::raw::c_longlong;
    pub fn __fdiml(__x: u128, __y: u128) -> u128;
    pub fn __fmaxl(__x: u128, __y: u128) -> u128;
    pub fn __fminl(__x: u128, __y: u128) -> u128;
    pub fn __fmal(__x: u128, __y: u128, __z: u128) -> u128;
    pub fn __scalbl(__x: u128, __n: u128) -> u128;
    pub fn strlcat(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        siz: usize,
    ) -> usize;
    pub fn strlcpy(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        siz: usize,
    ) -> usize;
    pub fn pg_get_user_name(
        user_id: uid_t,
        buffer: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> bool;
    pub fn pg_get_user_home_dir(
        user_id: uid_t,
        buffer: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> bool;
    pub fn pg_qsort(
        base: *mut ::std::os::raw::c_void,
        nel: usize,
        elsize: usize,
        cmp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
    pub fn pg_qsort_strcmp(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
    pub fn qsort_arg(
        base: *mut ::std::os::raw::c_void,
        nel: usize,
        elsize: usize,
        cmp: qsort_arg_comparator,
        arg: *mut ::std::os::raw::c_void,
    );
    pub fn qsort_interruptible(
        base: *mut ::std::os::raw::c_void,
        nel: usize,
        elsize: usize,
        cmp: qsort_arg_comparator,
        arg: *mut ::std::os::raw::c_void,
    );
    pub fn bsearch_arg(
        key: *const ::std::os::raw::c_void,
        base0: *const ::std::os::raw::c_void,
        nmemb: usize,
        size: usize,
        compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
    pub fn pg_get_encoding_from_locale(
        ctype: *const ::std::os::raw::c_char,
        write_message: bool,
    ) -> ::std::os::raw::c_int;
    pub fn pg_inet_net_ntop(
        af: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_void,
        bits: ::std::os::raw::c_int,
        dst: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> *mut ::std::os::raw::c_char;
    pub fn pg_strong_random_init();
    pub fn pg_strong_random(buf: *mut ::std::os::raw::c_void, len: usize) -> bool;
    pub fn pg_check_dir(dir: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn pg_mkdir_p(
        path: *mut ::std::os::raw::c_char,
        omode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn pqsignal(signo: ::std::os::raw::c_int, func: pqsigfunc) -> pqsigfunc;
    pub fn escape_single_quotes_ascii(
        src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn wait_result_to_str(exitstatus: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
    pub fn wait_result_is_signal(
        exit_status: ::std::os::raw::c_int,
        signum: ::std::os::raw::c_int,
    ) -> bool;
    pub fn wait_result_is_any_signal(
        exit_status: ::std::os::raw::c_int,
        include_command_not_found: bool,
    ) -> bool;
    pub fn wait_result_to_exit_code(exit_status: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn makeStringInfo() -> StringInfo;
    pub fn initStringInfo(str_: StringInfo);
    pub fn resetStringInfo(str_: StringInfo);
    pub fn appendStringInfo(str_: StringInfo, fmt: *const ::std::os::raw::c_char, ...);
    pub fn appendStringInfoString(str_: StringInfo, s: *const ::std::os::raw::c_char);
    pub fn appendStringInfoChar(str_: StringInfo, ch: ::std::os::raw::c_char);
    pub fn appendStringInfoSpaces(str_: StringInfo, count: ::std::os::raw::c_int);
    pub fn appendBinaryStringInfo(
        str_: StringInfo,
        data: *const ::std::os::raw::c_void,
        datalen: ::std::os::raw::c_int,
    );
    pub fn appendBinaryStringInfoNT(
        str_: StringInfo,
        data: *const ::std::os::raw::c_void,
        datalen: ::std::os::raw::c_int,
    );
    pub fn enlargeStringInfo(str_: StringInfo, needed: ::std::os::raw::c_int);
    pub fn message_level_is_interesting(elevel: ::std::os::raw::c_int) -> bool;
    pub fn errstart_cold(
        elevel: ::std::os::raw::c_int,
        domain: *const ::std::os::raw::c_char,
    ) -> bool;
    pub fn errcode_for_file_access() -> ::std::os::raw::c_int;
    pub fn errcode_for_socket_access() -> ::std::os::raw::c_int;
    pub fn errmsg_internal(fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
    pub fn errmsg_plural(
        fmt_singular: *const ::std::os::raw::c_char,
        fmt_plural: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_ulong,
        ...
    ) -> ::std::os::raw::c_int;
    pub fn errdetail_internal(fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
    pub fn errdetail_log(fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
    pub fn errdetail_log_plural(
        fmt_singular: *const ::std::os::raw::c_char,
        fmt_plural: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_ulong,
        ...
    ) -> ::std::os::raw::c_int;
    pub fn errdetail_plural(
        fmt_singular: *const ::std::os::raw::c_char,
        fmt_plural: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_ulong,
        ...
    ) -> ::std::os::raw::c_int;
    pub fn errhint_plural(
        fmt_singular: *const ::std::os::raw::c_char,
        fmt_plural: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_ulong,
        ...
    ) -> ::std::os::raw::c_int;
    pub fn set_errcontext_domain(domain: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn errhidestmt(hide_stmt: bool) -> ::std::os::raw::c_int;
    pub fn errhidecontext(hide_ctx: bool) -> ::std::os::raw::c_int;
    pub fn errbacktrace() -> ::std::os::raw::c_int;
    pub fn errposition(cursorpos: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn internalerrposition(cursorpos: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn internalerrquery(query: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn err_generic_string(
        field: ::std::os::raw::c_int,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn geterrcode() -> ::std::os::raw::c_int;
    pub fn geterrposition() -> ::std::os::raw::c_int;
    pub fn getinternalerrposition() -> ::std::os::raw::c_int;
    pub fn errsave_start(context: *mut Node, domain: *const ::std::os::raw::c_char) -> bool;
    pub fn errsave_finish(
        context: *mut Node,
        filename: *const ::std::os::raw::c_char,
        lineno: ::std::os::raw::c_int,
        funcname: *const ::std::os::raw::c_char,
    );
    pub fn pre_format_elog_string(
        errnumber: ::std::os::raw::c_int,
        domain: *const ::std::os::raw::c_char,
    );
    pub fn format_elog_string(
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
    pub fn EmitErrorReport();
    pub fn CopyErrorData() -> *mut ErrorData;
    pub fn FreeErrorData(edata: *mut ErrorData);
    pub fn FlushErrorState();
    pub fn ReThrowError(edata: *mut ErrorData) -> !;
    pub fn ThrowErrorData(edata: *mut ErrorData);
    pub fn GetErrorContextStack() -> *mut ::std::os::raw::c_char;
    pub fn log_status_format(
        buf: StringInfo,
        format: *const ::std::os::raw::c_char,
        edata: *mut ErrorData,
    );
    pub fn DebugFileOpen();
    pub fn unpack_sql_state(sql_state: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
    pub fn in_error_recursion_trouble() -> bool;
    pub fn reset_formatted_start_time();
    pub fn get_formatted_start_time() -> *mut ::std::os::raw::c_char;
    pub fn get_formatted_log_time() -> *mut ::std::os::raw::c_char;
    pub fn get_backend_type_for_log() -> *const ::std::os::raw::c_char;
    pub fn check_log_of_query(edata: *mut ErrorData) -> bool;
    pub fn error_severity(elevel: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
    pub fn write_pipe_chunks(
        data: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        dest: ::std::os::raw::c_int,
    );
    pub fn write_csvlog(edata: *mut ErrorData);
    pub fn write_jsonlog(edata: *mut ErrorData);
    pub fn write_stderr(fmt: *const ::std::os::raw::c_char, ...);
    pub fn MemoryContextAlloc(context: MemoryContext, size: Size) -> *mut ::std::os::raw::c_void;
    pub fn MemoryContextAllocZero(
        context: MemoryContext,
        size: Size,
    ) -> *mut ::std::os::raw::c_void;
    pub fn MemoryContextAllocZeroAligned(
        context: MemoryContext,
        size: Size,
    ) -> *mut ::std::os::raw::c_void;
    pub fn MemoryContextAllocExtended(
        context: MemoryContext,
        size: Size,
        flags: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
    pub fn MemoryContextAllocAligned(
        context: MemoryContext,
        size: Size,
        alignto: Size,
        flags: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
    pub fn palloc(size: Size) -> *mut ::std::os::raw::c_void;
    pub fn palloc0(size: Size) -> *mut ::std::os::raw::c_void;
    pub fn palloc_extended(size: Size, flags: ::std::os::raw::c_int)
        -> *mut ::std::os::raw::c_void;
    pub fn palloc_aligned(
        size: Size,
        alignto: Size,
        flags: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
    pub fn repalloc(
        pointer: *mut ::std::os::raw::c_void,
        size: Size,
    ) -> *mut ::std::os::raw::c_void;
    pub fn repalloc_extended(
        pointer: *mut ::std::os::raw::c_void,
        size: Size,
        flags: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
    pub fn repalloc0(
        pointer: *mut ::std::os::raw::c_void,
        oldsize: Size,
        size: Size,
    ) -> *mut ::std::os::raw::c_void;
    pub fn pfree(pointer: *mut ::std::os::raw::c_void);
    pub fn MemoryContextAllocHuge(
        context: MemoryContext,
        size: Size,
    ) -> *mut ::std::os::raw::c_void;
    pub fn repalloc_huge(
        pointer: *mut ::std::os::raw::c_void,
        size: Size,
    ) -> *mut ::std::os::raw::c_void;
    pub fn MemoryContextRegisterResetCallback(
        context: MemoryContext,
        cb: *mut MemoryContextCallback,
    );
    pub fn MemoryContextStrdup(
        context: MemoryContext,
        string: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn pstrdup(in_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    pub fn pnstrdup(in_: *const ::std::os::raw::c_char, len: Size) -> *mut ::std::os::raw::c_char;
    pub fn pchomp(in_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    pub fn psprintf(fmt: *const ::std::os::raw::c_char, ...) -> *mut ::std::os::raw::c_char;
    pub fn outNode(str_: *mut StringInfoData, obj: *const ::std::os::raw::c_void);
    pub fn outToken(str_: *mut StringInfoData, s: *const ::std::os::raw::c_char);
    pub fn outBitmapset(str_: *mut StringInfoData, bms: *const Bitmapset);
    pub fn outDatum(
        str_: *mut StringInfoData,
        value: usize,
        typlen: ::std::os::raw::c_int,
        typbyval: bool,
    );
    pub fn nodeToString(obj: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_char;
    pub fn bmsToString(bms: *const Bitmapset) -> *mut ::std::os::raw::c_char;
    pub fn stringToNode(str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
    pub fn readBitmapset() -> *mut Bitmapset;
    pub fn readDatum(typbyval: bool) -> usize;
    pub fn readBoolCols(numCols: ::std::os::raw::c_int) -> *mut bool;
    pub fn readIntCols(numCols: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_int;
    pub fn readOidCols(numCols: ::std::os::raw::c_int) -> *mut Oid;
    pub fn readAttrNumberCols(numCols: ::std::os::raw::c_int) -> *mut int16;
    pub fn copyObjectImpl(from: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
    pub fn equal(a: *const ::std::os::raw::c_void, b: *const ::std::os::raw::c_void) -> bool;
    pub fn list_make1_impl(t: NodeTag, datum1: ListCell) -> *mut List;
    pub fn list_make2_impl(t: NodeTag, datum1: ListCell, datum2: ListCell) -> *mut List;
    pub fn list_make3_impl(
        t: NodeTag,
        datum1: ListCell,
        datum2: ListCell,
        datum3: ListCell,
    ) -> *mut List;
    pub fn list_make4_impl(
        t: NodeTag,
        datum1: ListCell,
        datum2: ListCell,
        datum3: ListCell,
        datum4: ListCell,
    ) -> *mut List;
    pub fn list_make5_impl(
        t: NodeTag,
        datum1: ListCell,
        datum2: ListCell,
        datum3: ListCell,
        datum4: ListCell,
        datum5: ListCell,
    ) -> *mut List;
    pub fn lappend(list: *mut List, datum: *mut ::std::os::raw::c_void) -> *mut List;
    pub fn lappend_int(list: *mut List, datum: ::std::os::raw::c_int) -> *mut List;
    pub fn lappend_oid(list: *mut List, datum: Oid) -> *mut List;
    pub fn lappend_xid(list: *mut List, datum: TransactionId) -> *mut List;
    pub fn list_insert_nth(
        list: *mut List,
        pos: ::std::os::raw::c_int,
        datum: *mut ::std::os::raw::c_void,
    ) -> *mut List;
    pub fn list_insert_nth_int(
        list: *mut List,
        pos: ::std::os::raw::c_int,
        datum: ::std::os::raw::c_int,
    ) -> *mut List;
    pub fn list_insert_nth_oid(
        list: *mut List,
        pos: ::std::os::raw::c_int,
        datum: Oid,
    ) -> *mut List;
    pub fn lcons(datum: *mut ::std::os::raw::c_void, list: *mut List) -> *mut List;
    pub fn lcons_int(datum: ::std::os::raw::c_int, list: *mut List) -> *mut List;
    pub fn lcons_oid(datum: Oid, list: *mut List) -> *mut List;
    pub fn list_concat(list1: *mut List, list2: *const List) -> *mut List;
    pub fn list_concat_copy(list1: *const List, list2: *const List) -> *mut List;
    pub fn list_truncate(list: *mut List, new_size: ::std::os::raw::c_int) -> *mut List;
    pub fn list_member(list: *const List, datum: *const ::std::os::raw::c_void) -> bool;
    pub fn list_member_ptr(list: *const List, datum: *const ::std::os::raw::c_void) -> bool;
    pub fn list_member_int(list: *const List, datum: ::std::os::raw::c_int) -> bool;
    pub fn list_member_oid(list: *const List, datum: Oid) -> bool;
    pub fn list_member_xid(list: *const List, datum: TransactionId) -> bool;
    pub fn list_delete(list: *mut List, datum: *mut ::std::os::raw::c_void) -> *mut List;
    pub fn list_delete_ptr(list: *mut List, datum: *mut ::std::os::raw::c_void) -> *mut List;
    pub fn list_delete_int(list: *mut List, datum: ::std::os::raw::c_int) -> *mut List;
    pub fn list_delete_oid(list: *mut List, datum: Oid) -> *mut List;
    pub fn list_delete_first(list: *mut List) -> *mut List;
    pub fn list_delete_last(list: *mut List) -> *mut List;
    pub fn list_delete_first_n(list: *mut List, n: ::std::os::raw::c_int) -> *mut List;
    pub fn list_delete_nth_cell(list: *mut List, n: ::std::os::raw::c_int) -> *mut List;
    pub fn list_delete_cell(list: *mut List, cell: *mut ListCell) -> *mut List;
    pub fn list_union(list1: *const List, list2: *const List) -> *mut List;
    pub fn list_union_ptr(list1: *const List, list2: *const List) -> *mut List;
    pub fn list_union_int(list1: *const List, list2: *const List) -> *mut List;
    pub fn list_union_oid(list1: *const List, list2: *const List) -> *mut List;
    pub fn list_intersection(list1: *const List, list2: *const List) -> *mut List;
    pub fn list_intersection_int(list1: *const List, list2: *const List) -> *mut List;
    pub fn list_difference(list1: *const List, list2: *const List) -> *mut List;
    pub fn list_difference_ptr(list1: *const List, list2: *const List) -> *mut List;
    pub fn list_difference_int(list1: *const List, list2: *const List) -> *mut List;
    pub fn list_difference_oid(list1: *const List, list2: *const List) -> *mut List;
    pub fn list_append_unique(list: *mut List, datum: *mut ::std::os::raw::c_void) -> *mut List;
    pub fn list_append_unique_ptr(list: *mut List, datum: *mut ::std::os::raw::c_void)
        -> *mut List;
    pub fn list_append_unique_int(list: *mut List, datum: ::std::os::raw::c_int) -> *mut List;
    pub fn list_append_unique_oid(list: *mut List, datum: Oid) -> *mut List;
    pub fn list_concat_unique(list1: *mut List, list2: *const List) -> *mut List;
    pub fn list_concat_unique_ptr(list1: *mut List, list2: *const List) -> *mut List;
    pub fn list_concat_unique_int(list1: *mut List, list2: *const List) -> *mut List;
    pub fn list_concat_unique_oid(list1: *mut List, list2: *const List) -> *mut List;
    pub fn list_deduplicate_oid(list: *mut List);
    pub fn list_free(list: *mut List);
    pub fn list_free_deep(list: *mut List);
    pub fn list_copy(oldlist: *const List) -> *mut List;
    pub fn list_copy_head(oldlist: *const List, len: ::std::os::raw::c_int) -> *mut List;
    pub fn list_copy_tail(oldlist: *const List, nskip: ::std::os::raw::c_int) -> *mut List;
    pub fn list_copy_deep(oldlist: *const List) -> *mut List;
    pub fn list_sort(list: *mut List, cmp: list_sort_comparator);
    pub fn list_int_cmp(p1: *const ListCell, p2: *const ListCell) -> ::std::os::raw::c_int;
    pub fn list_oid_cmp(p1: *const ListCell, p2: *const ListCell) -> ::std::os::raw::c_int;
    pub fn CreateTemplateTupleDesc(natts: ::std::os::raw::c_int) -> TupleDesc;
    pub fn CreateTupleDesc(
        natts: ::std::os::raw::c_int,
        attrs: *mut Form_pg_attribute,
    ) -> TupleDesc;
    pub fn CreateTupleDescCopy(tupdesc: TupleDesc) -> TupleDesc;
    pub fn CreateTupleDescCopyConstr(tupdesc: TupleDesc) -> TupleDesc;
    pub fn TupleDescCopy(dst: TupleDesc, src: TupleDesc);
    pub fn TupleDescCopyEntry(
        dst: TupleDesc,
        dstAttno: AttrNumber,
        src: TupleDesc,
        srcAttno: AttrNumber,
    );
    pub fn FreeTupleDesc(tupdesc: TupleDesc);
    pub fn IncrTupleDescRefCount(tupdesc: TupleDesc);
    pub fn DecrTupleDescRefCount(tupdesc: TupleDesc);
    pub fn equalTupleDescs(tupdesc1: TupleDesc, tupdesc2: TupleDesc) -> bool;
    pub fn hashTupleDesc(desc: TupleDesc) -> uint32;
    pub fn TupleDescInitEntry(
        desc: TupleDesc,
        attributeNumber: AttrNumber,
        attributeName: *const ::std::os::raw::c_char,
        oidtypeid: Oid,
        typmod: int32,
        attdim: ::std::os::raw::c_int,
    );
    pub fn TupleDescInitBuiltinEntry(
        desc: TupleDesc,
        attributeNumber: AttrNumber,
        attributeName: *const ::std::os::raw::c_char,
        oidtypeid: Oid,
        typmod: int32,
        attdim: ::std::os::raw::c_int,
    );
    pub fn TupleDescInitEntryCollation(
        desc: TupleDesc,
        attributeNumber: AttrNumber,
        collationid: Oid,
    );
    pub fn BuildDescForRelation(schema: *mut List) -> TupleDesc;
    pub fn BuildDescFromLists(
        names: *mut List,
        types: *mut List,
        typmods: *mut List,
        collations: *mut List,
    ) -> TupleDesc;
    pub fn make_attrmap(maplen: ::std::os::raw::c_int) -> *mut AttrMap;
    pub fn free_attrmap(map: *mut AttrMap);
    pub fn build_attrmap_by_name(
        indesc: TupleDesc,
        outdesc: TupleDesc,
        missing_ok: bool,
    ) -> *mut AttrMap;
    pub fn build_attrmap_by_name_if_req(
        indesc: TupleDesc,
        outdesc: TupleDesc,
        missing_ok: bool,
    ) -> *mut AttrMap;
    pub fn build_attrmap_by_position(
        indesc: TupleDesc,
        outdesc: TupleDesc,
        msg: *const ::std::os::raw::c_char,
    ) -> *mut AttrMap;
    pub fn ItemPointerEquals(pointer1: ItemPointer, pointer2: ItemPointer) -> bool;
    pub fn ItemPointerCompare(arg1: ItemPointer, arg2: ItemPointer) -> int32;
    pub fn ItemPointerInc(pointer: ItemPointer);
    pub fn ItemPointerDec(pointer: ItemPointer);
    pub fn HeapTupleHeaderGetCmin(tup: HeapTupleHeader) -> CommandId;
    pub fn HeapTupleHeaderGetCmax(tup: HeapTupleHeader) -> CommandId;
    pub fn HeapTupleHeaderAdjustCmax(
        tup: HeapTupleHeader,
        cmax: *mut CommandId,
        iscombo: *mut bool,
    );
    pub fn HeapTupleGetUpdateXid(tuple: HeapTupleHeader) -> TransactionId;
    pub fn TransactionStartedDuringRecovery() -> bool;
    pub fn TransactionIdDidCommit(transactionId: TransactionId) -> bool;
    pub fn TransactionIdDidAbort(transactionId: TransactionId) -> bool;
    pub fn TransactionIdCommitTree(
        xid: TransactionId,
        nxids: ::std::os::raw::c_int,
        xids: *mut TransactionId,
    );
    pub fn TransactionIdAsyncCommitTree(
        xid: TransactionId,
        nxids: ::std::os::raw::c_int,
        xids: *mut TransactionId,
        lsn: XLogRecPtr,
    );
    pub fn TransactionIdAbortTree(
        xid: TransactionId,
        nxids: ::std::os::raw::c_int,
        xids: *mut TransactionId,
    );
    pub fn TransactionIdPrecedes(id1: TransactionId, id2: TransactionId) -> bool;
    pub fn TransactionIdPrecedesOrEquals(id1: TransactionId, id2: TransactionId) -> bool;
    pub fn TransactionIdFollows(id1: TransactionId, id2: TransactionId) -> bool;
    pub fn TransactionIdFollowsOrEquals(id1: TransactionId, id2: TransactionId) -> bool;
    pub fn TransactionIdLatest(
        mainxid: TransactionId,
        nxids: ::std::os::raw::c_int,
        xids: *const TransactionId,
    ) -> TransactionId;
    pub fn TransactionIdGetCommitLSN(xid: TransactionId) -> XLogRecPtr;
    pub fn GetNewTransactionId(isSubXact: bool) -> FullTransactionId;
    pub fn AdvanceNextFullTransactionIdPastXid(xid: TransactionId);
    pub fn ReadNextFullTransactionId() -> FullTransactionId;
    pub fn SetTransactionIdLimit(oldest_datfrozenxid: TransactionId, oldest_datoid: Oid);
    pub fn AdvanceOldestClogXid(oldest_datfrozenxid: TransactionId);
    pub fn ForceTransactionIdLimitUpdate() -> bool;
    pub fn GetNewObjectId() -> Oid;
    pub fn StopGeneratingPinnedObjectIds();
    pub fn AssertTransactionIdInAllowableRange(xid: TransactionId);
    pub fn PageInit(page: Page, pageSize: Size, specialSize: Size);
    pub fn PageIsVerifiedExtended(
        page: Page,
        blkno: BlockNumber,
        flags: ::std::os::raw::c_int,
    ) -> bool;
    pub fn PageAddItemExtended(
        page: Page,
        item: Item,
        size: Size,
        offsetNumber: OffsetNumber,
        flags: ::std::os::raw::c_int,
    ) -> OffsetNumber;
    pub fn PageGetTempPage(page: Page) -> Page;
    pub fn PageGetTempPageCopy(page: Page) -> Page;
    pub fn PageGetTempPageCopySpecial(page: Page) -> Page;
    pub fn PageRestoreTempPage(tempPage: Page, oldPage: Page);
    pub fn PageRepairFragmentation(page: Page);
    pub fn PageTruncateLinePointerArray(page: Page);
    pub fn PageGetFreeSpace(page: Page) -> Size;
    pub fn PageGetFreeSpaceForMultipleTuples(page: Page, ntups: ::std::os::raw::c_int) -> Size;
    pub fn PageGetExactFreeSpace(page: Page) -> Size;
    pub fn PageGetHeapFreeSpace(page: Page) -> Size;
    pub fn PageIndexTupleDelete(page: Page, offnum: OffsetNumber);
    pub fn PageIndexMultiDelete(
        page: Page,
        itemnos: *mut OffsetNumber,
        nitems: ::std::os::raw::c_int,
    );
    pub fn PageIndexTupleDeleteNoCompact(page: Page, offnum: OffsetNumber);
    pub fn PageIndexTupleOverwrite(
        page: Page,
        offnum: OffsetNumber,
        newtup: Item,
        newsize: Size,
    ) -> bool;
    pub fn PageSetChecksumCopy(page: Page, blkno: BlockNumber) -> *mut ::std::os::raw::c_char;
    pub fn PageSetChecksumInplace(page: Page, blkno: BlockNumber);
    pub fn heap_compute_data_size(
        tupleDesc: TupleDesc,
        values: *mut Datum,
        isnull: *mut bool,
    ) -> Size;
    pub fn heap_fill_tuple(
        tupleDesc: TupleDesc,
        values: *mut Datum,
        isnull: *mut bool,
        data: *mut ::std::os::raw::c_char,
        data_size: Size,
        infomask: *mut uint16,
        bit: *mut bits8,
    );
    pub fn heap_attisnull(
        tup: HeapTuple,
        attnum: ::std::os::raw::c_int,
        tupleDesc: TupleDesc,
    ) -> bool;
    pub fn nocachegetattr(
        tup: HeapTuple,
        attnum: ::std::os::raw::c_int,
        tupleDesc: TupleDesc,
    ) -> Datum;
    pub fn heap_getsysattr(
        tup: HeapTuple,
        attnum: ::std::os::raw::c_int,
        tupleDesc: TupleDesc,
        isnull: *mut bool,
    ) -> Datum;
    pub fn getmissingattr(
        tupleDesc: TupleDesc,
        attnum: ::std::os::raw::c_int,
        isnull: *mut bool,
    ) -> Datum;
    pub fn heap_copytuple(tuple: HeapTuple) -> HeapTuple;
    pub fn heap_copytuple_with_tuple(src: HeapTuple, dest: HeapTuple);
    pub fn heap_copy_tuple_as_datum(tuple: HeapTuple, tupleDesc: TupleDesc) -> Datum;
    pub fn heap_form_tuple(
        tupleDescriptor: TupleDesc,
        values: *mut Datum,
        isnull: *mut bool,
    ) -> HeapTuple;
    pub fn heap_modify_tuple(
        tuple: HeapTuple,
        tupleDesc: TupleDesc,
        replValues: *mut Datum,
        replIsnull: *mut bool,
        doReplace: *mut bool,
    ) -> HeapTuple;
    pub fn heap_modify_tuple_by_cols(
        tuple: HeapTuple,
        tupleDesc: TupleDesc,
        nCols: ::std::os::raw::c_int,
        replCols: *mut ::std::os::raw::c_int,
        replValues: *mut Datum,
        replIsnull: *mut bool,
    ) -> HeapTuple;
    pub fn heap_deform_tuple(
        tuple: HeapTuple,
        tupleDesc: TupleDesc,
        values: *mut Datum,
        isnull: *mut bool,
    );
    pub fn heap_freetuple(htup: HeapTuple);
    pub fn heap_form_minimal_tuple(
        tupleDescriptor: TupleDesc,
        values: *mut Datum,
        isnull: *mut bool,
    ) -> MinimalTuple;
    pub fn heap_free_minimal_tuple(mtup: MinimalTuple);
    pub fn heap_copy_minimal_tuple(mtup: MinimalTuple) -> MinimalTuple;
    pub fn heap_tuple_from_minimal_tuple(mtup: MinimalTuple) -> HeapTuple;
    pub fn minimal_tuple_from_heap_tuple(htup: HeapTuple) -> MinimalTuple;
    pub fn heap_expand_tuple(sourceTuple: HeapTuple, tupleDesc: TupleDesc) -> HeapTuple;
    pub fn minimal_expand_tuple(sourceTuple: HeapTuple, tupleDesc: TupleDesc) -> MinimalTuple;
    pub fn MakeTupleTableSlot(
        tupleDesc: TupleDesc,
        tts_ops: *const TupleTableSlotOps,
    ) -> *mut TupleTableSlot;
    pub fn ExecAllocTableSlot(
        tupleTable: *mut *mut List,
        desc: TupleDesc,
        tts_ops: *const TupleTableSlotOps,
    ) -> *mut TupleTableSlot;
    pub fn ExecResetTupleTable(tupleTable: *mut List, shouldFree: bool);
    pub fn MakeSingleTupleTableSlot(
        tupdesc: TupleDesc,
        tts_ops: *const TupleTableSlotOps,
    ) -> *mut TupleTableSlot;
    pub fn ExecDropSingleTupleTableSlot(slot: *mut TupleTableSlot);
    pub fn ExecSetSlotDescriptor(slot: *mut TupleTableSlot, tupdesc: TupleDesc);
    pub fn ExecStoreHeapTuple(
        tuple: HeapTuple,
        slot: *mut TupleTableSlot,
        shouldFree: bool,
    ) -> *mut TupleTableSlot;
    pub fn ExecForceStoreHeapTuple(tuple: HeapTuple, slot: *mut TupleTableSlot, shouldFree: bool);
    pub fn ExecStoreBufferHeapTuple(
        tuple: HeapTuple,
        slot: *mut TupleTableSlot,
        buffer: Buffer,
    ) -> *mut TupleTableSlot;
    pub fn ExecStorePinnedBufferHeapTuple(
        tuple: HeapTuple,
        slot: *mut TupleTableSlot,
        buffer: Buffer,
    ) -> *mut TupleTableSlot;
    pub fn ExecStoreMinimalTuple(
        mtup: MinimalTuple,
        slot: *mut TupleTableSlot,
        shouldFree: bool,
    ) -> *mut TupleTableSlot;
    pub fn ExecForceStoreMinimalTuple(
        mtup: MinimalTuple,
        slot: *mut TupleTableSlot,
        shouldFree: bool,
    );
    pub fn ExecStoreVirtualTuple(slot: *mut TupleTableSlot) -> *mut TupleTableSlot;
    pub fn ExecStoreAllNullTuple(slot: *mut TupleTableSlot) -> *mut TupleTableSlot;
    pub fn ExecStoreHeapTupleDatum(data: Datum, slot: *mut TupleTableSlot);
    pub fn ExecFetchSlotHeapTuple(
        slot: *mut TupleTableSlot,
        materialize: bool,
        shouldFree: *mut bool,
    ) -> HeapTuple;
    pub fn ExecFetchSlotMinimalTuple(
        slot: *mut TupleTableSlot,
        shouldFree: *mut bool,
    ) -> MinimalTuple;
    pub fn ExecFetchSlotHeapTupleDatum(slot: *mut TupleTableSlot) -> Datum;
    pub fn slot_getmissingattrs(
        slot: *mut TupleTableSlot,
        startAttNum: ::std::os::raw::c_int,
        lastAttNum: ::std::os::raw::c_int,
    );
    pub fn slot_getsomeattrs_int(slot: *mut TupleTableSlot, attnum: ::std::os::raw::c_int);
    pub fn bms_copy(a: *const Bitmapset) -> *mut Bitmapset;
    pub fn bms_equal(a: *const Bitmapset, b: *const Bitmapset) -> bool;
    pub fn bms_compare(a: *const Bitmapset, b: *const Bitmapset) -> ::std::os::raw::c_int;
    pub fn bms_make_singleton(x: ::std::os::raw::c_int) -> *mut Bitmapset;
    pub fn bms_free(a: *mut Bitmapset);
    pub fn bms_union(a: *const Bitmapset, b: *const Bitmapset) -> *mut Bitmapset;
    pub fn bms_intersect(a: *const Bitmapset, b: *const Bitmapset) -> *mut Bitmapset;
    pub fn bms_difference(a: *const Bitmapset, b: *const Bitmapset) -> *mut Bitmapset;
    pub fn bms_is_subset(a: *const Bitmapset, b: *const Bitmapset) -> bool;
    pub fn bms_subset_compare(a: *const Bitmapset, b: *const Bitmapset) -> BMS_Comparison;
    pub fn bms_is_member(x: ::std::os::raw::c_int, a: *const Bitmapset) -> bool;
    pub fn bms_member_index(a: *mut Bitmapset, x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn bms_overlap(a: *const Bitmapset, b: *const Bitmapset) -> bool;
    pub fn bms_overlap_list(a: *const Bitmapset, b: *const List) -> bool;
    pub fn bms_nonempty_difference(a: *const Bitmapset, b: *const Bitmapset) -> bool;
    pub fn bms_singleton_member(a: *const Bitmapset) -> ::std::os::raw::c_int;
    pub fn bms_get_singleton_member(
        a: *const Bitmapset,
        member: *mut ::std::os::raw::c_int,
    ) -> bool;
    pub fn bms_num_members(a: *const Bitmapset) -> ::std::os::raw::c_int;
    pub fn bms_membership(a: *const Bitmapset) -> BMS_Membership;
    pub fn bms_add_member(a: *mut Bitmapset, x: ::std::os::raw::c_int) -> *mut Bitmapset;
    pub fn bms_del_member(a: *mut Bitmapset, x: ::std::os::raw::c_int) -> *mut Bitmapset;
    pub fn bms_add_members(a: *mut Bitmapset, b: *const Bitmapset) -> *mut Bitmapset;
    pub fn bms_add_range(
        a: *mut Bitmapset,
        lower: ::std::os::raw::c_int,
        upper: ::std::os::raw::c_int,
    ) -> *mut Bitmapset;
    pub fn bms_int_members(a: *mut Bitmapset, b: *const Bitmapset) -> *mut Bitmapset;
    pub fn bms_del_members(a: *mut Bitmapset, b: *const Bitmapset) -> *mut Bitmapset;
    pub fn bms_join(a: *mut Bitmapset, b: *mut Bitmapset) -> *mut Bitmapset;
    pub fn bms_next_member(
        a: *const Bitmapset,
        prevbit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn bms_prev_member(
        a: *const Bitmapset,
        prevbit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn bms_hash_value(a: *const Bitmapset) -> uint32;
    pub fn bitmap_hash(key: *const ::std::os::raw::c_void, keysize: Size) -> uint32;
    pub fn bitmap_match(
        key1: *const ::std::os::raw::c_void,
        key2: *const ::std::os::raw::c_void,
        keysize: Size,
    ) -> ::std::os::raw::c_int;
    pub fn convert_tuples_by_position(
        indesc: TupleDesc,
        outdesc: TupleDesc,
        msg: *const ::std::os::raw::c_char,
    ) -> *mut TupleConversionMap;
    pub fn convert_tuples_by_name(indesc: TupleDesc, outdesc: TupleDesc)
        -> *mut TupleConversionMap;
    pub fn convert_tuples_by_name_attrmap(
        indesc: TupleDesc,
        outdesc: TupleDesc,
        attrMap: *mut AttrMap,
    ) -> *mut TupleConversionMap;
    pub fn execute_attr_map_tuple(tuple: HeapTuple, map: *mut TupleConversionMap) -> HeapTuple;
    pub fn execute_attr_map_slot(
        attrMap: *mut AttrMap,
        in_slot: *mut TupleTableSlot,
        out_slot: *mut TupleTableSlot,
    ) -> *mut TupleTableSlot;
    pub fn execute_attr_map_cols(attrMap: *mut AttrMap, in_cols: *mut Bitmapset) -> *mut Bitmapset;
    pub fn free_conversion_map(map: *mut TupleConversionMap);
    pub fn InstrAlloc(
        n: ::std::os::raw::c_int,
        instrument_options: ::std::os::raw::c_int,
        async_mode: bool,
    ) -> *mut Instrumentation;
    pub fn InstrInit(instr: *mut Instrumentation, instrument_options: ::std::os::raw::c_int);
    pub fn InstrStartNode(instr: *mut Instrumentation);
    pub fn InstrStopNode(instr: *mut Instrumentation, nTuples: f64);
    pub fn InstrUpdateTupleCount(instr: *mut Instrumentation, nTuples: f64);
    pub fn InstrEndLoop(instr: *mut Instrumentation);
    pub fn InstrAggNode(dst: *mut Instrumentation, add: *mut Instrumentation);
    pub fn InstrStartParallelQuery();
    pub fn InstrEndParallelQuery(bufusage: *mut BufferUsage, walusage: *mut WalUsage);
    pub fn InstrAccumParallelQuery(bufusage: *mut BufferUsage, walusage: *mut WalUsage);
    pub fn BufferUsageAccumDiff(
        dst: *mut BufferUsage,
        add: *const BufferUsage,
        sub: *const BufferUsage,
    );
    pub fn WalUsageAccumDiff(dst: *mut WalUsage, add: *const WalUsage, sub: *const WalUsage);
    pub fn fmgr_info(functionId: Oid, finfo: *mut FmgrInfo);
    pub fn fmgr_info_cxt(functionId: Oid, finfo: *mut FmgrInfo, mcxt: MemoryContext);
    pub fn fmgr_info_copy(dstinfo: *mut FmgrInfo, srcinfo: *mut FmgrInfo, destcxt: MemoryContext);
    pub fn fmgr_symbol(
        functionId: Oid,
        mod_: *mut *mut ::std::os::raw::c_char,
        fn_: *mut *mut ::std::os::raw::c_char,
    );
    pub fn pg_detoast_datum(datum: *mut varlena) -> *mut varlena;
    pub fn pg_detoast_datum_copy(datum: *mut varlena) -> *mut varlena;
    pub fn pg_detoast_datum_slice(datum: *mut varlena, first: int32, count: int32) -> *mut varlena;
    pub fn pg_detoast_datum_packed(datum: *mut varlena) -> *mut varlena;
    pub fn _PG_init();
    pub fn _PG_fini();
    pub fn DirectFunctionCall1Coll(func: PGFunction, collation: Oid, arg1: Datum) -> Datum;
    pub fn DirectFunctionCall2Coll(
        func: PGFunction,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
    ) -> Datum;
    pub fn DirectFunctionCall3Coll(
        func: PGFunction,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
    ) -> Datum;
    pub fn DirectFunctionCall4Coll(
        func: PGFunction,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
    ) -> Datum;
    pub fn DirectFunctionCall5Coll(
        func: PGFunction,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
    ) -> Datum;
    pub fn DirectFunctionCall6Coll(
        func: PGFunction,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
    ) -> Datum;
    pub fn DirectFunctionCall7Coll(
        func: PGFunction,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
    ) -> Datum;
    pub fn DirectFunctionCall8Coll(
        func: PGFunction,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
        arg8: Datum,
    ) -> Datum;
    pub fn DirectFunctionCall9Coll(
        func: PGFunction,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
        arg8: Datum,
        arg9: Datum,
    ) -> Datum;
    pub fn CallerFInfoFunctionCall1(
        func: PGFunction,
        flinfo: *mut FmgrInfo,
        collation: Oid,
        arg1: Datum,
    ) -> Datum;
    pub fn CallerFInfoFunctionCall2(
        func: PGFunction,
        flinfo: *mut FmgrInfo,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
    ) -> Datum;
    pub fn FunctionCall0Coll(flinfo: *mut FmgrInfo, collation: Oid) -> Datum;
    pub fn FunctionCall1Coll(flinfo: *mut FmgrInfo, collation: Oid, arg1: Datum) -> Datum;
    pub fn FunctionCall2Coll(
        flinfo: *mut FmgrInfo,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
    ) -> Datum;
    pub fn FunctionCall3Coll(
        flinfo: *mut FmgrInfo,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
    ) -> Datum;
    pub fn FunctionCall4Coll(
        flinfo: *mut FmgrInfo,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
    ) -> Datum;
    pub fn FunctionCall5Coll(
        flinfo: *mut FmgrInfo,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
    ) -> Datum;
    pub fn FunctionCall6Coll(
        flinfo: *mut FmgrInfo,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
    ) -> Datum;
    pub fn FunctionCall7Coll(
        flinfo: *mut FmgrInfo,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
    ) -> Datum;
    pub fn FunctionCall8Coll(
        flinfo: *mut FmgrInfo,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
        arg8: Datum,
    ) -> Datum;
    pub fn FunctionCall9Coll(
        flinfo: *mut FmgrInfo,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
        arg8: Datum,
        arg9: Datum,
    ) -> Datum;
    pub fn OidFunctionCall0Coll(functionId: Oid, collation: Oid) -> Datum;
    pub fn OidFunctionCall1Coll(functionId: Oid, collation: Oid, arg1: Datum) -> Datum;
    pub fn OidFunctionCall2Coll(functionId: Oid, collation: Oid, arg1: Datum, arg2: Datum)
        -> Datum;
    pub fn OidFunctionCall3Coll(
        functionId: Oid,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
    ) -> Datum;
    pub fn OidFunctionCall4Coll(
        functionId: Oid,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
    ) -> Datum;
    pub fn OidFunctionCall5Coll(
        functionId: Oid,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
    ) -> Datum;
    pub fn OidFunctionCall6Coll(
        functionId: Oid,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
    ) -> Datum;
    pub fn OidFunctionCall7Coll(
        functionId: Oid,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
    ) -> Datum;
    pub fn OidFunctionCall8Coll(
        functionId: Oid,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
        arg8: Datum,
    ) -> Datum;
    pub fn OidFunctionCall9Coll(
        functionId: Oid,
        collation: Oid,
        arg1: Datum,
        arg2: Datum,
        arg3: Datum,
        arg4: Datum,
        arg5: Datum,
        arg6: Datum,
        arg7: Datum,
        arg8: Datum,
        arg9: Datum,
    ) -> Datum;
    pub fn InputFunctionCall(
        flinfo: *mut FmgrInfo,
        str_: *mut ::std::os::raw::c_char,
        typioparam: Oid,
        typmod: int32,
    ) -> Datum;
    pub fn InputFunctionCallSafe(
        flinfo: *mut FmgrInfo,
        str_: *mut ::std::os::raw::c_char,
        typioparam: Oid,
        typmod: int32,
        escontext: fmNodePtr,
        result: *mut Datum,
    ) -> bool;
    pub fn DirectInputFunctionCallSafe(
        func: PGFunction,
        str_: *mut ::std::os::raw::c_char,
        typioparam: Oid,
        typmod: int32,
        escontext: fmNodePtr,
        result: *mut Datum,
    ) -> bool;
    pub fn OidInputFunctionCall(
        functionId: Oid,
        str_: *mut ::std::os::raw::c_char,
        typioparam: Oid,
        typmod: int32,
    ) -> Datum;
    pub fn OutputFunctionCall(flinfo: *mut FmgrInfo, val: Datum) -> *mut ::std::os::raw::c_char;
    pub fn OidOutputFunctionCall(functionId: Oid, val: Datum) -> *mut ::std::os::raw::c_char;
    pub fn ReceiveFunctionCall(
        flinfo: *mut FmgrInfo,
        buf: fmStringInfo,
        typioparam: Oid,
        typmod: int32,
    ) -> Datum;
    pub fn OidReceiveFunctionCall(
        functionId: Oid,
        buf: fmStringInfo,
        typioparam: Oid,
        typmod: int32,
    ) -> Datum;
    pub fn SendFunctionCall(flinfo: *mut FmgrInfo, val: Datum) -> *mut bytea;
    pub fn OidSendFunctionCall(functionId: Oid, val: Datum) -> *mut bytea;
    pub fn fetch_finfo_record(
        filehandle: *mut ::std::os::raw::c_void,
        funcname: *const ::std::os::raw::c_char,
    ) -> *const Pg_finfo_record;
    pub fn fmgr_internal_function(proname: *const ::std::os::raw::c_char) -> Oid;
    pub fn get_fn_expr_rettype(flinfo: *mut FmgrInfo) -> Oid;
    pub fn get_fn_expr_argtype(flinfo: *mut FmgrInfo, argnum: ::std::os::raw::c_int) -> Oid;
    pub fn get_call_expr_argtype(expr: fmNodePtr, argnum: ::std::os::raw::c_int) -> Oid;
    pub fn get_fn_expr_arg_stable(flinfo: *mut FmgrInfo, argnum: ::std::os::raw::c_int) -> bool;
    pub fn get_call_expr_arg_stable(expr: fmNodePtr, argnum: ::std::os::raw::c_int) -> bool;
    pub fn get_fn_expr_variadic(flinfo: *mut FmgrInfo) -> bool;
    pub fn get_fn_opclass_options(flinfo: *mut FmgrInfo) -> *mut bytea;
    pub fn has_fn_opclass_options(flinfo: *mut FmgrInfo) -> bool;
    pub fn set_fn_opclass_options(flinfo: *mut FmgrInfo, options: *mut bytea);
    pub fn CheckFunctionValidatorAccess(validatorOid: Oid, functionOid: Oid) -> bool;
    pub fn load_external_function(
        filename: *const ::std::os::raw::c_char,
        funcname: *const ::std::os::raw::c_char,
        signalNotFound: bool,
        filehandle: *mut *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
    pub fn lookup_external_function(
        filehandle: *mut ::std::os::raw::c_void,
        funcname: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
    pub fn load_file(filename: *const ::std::os::raw::c_char, restricted: bool);
    pub fn find_rendezvous_variable(
        varName: *const ::std::os::raw::c_char,
    ) -> *mut *mut ::std::os::raw::c_void;
    pub fn EstimateLibraryStateSpace() -> Size;
    pub fn SerializeLibraryState(maxsize: Size, start_address: *mut ::std::os::raw::c_char);
    pub fn RestoreLibraryState(start_address: *mut ::std::os::raw::c_char);
    pub fn AggCheckCallContext(
        fcinfo: FunctionCallInfo,
        aggcontext: *mut MemoryContext,
    ) -> ::std::os::raw::c_int;
    pub fn AggGetAggref(fcinfo: FunctionCallInfo) -> fmAggrefPtr;
    pub fn AggGetTempMemoryContext(fcinfo: FunctionCallInfo) -> MemoryContext;
    pub fn AggStateIsShared(fcinfo: FunctionCallInfo) -> bool;
    pub fn AggRegisterCallback(
        fcinfo: FunctionCallInfo,
        func: fmExprContextCallbackFunction,
        arg: Datum,
    );
    pub fn slist_delete(head: *mut slist_head, node: *const slist_node);
    pub fn pairingheap_allocate(
        compare: pairingheap_comparator,
        arg: *mut ::std::os::raw::c_void,
    ) -> *mut pairingheap;
    pub fn pairingheap_free(heap: *mut pairingheap);
    pub fn pairingheap_add(heap: *mut pairingheap, node: *mut pairingheap_node);
    pub fn pairingheap_first(heap: *mut pairingheap) -> *mut pairingheap_node;
    pub fn pairingheap_remove_first(heap: *mut pairingheap) -> *mut pairingheap_node;
    pub fn pairingheap_remove(heap: *mut pairingheap, node: *mut pairingheap_node);
    pub fn makeParamList(numParams: ::std::os::raw::c_int) -> ParamListInfo;
    pub fn copyParamList(from: ParamListInfo) -> ParamListInfo;
    pub fn EstimateParamListSpace(paramLI: ParamListInfo) -> Size;
    pub fn SerializeParamList(
        paramLI: ParamListInfo,
        start_address: *mut *mut ::std::os::raw::c_char,
    );
    pub fn RestoreParamList(start_address: *mut *mut ::std::os::raw::c_char) -> ParamListInfo;
    pub fn BuildParamLogString(
        params: ParamListInfo,
        knownTextValues: *mut *mut ::std::os::raw::c_char,
        maxlen: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
    pub fn ParamsErrorCallback(arg: *mut ::std::os::raw::c_void);
    pub fn forkname_to_number(forkName: *const ::std::os::raw::c_char) -> ForkNumber;
    pub fn forkname_chars(
        str_: *const ::std::os::raw::c_char,
        fork: *mut ForkNumber,
    ) -> ::std::os::raw::c_int;
    pub fn GetDatabasePath(dbOid: Oid, spcOid: Oid) -> *mut ::std::os::raw::c_char;
    pub fn GetRelationPath(
        dbOid: Oid,
        spcOid: Oid,
        relNumber: RelFileNumber,
        backendId: ::std::os::raw::c_int,
        forkNumber: ForkNumber,
    ) -> *mut ::std::os::raw::c_char;
    pub fn makeInteger(i: ::std::os::raw::c_int) -> *mut Integer;
    pub fn makeFloat(numericStr: *mut ::std::os::raw::c_char) -> *mut Float;
    pub fn makeBoolean(val: bool) -> *mut Boolean;
    pub fn makeString(str_: *mut ::std::os::raw::c_char) -> *mut String;
    pub fn makeBitString(str_: *mut ::std::os::raw::c_char) -> *mut BitString;
    pub fn dsm_impl_op(
        op: dsm_op,
        handle: dsm_handle,
        request_size: Size,
        impl_private: *mut *mut ::std::os::raw::c_void,
        mapped_address: *mut *mut ::std::os::raw::c_void,
        mapped_size: *mut Size,
        elevel: ::std::os::raw::c_int,
    ) -> bool;
    pub fn dsm_impl_pin_segment(
        handle: dsm_handle,
        impl_private: *mut ::std::os::raw::c_void,
        impl_private_pm_handle: *mut *mut ::std::os::raw::c_void,
    );
    pub fn dsm_impl_unpin_segment(
        handle: dsm_handle,
        impl_private: *mut *mut ::std::os::raw::c_void,
    );
    pub fn dsm_cleanup_using_control_segment(old_control_handle: dsm_handle);
    pub fn dsm_postmaster_startup(arg1: *mut PGShmemHeader);
    pub fn dsm_backend_shutdown();
    pub fn dsm_detach_all();
    pub fn dsm_estimate_size() -> usize;
    pub fn dsm_shmem_init();
    pub fn dsm_create(size: Size, flags: ::std::os::raw::c_int) -> *mut dsm_segment;
    pub fn dsm_attach(h: dsm_handle) -> *mut dsm_segment;
    pub fn dsm_detach(seg: *mut dsm_segment);
    pub fn dsm_pin_mapping(seg: *mut dsm_segment);
    pub fn dsm_unpin_mapping(seg: *mut dsm_segment);
    pub fn dsm_pin_segment(seg: *mut dsm_segment);
    pub fn dsm_unpin_segment(handle: dsm_handle);
    pub fn dsm_find_mapping(handle: dsm_handle) -> *mut dsm_segment;
    pub fn dsm_segment_address(seg: *mut dsm_segment) -> *mut ::std::os::raw::c_void;
    pub fn dsm_segment_map_length(seg: *mut dsm_segment) -> Size;
    pub fn dsm_segment_handle(seg: *mut dsm_segment) -> dsm_handle;
    pub fn on_dsm_detach(seg: *mut dsm_segment, function: on_dsm_detach_callback, arg: Datum);
    pub fn cancel_on_dsm_detach(
        seg: *mut dsm_segment,
        function: on_dsm_detach_callback,
        arg: Datum,
    );
    pub fn reset_on_dsm_detach();
    pub fn dsa_create(tranche_id: ::std::os::raw::c_int) -> *mut dsa_area;
    pub fn dsa_create_in_place(
        place: *mut ::std::os::raw::c_void,
        size: usize,
        tranche_id: ::std::os::raw::c_int,
        segment: *mut dsm_segment,
    ) -> *mut dsa_area;
    pub fn dsa_attach(handle: dsa_handle) -> *mut dsa_area;
    pub fn dsa_attach_in_place(
        place: *mut ::std::os::raw::c_void,
        segment: *mut dsm_segment,
    ) -> *mut dsa_area;
    pub fn dsa_release_in_place(place: *mut ::std::os::raw::c_void);
    pub fn dsa_on_dsm_detach_release_in_place(arg1: *mut dsm_segment, arg2: Datum);
    pub fn dsa_on_shmem_exit_release_in_place(arg1: ::std::os::raw::c_int, arg2: Datum);
    pub fn dsa_pin_mapping(area: *mut dsa_area);
    pub fn dsa_detach(area: *mut dsa_area);
    pub fn dsa_pin(area: *mut dsa_area);
    pub fn dsa_unpin(area: *mut dsa_area);
    pub fn dsa_set_size_limit(area: *mut dsa_area, limit: usize);
    pub fn dsa_minimum_size() -> usize;
    pub fn dsa_get_handle(area: *mut dsa_area) -> dsa_handle;
    pub fn dsa_allocate_extended(
        area: *mut dsa_area,
        size: usize,
        flags: ::std::os::raw::c_int,
    ) -> dsa_pointer;
    pub fn dsa_free(area: *mut dsa_area, dp: dsa_pointer);
    pub fn dsa_get_address(area: *mut dsa_area, dp: dsa_pointer) -> *mut ::std::os::raw::c_void;
    pub fn dsa_trim(area: *mut dsa_area);
    pub fn dsa_dump(area: *mut dsa_area);
    pub fn tbm_create(maxbytes: ::std::os::raw::c_long, dsa: *mut dsa_area) -> *mut TIDBitmap;
    pub fn tbm_free(tbm: *mut TIDBitmap);
    pub fn tbm_free_shared_area(dsa: *mut dsa_area, dp: dsa_pointer);
    pub fn tbm_add_tuples(
        tbm: *mut TIDBitmap,
        tids: ItemPointer,
        ntids: ::std::os::raw::c_int,
        recheck: bool,
    );
    pub fn tbm_add_page(tbm: *mut TIDBitmap, pageno: BlockNumber);
    pub fn tbm_union(a: *mut TIDBitmap, b: *const TIDBitmap);
    pub fn tbm_intersect(a: *mut TIDBitmap, b: *const TIDBitmap);
    pub fn tbm_is_empty(tbm: *const TIDBitmap) -> bool;
    pub fn tbm_begin_iterate(tbm: *mut TIDBitmap) -> *mut TBMIterator;
    pub fn tbm_prepare_shared_iterate(tbm: *mut TIDBitmap) -> dsa_pointer;
    pub fn tbm_iterate(iterator: *mut TBMIterator) -> *mut TBMIterateResult;
    pub fn tbm_shared_iterate(iterator: *mut TBMSharedIterator) -> *mut TBMIterateResult;
    pub fn tbm_end_iterate(iterator: *mut TBMIterator);
    pub fn tbm_end_shared_iterate(iterator: *mut TBMSharedIterator);
    pub fn tbm_attach_shared_iterate(dsa: *mut dsa_area, dp: dsa_pointer)
        -> *mut TBMSharedIterator;
    pub fn tbm_calculate_entries(maxbytes: f64) -> ::std::os::raw::c_long;
    pub fn s_lock(
        lock: *mut slock_t,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn set_spins_per_delay(shared_spins_per_delay: ::std::os::raw::c_int);
    pub fn update_spins_per_delay(
        shared_spins_per_delay: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn perform_spin_delay(status: *mut SpinDelayStatus);
    pub fn finish_spin_delay(status: *mut SpinDelayStatus);
    pub fn SpinlockSemas() -> ::std::os::raw::c_int;
    pub fn SpinlockSemaSize() -> Size;
    pub fn ConditionVariableInit(cv: *mut ConditionVariable);
    pub fn ConditionVariableSleep(cv: *mut ConditionVariable, wait_event_info: uint32);
    pub fn ConditionVariableTimedSleep(
        cv: *mut ConditionVariable,
        timeout: ::std::os::raw::c_long,
        wait_event_info: uint32,
    ) -> bool;
    pub fn ConditionVariableCancelSleep() -> bool;
    pub fn ConditionVariablePrepareToSleep(cv: *mut ConditionVariable);
    pub fn ConditionVariableSignal(cv: *mut ConditionVariable);
    pub fn ConditionVariableBroadcast(cv: *mut ConditionVariable);
    pub fn hash_create(
        tabname: *const ::std::os::raw::c_char,
        nelem: ::std::os::raw::c_long,
        info: *const HASHCTL,
        flags: ::std::os::raw::c_int,
    ) -> *mut HTAB;
    pub fn hash_destroy(hashp: *mut HTAB);
    pub fn hash_stats(where_: *const ::std::os::raw::c_char, hashp: *mut HTAB);
    pub fn hash_search(
        hashp: *mut HTAB,
        keyPtr: *const ::std::os::raw::c_void,
        action: HASHACTION,
        foundPtr: *mut bool,
    ) -> *mut ::std::os::raw::c_void;
    pub fn get_hash_value(hashp: *mut HTAB, keyPtr: *const ::std::os::raw::c_void) -> uint32;
    pub fn hash_search_with_hash_value(
        hashp: *mut HTAB,
        keyPtr: *const ::std::os::raw::c_void,
        hashvalue: uint32,
        action: HASHACTION,
        foundPtr: *mut bool,
    ) -> *mut ::std::os::raw::c_void;
    pub fn hash_update_hash_key(
        hashp: *mut HTAB,
        existingEntry: *mut ::std::os::raw::c_void,
        newKeyPtr: *const ::std::os::raw::c_void,
    ) -> bool;
    pub fn hash_get_num_entries(hashp: *mut HTAB) -> ::std::os::raw::c_long;
    pub fn hash_seq_init(status: *mut HASH_SEQ_STATUS, hashp: *mut HTAB);
    pub fn hash_seq_search(status: *mut HASH_SEQ_STATUS) -> *mut ::std::os::raw::c_void;
    pub fn hash_seq_term(status: *mut HASH_SEQ_STATUS);
    pub fn hash_freeze(hashp: *mut HTAB);
    pub fn hash_estimate_size(num_entries: ::std::os::raw::c_long, entrysize: Size) -> Size;
    pub fn hash_select_dirsize(num_entries: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
    pub fn hash_get_shared_size(info: *mut HASHCTL, flags: ::std::os::raw::c_int) -> Size;
    pub fn AtEOXact_HashTables(isCommit: bool);
    pub fn AtEOSubXact_HashTables(isCommit: bool, nestDepth: ::std::os::raw::c_int);
    pub fn create_queryEnv() -> *mut QueryEnvironment;
    pub fn get_visible_ENR_metadata(
        queryEnv: *mut QueryEnvironment,
        refname: *const ::std::os::raw::c_char,
    ) -> EphemeralNamedRelationMetadata;
    pub fn register_ENR(queryEnv: *mut QueryEnvironment, enr: EphemeralNamedRelation);
    pub fn unregister_ENR(queryEnv: *mut QueryEnvironment, name: *const ::std::os::raw::c_char);
    pub fn get_ENR(
        queryEnv: *mut QueryEnvironment,
        name: *const ::std::os::raw::c_char,
    ) -> EphemeralNamedRelation;
    pub fn ENRMetadataGetTupDesc(enrmd: EphemeralNamedRelationMetadata) -> TupleDesc;
    pub fn PathNameOpenFile(
        fileName: *const ::std::os::raw::c_char,
        fileFlags: ::std::os::raw::c_int,
    ) -> File;
    pub fn PathNameOpenFilePerm(
        fileName: *const ::std::os::raw::c_char,
        fileFlags: ::std::os::raw::c_int,
        fileMode: mode_t,
    ) -> File;
    pub fn OpenTemporaryFile(interXact: bool) -> File;
    pub fn FileClose(file: File);
    pub fn FilePrefetch(
        file: File,
        offset: off_t,
        amount: off_t,
        wait_event_info: uint32,
    ) -> ::std::os::raw::c_int;
    pub fn FileRead(
        file: File,
        buffer: *mut ::std::os::raw::c_void,
        amount: usize,
        offset: off_t,
        wait_event_info: uint32,
    ) -> ::std::os::raw::c_int;
    pub fn FileWrite(
        file: File,
        buffer: *const ::std::os::raw::c_void,
        amount: usize,
        offset: off_t,
        wait_event_info: uint32,
    ) -> ::std::os::raw::c_int;
    pub fn FileSync(file: File, wait_event_info: uint32) -> ::std::os::raw::c_int;
    pub fn FileZero(
        file: File,
        offset: off_t,
        amount: off_t,
        wait_event_info: uint32,
    ) -> ::std::os::raw::c_int;
    pub fn FileFallocate(
        file: File,
        offset: off_t,
        amount: off_t,
        wait_event_info: uint32,
    ) -> ::std::os::raw::c_int;
    pub fn FileSize(file: File) -> off_t;
    pub fn FileTruncate(
        file: File,
        offset: off_t,
        wait_event_info: uint32,
    ) -> ::std::os::raw::c_int;
    pub fn FileWriteback(file: File, offset: off_t, nbytes: off_t, wait_event_info: uint32);
    pub fn FilePathName(file: File) -> *mut ::std::os::raw::c_char;
    pub fn FileGetRawDesc(file: File) -> ::std::os::raw::c_int;
    pub fn FileGetRawFlags(file: File) -> ::std::os::raw::c_int;
    pub fn FileGetRawMode(file: File) -> mode_t;
    pub fn PathNameCreateTemporaryFile(
        path: *const ::std::os::raw::c_char,
        error_on_failure: bool,
    ) -> File;
    pub fn PathNameOpenTemporaryFile(
        path: *const ::std::os::raw::c_char,
        mode: ::std::os::raw::c_int,
    ) -> File;
    pub fn PathNameDeleteTemporaryFile(
        path: *const ::std::os::raw::c_char,
        error_on_failure: bool,
    ) -> bool;
    pub fn PathNameCreateTemporaryDir(
        basedir: *const ::std::os::raw::c_char,
        directory: *const ::std::os::raw::c_char,
    );
    pub fn PathNameDeleteTemporaryDir(dirname: *const ::std::os::raw::c_char);
    pub fn TempTablespacePath(path: *mut ::std::os::raw::c_char, tablespace: Oid);
    pub fn AllocateFile(
        name: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
    pub fn FreeFile(file: *mut FILE) -> ::std::os::raw::c_int;
    pub fn OpenPipeStream(
        command: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
    pub fn ClosePipeStream(file: *mut FILE) -> ::std::os::raw::c_int;
    pub fn AllocateDir(dirname: *const ::std::os::raw::c_char) -> *mut DIR;
    pub fn ReadDir(dir: *mut DIR, dirname: *const ::std::os::raw::c_char) -> *mut dirent;
    pub fn ReadDirExtended(
        dir: *mut DIR,
        dirname: *const ::std::os::raw::c_char,
        elevel: ::std::os::raw::c_int,
    ) -> *mut dirent;
    pub fn FreeDir(dir: *mut DIR) -> ::std::os::raw::c_int;
    pub fn OpenTransientFile(
        fileName: *const ::std::os::raw::c_char,
        fileFlags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn OpenTransientFilePerm(
        fileName: *const ::std::os::raw::c_char,
        fileFlags: ::std::os::raw::c_int,
        fileMode: mode_t,
    ) -> ::std::os::raw::c_int;
    pub fn CloseTransientFile(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn BasicOpenFile(
        fileName: *const ::std::os::raw::c_char,
        fileFlags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn BasicOpenFilePerm(
        fileName: *const ::std::os::raw::c_char,
        fileFlags: ::std::os::raw::c_int,
        fileMode: mode_t,
    ) -> ::std::os::raw::c_int;
    pub fn AcquireExternalFD() -> bool;
    pub fn ReserveExternalFD();
    pub fn ReleaseExternalFD();
    pub fn MakePGDirectory(directoryName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn InitFileAccess();
    pub fn InitTemporaryFileAccess();
    pub fn set_max_safe_fds();
    pub fn closeAllVfds();
    pub fn SetTempTablespaces(tableSpaces: *mut Oid, numSpaces: ::std::os::raw::c_int);
    pub fn TempTablespacesAreSet() -> bool;
    pub fn GetTempTablespaces(
        tableSpaces: *mut Oid,
        numSpaces: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn GetNextTempTableSpace() -> Oid;
    pub fn AtEOXact_Files(isCommit: bool);
    pub fn AtEOSubXact_Files(
        isCommit: bool,
        mySubid: SubTransactionId,
        parentSubid: SubTransactionId,
    );
    pub fn RemovePgTempFiles();
    pub fn RemovePgTempFilesInDir(
        tmpdirname: *const ::std::os::raw::c_char,
        missing_ok: bool,
        unlink_all: bool,
    );
    pub fn looks_like_temp_rel_name(name: *const ::std::os::raw::c_char) -> bool;
    pub fn pg_fsync(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn pg_fsync_no_writethrough(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn pg_fsync_writethrough(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn pg_fdatasync(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn pg_flush_data(fd: ::std::os::raw::c_int, offset: off_t, nbytes: off_t);
    pub fn pg_truncate(path: *const ::std::os::raw::c_char, length: off_t)
        -> ::std::os::raw::c_int;
    pub fn fsync_fname(fname: *const ::std::os::raw::c_char, isdir: bool);
    pub fn fsync_fname_ext(
        fname: *const ::std::os::raw::c_char,
        isdir: bool,
        ignore_perm: bool,
        elevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn durable_rename(
        oldfile: *const ::std::os::raw::c_char,
        newfile: *const ::std::os::raw::c_char,
        elevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn durable_unlink(
        fname: *const ::std::os::raw::c_char,
        elevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn SyncDataDirectory();
    pub fn data_sync_elevel(elevel: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn FileSetInit(fileset: *mut FileSet);
    pub fn FileSetCreate(fileset: *mut FileSet, name: *const ::std::os::raw::c_char) -> File;
    pub fn FileSetOpen(
        fileset: *mut FileSet,
        name: *const ::std::os::raw::c_char,
        mode: ::std::os::raw::c_int,
    ) -> File;
    pub fn FileSetDelete(
        fileset: *mut FileSet,
        name: *const ::std::os::raw::c_char,
        error_on_failure: bool,
    ) -> bool;
    pub fn FileSetDeleteAll(fileset: *mut FileSet);
    pub fn SharedFileSetInit(fileset: *mut SharedFileSet, seg: *mut dsm_segment);
    pub fn SharedFileSetAttach(fileset: *mut SharedFileSet, seg: *mut dsm_segment);
    pub fn SharedFileSetDeleteAll(fileset: *mut SharedFileSet);
    pub fn sts_estimate(participants: ::std::os::raw::c_int) -> usize;
    pub fn sts_initialize(
        sts: *mut SharedTuplestore,
        participants: ::std::os::raw::c_int,
        my_participant_number: ::std::os::raw::c_int,
        meta_data_size: usize,
        flags: ::std::os::raw::c_int,
        fileset: *mut SharedFileSet,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SharedTuplestoreAccessor;
    pub fn sts_attach(
        sts: *mut SharedTuplestore,
        my_participant_number: ::std::os::raw::c_int,
        fileset: *mut SharedFileSet,
    ) -> *mut SharedTuplestoreAccessor;
    pub fn sts_end_write(accessor: *mut SharedTuplestoreAccessor);
    pub fn sts_reinitialize(accessor: *mut SharedTuplestoreAccessor);
    pub fn sts_begin_parallel_scan(accessor: *mut SharedTuplestoreAccessor);
    pub fn sts_end_parallel_scan(accessor: *mut SharedTuplestoreAccessor);
    pub fn sts_puttuple(
        accessor: *mut SharedTuplestoreAccessor,
        meta_data: *mut ::std::os::raw::c_void,
        tuple: MinimalTuple,
    );
    pub fn sts_parallel_scan_next(
        accessor: *mut SharedTuplestoreAccessor,
        meta_data: *mut ::std::os::raw::c_void,
    ) -> MinimalTuple;
    pub fn RelationIdGetRelation(relationId: Oid) -> Relation;
    pub fn RelationClose(relation: Relation);
    pub fn RelationGetFKeyList(relation: Relation) -> *mut List;
    pub fn RelationGetIndexList(relation: Relation) -> *mut List;
    pub fn RelationGetStatExtList(relation: Relation) -> *mut List;
    pub fn RelationGetPrimaryKeyIndex(relation: Relation) -> Oid;
    pub fn RelationGetReplicaIndex(relation: Relation) -> Oid;
    pub fn RelationGetIndexExpressions(relation: Relation) -> *mut List;
    pub fn RelationGetDummyIndexExpressions(relation: Relation) -> *mut List;
    pub fn RelationGetIndexPredicate(relation: Relation) -> *mut List;
    pub fn RelationGetIndexRawAttOptions(indexrel: Relation) -> *mut Datum;
    pub fn RelationGetIndexAttOptions(relation: Relation, copy: bool) -> *mut *mut bytea;
    pub fn RelationGetIndexAttrBitmap(
        relation: Relation,
        attrKind: IndexAttrBitmapKind,
    ) -> *mut Bitmapset;
    pub fn RelationGetIdentityKeyBitmap(relation: Relation) -> *mut Bitmapset;
    pub fn RelationGetExclusionInfo(
        indexRelation: Relation,
        operators: *mut *mut Oid,
        procs: *mut *mut Oid,
        strategies: *mut *mut uint16,
    );
    pub fn RelationInitIndexAccessInfo(relation: Relation);
    pub fn RelationBuildPublicationDesc(relation: Relation, pubdesc: *mut PublicationDesc);
    pub fn RelationInitTableAccessMethod(relation: Relation);
    pub fn errtable(rel: Relation) -> ::std::os::raw::c_int;
    pub fn errtablecol(rel: Relation, attnum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn errtablecolname(
        rel: Relation,
        colname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn errtableconstraint(
        rel: Relation,
        conname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn RelationCacheInitialize();
    pub fn RelationCacheInitializePhase2();
    pub fn RelationCacheInitializePhase3();
    pub fn RelationBuildLocalRelation(
        relname: *const ::std::os::raw::c_char,
        relnamespace: Oid,
        tupDesc: TupleDesc,
        relid: Oid,
        accessmtd: Oid,
        relfilenumber: RelFileNumber,
        reltablespace: Oid,
        shared_relation: bool,
        mapped_relation: bool,
        relpersistence: ::std::os::raw::c_char,
        relkind: ::std::os::raw::c_char,
    ) -> Relation;
    pub fn RelationSetNewRelfilenumber(relation: Relation, persistence: ::std::os::raw::c_char);
    pub fn RelationAssumeNewRelfilelocator(relation: Relation);
    pub fn RelationForgetRelation(rid: Oid);
    pub fn RelationCacheInvalidateEntry(relationId: Oid);
    pub fn RelationCacheInvalidate(debug_discard: bool);
    pub fn RelationCloseSmgrByOid(relationId: Oid);
    pub fn AssertPendingSyncs_RelationCache();
    pub fn AtEOXact_RelationCache(isCommit: bool);
    pub fn AtEOSubXact_RelationCache(
        isCommit: bool,
        mySubid: SubTransactionId,
        parentSubid: SubTransactionId,
    );
    pub fn RelationIdIsInInitFile(relationId: Oid) -> bool;
    pub fn RelationCacheInitFilePreInvalidate();
    pub fn RelationCacheInitFilePostInvalidate();
    pub fn RelationCacheInitFileRemove();
    pub fn ssup_datum_unsigned_cmp(x: Datum, y: Datum, ssup: SortSupport) -> ::std::os::raw::c_int;
    pub fn ssup_datum_signed_cmp(x: Datum, y: Datum, ssup: SortSupport) -> ::std::os::raw::c_int;
    pub fn ssup_datum_int32_cmp(x: Datum, y: Datum, ssup: SortSupport) -> ::std::os::raw::c_int;
    pub fn PrepareSortSupportComparisonShim(cmpFunc: Oid, ssup: SortSupport);
    pub fn PrepareSortSupportFromOrderingOp(orderingOp: Oid, ssup: SortSupport);
    pub fn PrepareSortSupportFromIndexRel(indexRel: Relation, strategy: int16, ssup: SortSupport);
    pub fn PrepareSortSupportFromGistIndexRel(indexRel: Relation, ssup: SortSupport);
    pub fn index_form_tuple(
        tupleDescriptor: TupleDesc,
        values: *mut Datum,
        isnull: *mut bool,
    ) -> IndexTuple;
    pub fn index_form_tuple_context(
        tupleDescriptor: TupleDesc,
        values: *mut Datum,
        isnull: *mut bool,
        context: MemoryContext,
    ) -> IndexTuple;
    pub fn nocache_index_getattr(
        tup: IndexTuple,
        attnum: ::std::os::raw::c_int,
        tupleDesc: TupleDesc,
    ) -> Datum;
    pub fn index_deform_tuple(
        tup: IndexTuple,
        tupleDescriptor: TupleDesc,
        values: *mut Datum,
        isnull: *mut bool,
    );
    pub fn index_deform_tuple_internal(
        tupleDescriptor: TupleDesc,
        values: *mut Datum,
        isnull: *mut bool,
        tp: *mut ::std::os::raw::c_char,
        bp: *mut bits8,
        hasnulls: ::std::os::raw::c_int,
    );
    pub fn CopyIndexTuple(source: IndexTuple) -> IndexTuple;
    pub fn index_truncate_tuple(
        sourceDescriptor: TupleDesc,
        source: IndexTuple,
        leavenatts: ::std::os::raw::c_int,
    ) -> IndexTuple;
    pub fn LogicalTapeSetCreate(
        preallocate: bool,
        fileset: *mut SharedFileSet,
        worker: ::std::os::raw::c_int,
    ) -> *mut LogicalTapeSet;
    pub fn LogicalTapeClose(lt: *mut LogicalTape);
    pub fn LogicalTapeSetClose(lts: *mut LogicalTapeSet);
    pub fn LogicalTapeCreate(lts: *mut LogicalTapeSet) -> *mut LogicalTape;
    pub fn LogicalTapeImport(
        lts: *mut LogicalTapeSet,
        worker: ::std::os::raw::c_int,
        shared: *mut TapeShare,
    ) -> *mut LogicalTape;
    pub fn LogicalTapeSetForgetFreeSpace(lts: *mut LogicalTapeSet);
    pub fn LogicalTapeRead(
        lt: *mut LogicalTape,
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> usize;
    pub fn LogicalTapeWrite(lt: *mut LogicalTape, ptr: *const ::std::os::raw::c_void, size: usize);
    pub fn LogicalTapeRewindForRead(lt: *mut LogicalTape, buffer_size: usize);
    pub fn LogicalTapeFreeze(lt: *mut LogicalTape, share: *mut TapeShare);
    pub fn LogicalTapeBackspace(lt: *mut LogicalTape, size: usize) -> usize;
    pub fn LogicalTapeSeek(
        lt: *mut LogicalTape,
        blocknum: ::std::os::raw::c_long,
        offset: ::std::os::raw::c_int,
    );
    pub fn LogicalTapeTell(
        lt: *mut LogicalTape,
        blocknum: *mut ::std::os::raw::c_long,
        offset: *mut ::std::os::raw::c_int,
    );
    pub fn LogicalTapeSetBlocks(lts: *mut LogicalTapeSet) -> ::std::os::raw::c_long;
    pub fn tuplesort_begin_common(
        workMem: ::std::os::raw::c_int,
        coordinate: SortCoordinate,
        sortopt: ::std::os::raw::c_int,
    ) -> *mut Tuplesortstate;
    pub fn tuplesort_set_bound(state: *mut Tuplesortstate, bound: int64);
    pub fn tuplesort_used_bound(state: *mut Tuplesortstate) -> bool;
    pub fn tuplesort_puttuple_common(
        state: *mut Tuplesortstate,
        tuple: *mut SortTuple,
        useAbbrev: bool,
    );
    pub fn tuplesort_performsort(state: *mut Tuplesortstate);
    pub fn tuplesort_gettuple_common(
        state: *mut Tuplesortstate,
        forward: bool,
        stup: *mut SortTuple,
    ) -> bool;
    pub fn tuplesort_skiptuples(state: *mut Tuplesortstate, ntuples: int64, forward: bool) -> bool;
    pub fn tuplesort_end(state: *mut Tuplesortstate);
    pub fn tuplesort_reset(state: *mut Tuplesortstate);
    pub fn tuplesort_get_stats(state: *mut Tuplesortstate, stats: *mut TuplesortInstrumentation);
    pub fn tuplesort_method_name(m: TuplesortMethod) -> *const ::std::os::raw::c_char;
    pub fn tuplesort_space_type_name(t: TuplesortSpaceType) -> *const ::std::os::raw::c_char;
    pub fn tuplesort_merge_order(allowedMem: int64) -> ::std::os::raw::c_int;
    pub fn tuplesort_estimate_shared(nWorkers: ::std::os::raw::c_int) -> Size;
    pub fn tuplesort_initialize_shared(
        shared: *mut Sharedsort,
        nWorkers: ::std::os::raw::c_int,
        seg: *mut dsm_segment,
    );
    pub fn tuplesort_attach_shared(shared: *mut Sharedsort, seg: *mut dsm_segment);
    pub fn tuplesort_rescan(state: *mut Tuplesortstate);
    pub fn tuplesort_markpos(state: *mut Tuplesortstate);
    pub fn tuplesort_restorepos(state: *mut Tuplesortstate);
    pub fn tuplesort_readtup_alloc(
        state: *mut Tuplesortstate,
        tuplen: Size,
    ) -> *mut ::std::os::raw::c_void;
    pub fn tuplesort_begin_heap(
        tupDesc: TupleDesc,
        nkeys: ::std::os::raw::c_int,
        attNums: *mut AttrNumber,
        sortOperators: *mut Oid,
        sortCollations: *mut Oid,
        nullsFirstFlags: *mut bool,
        workMem: ::std::os::raw::c_int,
        coordinate: SortCoordinate,
        sortopt: ::std::os::raw::c_int,
    ) -> *mut Tuplesortstate;
    pub fn tuplesort_begin_cluster(
        tupDesc: TupleDesc,
        indexRel: Relation,
        workMem: ::std::os::raw::c_int,
        coordinate: SortCoordinate,
        sortopt: ::std::os::raw::c_int,
    ) -> *mut Tuplesortstate;
    pub fn tuplesort_begin_index_btree(
        heapRel: Relation,
        indexRel: Relation,
        enforceUnique: bool,
        uniqueNullsNotDistinct: bool,
        workMem: ::std::os::raw::c_int,
        coordinate: SortCoordinate,
        sortopt: ::std::os::raw::c_int,
    ) -> *mut Tuplesortstate;
    pub fn tuplesort_begin_index_hash(
        heapRel: Relation,
        indexRel: Relation,
        high_mask: uint32,
        low_mask: uint32,
        max_buckets: uint32,
        workMem: ::std::os::raw::c_int,
        coordinate: SortCoordinate,
        sortopt: ::std::os::raw::c_int,
    ) -> *mut Tuplesortstate;
    pub fn tuplesort_begin_index_gist(
        heapRel: Relation,
        indexRel: Relation,
        workMem: ::std::os::raw::c_int,
        coordinate: SortCoordinate,
        sortopt: ::std::os::raw::c_int,
    ) -> *mut Tuplesortstate;
    pub fn tuplesort_begin_datum(
        datumType: Oid,
        sortOperator: Oid,
        sortCollation: Oid,
        nullsFirstFlag: bool,
        workMem: ::std::os::raw::c_int,
        coordinate: SortCoordinate,
        sortopt: ::std::os::raw::c_int,
    ) -> *mut Tuplesortstate;
    pub fn tuplesort_puttupleslot(state: *mut Tuplesortstate, slot: *mut TupleTableSlot);
    pub fn tuplesort_putheaptuple(state: *mut Tuplesortstate, tup: HeapTuple);
    pub fn tuplesort_putindextuplevalues(
        state: *mut Tuplesortstate,
        rel: Relation,
        self_: ItemPointer,
        values: *mut Datum,
        isnull: *mut bool,
    );
    pub fn tuplesort_putdatum(state: *mut Tuplesortstate, val: Datum, isNull: bool);
    pub fn tuplesort_gettupleslot(
        state: *mut Tuplesortstate,
        forward: bool,
        copy: bool,
        slot: *mut TupleTableSlot,
        abbrev: *mut Datum,
    ) -> bool;
    pub fn tuplesort_getheaptuple(state: *mut Tuplesortstate, forward: bool) -> HeapTuple;
    pub fn tuplesort_getindextuple(state: *mut Tuplesortstate, forward: bool) -> IndexTuple;
    pub fn tuplesort_getdatum(
        state: *mut Tuplesortstate,
        forward: bool,
        copy: bool,
        val: *mut Datum,
        isNull: *mut bool,
        abbrev: *mut Datum,
    ) -> bool;
    pub fn tuplestore_begin_heap(
        randomAccess: bool,
        interXact: bool,
        maxKBytes: ::std::os::raw::c_int,
    ) -> *mut Tuplestorestate;
    pub fn tuplestore_set_eflags(state: *mut Tuplestorestate, eflags: ::std::os::raw::c_int);
    pub fn tuplestore_puttupleslot(state: *mut Tuplestorestate, slot: *mut TupleTableSlot);
    pub fn tuplestore_puttuple(state: *mut Tuplestorestate, tuple: HeapTuple);
    pub fn tuplestore_putvalues(
        state: *mut Tuplestorestate,
        tdesc: TupleDesc,
        values: *mut Datum,
        isnull: *mut bool,
    );
    pub fn tuplestore_alloc_read_pointer(
        state: *mut Tuplestorestate,
        eflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn tuplestore_select_read_pointer(state: *mut Tuplestorestate, ptr: ::std::os::raw::c_int);
    pub fn tuplestore_copy_read_pointer(
        state: *mut Tuplestorestate,
        srcptr: ::std::os::raw::c_int,
        destptr: ::std::os::raw::c_int,
    );
    pub fn tuplestore_trim(state: *mut Tuplestorestate);
    pub fn tuplestore_in_memory(state: *mut Tuplestorestate) -> bool;
    pub fn tuplestore_gettupleslot(
        state: *mut Tuplestorestate,
        forward: bool,
        copy: bool,
        slot: *mut TupleTableSlot,
    ) -> bool;
    pub fn tuplestore_advance(state: *mut Tuplestorestate, forward: bool) -> bool;
    pub fn tuplestore_skiptuples(
        state: *mut Tuplestorestate,
        ntuples: int64,
        forward: bool,
    ) -> bool;
    pub fn tuplestore_tuple_count(state: *mut Tuplestorestate) -> int64;
    pub fn tuplestore_ateof(state: *mut Tuplestorestate) -> bool;
    pub fn tuplestore_rescan(state: *mut Tuplestorestate);
    pub fn tuplestore_clear(state: *mut Tuplestorestate);
    pub fn tuplestore_end(state: *mut Tuplestorestate);
    pub fn pg_popcount(buf: *const ::std::os::raw::c_char, bytes: ::std::os::raw::c_int) -> uint64;
    pub fn tuplehash_create(
        ctx: MemoryContext,
        nelements: uint32,
        private_data: *mut ::std::os::raw::c_void,
    ) -> *mut tuplehash_hash;
    pub fn tuplehash_destroy(tb: *mut tuplehash_hash);
    pub fn tuplehash_reset(tb: *mut tuplehash_hash);
    pub fn tuplehash_grow(tb: *mut tuplehash_hash, newsize: uint64);
    pub fn tuplehash_insert(
        tb: *mut tuplehash_hash,
        key: MinimalTuple,
        found: *mut bool,
    ) -> *mut TupleHashEntryData;
    pub fn tuplehash_insert_hash(
        tb: *mut tuplehash_hash,
        key: MinimalTuple,
        hash: uint32,
        found: *mut bool,
    ) -> *mut TupleHashEntryData;
    pub fn tuplehash_lookup(tb: *mut tuplehash_hash, key: MinimalTuple) -> *mut TupleHashEntryData;
    pub fn tuplehash_lookup_hash(
        tb: *mut tuplehash_hash,
        key: MinimalTuple,
        hash: uint32,
    ) -> *mut TupleHashEntryData;
    pub fn tuplehash_delete_item(tb: *mut tuplehash_hash, entry: *mut TupleHashEntryData);
    pub fn tuplehash_delete(tb: *mut tuplehash_hash, key: MinimalTuple) -> bool;
    pub fn tuplehash_start_iterate(tb: *mut tuplehash_hash, iter: *mut tuplehash_iterator);
    pub fn tuplehash_start_iterate_at(
        tb: *mut tuplehash_hash,
        iter: *mut tuplehash_iterator,
        at: uint32,
    );
    pub fn tuplehash_iterate(
        tb: *mut tuplehash_hash,
        iter: *mut tuplehash_iterator,
    ) -> *mut TupleHashEntryData;
    pub fn tuplehash_stat(tb: *mut tuplehash_hash);
    pub fn InitializeQueryCompletion(qc: *mut QueryCompletion);
    pub fn GetCommandTagName(commandTag: CommandTag) -> *const ::std::os::raw::c_char;
    pub fn GetCommandTagNameAndLen(
        commandTag: CommandTag,
        len: *mut Size,
    ) -> *const ::std::os::raw::c_char;
    pub fn command_tag_display_rowcount(commandTag: CommandTag) -> bool;
    pub fn command_tag_event_trigger_ok(commandTag: CommandTag) -> bool;
    pub fn command_tag_table_rewrite_ok(commandTag: CommandTag) -> bool;
    pub fn GetCommandTagEnum(commandname: *const ::std::os::raw::c_char) -> CommandTag;
    pub fn BuildQueryCompletionString(
        buff: *mut ::std::os::raw::c_char,
        qc: *const QueryCompletion,
        nameonly: bool,
    ) -> Size;
    pub fn BeginCommand(commandTag: CommandTag, dest: CommandDest);
    pub fn CreateDestReceiver(dest: CommandDest) -> *mut DestReceiver;
    pub fn EndCommand(
        qc: *const QueryCompletion,
        dest: CommandDest,
        force_undecorated_output: bool,
    );
    pub fn EndReplicationCommand(commandTag: *const ::std::os::raw::c_char);
    pub fn NullCommand(dest: CommandDest);
    pub fn ReadyForQuery(dest: CommandDest);
    pub fn CreateQueryDesc(
        plannedstmt: *mut PlannedStmt,
        sourceText: *const ::std::os::raw::c_char,
        snapshot: Snapshot,
        crosscheck_snapshot: Snapshot,
        dest: *mut DestReceiver,
        params: ParamListInfo,
        queryEnv: *mut QueryEnvironment,
        instrument_options: ::std::os::raw::c_int,
    ) -> *mut QueryDesc;
    pub fn FreeQueryDesc(qdesc: *mut QueryDesc);
    pub fn MemoryContextInit();
    pub fn MemoryContextReset(context: MemoryContext);
    pub fn MemoryContextDelete(context: MemoryContext);
    pub fn MemoryContextResetOnly(context: MemoryContext);
    pub fn MemoryContextResetChildren(context: MemoryContext);
    pub fn MemoryContextDeleteChildren(context: MemoryContext);
    pub fn MemoryContextSetIdentifier(context: MemoryContext, id: *const ::std::os::raw::c_char);
    pub fn MemoryContextSetParent(context: MemoryContext, new_parent: MemoryContext);
    pub fn GetMemoryChunkContext(pointer: *mut ::std::os::raw::c_void) -> MemoryContext;
    pub fn GetMemoryChunkSpace(pointer: *mut ::std::os::raw::c_void) -> Size;
    pub fn MemoryContextGetParent(context: MemoryContext) -> MemoryContext;
    pub fn MemoryContextIsEmpty(context: MemoryContext) -> bool;
    pub fn MemoryContextMemAllocated(context: MemoryContext, recurse: bool) -> Size;
    pub fn MemoryContextStats(context: MemoryContext);
    pub fn MemoryContextStatsDetail(
        context: MemoryContext,
        max_children: ::std::os::raw::c_int,
        print_to_stderr: bool,
    );
    pub fn MemoryContextAllowInCriticalSection(context: MemoryContext, allow: bool);
    pub fn MemoryContextCheck(context: MemoryContext);
    pub fn HandleLogMemoryContextInterrupt();
    pub fn ProcessLogMemoryContextInterrupt();
    pub fn AllocSetContextCreateInternal(
        parent: MemoryContext,
        name: *const ::std::os::raw::c_char,
        minContextSize: Size,
        initBlockSize: Size,
        maxBlockSize: Size,
    ) -> MemoryContext;
    pub fn SlabContextCreate(
        parent: MemoryContext,
        name: *const ::std::os::raw::c_char,
        blockSize: Size,
        chunkSize: Size,
    ) -> MemoryContext;
    pub fn GenerationContextCreate(
        parent: MemoryContext,
        name: *const ::std::os::raw::c_char,
        minContextSize: Size,
        initBlockSize: Size,
        maxBlockSize: Size,
    ) -> MemoryContext;
    pub fn ExecReScan(node: *mut PlanState);
    pub fn ExecMarkPos(node: *mut PlanState);
    pub fn ExecRestrPos(node: *mut PlanState);
    pub fn ExecSupportsMarkRestore(pathnode: *mut Path) -> bool;
    pub fn ExecSupportsBackwardScan(node: *mut Plan) -> bool;
    pub fn ExecMaterializesOutput(plantype: NodeTag) -> bool;
    pub fn execCurrentOf(
        cexpr: *mut CurrentOfExpr,
        econtext: *mut ExprContext,
        table_oid: Oid,
        current_tid: ItemPointer,
    ) -> bool;
    pub fn execTuplesMatchPrepare(
        desc: TupleDesc,
        numCols: ::std::os::raw::c_int,
        keyColIdx: *const AttrNumber,
        eqOperators: *const Oid,
        collations: *const Oid,
        parent: *mut PlanState,
    ) -> *mut ExprState;
    pub fn execTuplesHashPrepare(
        numCols: ::std::os::raw::c_int,
        eqOperators: *const Oid,
        eqFuncOids: *mut *mut Oid,
        hashFunctions: *mut *mut FmgrInfo,
    );
    pub fn BuildTupleHashTable(
        parent: *mut PlanState,
        inputDesc: TupleDesc,
        numCols: ::std::os::raw::c_int,
        keyColIdx: *mut AttrNumber,
        eqfuncoids: *const Oid,
        hashfunctions: *mut FmgrInfo,
        collations: *mut Oid,
        nbuckets: ::std::os::raw::c_long,
        additionalsize: Size,
        tablecxt: MemoryContext,
        tempcxt: MemoryContext,
        use_variable_hash_iv: bool,
    ) -> TupleHashTable;
    pub fn BuildTupleHashTableExt(
        parent: *mut PlanState,
        inputDesc: TupleDesc,
        numCols: ::std::os::raw::c_int,
        keyColIdx: *mut AttrNumber,
        eqfuncoids: *const Oid,
        hashfunctions: *mut FmgrInfo,
        collations: *mut Oid,
        nbuckets: ::std::os::raw::c_long,
        additionalsize: Size,
        metacxt: MemoryContext,
        tablecxt: MemoryContext,
        tempcxt: MemoryContext,
        use_variable_hash_iv: bool,
    ) -> TupleHashTable;
    pub fn LookupTupleHashEntry(
        hashtable: TupleHashTable,
        slot: *mut TupleTableSlot,
        isnew: *mut bool,
        hash: *mut uint32,
    ) -> TupleHashEntry;
    pub fn TupleHashTableHash(hashtable: TupleHashTable, slot: *mut TupleTableSlot) -> uint32;
    pub fn LookupTupleHashEntryHash(
        hashtable: TupleHashTable,
        slot: *mut TupleTableSlot,
        isnew: *mut bool,
        hash: uint32,
    ) -> TupleHashEntry;
    pub fn FindTupleHashEntry(
        hashtable: TupleHashTable,
        slot: *mut TupleTableSlot,
        eqcomp: *mut ExprState,
        hashfunctions: *mut FmgrInfo,
    ) -> TupleHashEntry;
    pub fn ResetTupleHashTable(hashtable: TupleHashTable);
    pub fn ExecInitJunkFilter(targetList: *mut List, slot: *mut TupleTableSlot) -> *mut JunkFilter;
    pub fn ExecInitJunkFilterConversion(
        targetList: *mut List,
        cleanTupType: TupleDesc,
        slot: *mut TupleTableSlot,
    ) -> *mut JunkFilter;
    pub fn ExecFindJunkAttribute(
        junkfilter: *mut JunkFilter,
        attrName: *const ::std::os::raw::c_char,
    ) -> AttrNumber;
    pub fn ExecFindJunkAttributeInTlist(
        targetlist: *mut List,
        attrName: *const ::std::os::raw::c_char,
    ) -> AttrNumber;
    pub fn ExecFilterJunk(
        junkfilter: *mut JunkFilter,
        slot: *mut TupleTableSlot,
    ) -> *mut TupleTableSlot;
    pub fn ExecutorStart(queryDesc: *mut QueryDesc, eflags: ::std::os::raw::c_int);
    pub fn standard_ExecutorStart(queryDesc: *mut QueryDesc, eflags: ::std::os::raw::c_int);
    pub fn ExecutorRun(
        queryDesc: *mut QueryDesc,
        direction: ScanDirection,
        count: uint64,
        execute_once: bool,
    );
    pub fn standard_ExecutorRun(
        queryDesc: *mut QueryDesc,
        direction: ScanDirection,
        count: uint64,
        execute_once: bool,
    );
    pub fn ExecutorFinish(queryDesc: *mut QueryDesc);
    pub fn standard_ExecutorFinish(queryDesc: *mut QueryDesc);
    pub fn ExecutorEnd(queryDesc: *mut QueryDesc);
    pub fn standard_ExecutorEnd(queryDesc: *mut QueryDesc);
    pub fn ExecutorRewind(queryDesc: *mut QueryDesc);
    pub fn ExecCheckPermissions(
        rangeTable: *mut List,
        rteperminfos: *mut List,
        ereport_on_violation: bool,
    ) -> bool;
    pub fn CheckValidResultRel(resultRelInfo: *mut ResultRelInfo, operation: CmdType);
    pub fn InitResultRelInfo(
        resultRelInfo: *mut ResultRelInfo,
        resultRelationDesc: Relation,
        resultRelationIndex: Index,
        partition_root_rri: *mut ResultRelInfo,
        instrument_options: ::std::os::raw::c_int,
    );
    pub fn ExecGetTriggerResultRel(
        estate: *mut EState,
        relid: Oid,
        rootRelInfo: *mut ResultRelInfo,
    ) -> *mut ResultRelInfo;
    pub fn ExecGetAncestorResultRels(
        estate: *mut EState,
        resultRelInfo: *mut ResultRelInfo,
    ) -> *mut List;
    pub fn ExecConstraints(
        resultRelInfo: *mut ResultRelInfo,
        slot: *mut TupleTableSlot,
        estate: *mut EState,
    );
    pub fn ExecPartitionCheck(
        resultRelInfo: *mut ResultRelInfo,
        slot: *mut TupleTableSlot,
        estate: *mut EState,
        emitError: bool,
    ) -> bool;
    pub fn ExecPartitionCheckEmitError(
        resultRelInfo: *mut ResultRelInfo,
        slot: *mut TupleTableSlot,
        estate: *mut EState,
    );
    pub fn ExecWithCheckOptions(
        kind: WCOKind,
        resultRelInfo: *mut ResultRelInfo,
        slot: *mut TupleTableSlot,
        estate: *mut EState,
    );
    pub fn ExecUpdateLockMode(estate: *mut EState, relinfo: *mut ResultRelInfo) -> LockTupleMode;
    pub fn ExecFindRowMark(estate: *mut EState, rti: Index, missing_ok: bool) -> *mut ExecRowMark;
    pub fn ExecBuildAuxRowMark(erm: *mut ExecRowMark, targetlist: *mut List)
        -> *mut ExecAuxRowMark;
    pub fn EvalPlanQual(
        epqstate: *mut EPQState,
        relation: Relation,
        rti: Index,
        inputslot: *mut TupleTableSlot,
    ) -> *mut TupleTableSlot;
    pub fn EvalPlanQualInit(
        epqstate: *mut EPQState,
        parentestate: *mut EState,
        subplan: *mut Plan,
        auxrowmarks: *mut List,
        epqParam: ::std::os::raw::c_int,
        resultRelations: *mut List,
    );
    pub fn EvalPlanQualSetPlan(epqstate: *mut EPQState, subplan: *mut Plan, auxrowmarks: *mut List);
    pub fn EvalPlanQualSlot(
        epqstate: *mut EPQState,
        relation: Relation,
        rti: Index,
    ) -> *mut TupleTableSlot;
    pub fn EvalPlanQualFetchRowMark(
        epqstate: *mut EPQState,
        rti: Index,
        slot: *mut TupleTableSlot,
    ) -> bool;
    pub fn EvalPlanQualNext(epqstate: *mut EPQState) -> *mut TupleTableSlot;
    pub fn EvalPlanQualBegin(epqstate: *mut EPQState);
    pub fn EvalPlanQualEnd(epqstate: *mut EPQState);
    pub fn ExecInitNode(
        node: *mut Plan,
        estate: *mut EState,
        eflags: ::std::os::raw::c_int,
    ) -> *mut PlanState;
    pub fn ExecSetExecProcNode(node: *mut PlanState, function: ExecProcNodeMtd);
    pub fn MultiExecProcNode(node: *mut PlanState) -> *mut Node;
    pub fn ExecEndNode(node: *mut PlanState);
    pub fn ExecShutdownNode(node: *mut PlanState);
    pub fn ExecSetTupleBound(tuples_needed: int64, child_node: *mut PlanState);
    pub fn ExecInitExpr(node: *mut Expr, parent: *mut PlanState) -> *mut ExprState;
    pub fn ExecInitExprWithParams(node: *mut Expr, ext_params: ParamListInfo) -> *mut ExprState;
    pub fn ExecInitQual(qual: *mut List, parent: *mut PlanState) -> *mut ExprState;
    pub fn ExecInitCheck(qual: *mut List, parent: *mut PlanState) -> *mut ExprState;
    pub fn ExecInitExprList(nodes: *mut List, parent: *mut PlanState) -> *mut List;
    pub fn ExecBuildAggTrans(
        aggstate: *mut AggState,
        phase: *mut AggStatePerPhaseData,
        doSort: bool,
        doHash: bool,
        nullcheck: bool,
    ) -> *mut ExprState;
    pub fn ExecBuildGroupingEqual(
        ldesc: TupleDesc,
        rdesc: TupleDesc,
        lops: *const TupleTableSlotOps,
        rops: *const TupleTableSlotOps,
        numCols: ::std::os::raw::c_int,
        keyColIdx: *const AttrNumber,
        eqfunctions: *const Oid,
        collations: *const Oid,
        parent: *mut PlanState,
    ) -> *mut ExprState;
    pub fn ExecBuildParamSetEqual(
        desc: TupleDesc,
        lops: *const TupleTableSlotOps,
        rops: *const TupleTableSlotOps,
        eqfunctions: *const Oid,
        collations: *const Oid,
        param_exprs: *const List,
        parent: *mut PlanState,
    ) -> *mut ExprState;
    pub fn ExecBuildProjectionInfo(
        targetList: *mut List,
        econtext: *mut ExprContext,
        slot: *mut TupleTableSlot,
        parent: *mut PlanState,
        inputDesc: TupleDesc,
    ) -> *mut ProjectionInfo;
    pub fn ExecBuildUpdateProjection(
        targetList: *mut List,
        evalTargetList: bool,
        targetColnos: *mut List,
        relDesc: TupleDesc,
        econtext: *mut ExprContext,
        slot: *mut TupleTableSlot,
        parent: *mut PlanState,
    ) -> *mut ProjectionInfo;
    pub fn ExecPrepareExpr(node: *mut Expr, estate: *mut EState) -> *mut ExprState;
    pub fn ExecPrepareQual(qual: *mut List, estate: *mut EState) -> *mut ExprState;
    pub fn ExecPrepareCheck(qual: *mut List, estate: *mut EState) -> *mut ExprState;
    pub fn ExecPrepareExprList(nodes: *mut List, estate: *mut EState) -> *mut List;
    pub fn ExecCheck(state: *mut ExprState, econtext: *mut ExprContext) -> bool;
    pub fn ExecInitTableFunctionResult(
        expr: *mut Expr,
        econtext: *mut ExprContext,
        parent: *mut PlanState,
    ) -> *mut SetExprState;
    pub fn ExecMakeTableFunctionResult(
        setexpr: *mut SetExprState,
        econtext: *mut ExprContext,
        argContext: MemoryContext,
        expectedDesc: TupleDesc,
        randomAccess: bool,
    ) -> *mut Tuplestorestate;
    pub fn ExecInitFunctionResultSet(
        expr: *mut Expr,
        econtext: *mut ExprContext,
        parent: *mut PlanState,
    ) -> *mut SetExprState;
    pub fn ExecMakeFunctionResultSet(
        fcache: *mut SetExprState,
        econtext: *mut ExprContext,
        argContext: MemoryContext,
        isNull: *mut bool,
        isDone: *mut ExprDoneCond,
    ) -> Datum;
    pub fn ExecScan(
        node: *mut ScanState,
        accessMtd: ExecScanAccessMtd,
        recheckMtd: ExecScanRecheckMtd,
    ) -> *mut TupleTableSlot;
    pub fn ExecAssignScanProjectionInfo(node: *mut ScanState);
    pub fn ExecAssignScanProjectionInfoWithVarno(
        node: *mut ScanState,
        varno: ::std::os::raw::c_int,
    );
    pub fn ExecScanReScan(node: *mut ScanState);
    pub fn ExecInitResultTypeTL(planstate: *mut PlanState);
    pub fn ExecInitResultSlot(planstate: *mut PlanState, tts_ops: *const TupleTableSlotOps);
    pub fn ExecInitResultTupleSlotTL(planstate: *mut PlanState, tts_ops: *const TupleTableSlotOps);
    pub fn ExecInitScanTupleSlot(
        estate: *mut EState,
        scanstate: *mut ScanState,
        tupledesc: TupleDesc,
        tts_ops: *const TupleTableSlotOps,
    );
    pub fn ExecInitExtraTupleSlot(
        estate: *mut EState,
        tupledesc: TupleDesc,
        tts_ops: *const TupleTableSlotOps,
    ) -> *mut TupleTableSlot;
    pub fn ExecInitNullTupleSlot(
        estate: *mut EState,
        tupType: TupleDesc,
        tts_ops: *const TupleTableSlotOps,
    ) -> *mut TupleTableSlot;
    pub fn ExecTypeFromTL(targetList: *mut List) -> TupleDesc;
    pub fn ExecCleanTypeFromTL(targetList: *mut List) -> TupleDesc;
    pub fn ExecTypeFromExprList(exprList: *mut List) -> TupleDesc;
    pub fn ExecTypeSetColNames(typeInfo: TupleDesc, namesList: *mut List);
    pub fn UpdateChangedParamSet(node: *mut PlanState, newchg: *mut Bitmapset);
    pub fn begin_tup_output_tupdesc(
        dest: *mut DestReceiver,
        tupdesc: TupleDesc,
        tts_ops: *const TupleTableSlotOps,
    ) -> *mut TupOutputState;
    pub fn do_tup_output(tstate: *mut TupOutputState, values: *mut Datum, isnull: *mut bool);
    pub fn do_text_output_multiline(
        tstate: *mut TupOutputState,
        txt: *const ::std::os::raw::c_char,
    );
    pub fn end_tup_output(tstate: *mut TupOutputState);
    pub fn CreateExecutorState() -> *mut EState;
    pub fn FreeExecutorState(estate: *mut EState);
    pub fn CreateExprContext(estate: *mut EState) -> *mut ExprContext;
    pub fn CreateWorkExprContext(estate: *mut EState) -> *mut ExprContext;
    pub fn CreateStandaloneExprContext() -> *mut ExprContext;
    pub fn FreeExprContext(econtext: *mut ExprContext, isCommit: bool);
    pub fn ReScanExprContext(econtext: *mut ExprContext);
    pub fn MakePerTupleExprContext(estate: *mut EState) -> *mut ExprContext;
    pub fn ExecAssignExprContext(estate: *mut EState, planstate: *mut PlanState);
    pub fn ExecGetResultType(planstate: *mut PlanState) -> TupleDesc;
    pub fn ExecGetResultSlotOps(
        planstate: *mut PlanState,
        isfixed: *mut bool,
    ) -> *const TupleTableSlotOps;
    pub fn ExecAssignProjectionInfo(planstate: *mut PlanState, inputDesc: TupleDesc);
    pub fn ExecConditionalAssignProjectionInfo(
        planstate: *mut PlanState,
        inputDesc: TupleDesc,
        varno: ::std::os::raw::c_int,
    );
    pub fn ExecFreeExprContext(planstate: *mut PlanState);
    pub fn ExecAssignScanType(scanstate: *mut ScanState, tupDesc: TupleDesc);
    pub fn ExecCreateScanSlotFromOuterPlan(
        estate: *mut EState,
        scanstate: *mut ScanState,
        tts_ops: *const TupleTableSlotOps,
    );
    pub fn ExecRelationIsTargetRelation(estate: *mut EState, scanrelid: Index) -> bool;
    pub fn ExecOpenScanRelation(
        estate: *mut EState,
        scanrelid: Index,
        eflags: ::std::os::raw::c_int,
    ) -> Relation;
    pub fn ExecInitRangeTable(estate: *mut EState, rangeTable: *mut List, permInfos: *mut List);
    pub fn ExecCloseRangeTableRelations(estate: *mut EState);
    pub fn ExecCloseResultRelations(estate: *mut EState);
    pub fn ExecGetRangeTableRelation(estate: *mut EState, rti: Index) -> Relation;
    pub fn ExecInitResultRelation(
        estate: *mut EState,
        resultRelInfo: *mut ResultRelInfo,
        rti: Index,
    );
    pub fn executor_errposition(
        estate: *mut EState,
        location: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn RegisterExprContextCallback(
        econtext: *mut ExprContext,
        function: ExprContextCallbackFunction,
        arg: Datum,
    );
    pub fn UnregisterExprContextCallback(
        econtext: *mut ExprContext,
        function: ExprContextCallbackFunction,
        arg: Datum,
    );
    pub fn GetAttributeByName(
        tuple: HeapTupleHeader,
        attname: *const ::std::os::raw::c_char,
        isNull: *mut bool,
    ) -> Datum;
    pub fn GetAttributeByNum(
        tuple: HeapTupleHeader,
        attrno: AttrNumber,
        isNull: *mut bool,
    ) -> Datum;
    pub fn ExecTargetListLength(targetlist: *mut List) -> ::std::os::raw::c_int;
    pub fn ExecCleanTargetListLength(targetlist: *mut List) -> ::std::os::raw::c_int;
    pub fn ExecGetTriggerOldSlot(
        estate: *mut EState,
        relInfo: *mut ResultRelInfo,
    ) -> *mut TupleTableSlot;
    pub fn ExecGetTriggerNewSlot(
        estate: *mut EState,
        relInfo: *mut ResultRelInfo,
    ) -> *mut TupleTableSlot;
    pub fn ExecGetReturningSlot(
        estate: *mut EState,
        relInfo: *mut ResultRelInfo,
    ) -> *mut TupleTableSlot;
    pub fn ExecGetChildToRootMap(resultRelInfo: *mut ResultRelInfo) -> *mut TupleConversionMap;
    pub fn ExecGetRootToChildMap(
        resultRelInfo: *mut ResultRelInfo,
        estate: *mut EState,
    ) -> *mut TupleConversionMap;
    pub fn ExecGetResultRelCheckAsUser(relInfo: *mut ResultRelInfo, estate: *mut EState) -> Oid;
    pub fn ExecGetInsertedCols(relinfo: *mut ResultRelInfo, estate: *mut EState) -> *mut Bitmapset;
    pub fn ExecGetUpdatedCols(relinfo: *mut ResultRelInfo, estate: *mut EState) -> *mut Bitmapset;
    pub fn ExecGetExtraUpdatedCols(
        relinfo: *mut ResultRelInfo,
        estate: *mut EState,
    ) -> *mut Bitmapset;
    pub fn ExecGetAllUpdatedCols(
        relinfo: *mut ResultRelInfo,
        estate: *mut EState,
    ) -> *mut Bitmapset;
    pub fn ExecOpenIndices(resultRelInfo: *mut ResultRelInfo, speculative: bool);
    pub fn ExecCloseIndices(resultRelInfo: *mut ResultRelInfo);
    pub fn ExecInsertIndexTuples(
        resultRelInfo: *mut ResultRelInfo,
        slot: *mut TupleTableSlot,
        estate: *mut EState,
        update: bool,
        noDupErr: bool,
        specConflict: *mut bool,
        arbiterIndexes: *mut List,
        onlySummarizing: bool,
    ) -> *mut List;
    pub fn ExecCheckIndexConstraints(
        resultRelInfo: *mut ResultRelInfo,
        slot: *mut TupleTableSlot,
        estate: *mut EState,
        conflictTid: ItemPointer,
        arbiterIndexes: *mut List,
    ) -> bool;
    pub fn check_exclusion_constraint(
        heap: Relation,
        index: Relation,
        indexInfo: *mut IndexInfo,
        tupleid: ItemPointer,
        values: *mut Datum,
        isnull: *mut bool,
        estate: *mut EState,
        newIndex: bool,
    );
    pub fn RelationFindReplTupleByIndex(
        rel: Relation,
        idxoid: Oid,
        lockmode: LockTupleMode,
        searchslot: *mut TupleTableSlot,
        outslot: *mut TupleTableSlot,
    ) -> bool;
    pub fn RelationFindReplTupleSeq(
        rel: Relation,
        lockmode: LockTupleMode,
        searchslot: *mut TupleTableSlot,
        outslot: *mut TupleTableSlot,
    ) -> bool;
    pub fn ExecSimpleRelationInsert(
        resultRelInfo: *mut ResultRelInfo,
        estate: *mut EState,
        slot: *mut TupleTableSlot,
    );
    pub fn ExecSimpleRelationUpdate(
        resultRelInfo: *mut ResultRelInfo,
        estate: *mut EState,
        epqstate: *mut EPQState,
        searchslot: *mut TupleTableSlot,
        slot: *mut TupleTableSlot,
    );
    pub fn ExecSimpleRelationDelete(
        resultRelInfo: *mut ResultRelInfo,
        estate: *mut EState,
        epqstate: *mut EPQState,
        searchslot: *mut TupleTableSlot,
    );
    pub fn CheckCmdReplicaIdentity(rel: Relation, cmd: CmdType);
    pub fn CheckSubscriptionRelkind(
        relkind: ::std::os::raw::c_char,
        nspname: *const ::std::os::raw::c_char,
        relname: *const ::std::os::raw::c_char,
    );
    pub fn ExecGetUpdateNewTuple(
        relinfo: *mut ResultRelInfo,
        planSlot: *mut TupleTableSlot,
        oldSlot: *mut TupleTableSlot,
    ) -> *mut TupleTableSlot;
    pub fn ExecLookupResultRelByOid(
        node: *mut ModifyTableState,
        resultoid: Oid,
        missing_ok: bool,
        update_cache: bool,
    ) -> *mut ResultRelInfo;
    pub fn get_call_result_type(
        fcinfo: FunctionCallInfo,
        resultTypeId: *mut Oid,
        resultTupleDesc: *mut TupleDesc,
    ) -> TypeFuncClass;
    pub fn get_expr_result_type(
        expr: *mut Node,
        resultTypeId: *mut Oid,
        resultTupleDesc: *mut TupleDesc,
    ) -> TypeFuncClass;
    pub fn get_func_result_type(
        functionId: Oid,
        resultTypeId: *mut Oid,
        resultTupleDesc: *mut TupleDesc,
    ) -> TypeFuncClass;
    pub fn get_expr_result_tupdesc(expr: *mut Node, noError: bool) -> TupleDesc;
    pub fn resolve_polymorphic_argtypes(
        numargs: ::std::os::raw::c_int,
        argtypes: *mut Oid,
        argmodes: *mut ::std::os::raw::c_char,
        call_expr: *mut Node,
    ) -> bool;
    pub fn get_func_arg_info(
        procTup: HeapTuple,
        p_argtypes: *mut *mut Oid,
        p_argnames: *mut *mut *mut ::std::os::raw::c_char,
        p_argmodes: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn get_func_input_arg_names(
        proargnames: Datum,
        proargmodes: Datum,
        arg_names: *mut *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn get_func_trftypes(
        procTup: HeapTuple,
        p_trftypes: *mut *mut Oid,
    ) -> ::std::os::raw::c_int;
    pub fn get_func_result_name(functionId: Oid) -> *mut ::std::os::raw::c_char;
    pub fn build_function_result_tupdesc_d(
        prokind: ::std::os::raw::c_char,
        proallargtypes: Datum,
        proargmodes: Datum,
        proargnames: Datum,
    ) -> TupleDesc;
    pub fn build_function_result_tupdesc_t(procTuple: HeapTuple) -> TupleDesc;
    pub fn RelationNameGetTupleDesc(relname: *const ::std::os::raw::c_char) -> TupleDesc;
    pub fn TypeGetTupleDesc(typeoid: Oid, colaliases: *mut List) -> TupleDesc;
    pub fn BlessTupleDesc(tupdesc: TupleDesc) -> TupleDesc;
    pub fn TupleDescGetAttInMetadata(tupdesc: TupleDesc) -> *mut AttInMetadata;
    pub fn BuildTupleFromCStrings(
        attinmeta: *mut AttInMetadata,
        values: *mut *mut ::std::os::raw::c_char,
    ) -> HeapTuple;
    pub fn HeapTupleHeaderGetDatum(tuple: HeapTupleHeader) -> Datum;
    pub fn InitMaterializedSRF(fcinfo: FunctionCallInfo, flags: bits32);
    pub fn init_MultiFuncCall(fcinfo: FunctionCallInfo) -> *mut FuncCallContext;
    pub fn per_MultiFuncCall(fcinfo: FunctionCallInfo) -> *mut FuncCallContext;
    pub fn end_MultiFuncCall(fcinfo: FunctionCallInfo, funcctx: *mut FuncCallContext);
    pub fn extract_variadic_args(
        fcinfo: FunctionCallInfo,
        variadic_start: ::std::os::raw::c_int,
        convert_unknown: bool,
        args: *mut *mut Datum,
        types: *mut *mut Oid,
        nulls: *mut *mut bool,
    ) -> ::std::os::raw::c_int;
    pub fn pg_localtime(timep: *const pg_time_t, tz: *const pg_tz) -> *mut pg_tm;
    pub fn pg_gmtime(timep: *const pg_time_t) -> *mut pg_tm;
    pub fn pg_next_dst_boundary(
        timep: *const pg_time_t,
        before_gmtoff: *mut ::std::os::raw::c_long,
        before_isdst: *mut ::std::os::raw::c_int,
        boundary: *mut pg_time_t,
        after_gmtoff: *mut ::std::os::raw::c_long,
        after_isdst: *mut ::std::os::raw::c_int,
        tz: *const pg_tz,
    ) -> ::std::os::raw::c_int;
    pub fn pg_interpret_timezone_abbrev(
        abbrev: *const ::std::os::raw::c_char,
        timep: *const pg_time_t,
        gmtoff: *mut ::std::os::raw::c_long,
        isdst: *mut ::std::os::raw::c_int,
        tz: *const pg_tz,
    ) -> bool;
    pub fn pg_get_timezone_offset(tz: *const pg_tz, gmtoff: *mut ::std::os::raw::c_long) -> bool;
    pub fn pg_get_timezone_name(tz: *mut pg_tz) -> *const ::std::os::raw::c_char;
    pub fn pg_tz_acceptable(tz: *mut pg_tz) -> bool;
    pub fn pg_strftime(
        s: *mut ::std::os::raw::c_char,
        maxsize: usize,
        format: *const ::std::os::raw::c_char,
        t: *const pg_tm,
    ) -> usize;
    pub fn pg_timezone_initialize();
    pub fn pg_tzset(tzname: *const ::std::os::raw::c_char) -> *mut pg_tz;
    pub fn pg_tzset_offset(gmtoffset: ::std::os::raw::c_long) -> *mut pg_tz;
    pub fn pg_tzenumerate_start() -> *mut pg_tzenum;
    pub fn pg_tzenumerate_next(dir: *mut pg_tzenum) -> *mut pg_tz;
    pub fn pg_tzenumerate_end(dir: *mut pg_tzenum);
    pub fn ProcessInterrupts();
    pub fn set_stack_base() -> pg_stack_base_t;
    pub fn restore_stack_base(base: pg_stack_base_t);
    pub fn check_stack_depth();
    pub fn stack_is_too_deep() -> bool;
    pub fn PreventCommandIfReadOnly(cmdname: *const ::std::os::raw::c_char);
    pub fn PreventCommandIfParallelMode(cmdname: *const ::std::os::raw::c_char);
    pub fn PreventCommandDuringRecovery(cmdname: *const ::std::os::raw::c_char);
    pub fn trace_recovery(trace_level: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn InitPostmasterChild();
    pub fn InitStandaloneProcess(argv0: *const ::std::os::raw::c_char);
    pub fn InitProcessLocalLatch();
    pub fn SwitchToSharedLatch();
    pub fn SwitchBackToLocalLatch();
    pub fn GetBackendTypeDesc(backendType: BackendType) -> *const ::std::os::raw::c_char;
    pub fn SetDatabasePath(path: *const ::std::os::raw::c_char);
    pub fn checkDataDir();
    pub fn SetDataDir(dir: *const ::std::os::raw::c_char);
    pub fn ChangeToDataDir();
    pub fn GetUserNameFromId(roleid: Oid, noerr: bool) -> *mut ::std::os::raw::c_char;
    pub fn GetUserId() -> Oid;
    pub fn GetOuterUserId() -> Oid;
    pub fn GetSessionUserId() -> Oid;
    pub fn GetAuthenticatedUserId() -> Oid;
    pub fn GetUserIdAndSecContext(userid: *mut Oid, sec_context: *mut ::std::os::raw::c_int);
    pub fn SetUserIdAndSecContext(userid: Oid, sec_context: ::std::os::raw::c_int);
    pub fn InLocalUserIdChange() -> bool;
    pub fn InSecurityRestrictedOperation() -> bool;
    pub fn InNoForceRLSOperation() -> bool;
    pub fn GetUserIdAndContext(userid: *mut Oid, sec_def_context: *mut bool);
    pub fn SetUserIdAndContext(userid: Oid, sec_def_context: bool);
    pub fn InitializeSessionUserId(rolename: *const ::std::os::raw::c_char, roleid: Oid);
    pub fn InitializeSessionUserIdStandalone();
    pub fn SetSessionAuthorization(userid: Oid, is_superuser: bool);
    pub fn GetCurrentRoleId() -> Oid;
    pub fn SetCurrentRoleId(roleid: Oid, is_superuser: bool);
    pub fn InitializeSystemUser(
        authn_id: *const ::std::os::raw::c_char,
        auth_method: *const ::std::os::raw::c_char,
    );
    pub fn GetSystemUser() -> *const ::std::os::raw::c_char;
    pub fn superuser() -> bool;
    pub fn superuser_arg(roleid: Oid) -> bool;
    #[doc = "\t  pinit.h --\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t *\n\t\t\tPOSTGRES initialization and cleanup definitions.                 *"]
    pub fn pg_split_opts(
        argv: *mut *mut ::std::os::raw::c_char,
        argcp: *mut ::std::os::raw::c_int,
        optstr: *const ::std::os::raw::c_char,
    );
    pub fn InitializeMaxBackends();
    pub fn InitPostgres(
        in_dbname: *const ::std::os::raw::c_char,
        dboid: Oid,
        username: *const ::std::os::raw::c_char,
        useroid: Oid,
        load_session_libraries: bool,
        override_allow_connections: bool,
        out_dbname: *mut ::std::os::raw::c_char,
    );
    pub fn BaseInit();
    pub fn CreateDataDirLockFile(amPostmaster: bool);
    pub fn CreateSocketLockFile(
        socketfile: *const ::std::os::raw::c_char,
        amPostmaster: bool,
        socketDir: *const ::std::os::raw::c_char,
    );
    pub fn TouchSocketLockFiles();
    pub fn AddToDataDirLockFile(
        target_line: ::std::os::raw::c_int,
        str_: *const ::std::os::raw::c_char,
    );
    pub fn RecheckDataDirLockFile() -> bool;
    pub fn ValidatePgVersion(path: *const ::std::os::raw::c_char);
    pub fn process_shared_preload_libraries();
    pub fn process_session_preload_libraries();
    pub fn process_shmem_requests();
    pub fn pg_bindtextdomain(domain: *const ::std::os::raw::c_char);
    pub fn has_rolreplication(roleid: Oid) -> bool;
    pub fn EstimateClientConnectionInfoSpace() -> Size;
    pub fn SerializeClientConnectionInfo(maxsize: Size, start_address: *mut ::std::os::raw::c_char);
    pub fn RestoreClientConnectionInfo(conninfo: *mut ::std::os::raw::c_char);
    pub fn get_hash_memory_limit() -> usize;
    pub fn PgArchShmemSize() -> Size;
    pub fn PgArchShmemInit();
    pub fn PgArchCanRestart() -> bool;
    pub fn PgArchiverMain() -> !;
    pub fn PgArchWakeup();
    pub fn PgArchForceDirScan();
    pub fn pgstat_progress_start_command(cmdtype: ProgressCommandType, relid: Oid);
    pub fn pgstat_progress_update_param(index: ::std::os::raw::c_int, val: int64);
    pub fn pgstat_progress_incr_param(index: ::std::os::raw::c_int, incr: int64);
    pub fn pgstat_progress_update_multi_param(
        nparam: ::std::os::raw::c_int,
        index: *const ::std::os::raw::c_int,
        val: *const int64,
    );
    pub fn pgstat_progress_end_command();
    pub fn bindresvport6(
        __sockfd: ::std::os::raw::c_int,
        __sock_in: *mut sockaddr_in6,
    ) -> ::std::os::raw::c_int;
    pub fn BackendStatusShmemSize() -> Size;
    pub fn CreateSharedBackendStatus();
    pub fn pgstat_beinit();
    pub fn pgstat_bestart();
    pub fn pgstat_clear_backend_activity_snapshot();
    pub fn pgstat_report_activity(state: BackendState, cmd_str: *const ::std::os::raw::c_char);
    pub fn pgstat_report_query_id(query_id: uint64, force: bool);
    pub fn pgstat_report_tempfile(filesize: usize);
    pub fn pgstat_report_appname(appname: *const ::std::os::raw::c_char);
    pub fn pgstat_report_xact_timestamp(tstamp: TimestampTz);
    pub fn pgstat_get_backend_current_activity(
        pid: ::std::os::raw::c_int,
        checkUser: bool,
    ) -> *const ::std::os::raw::c_char;
    pub fn pgstat_get_crashed_backend_activity(
        pid: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_char,
        buflen: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
    pub fn pgstat_get_my_query_id() -> uint64;
    pub fn pgstat_fetch_stat_numbackends() -> ::std::os::raw::c_int;
    pub fn pgstat_get_beentry_by_backend_id(beid: BackendId) -> *mut PgBackendStatus;
    pub fn pgstat_get_local_beentry_by_backend_id(beid: BackendId) -> *mut LocalPgBackendStatus;
    pub fn pgstat_get_local_beentry_by_index(
        idx: ::std::os::raw::c_int,
    ) -> *mut LocalPgBackendStatus;
    pub fn pgstat_clip_activity(
        raw_activity: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn pgstat_get_wait_event(wait_event_info: uint32) -> *const ::std::os::raw::c_char;
    pub fn pgstat_get_wait_event_type(wait_event_info: uint32) -> *const ::std::os::raw::c_char;
    pub fn pgstat_set_wait_event_storage(wait_event_info: *mut uint32);
    pub fn pgstat_reset_wait_event_storage();
    pub fn StatsShmemSize() -> Size;
    pub fn StatsShmemInit();
    pub fn pgstat_restore_stats();
    pub fn pgstat_discard_stats();
    pub fn pgstat_before_server_shutdown(code: ::std::os::raw::c_int, arg: Datum);
    pub fn pgstat_initialize();
    pub fn pgstat_report_stat(force: bool) -> ::std::os::raw::c_long;
    pub fn pgstat_force_next_flush();
    pub fn pgstat_reset_counters();
    pub fn pgstat_reset(kind: PgStat_Kind, dboid: Oid, objoid: Oid);
    pub fn pgstat_reset_of_kind(kind: PgStat_Kind);
    pub fn pgstat_clear_snapshot();
    pub fn pgstat_get_stat_snapshot_timestamp(have_snapshot: *mut bool) -> TimestampTz;
    pub fn pgstat_get_kind_from_str(kind_str: *mut ::std::os::raw::c_char) -> PgStat_Kind;
    pub fn pgstat_have_entry(kind: PgStat_Kind, dboid: Oid, objoid: Oid) -> bool;
    pub fn pgstat_report_archiver(xlog: *const ::std::os::raw::c_char, failed: bool);
    pub fn pgstat_fetch_stat_archiver() -> *mut PgStat_ArchiverStats;
    pub fn pgstat_report_bgwriter();
    pub fn pgstat_fetch_stat_bgwriter() -> *mut PgStat_BgWriterStats;
    pub fn pgstat_report_checkpointer();
    pub fn pgstat_fetch_stat_checkpointer() -> *mut PgStat_CheckpointerStats;
    pub fn pgstat_bktype_io_stats_valid(
        backend_io: *mut PgStat_BktypeIO,
        bktype: BackendType,
    ) -> bool;
    pub fn pgstat_count_io_op(io_object: IOObject, io_context: IOContext, io_op: IOOp);
    pub fn pgstat_count_io_op_n(
        io_object: IOObject,
        io_context: IOContext,
        io_op: IOOp,
        cnt: uint32,
    );
    pub fn pgstat_prepare_io_time() -> instr_time;
    pub fn pgstat_count_io_op_time(
        io_object: IOObject,
        io_context: IOContext,
        io_op: IOOp,
        start_time: instr_time,
        cnt: uint32,
    );
    pub fn pgstat_fetch_stat_io() -> *mut PgStat_IO;
    pub fn pgstat_get_io_context_name(io_context: IOContext) -> *const ::std::os::raw::c_char;
    pub fn pgstat_get_io_object_name(io_object: IOObject) -> *const ::std::os::raw::c_char;
    pub fn pgstat_tracks_io_bktype(bktype: BackendType) -> bool;
    pub fn pgstat_tracks_io_object(
        bktype: BackendType,
        io_object: IOObject,
        io_context: IOContext,
    ) -> bool;
    pub fn pgstat_tracks_io_op(
        bktype: BackendType,
        io_object: IOObject,
        io_context: IOContext,
        io_op: IOOp,
    ) -> bool;
    pub fn pgstat_drop_database(databaseid: Oid);
    pub fn pgstat_report_autovac(dboid: Oid);
    pub fn pgstat_report_recovery_conflict(reason: ::std::os::raw::c_int);
    pub fn pgstat_report_deadlock();
    pub fn pgstat_report_checksum_failures_in_db(dboid: Oid, failurecount: ::std::os::raw::c_int);
    pub fn pgstat_report_checksum_failure();
    pub fn pgstat_report_connect(dboid: Oid);
    pub fn pgstat_fetch_stat_dbentry(dboid: Oid) -> *mut PgStat_StatDBEntry;
    pub fn pgstat_create_function(proid: Oid);
    pub fn pgstat_drop_function(proid: Oid);
    pub fn pgstat_init_function_usage(
        fcinfo: *mut FunctionCallInfoBaseData,
        fcu: *mut PgStat_FunctionCallUsage,
    );
    pub fn pgstat_end_function_usage(fcu: *mut PgStat_FunctionCallUsage, finalize: bool);
    pub fn pgstat_fetch_stat_funcentry(func_id: Oid) -> *mut PgStat_StatFuncEntry;
    pub fn find_funcstat_entry(func_id: Oid) -> *mut PgStat_FunctionCounts;
    pub fn pgstat_create_relation(rel: Relation);
    pub fn pgstat_drop_relation(rel: Relation);
    pub fn pgstat_copy_relation_stats(dst: Relation, src: Relation);
    pub fn pgstat_init_relation(rel: Relation);
    pub fn pgstat_assoc_relation(rel: Relation);
    pub fn pgstat_unlink_relation(rel: Relation);
    pub fn pgstat_report_vacuum(
        tableoid: Oid,
        shared: bool,
        livetuples: PgStat_Counter,
        deadtuples: PgStat_Counter,
    );
    pub fn pgstat_report_analyze(
        rel: Relation,
        livetuples: PgStat_Counter,
        deadtuples: PgStat_Counter,
        resetcounter: bool,
    );
    pub fn pgstat_count_heap_insert(rel: Relation, n: PgStat_Counter);
    pub fn pgstat_count_heap_update(rel: Relation, hot: bool, newpage: bool);
    pub fn pgstat_count_heap_delete(rel: Relation);
    pub fn pgstat_count_truncate(rel: Relation);
    pub fn pgstat_update_heap_dead_tuples(rel: Relation, delta: ::std::os::raw::c_int);
    pub fn pgstat_twophase_postcommit(
        xid: TransactionId,
        info: uint16,
        recdata: *mut ::std::os::raw::c_void,
        len: uint32,
    );
    pub fn pgstat_twophase_postabort(
        xid: TransactionId,
        info: uint16,
        recdata: *mut ::std::os::raw::c_void,
        len: uint32,
    );
    pub fn pgstat_fetch_stat_tabentry(relid: Oid) -> *mut PgStat_StatTabEntry;
    pub fn pgstat_fetch_stat_tabentry_ext(shared: bool, reloid: Oid) -> *mut PgStat_StatTabEntry;
    pub fn find_tabstat_entry(rel_id: Oid) -> *mut PgStat_TableStatus;
    pub fn pgstat_reset_replslot(name: *const ::std::os::raw::c_char);
    pub fn pgstat_report_replslot(
        slot: *mut ReplicationSlot,
        repSlotStat: *const PgStat_StatReplSlotEntry,
    );
    pub fn pgstat_create_replslot(slot: *mut ReplicationSlot);
    pub fn pgstat_acquire_replslot(slot: *mut ReplicationSlot);
    pub fn pgstat_drop_replslot(slot: *mut ReplicationSlot);
    pub fn pgstat_fetch_replslot(slotname: NameData) -> *mut PgStat_StatReplSlotEntry;
    pub fn pgstat_reset_slru(arg1: *const ::std::os::raw::c_char);
    pub fn pgstat_count_slru_page_zeroed(slru_idx: ::std::os::raw::c_int);
    pub fn pgstat_count_slru_page_hit(slru_idx: ::std::os::raw::c_int);
    pub fn pgstat_count_slru_page_read(slru_idx: ::std::os::raw::c_int);
    pub fn pgstat_count_slru_page_written(slru_idx: ::std::os::raw::c_int);
    pub fn pgstat_count_slru_page_exists(slru_idx: ::std::os::raw::c_int);
    pub fn pgstat_count_slru_flush(slru_idx: ::std::os::raw::c_int);
    pub fn pgstat_count_slru_truncate(slru_idx: ::std::os::raw::c_int);
    pub fn pgstat_get_slru_name(slru_idx: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
    pub fn pgstat_get_slru_index(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn pgstat_fetch_slru() -> *mut PgStat_SLRUStats;
    pub fn pgstat_report_subscription_error(subid: Oid, is_apply_error: bool);
    pub fn pgstat_create_subscription(subid: Oid);
    pub fn pgstat_drop_subscription(subid: Oid);
    pub fn pgstat_fetch_stat_subscription(subid: Oid) -> *mut PgStat_StatSubEntry;
    pub fn AtEOXact_PgStat(isCommit: bool, parallel: bool);
    pub fn AtEOSubXact_PgStat(isCommit: bool, nestDepth: ::std::os::raw::c_int);
    pub fn AtPrepare_PgStat();
    pub fn PostPrepare_PgStat();
    pub fn pgstat_get_transactional_drops(
        isCommit: bool,
        items: *mut *mut xl_xact_stats_item,
    ) -> ::std::os::raw::c_int;
    pub fn pgstat_execute_transactional_drops(
        ndrops: ::std::os::raw::c_int,
        items: *mut xl_xact_stats_item,
        is_redo: bool,
    );
    pub fn pgstat_report_wal(force: bool);
    pub fn pgstat_fetch_stat_wal() -> *mut PgStat_WalStats;
    pub fn ScanKeyInit(
        entry: ScanKey,
        attributeNumber: AttrNumber,
        strategy: StrategyNumber,
        procedure: RegProcedure,
        argument: Datum,
    );
    pub fn ScanKeyEntryInitialize(
        entry: ScanKey,
        flags: ::std::os::raw::c_int,
        attributeNumber: AttrNumber,
        strategy: StrategyNumber,
        subtype: Oid,
        collation: Oid,
        procedure: RegProcedure,
        argument: Datum,
    );
    pub fn ScanKeyEntryInitializeWithInfo(
        entry: ScanKey,
        flags: ::std::os::raw::c_int,
        attributeNumber: AttrNumber,
        strategy: StrategyNumber,
        subtype: Oid,
        collation: Oid,
        finfo: *mut FmgrInfo,
        argument: Datum,
    );
    pub fn index_open(relationId: Oid, lockmode: LOCKMODE) -> Relation;
    pub fn index_close(relation: Relation, lockmode: LOCKMODE);
    pub fn index_insert(
        indexRelation: Relation,
        values: *mut Datum,
        isnull: *mut bool,
        heap_t_ctid: ItemPointer,
        heapRelation: Relation,
        checkUnique: IndexUniqueCheck,
        indexUnchanged: bool,
        indexInfo: *mut IndexInfo,
    ) -> bool;
    pub fn index_beginscan(
        heapRelation: Relation,
        indexRelation: Relation,
        snapshot: Snapshot,
        nkeys: ::std::os::raw::c_int,
        norderbys: ::std::os::raw::c_int,
    ) -> IndexScanDesc;
    pub fn index_beginscan_bitmap(
        indexRelation: Relation,
        snapshot: Snapshot,
        nkeys: ::std::os::raw::c_int,
    ) -> IndexScanDesc;
    pub fn index_rescan(
        scan: IndexScanDesc,
        keys: ScanKey,
        nkeys: ::std::os::raw::c_int,
        orderbys: ScanKey,
        norderbys: ::std::os::raw::c_int,
    );
    pub fn index_endscan(scan: IndexScanDesc);
    pub fn index_markpos(scan: IndexScanDesc);
    pub fn index_restrpos(scan: IndexScanDesc);
    pub fn index_parallelscan_estimate(indexRelation: Relation, snapshot: Snapshot) -> Size;
    pub fn index_parallelscan_initialize(
        heapRelation: Relation,
        indexRelation: Relation,
        snapshot: Snapshot,
        target: ParallelIndexScanDesc,
    );
    pub fn index_parallelrescan(scan: IndexScanDesc);
    pub fn index_beginscan_parallel(
        heaprel: Relation,
        indexrel: Relation,
        nkeys: ::std::os::raw::c_int,
        norderbys: ::std::os::raw::c_int,
        pscan: ParallelIndexScanDesc,
    ) -> IndexScanDesc;
    pub fn index_getnext_tid(scan: IndexScanDesc, direction: ScanDirection) -> ItemPointer;
    pub fn index_fetch_heap(scan: IndexScanDesc, slot: *mut TupleTableSlot) -> bool;
    pub fn index_getnext_slot(
        scan: IndexScanDesc,
        direction: ScanDirection,
        slot: *mut TupleTableSlot,
    ) -> bool;
    pub fn index_getbitmap(scan: IndexScanDesc, bitmap: *mut TIDBitmap) -> int64;
    pub fn index_bulk_delete(
        info: *mut IndexVacuumInfo,
        istat: *mut IndexBulkDeleteResult,
        callback: IndexBulkDeleteCallback,
        callback_state: *mut ::std::os::raw::c_void,
    ) -> *mut IndexBulkDeleteResult;
    pub fn index_vacuum_cleanup(
        info: *mut IndexVacuumInfo,
        istat: *mut IndexBulkDeleteResult,
    ) -> *mut IndexBulkDeleteResult;
    pub fn index_can_return(indexRelation: Relation, attno: ::std::os::raw::c_int) -> bool;
    pub fn index_getprocid(irel: Relation, attnum: AttrNumber, procnum: uint16) -> RegProcedure;
    pub fn index_getprocinfo(irel: Relation, attnum: AttrNumber, procnum: uint16) -> *mut FmgrInfo;
    pub fn index_store_float8_orderby_distances(
        scan: IndexScanDesc,
        orderByTypes: *mut Oid,
        distances: *mut IndexOrderByDistance,
        recheckOrderBy: bool,
    );
    pub fn index_opclass_options(
        indrel: Relation,
        attnum: AttrNumber,
        attoptions: Datum,
        validate: bool,
    ) -> *mut bytea;
    pub fn RelationGetIndexScan(
        indexRelation: Relation,
        nkeys: ::std::os::raw::c_int,
        norderbys: ::std::os::raw::c_int,
    ) -> IndexScanDesc;
    pub fn IndexScanEnd(scan: IndexScanDesc);
    pub fn BuildIndexValueDescription(
        indexRelation: Relation,
        values: *mut Datum,
        isnull: *mut bool,
    ) -> *mut ::std::os::raw::c_char;
    pub fn index_compute_xid_horizon_for_tuples(
        irel: Relation,
        hrel: Relation,
        ibuf: Buffer,
        itemnos: *mut OffsetNumber,
        nitems: ::std::os::raw::c_int,
    ) -> TransactionId;
    pub fn systable_beginscan(
        heapRelation: Relation,
        indexId: Oid,
        indexOK: bool,
        snapshot: Snapshot,
        nkeys: ::std::os::raw::c_int,
        key: ScanKey,
    ) -> SysScanDesc;
    pub fn systable_getnext(sysscan: SysScanDesc) -> HeapTuple;
    pub fn systable_recheck_tuple(sysscan: SysScanDesc, tup: HeapTuple) -> bool;
    pub fn systable_endscan(sysscan: SysScanDesc);
    pub fn systable_beginscan_ordered(
        heapRelation: Relation,
        indexRelation: Relation,
        snapshot: Snapshot,
        nkeys: ::std::os::raw::c_int,
        key: ScanKey,
    ) -> SysScanDesc;
    pub fn systable_getnext_ordered(sysscan: SysScanDesc, direction: ScanDirection) -> HeapTuple;
    pub fn systable_endscan_ordered(sysscan: SysScanDesc);
    pub fn GetIndexAmRoutine(amhandler: Oid) -> *mut IndexAmRoutine;
    pub fn GetIndexAmRoutineByAmId(amoid: Oid, noerror: bool) -> *mut IndexAmRoutine;
    pub fn build_backup_content(
        state: *mut BackupState,
        ishistoryfile: bool,
    ) -> *mut ::std::os::raw::c_char;
    pub fn XLogInsertRecord(
        rdata: *mut XLogRecData,
        fpw_lsn: XLogRecPtr,
        flags: uint8,
        num_fpi: ::std::os::raw::c_int,
        topxid_included: bool,
    ) -> XLogRecPtr;
    pub fn XLogFlush(record: XLogRecPtr);
    pub fn XLogBackgroundFlush() -> bool;
    pub fn XLogNeedsFlush(record: XLogRecPtr) -> bool;
    pub fn XLogFileInit(logsegno: XLogSegNo, logtli: TimeLineID) -> ::std::os::raw::c_int;
    pub fn XLogFileOpen(segno: XLogSegNo, tli: TimeLineID) -> ::std::os::raw::c_int;
    pub fn CheckXLogRemoved(segno: XLogSegNo, tli: TimeLineID);
    pub fn XLogGetLastRemovedSegno() -> XLogSegNo;
    pub fn XLogSetAsyncXactLSN(asyncXactLSN: XLogRecPtr);
    pub fn XLogSetReplicationSlotMinimumLSN(lsn: XLogRecPtr);
    pub fn xlog_redo(record: *mut XLogReaderState);
    pub fn xlog_desc(buf: StringInfo, record: *mut XLogReaderState);
    pub fn xlog_identify(info: uint8) -> *const ::std::os::raw::c_char;
    pub fn issue_xlog_fsync(fd: ::std::os::raw::c_int, segno: XLogSegNo, tli: TimeLineID);
    pub fn RecoveryInProgress() -> bool;
    pub fn GetRecoveryState() -> RecoveryState;
    pub fn XLogInsertAllowed() -> bool;
    pub fn GetXLogInsertRecPtr() -> XLogRecPtr;
    pub fn GetXLogWriteRecPtr() -> XLogRecPtr;
    pub fn GetSystemIdentifier() -> uint64;
    pub fn GetMockAuthenticationNonce() -> *mut ::std::os::raw::c_char;
    pub fn DataChecksumsEnabled() -> bool;
    pub fn GetFakeLSNForUnloggedRel() -> XLogRecPtr;
    pub fn XLOGShmemSize() -> Size;
    pub fn XLOGShmemInit();
    pub fn BootStrapXLOG();
    pub fn InitializeWalConsistencyChecking();
    pub fn LocalProcessControlFile(reset: bool);
    pub fn GetActiveWalLevelOnStandby() -> WalLevel;
    pub fn StartupXLOG();
    pub fn ShutdownXLOG(code: ::std::os::raw::c_int, arg: Datum);
    pub fn CreateCheckPoint(flags: ::std::os::raw::c_int);
    pub fn CreateRestartPoint(flags: ::std::os::raw::c_int) -> bool;
    pub fn GetWALAvailability(targetLSN: XLogRecPtr) -> WALAvailability;
    pub fn XLogPutNextOid(nextOid: Oid);
    pub fn XLogRestorePoint(rpName: *const ::std::os::raw::c_char) -> XLogRecPtr;
    pub fn UpdateFullPageWrites();
    pub fn GetFullPageWriteInfo(RedoRecPtr_p: *mut XLogRecPtr, doPageWrites_p: *mut bool);
    pub fn GetRedoRecPtr() -> XLogRecPtr;
    pub fn GetInsertRecPtr() -> XLogRecPtr;
    pub fn GetFlushRecPtr(insertTLI: *mut TimeLineID) -> XLogRecPtr;
    pub fn GetWALInsertionTimeLine() -> TimeLineID;
    pub fn GetLastImportantRecPtr() -> XLogRecPtr;
    pub fn SetWalWriterSleeping(sleeping: bool);
    pub fn RemoveNonParentXlogFiles(switchpoint: XLogRecPtr, newTLI: TimeLineID);
    pub fn XLogCheckpointNeeded(new_segno: XLogSegNo) -> bool;
    pub fn SwitchIntoArchiveRecovery(EndRecPtr: XLogRecPtr, replayTLI: TimeLineID);
    pub fn ReachedEndOfBackup(EndRecPtr: XLogRecPtr, tli: TimeLineID);
    pub fn SetInstallXLogFileSegmentActive();
    pub fn IsInstallXLogFileSegmentActive() -> bool;
    pub fn XLogShutdownWalRcv();
    pub fn do_pg_backup_start(
        backupidstr: *const ::std::os::raw::c_char,
        fast: bool,
        tablespaces: *mut *mut List,
        state: *mut BackupState,
        tblspcmapfile: StringInfo,
    );
    pub fn do_pg_backup_stop(state: *mut BackupState, waitforarchive: bool);
    pub fn do_pg_abort_backup(code: ::std::os::raw::c_int, arg: Datum);
    pub fn register_persistent_abort_backup_handler();
    pub fn get_backup_status() -> SessionBackupState;
    pub fn pg_comp_crc32c_sb8(
        crc: pg_crc32c,
        data: *const ::std::os::raw::c_void,
        len: usize,
    ) -> pg_crc32c;
    pub fn pg_comp_crc32c_sse42(
        crc: pg_crc32c,
        data: *const ::std::os::raw::c_void,
        len: usize,
    ) -> pg_crc32c;
    pub fn XLogReaderAllocate(
        wal_segment_size: ::std::os::raw::c_int,
        waldir: *const ::std::os::raw::c_char,
        routine: *mut XLogReaderRoutine,
        private_data: *mut ::std::os::raw::c_void,
    ) -> *mut XLogReaderState;
    pub fn XLogReaderFree(state: *mut XLogReaderState);
    pub fn XLogReaderSetDecodeBuffer(
        state: *mut XLogReaderState,
        buffer: *mut ::std::os::raw::c_void,
        size: usize,
    );
    pub fn XLogBeginRead(state: *mut XLogReaderState, RecPtr: XLogRecPtr);
    pub fn XLogFindNextRecord(state: *mut XLogReaderState, RecPtr: XLogRecPtr) -> XLogRecPtr;
    pub fn XLogReadRecord(
        state: *mut XLogReaderState,
        errormsg: *mut *mut ::std::os::raw::c_char,
    ) -> *mut XLogRecord;
    pub fn XLogNextRecord(
        state: *mut XLogReaderState,
        errormsg: *mut *mut ::std::os::raw::c_char,
    ) -> *mut DecodedXLogRecord;
    pub fn XLogReleasePreviousRecord(state: *mut XLogReaderState) -> XLogRecPtr;
    pub fn XLogReadAhead(state: *mut XLogReaderState, nonblocking: bool) -> *mut DecodedXLogRecord;
    pub fn XLogReaderValidatePageHeader(
        state: *mut XLogReaderState,
        recptr: XLogRecPtr,
        phdr: *mut ::std::os::raw::c_char,
    ) -> bool;
    pub fn XLogReaderResetError(state: *mut XLogReaderState);
    pub fn WALRead(
        state: *mut XLogReaderState,
        buf: *mut ::std::os::raw::c_char,
        startptr: XLogRecPtr,
        count: Size,
        tli: TimeLineID,
        errinfo: *mut WALReadError,
    ) -> bool;
    pub fn DecodeXLogRecordRequiredSpace(xl_tot_len: usize) -> usize;
    pub fn DecodeXLogRecord(
        state: *mut XLogReaderState,
        decoded: *mut DecodedXLogRecord,
        record: *mut XLogRecord,
        lsn: XLogRecPtr,
        errormsg: *mut *mut ::std::os::raw::c_char,
    ) -> bool;
    pub fn XLogRecGetFullXid(record: *mut XLogReaderState) -> FullTransactionId;
    pub fn RestoreBlockImage(
        record: *mut XLogReaderState,
        block_id: uint8,
        page: *mut ::std::os::raw::c_char,
    ) -> bool;
    pub fn XLogRecGetBlockData(
        record: *mut XLogReaderState,
        block_id: uint8,
        len: *mut Size,
    ) -> *mut ::std::os::raw::c_char;
    pub fn XLogRecGetBlockTag(
        record: *mut XLogReaderState,
        block_id: uint8,
        rlocator: *mut RelFileLocator,
        forknum: *mut ForkNumber,
        blknum: *mut BlockNumber,
    );
    pub fn XLogRecGetBlockTagExtended(
        record: *mut XLogReaderState,
        block_id: uint8,
        rlocator: *mut RelFileLocator,
        forknum: *mut ForkNumber,
        blknum: *mut BlockNumber,
        prefetch_buffer: *mut Buffer,
    ) -> bool;
    pub fn RmgrStartup();
    pub fn RmgrCleanup();
    pub fn RmgrNotFound(rmid: RmgrId);
    pub fn RegisterCustomRmgr(rmid: RmgrId, rmgr: *const RmgrData);
    pub fn GetLastSegSwitchData(lastSwitchLSN: *mut XLogRecPtr) -> pg_time_t;
    pub fn RequestXLogSwitch(mark_unimportant: bool) -> XLogRecPtr;
    pub fn GetOldestRestartPoint(oldrecptr: *mut XLogRecPtr, oldtli: *mut TimeLineID);
    pub fn XLogRecGetBlockRefInfo(
        record: *mut XLogReaderState,
        pretty: bool,
        detailed_format: bool,
        buf: StringInfo,
        fpi_len: *mut uint32,
    );
    pub fn XLogBeginInsert();
    pub fn XLogSetRecordFlags(flags: uint8);
    pub fn XLogInsert(rmid: RmgrId, info: uint8) -> XLogRecPtr;
    pub fn XLogEnsureRecordSpace(
        max_block_id: ::std::os::raw::c_int,
        ndatas: ::std::os::raw::c_int,
    );
    pub fn XLogRegisterData(data: *mut ::std::os::raw::c_char, len: uint32);
    pub fn XLogRegisterBuffer(block_id: uint8, buffer: Buffer, flags: uint8);
    pub fn XLogRegisterBlock(
        block_id: uint8,
        rlocator: *mut RelFileLocator,
        forknum: ForkNumber,
        blknum: BlockNumber,
        page: *mut ::std::os::raw::c_char,
        flags: uint8,
    );
    pub fn XLogRegisterBufData(block_id: uint8, data: *mut ::std::os::raw::c_char, len: uint32);
    pub fn XLogResetInsertion();
    pub fn XLogCheckBufferNeedsBackup(buffer: Buffer) -> bool;
    pub fn log_newpage(
        rlocator: *mut RelFileLocator,
        forknum: ForkNumber,
        blkno: BlockNumber,
        page: *mut ::std::os::raw::c_char,
        page_std: bool,
    ) -> XLogRecPtr;
    pub fn log_newpages(
        rlocator: *mut RelFileLocator,
        forknum: ForkNumber,
        num_pages: ::std::os::raw::c_int,
        blknos: *mut BlockNumber,
        pages: *mut *mut ::std::os::raw::c_char,
        page_std: bool,
    );
    pub fn log_newpage_buffer(buffer: Buffer, page_std: bool) -> XLogRecPtr;
    pub fn log_newpage_range(
        rel: Relation,
        forknum: ForkNumber,
        startblk: BlockNumber,
        endblk: BlockNumber,
        page_std: bool,
    );
    pub fn XLogSaveBufferForHint(buffer: Buffer, buffer_std: bool) -> XLogRecPtr;
    pub fn InitXLogInsert();
    pub fn errdetail_relkind_not_supported(
        relkind: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn IsSystemRelation(relation: Relation) -> bool;
    pub fn IsToastRelation(relation: Relation) -> bool;
    pub fn IsCatalogRelation(relation: Relation) -> bool;
    pub fn IsSystemClass(relid: Oid, reltuple: Form_pg_class) -> bool;
    pub fn IsToastClass(reltuple: Form_pg_class) -> bool;
    pub fn IsCatalogRelationOid(relid: Oid) -> bool;
    pub fn IsCatalogNamespace(namespaceId: Oid) -> bool;
    pub fn IsToastNamespace(namespaceId: Oid) -> bool;
    pub fn IsReservedName(name: *const ::std::os::raw::c_char) -> bool;
    pub fn IsSharedRelation(relationId: Oid) -> bool;
    pub fn IsPinnedObject(classId: Oid, objectId: Oid) -> bool;
    pub fn GetNewOidWithIndex(relation: Relation, indexId: Oid, oidcolumn: AttrNumber) -> Oid;
    pub fn GetNewRelFileNumber(
        reltablespace: Oid,
        pg_class: Relation,
        relpersistence: ::std::os::raw::c_char,
    ) -> RelFileNumber;
    pub fn get_object_address(
        objtype: ObjectType,
        object: *mut Node,
        relp: *mut Relation,
        lockmode: LOCKMODE,
        missing_ok: bool,
    ) -> ObjectAddress;
    pub fn get_object_address_rv(
        objtype: ObjectType,
        rel: *mut RangeVar,
        object: *mut List,
        relp: *mut Relation,
        lockmode: LOCKMODE,
        missing_ok: bool,
    ) -> ObjectAddress;
    pub fn check_object_ownership(
        roleid: Oid,
        objtype: ObjectType,
        address: ObjectAddress,
        object: *mut Node,
        relation: Relation,
    );
    pub fn get_object_namespace(address: *const ObjectAddress) -> Oid;
    pub fn is_objectclass_supported(class_id: Oid) -> bool;
    pub fn get_object_class_descr(class_id: Oid) -> *const ::std::os::raw::c_char;
    pub fn get_object_oid_index(class_id: Oid) -> Oid;
    pub fn get_object_catcache_oid(class_id: Oid) -> ::std::os::raw::c_int;
    pub fn get_object_catcache_name(class_id: Oid) -> ::std::os::raw::c_int;
    pub fn get_object_attnum_oid(class_id: Oid) -> AttrNumber;
    pub fn get_object_attnum_name(class_id: Oid) -> AttrNumber;
    pub fn get_object_attnum_namespace(class_id: Oid) -> AttrNumber;
    pub fn get_object_attnum_owner(class_id: Oid) -> AttrNumber;
    pub fn get_object_attnum_acl(class_id: Oid) -> AttrNumber;
    pub fn get_object_type(class_id: Oid, object_id: Oid) -> ObjectType;
    pub fn get_object_namensp_unique(class_id: Oid) -> bool;
    pub fn get_catalog_object_by_oid(
        catalog: Relation,
        oidcol: AttrNumber,
        objectId: Oid,
    ) -> HeapTuple;
    pub fn getObjectDescription(
        object: *const ObjectAddress,
        missing_ok: bool,
    ) -> *mut ::std::os::raw::c_char;
    pub fn getObjectDescriptionOids(classid: Oid, objid: Oid) -> *mut ::std::os::raw::c_char;
    pub fn read_objtype_from_string(
        objtype: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn getObjectTypeDescription(
        object: *const ObjectAddress,
        missing_ok: bool,
    ) -> *mut ::std::os::raw::c_char;
    pub fn getObjectIdentity(
        object: *const ObjectAddress,
        missing_ok: bool,
    ) -> *mut ::std::os::raw::c_char;
    pub fn getObjectIdentityParts(
        object: *const ObjectAddress,
        objname: *mut *mut List,
        objargs: *mut *mut List,
        missing_ok: bool,
    ) -> *mut ::std::os::raw::c_char;
    pub fn strlist_to_textarray(list: *mut List) -> *mut ArrayType;
    pub fn get_relkind_objtype(relkind: ::std::os::raw::c_char) -> ObjectType;
    pub fn GetPublication(pubid: Oid) -> *mut Publication;
    pub fn GetPublicationByName(
        pubname: *const ::std::os::raw::c_char,
        missing_ok: bool,
    ) -> *mut Publication;
    pub fn GetRelationPublications(relid: Oid) -> *mut List;
    pub fn GetPublicationRelations(pubid: Oid, pub_partopt: PublicationPartOpt) -> *mut List;
    pub fn GetAllTablesPublications() -> *mut List;
    pub fn GetAllTablesPublicationRelations(pubviaroot: bool) -> *mut List;
    pub fn GetPublicationSchemas(pubid: Oid) -> *mut List;
    pub fn GetSchemaPublications(schemaid: Oid) -> *mut List;
    pub fn GetSchemaPublicationRelations(
        schemaid: Oid,
        pub_partopt: PublicationPartOpt,
    ) -> *mut List;
    pub fn GetAllSchemaPublicationRelations(
        pubid: Oid,
        pub_partopt: PublicationPartOpt,
    ) -> *mut List;
    pub fn GetPubPartitionOptionRelations(
        result: *mut List,
        pub_partopt: PublicationPartOpt,
        relid: Oid,
    ) -> *mut List;
    pub fn GetTopMostAncestorInPublication(
        puboid: Oid,
        ancestors: *mut List,
        ancestor_level: *mut ::std::os::raw::c_int,
    ) -> Oid;
    pub fn is_publishable_relation(rel: Relation) -> bool;
    pub fn is_schema_publication(pubid: Oid) -> bool;
    pub fn publication_add_relation(
        pubid: Oid,
        pri: *mut PublicationRelInfo,
        if_not_exists: bool,
    ) -> ObjectAddress;
    pub fn publication_add_schema(pubid: Oid, schemaid: Oid, if_not_exists: bool) -> ObjectAddress;
    pub fn pub_collist_to_bitmapset(
        columns: *mut Bitmapset,
        pubcols: Datum,
        mcxt: MemoryContext,
    ) -> *mut Bitmapset;
    pub fn smgrinit();
    pub fn smgropen(rlocator: RelFileLocator, backend: BackendId) -> SMgrRelation;
    pub fn smgrexists(reln: SMgrRelation, forknum: ForkNumber) -> bool;
    pub fn smgrsetowner(owner: *mut SMgrRelation, reln: SMgrRelation);
    pub fn smgrclearowner(owner: *mut SMgrRelation, reln: SMgrRelation);
    pub fn smgrclose(reln: SMgrRelation);
    pub fn smgrcloseall();
    pub fn smgrcloserellocator(rlocator: RelFileLocatorBackend);
    pub fn smgrrelease(reln: SMgrRelation);
    pub fn smgrreleaseall();
    pub fn smgrcreate(reln: SMgrRelation, forknum: ForkNumber, isRedo: bool);
    pub fn smgrdosyncall(rels: *mut SMgrRelation, nrels: ::std::os::raw::c_int);
    pub fn smgrdounlinkall(rels: *mut SMgrRelation, nrels: ::std::os::raw::c_int, isRedo: bool);
    pub fn smgrextend(
        reln: SMgrRelation,
        forknum: ForkNumber,
        blocknum: BlockNumber,
        buffer: *const ::std::os::raw::c_void,
        skipFsync: bool,
    );
    pub fn smgrzeroextend(
        reln: SMgrRelation,
        forknum: ForkNumber,
        blocknum: BlockNumber,
        nblocks: ::std::os::raw::c_int,
        skipFsync: bool,
    );
    pub fn smgrprefetch(reln: SMgrRelation, forknum: ForkNumber, blocknum: BlockNumber) -> bool;
    pub fn smgrread(
        reln: SMgrRelation,
        forknum: ForkNumber,
        blocknum: BlockNumber,
        buffer: *mut ::std::os::raw::c_void,
    );
    pub fn smgrwrite(
        reln: SMgrRelation,
        forknum: ForkNumber,
        blocknum: BlockNumber,
        buffer: *const ::std::os::raw::c_void,
        skipFsync: bool,
    );
    pub fn smgrwriteback(
        reln: SMgrRelation,
        forknum: ForkNumber,
        blocknum: BlockNumber,
        nblocks: BlockNumber,
    );
    pub fn smgrnblocks(reln: SMgrRelation, forknum: ForkNumber) -> BlockNumber;
    pub fn smgrnblocks_cached(reln: SMgrRelation, forknum: ForkNumber) -> BlockNumber;
    pub fn smgrtruncate(
        reln: SMgrRelation,
        forknum: *mut ForkNumber,
        nforks: ::std::os::raw::c_int,
        nblocks: *mut BlockNumber,
    );
    pub fn smgrimmedsync(reln: SMgrRelation, forknum: ForkNumber);
    pub fn AtEOXact_SMgr();
    pub fn ProcessBarrierSmgrRelease() -> bool;
    pub fn RelationIncrementReferenceCount(rel: Relation);
    pub fn RelationDecrementReferenceCount(rel: Relation);
    pub fn GenericXLogStart(relation: Relation) -> *mut GenericXLogState;
    pub fn GenericXLogRegisterBuffer(
        state: *mut GenericXLogState,
        buffer: Buffer,
        flags: ::std::os::raw::c_int,
    ) -> Page;
    pub fn GenericXLogFinish(state: *mut GenericXLogState) -> XLogRecPtr;
    pub fn GenericXLogAbort(state: *mut GenericXLogState);
    pub fn generic_redo(record: *mut XLogReaderState);
    pub fn generic_identify(info: uint8) -> *const ::std::os::raw::c_char;
    pub fn generic_desc(buf: StringInfo, record: *mut XLogReaderState);
    pub fn generic_mask(page: *mut ::std::os::raw::c_char, blkno: BlockNumber);
    pub fn ginGetStats(index: Relation, stats: *mut GinStatsData);
    pub fn ginUpdateStats(index: Relation, stats: *const GinStatsData, is_build: bool);
    pub fn relation_open(relationId: Oid, lockmode: LOCKMODE) -> Relation;
    pub fn try_relation_open(relationId: Oid, lockmode: LOCKMODE) -> Relation;
    pub fn relation_openrv(relation: *const RangeVar, lockmode: LOCKMODE) -> Relation;
    pub fn relation_openrv_extended(
        relation: *const RangeVar,
        lockmode: LOCKMODE,
        missing_ok: bool,
    ) -> Relation;
    pub fn relation_close(relation: Relation, lockmode: LOCKMODE);
    pub fn table_open(relationId: Oid, lockmode: LOCKMODE) -> Relation;
    pub fn table_openrv(relation: *const RangeVar, lockmode: LOCKMODE) -> Relation;
    pub fn table_openrv_extended(
        relation: *const RangeVar,
        lockmode: LOCKMODE,
        missing_ok: bool,
    ) -> Relation;
    pub fn try_table_open(relationId: Oid, lockmode: LOCKMODE) -> Relation;
    pub fn table_close(relation: Relation, lockmode: LOCKMODE);
    pub fn SendSharedInvalidMessages(
        msgs: *const SharedInvalidationMessage,
        n: ::std::os::raw::c_int,
    );
    pub fn ReceiveSharedInvalidMessages(
        invalFunction: ::std::option::Option<
            unsafe extern "C" fn(msg: *mut SharedInvalidationMessage),
        >,
        resetFunction: ::std::option::Option<unsafe extern "C" fn()>,
    );
    pub fn HandleCatchupInterrupt();
    pub fn ProcessCatchupInterrupt();
    pub fn xactGetCommittedInvalidationMessages(
        msgs: *mut *mut SharedInvalidationMessage,
        RelcacheInitFileInval: *mut bool,
    ) -> ::std::os::raw::c_int;
    pub fn ProcessCommittedInvalidationMessages(
        msgs: *mut SharedInvalidationMessage,
        nmsgs: ::std::os::raw::c_int,
        RelcacheInitFileInval: bool,
        dbid: Oid,
        tsid: Oid,
    );
    pub fn LocalExecuteInvalidationMessage(msg: *mut SharedInvalidationMessage);
    pub fn IsTransactionState() -> bool;
    pub fn IsAbortedTransactionBlockState() -> bool;
    pub fn GetTopTransactionId() -> TransactionId;
    pub fn GetTopTransactionIdIfAny() -> TransactionId;
    pub fn GetCurrentTransactionId() -> TransactionId;
    pub fn GetCurrentTransactionIdIfAny() -> TransactionId;
    pub fn GetStableLatestTransactionId() -> TransactionId;
    pub fn GetCurrentSubTransactionId() -> SubTransactionId;
    pub fn GetTopFullTransactionId() -> FullTransactionId;
    pub fn GetTopFullTransactionIdIfAny() -> FullTransactionId;
    pub fn GetCurrentFullTransactionId() -> FullTransactionId;
    pub fn GetCurrentFullTransactionIdIfAny() -> FullTransactionId;
    pub fn MarkCurrentTransactionIdLoggedIfAny();
    pub fn SubTransactionIsActive(subxid: SubTransactionId) -> bool;
    pub fn GetCurrentCommandId(used: bool) -> CommandId;
    pub fn SetParallelStartTimestamps(xact_ts: TimestampTz, stmt_ts: TimestampTz);
    pub fn GetCurrentTransactionStartTimestamp() -> TimestampTz;
    pub fn GetCurrentStatementStartTimestamp() -> TimestampTz;
    pub fn GetCurrentTransactionStopTimestamp() -> TimestampTz;
    pub fn SetCurrentStatementStartTimestamp();
    pub fn GetCurrentTransactionNestLevel() -> ::std::os::raw::c_int;
    pub fn TransactionIdIsCurrentTransactionId(xid: TransactionId) -> bool;
    pub fn CommandCounterIncrement();
    pub fn ForceSyncCommit();
    pub fn StartTransactionCommand();
    pub fn SaveTransactionCharacteristics(s: *mut SavedTransactionCharacteristics);
    pub fn RestoreTransactionCharacteristics(s: *const SavedTransactionCharacteristics);
    pub fn CommitTransactionCommand();
    pub fn AbortCurrentTransaction();
    pub fn BeginTransactionBlock();
    pub fn EndTransactionBlock(chain: bool) -> bool;
    pub fn PrepareTransactionBlock(gid: *const ::std::os::raw::c_char) -> bool;
    pub fn UserAbortTransactionBlock(chain: bool);
    pub fn BeginImplicitTransactionBlock();
    pub fn EndImplicitTransactionBlock();
    pub fn ReleaseSavepoint(name: *const ::std::os::raw::c_char);
    pub fn DefineSavepoint(name: *const ::std::os::raw::c_char);
    pub fn RollbackToSavepoint(name: *const ::std::os::raw::c_char);
    pub fn BeginInternalSubTransaction(name: *const ::std::os::raw::c_char);
    pub fn ReleaseCurrentSubTransaction();
    pub fn RollbackAndReleaseCurrentSubTransaction();
    pub fn IsSubTransaction() -> bool;
    pub fn EstimateTransactionStateSpace() -> Size;
    pub fn SerializeTransactionState(maxsize: Size, start_address: *mut ::std::os::raw::c_char);
    pub fn StartParallelWorkerTransaction(tstatespace: *mut ::std::os::raw::c_char);
    pub fn EndParallelWorkerTransaction();
    pub fn IsTransactionBlock() -> bool;
    pub fn IsTransactionOrTransactionBlock() -> bool;
    pub fn TransactionBlockStatusCode() -> ::std::os::raw::c_char;
    pub fn AbortOutOfAnyTransaction();
    pub fn PreventInTransactionBlock(isTopLevel: bool, stmtType: *const ::std::os::raw::c_char);
    pub fn RequireTransactionBlock(isTopLevel: bool, stmtType: *const ::std::os::raw::c_char);
    pub fn WarnNoTransactionBlock(isTopLevel: bool, stmtType: *const ::std::os::raw::c_char);
    pub fn IsInTransactionBlock(isTopLevel: bool) -> bool;
    pub fn RegisterXactCallback(callback: XactCallback, arg: *mut ::std::os::raw::c_void);
    pub fn UnregisterXactCallback(callback: XactCallback, arg: *mut ::std::os::raw::c_void);
    pub fn RegisterSubXactCallback(callback: SubXactCallback, arg: *mut ::std::os::raw::c_void);
    pub fn UnregisterSubXactCallback(callback: SubXactCallback, arg: *mut ::std::os::raw::c_void);
    pub fn IsSubxactTopXidLogPending() -> bool;
    pub fn MarkSubxactTopXidLogged();
    pub fn xactGetCommittedChildren(ptr: *mut *mut TransactionId) -> ::std::os::raw::c_int;
    pub fn XactLogCommitRecord(
        commit_time: TimestampTz,
        nsubxacts: ::std::os::raw::c_int,
        subxacts: *mut TransactionId,
        nrels: ::std::os::raw::c_int,
        rels: *mut RelFileLocator,
        ndroppedstats: ::std::os::raw::c_int,
        droppedstats: *mut xl_xact_stats_item,
        nmsgs: ::std::os::raw::c_int,
        msgs: *mut SharedInvalidationMessage,
        relcacheInval: bool,
        xactflags: ::std::os::raw::c_int,
        twophase_xid: TransactionId,
        twophase_gid: *const ::std::os::raw::c_char,
    ) -> XLogRecPtr;
    pub fn XactLogAbortRecord(
        abort_time: TimestampTz,
        nsubxacts: ::std::os::raw::c_int,
        subxacts: *mut TransactionId,
        nrels: ::std::os::raw::c_int,
        rels: *mut RelFileLocator,
        ndroppedstats: ::std::os::raw::c_int,
        droppedstats: *mut xl_xact_stats_item,
        xactflags: ::std::os::raw::c_int,
        twophase_xid: TransactionId,
        twophase_gid: *const ::std::os::raw::c_char,
    ) -> XLogRecPtr;
    pub fn xact_redo(record: *mut XLogReaderState);
    pub fn xact_desc(buf: StringInfo, record: *mut XLogReaderState);
    pub fn xact_identify(info: uint8) -> *const ::std::os::raw::c_char;
    pub fn ParseCommitRecord(
        info: uint8,
        xlrec: *mut xl_xact_commit,
        parsed: *mut xl_xact_parsed_commit,
    );
    pub fn ParseAbortRecord(
        info: uint8,
        xlrec: *mut xl_xact_abort,
        parsed: *mut xl_xact_parsed_abort,
    );
    pub fn ParsePrepareRecord(
        info: uint8,
        xlrec: *mut xl_xact_prepare,
        parsed: *mut xl_xact_parsed_prepare,
    );
    pub fn EnterParallelMode();
    pub fn ExitParallelMode();
    pub fn IsInParallelMode() -> bool;
    pub fn table_slot_callbacks(relation: Relation) -> *const TupleTableSlotOps;
    pub fn table_slot_create(relation: Relation, reglist: *mut *mut List) -> *mut TupleTableSlot;
    pub fn table_beginscan_catalog(
        relation: Relation,
        nkeys: ::std::os::raw::c_int,
        key: *mut ScanKeyData,
    ) -> TableScanDesc;
    pub fn table_scan_update_snapshot(scan: TableScanDesc, snapshot: Snapshot);
    pub fn table_parallelscan_estimate(rel: Relation, snapshot: Snapshot) -> Size;
    pub fn table_parallelscan_initialize(
        rel: Relation,
        pscan: ParallelTableScanDesc,
        snapshot: Snapshot,
    );
    pub fn table_beginscan_parallel(
        relation: Relation,
        pscan: ParallelTableScanDesc,
    ) -> TableScanDesc;
    pub fn table_index_fetch_tuple_check(
        rel: Relation,
        tid: ItemPointer,
        snapshot: Snapshot,
        all_dead: *mut bool,
    ) -> bool;
    pub fn table_tuple_get_latest_tid(scan: TableScanDesc, tid: ItemPointer);
    pub fn simple_table_tuple_insert(rel: Relation, slot: *mut TupleTableSlot);
    pub fn simple_table_tuple_delete(rel: Relation, tid: ItemPointer, snapshot: Snapshot);
    pub fn simple_table_tuple_update(
        rel: Relation,
        otid: ItemPointer,
        slot: *mut TupleTableSlot,
        snapshot: Snapshot,
        update_indexes: *mut TU_UpdateIndexes,
    );
    pub fn table_block_parallelscan_estimate(rel: Relation) -> Size;
    pub fn table_block_parallelscan_initialize(rel: Relation, pscan: ParallelTableScanDesc)
        -> Size;
    pub fn table_block_parallelscan_reinitialize(rel: Relation, pscan: ParallelTableScanDesc);
    pub fn table_block_parallelscan_nextpage(
        rel: Relation,
        pbscanwork: ParallelBlockTableScanWorker,
        pbscan: ParallelBlockTableScanDesc,
    ) -> BlockNumber;
    pub fn table_block_parallelscan_startblock_init(
        rel: Relation,
        pbscanwork: ParallelBlockTableScanWorker,
        pbscan: ParallelBlockTableScanDesc,
    );
    pub fn table_block_relation_size(rel: Relation, forkNumber: ForkNumber) -> uint64;
    pub fn table_block_relation_estimate_size(
        rel: Relation,
        attr_widths: *mut int32,
        pages: *mut BlockNumber,
        tuples: *mut f64,
        allvisfrac: *mut f64,
        overhead_bytes_per_tuple: Size,
        usable_bytes_per_page: Size,
    );
    pub fn GetTableAmRoutine(amhandler: Oid) -> *const TableAmRoutine;
    pub fn GetHeapamTableAmRoutine() -> *const TableAmRoutine;
    pub fn InitShmemAccess(seghdr: *mut ::std::os::raw::c_void);
    pub fn InitShmemAllocation();
    pub fn ShmemAlloc(size: Size) -> *mut ::std::os::raw::c_void;
    pub fn ShmemAllocNoError(size: Size) -> *mut ::std::os::raw::c_void;
    pub fn ShmemAllocUnlocked(size: Size) -> *mut ::std::os::raw::c_void;
    pub fn ShmemAddrIsValid(addr: *const ::std::os::raw::c_void) -> bool;
    pub fn InitShmemIndex();
    pub fn ShmemInitHash(
        name: *const ::std::os::raw::c_char,
        init_size: ::std::os::raw::c_long,
        max_size: ::std::os::raw::c_long,
        infoP: *mut HASHCTL,
        hash_flags: ::std::os::raw::c_int,
    ) -> *mut HTAB;
    pub fn ShmemInitStruct(
        name: *const ::std::os::raw::c_char,
        size: Size,
        foundPtr: *mut bool,
    ) -> *mut ::std::os::raw::c_void;
    pub fn add_size(s1: Size, s2: Size) -> Size;
    pub fn mul_size(s1: Size, s2: Size) -> Size;
    pub fn RequestAddinShmemSpace(size: Size);
    pub fn shm_toc_create(
        magic: uint64,
        address: *mut ::std::os::raw::c_void,
        nbytes: Size,
    ) -> *mut shm_toc;
    pub fn shm_toc_attach(magic: uint64, address: *mut ::std::os::raw::c_void) -> *mut shm_toc;
    pub fn shm_toc_allocate(toc: *mut shm_toc, nbytes: Size) -> *mut ::std::os::raw::c_void;
    pub fn shm_toc_freespace(toc: *mut shm_toc) -> Size;
    pub fn shm_toc_insert(toc: *mut shm_toc, key: uint64, address: *mut ::std::os::raw::c_void);
    pub fn shm_toc_lookup(
        toc: *mut shm_toc,
        key: uint64,
        noError: bool,
    ) -> *mut ::std::os::raw::c_void;
    pub fn shm_toc_estimate(e: *mut shm_toc_estimator) -> Size;
    pub fn heap_beginscan(
        relation: Relation,
        snapshot: Snapshot,
        nkeys: ::std::os::raw::c_int,
        key: ScanKey,
        parallel_scan: ParallelTableScanDesc,
        flags: uint32,
    ) -> TableScanDesc;
    pub fn heap_setscanlimits(sscan: TableScanDesc, startBlk: BlockNumber, numBlks: BlockNumber);
    pub fn heapgetpage(sscan: TableScanDesc, block: BlockNumber);
    pub fn heap_rescan(
        sscan: TableScanDesc,
        key: ScanKey,
        set_params: bool,
        allow_strat: bool,
        allow_sync: bool,
        allow_pagemode: bool,
    );
    pub fn heap_endscan(sscan: TableScanDesc);
    pub fn heap_getnext(sscan: TableScanDesc, direction: ScanDirection) -> HeapTuple;
    pub fn heap_getnextslot(
        sscan: TableScanDesc,
        direction: ScanDirection,
        slot: *mut TupleTableSlot,
    ) -> bool;
    pub fn heap_set_tidrange(sscan: TableScanDesc, mintid: ItemPointer, maxtid: ItemPointer);
    pub fn heap_getnextslot_tidrange(
        sscan: TableScanDesc,
        direction: ScanDirection,
        slot: *mut TupleTableSlot,
    ) -> bool;
    pub fn heap_fetch(
        relation: Relation,
        snapshot: Snapshot,
        tuple: HeapTuple,
        userbuf: *mut Buffer,
        keep_buf: bool,
    ) -> bool;
    pub fn heap_hot_search_buffer(
        tid: ItemPointer,
        relation: Relation,
        buffer: Buffer,
        snapshot: Snapshot,
        heapTuple: HeapTuple,
        all_dead: *mut bool,
        first_call: bool,
    ) -> bool;
    pub fn heap_get_latest_tid(sscan: TableScanDesc, tid: ItemPointer);
    pub fn GetBulkInsertState() -> BulkInsertState;
    pub fn FreeBulkInsertState(arg1: BulkInsertState);
    pub fn ReleaseBulkInsertStatePin(bistate: BulkInsertState);
    pub fn heap_insert(
        relation: Relation,
        tup: HeapTuple,
        cid: CommandId,
        options: ::std::os::raw::c_int,
        bistate: BulkInsertState,
    );
    pub fn heap_multi_insert(
        relation: Relation,
        slots: *mut *mut TupleTableSlot,
        ntuples: ::std::os::raw::c_int,
        cid: CommandId,
        options: ::std::os::raw::c_int,
        bistate: BulkInsertState,
    );
    pub fn heap_delete(
        relation: Relation,
        tid: ItemPointer,
        cid: CommandId,
        crosscheck: Snapshot,
        wait: bool,
        tmfd: *mut TM_FailureData,
        changingPart: bool,
    ) -> TM_Result;
    pub fn heap_finish_speculative(relation: Relation, tid: ItemPointer);
    pub fn heap_abort_speculative(relation: Relation, tid: ItemPointer);
    pub fn heap_update(
        relation: Relation,
        otid: ItemPointer,
        newtup: HeapTuple,
        cid: CommandId,
        crosscheck: Snapshot,
        wait: bool,
        tmfd: *mut TM_FailureData,
        lockmode: *mut LockTupleMode,
        update_indexes: *mut TU_UpdateIndexes,
    ) -> TM_Result;
    pub fn heap_lock_tuple(
        relation: Relation,
        tuple: HeapTuple,
        cid: CommandId,
        mode: LockTupleMode,
        wait_policy: LockWaitPolicy,
        follow_updates: bool,
        buffer: *mut Buffer,
        tmfd: *mut TM_FailureData,
    ) -> TM_Result;
    pub fn heap_inplace_update(relation: Relation, tuple: HeapTuple);
    pub fn heap_prepare_freeze_tuple(
        tuple: HeapTupleHeader,
        cutoffs: *const VacuumCutoffs,
        pagefrz: *mut HeapPageFreeze,
        frz: *mut HeapTupleFreeze,
        totally_frozen: *mut bool,
    ) -> bool;
    pub fn heap_freeze_execute_prepared(
        rel: Relation,
        buffer: Buffer,
        snapshotConflictHorizon: TransactionId,
        tuples: *mut HeapTupleFreeze,
        ntuples: ::std::os::raw::c_int,
    );
    pub fn heap_freeze_tuple(
        tuple: HeapTupleHeader,
        relfrozenxid: TransactionId,
        relminmxid: TransactionId,
        FreezeLimit: TransactionId,
        MultiXactCutoff: TransactionId,
    ) -> bool;
    pub fn heap_tuple_should_freeze(
        tuple: HeapTupleHeader,
        cutoffs: *const VacuumCutoffs,
        NoFreezePageRelfrozenXid: *mut TransactionId,
        NoFreezePageRelminMxid: *mut MultiXactId,
    ) -> bool;
    pub fn heap_tuple_needs_eventual_freeze(tuple: HeapTupleHeader) -> bool;
    pub fn simple_heap_insert(relation: Relation, tup: HeapTuple);
    pub fn simple_heap_delete(relation: Relation, tid: ItemPointer);
    pub fn simple_heap_update(
        relation: Relation,
        otid: ItemPointer,
        tup: HeapTuple,
        update_indexes: *mut TU_UpdateIndexes,
    );
    pub fn heap_index_delete_tuples(
        rel: Relation,
        delstate: *mut TM_IndexDeleteOp,
    ) -> TransactionId;
    pub fn heap_page_prune_opt(relation: Relation, buffer: Buffer);
    pub fn heap_page_prune(
        relation: Relation,
        buffer: Buffer,
        vistest: *mut GlobalVisState,
        old_snap_xmin: TransactionId,
        old_snap_ts: TimestampTz,
        nnewlpdead: *mut ::std::os::raw::c_int,
        off_loc: *mut OffsetNumber,
    ) -> ::std::os::raw::c_int;
    pub fn heap_page_prune_execute(
        buffer: Buffer,
        redirected: *mut OffsetNumber,
        nredirected: ::std::os::raw::c_int,
        nowdead: *mut OffsetNumber,
        ndead: ::std::os::raw::c_int,
        nowunused: *mut OffsetNumber,
        nunused: ::std::os::raw::c_int,
    );
    pub fn heap_get_root_tuples(page: Page, root_offsets: *mut OffsetNumber);
    pub fn heap_vacuum_rel(
        rel: Relation,
        params: *mut VacuumParams,
        bstrategy: BufferAccessStrategy,
    );
    pub fn HeapTupleSatisfiesVisibility(
        htup: HeapTuple,
        snapshot: Snapshot,
        buffer: Buffer,
    ) -> bool;
    pub fn HeapTupleSatisfiesUpdate(
        htup: HeapTuple,
        curcid: CommandId,
        buffer: Buffer,
    ) -> TM_Result;
    pub fn HeapTupleSatisfiesVacuum(
        htup: HeapTuple,
        OldestXmin: TransactionId,
        buffer: Buffer,
    ) -> HTSV_Result;
    pub fn HeapTupleSatisfiesVacuumHorizon(
        htup: HeapTuple,
        buffer: Buffer,
        dead_after: *mut TransactionId,
    ) -> HTSV_Result;
    pub fn HeapTupleSetHintBits(
        tuple: HeapTupleHeader,
        buffer: Buffer,
        infomask: uint16,
        xid: TransactionId,
    );
    pub fn HeapTupleHeaderIsOnlyLocked(tuple: HeapTupleHeader) -> bool;
    pub fn HeapTupleIsSurelyDead(htup: HeapTuple, vistest: *mut GlobalVisState) -> bool;
    pub fn ResolveCminCmaxDuringDecoding(
        tuplecid_data: *mut HTAB,
        snapshot: Snapshot,
        htup: HeapTuple,
        buffer: Buffer,
        cmin: *mut CommandId,
        cmax: *mut CommandId,
    ) -> bool;
    pub fn HeapCheckForSerializableConflictOut(
        visible: bool,
        relation: Relation,
        tuple: HeapTuple,
        buffer: Buffer,
        snapshot: Snapshot,
    );
    pub fn LWLockAcquire(lock: *mut LWLock, mode: LWLockMode) -> bool;
    pub fn LWLockConditionalAcquire(lock: *mut LWLock, mode: LWLockMode) -> bool;
    pub fn LWLockAcquireOrWait(lock: *mut LWLock, mode: LWLockMode) -> bool;
    pub fn LWLockRelease(lock: *mut LWLock);
    pub fn LWLockReleaseClearVar(lock: *mut LWLock, valptr: *mut uint64, val: uint64);
    pub fn LWLockReleaseAll();
    pub fn LWLockHeldByMe(lock: *mut LWLock) -> bool;
    pub fn LWLockAnyHeldByMe(
        lock: *mut LWLock,
        nlocks: ::std::os::raw::c_int,
        stride: usize,
    ) -> bool;
    pub fn LWLockHeldByMeInMode(lock: *mut LWLock, mode: LWLockMode) -> bool;
    pub fn LWLockWaitForVar(
        lock: *mut LWLock,
        valptr: *mut uint64,
        oldval: uint64,
        newval: *mut uint64,
    ) -> bool;
    pub fn LWLockUpdateVar(lock: *mut LWLock, valptr: *mut uint64, val: uint64);
    pub fn LWLockShmemSize() -> Size;
    pub fn CreateLWLocks();
    pub fn InitLWLockAccess();
    pub fn GetLWLockIdentifier(classId: uint32, eventId: uint16) -> *const ::std::os::raw::c_char;
    pub fn RequestNamedLWLockTranche(
        tranche_name: *const ::std::os::raw::c_char,
        num_lwlocks: ::std::os::raw::c_int,
    );
    pub fn GetNamedLWLockTranche(tranche_name: *const ::std::os::raw::c_char) -> *mut LWLockPadded;
    pub fn LWLockNewTrancheId() -> ::std::os::raw::c_int;
    pub fn LWLockRegisterTranche(
        tranche_id: ::std::os::raw::c_int,
        tranche_name: *const ::std::os::raw::c_char,
    );
    pub fn LWLockInitialize(lock: *mut LWLock, tranche_id: ::std::os::raw::c_int);
    pub fn anytimestamp_typmod_check(istz: bool, typmod: int32) -> int32;
    pub fn GetCurrentTimestamp() -> TimestampTz;
    pub fn GetSQLCurrentTimestamp(typmod: int32) -> TimestampTz;
    pub fn GetSQLLocalTimestamp(typmod: int32) -> Timestamp;
    pub fn TimestampDifference(
        start_time: TimestampTz,
        stop_time: TimestampTz,
        secs: *mut ::std::os::raw::c_long,
        microsecs: *mut ::std::os::raw::c_int,
    );
    pub fn TimestampDifferenceMilliseconds(
        start_time: TimestampTz,
        stop_time: TimestampTz,
    ) -> ::std::os::raw::c_long;
    pub fn TimestampDifferenceExceeds(
        start_time: TimestampTz,
        stop_time: TimestampTz,
        msec: ::std::os::raw::c_int,
    ) -> bool;
    pub fn time_t_to_timestamptz(tm: pg_time_t) -> TimestampTz;
    pub fn timestamptz_to_time_t(t: TimestampTz) -> pg_time_t;
    pub fn timestamptz_to_str(t: TimestampTz) -> *const ::std::os::raw::c_char;
    pub fn tm2timestamp(
        tm: *mut pg_tm,
        fsec: fsec_t,
        tzp: *mut ::std::os::raw::c_int,
        result: *mut Timestamp,
    ) -> ::std::os::raw::c_int;
    pub fn timestamp2tm(
        dt: Timestamp,
        tzp: *mut ::std::os::raw::c_int,
        tm: *mut pg_tm,
        fsec: *mut fsec_t,
        tzn: *mut *const ::std::os::raw::c_char,
        attimezone: *mut pg_tz,
    ) -> ::std::os::raw::c_int;
    pub fn dt2time(
        jd: Timestamp,
        hour: *mut ::std::os::raw::c_int,
        min: *mut ::std::os::raw::c_int,
        sec: *mut ::std::os::raw::c_int,
        fsec: *mut fsec_t,
    );
    pub fn interval2itm(span: Interval, itm: *mut pg_itm);
    pub fn itm2interval(itm: *mut pg_itm, span: *mut Interval) -> ::std::os::raw::c_int;
    pub fn itmin2interval(itm_in: *mut pg_itm_in, span: *mut Interval) -> ::std::os::raw::c_int;
    pub fn SetEpochTimestamp() -> Timestamp;
    pub fn GetEpochTime(tm: *mut pg_tm);
    pub fn timestamp_cmp_internal(dt1: Timestamp, dt2: Timestamp) -> ::std::os::raw::c_int;
    pub fn timestamp2timestamptz_opt_overflow(
        timestamp: Timestamp,
        overflow: *mut ::std::os::raw::c_int,
    ) -> TimestampTz;
    pub fn timestamp_cmp_timestamptz_internal(timestampVal: Timestamp, dt2: TimestampTz) -> int32;
    pub fn isoweek2j(
        year: ::std::os::raw::c_int,
        week: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn isoweek2date(
        woy: ::std::os::raw::c_int,
        year: *mut ::std::os::raw::c_int,
        mon: *mut ::std::os::raw::c_int,
        mday: *mut ::std::os::raw::c_int,
    );
    pub fn isoweekdate2date(
        isoweek: ::std::os::raw::c_int,
        wday: ::std::os::raw::c_int,
        year: *mut ::std::os::raw::c_int,
        mon: *mut ::std::os::raw::c_int,
        mday: *mut ::std::os::raw::c_int,
    );
    pub fn date2isoweek(
        year: ::std::os::raw::c_int,
        mon: ::std::os::raw::c_int,
        mday: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn date2isoyear(
        year: ::std::os::raw::c_int,
        mon: ::std::os::raw::c_int,
        mday: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn date2isoyearday(
        year: ::std::os::raw::c_int,
        mon: ::std::os::raw::c_int,
        mday: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn TimestampTimestampTzRequiresRewrite() -> bool;
    pub fn InitLocks();
    pub fn GetLocksMethodTable(lock: *const LOCK) -> LockMethod;
    pub fn GetLockTagsMethodTable(locktag: *const LOCKTAG) -> LockMethod;
    pub fn LockTagHashCode(locktag: *const LOCKTAG) -> uint32;
    pub fn DoLockModesConflict(mode1: LOCKMODE, mode2: LOCKMODE) -> bool;
    pub fn LockAcquire(
        locktag: *const LOCKTAG,
        lockmode: LOCKMODE,
        sessionLock: bool,
        dontWait: bool,
    ) -> LockAcquireResult;
    pub fn LockAcquireExtended(
        locktag: *const LOCKTAG,
        lockmode: LOCKMODE,
        sessionLock: bool,
        dontWait: bool,
        reportMemoryError: bool,
        locallockp: *mut *mut LOCALLOCK,
    ) -> LockAcquireResult;
    pub fn AbortStrongLockAcquire();
    pub fn MarkLockClear(locallock: *mut LOCALLOCK);
    pub fn LockRelease(locktag: *const LOCKTAG, lockmode: LOCKMODE, sessionLock: bool) -> bool;
    pub fn LockReleaseAll(lockmethodid: LOCKMETHODID, allLocks: bool);
    pub fn LockReleaseSession(lockmethodid: LOCKMETHODID);
    pub fn LockReleaseCurrentOwner(locallocks: *mut *mut LOCALLOCK, nlocks: ::std::os::raw::c_int);
    pub fn LockReassignCurrentOwner(locallocks: *mut *mut LOCALLOCK, nlocks: ::std::os::raw::c_int);
    pub fn LockHeldByMe(locktag: *const LOCKTAG, lockmode: LOCKMODE) -> bool;
    pub fn GetLockMethodLocalHash() -> *mut HTAB;
    pub fn LockHasWaiters(locktag: *const LOCKTAG, lockmode: LOCKMODE, sessionLock: bool) -> bool;
    pub fn GetLockConflicts(
        locktag: *const LOCKTAG,
        lockmode: LOCKMODE,
        countp: *mut ::std::os::raw::c_int,
    ) -> *mut VirtualTransactionId;
    pub fn AtPrepare_Locks();
    pub fn PostPrepare_Locks(xid: TransactionId);
    pub fn LockCheckConflicts(
        lockMethodTable: LockMethod,
        lockmode: LOCKMODE,
        lock: *mut LOCK,
        proclock: *mut PROCLOCK,
    ) -> bool;
    pub fn GrantLock(lock: *mut LOCK, proclock: *mut PROCLOCK, lockmode: LOCKMODE);
    pub fn GrantAwaitedLock();
    pub fn RemoveFromWaitQueue(proc_: *mut PGPROC, hashcode: uint32);
    pub fn LockShmemSize() -> Size;
    pub fn GetLockStatusData() -> *mut LockData;
    pub fn GetBlockerStatusData(blocked_pid: ::std::os::raw::c_int) -> *mut BlockedProcsData;
    pub fn GetRunningTransactionLocks(nlocks: *mut ::std::os::raw::c_int) -> *mut xl_standby_lock;
    pub fn GetLockmodeName(
        lockmethodid: LOCKMETHODID,
        mode: LOCKMODE,
    ) -> *const ::std::os::raw::c_char;
    pub fn lock_twophase_recover(
        xid: TransactionId,
        info: uint16,
        recdata: *mut ::std::os::raw::c_void,
        len: uint32,
    );
    pub fn lock_twophase_postcommit(
        xid: TransactionId,
        info: uint16,
        recdata: *mut ::std::os::raw::c_void,
        len: uint32,
    );
    pub fn lock_twophase_postabort(
        xid: TransactionId,
        info: uint16,
        recdata: *mut ::std::os::raw::c_void,
        len: uint32,
    );
    pub fn lock_twophase_standby_recover(
        xid: TransactionId,
        info: uint16,
        recdata: *mut ::std::os::raw::c_void,
        len: uint32,
    );
    pub fn DeadLockCheck(proc_: *mut PGPROC) -> DeadLockState;
    pub fn GetBlockingAutoVacuumPgproc() -> *mut PGPROC;
    pub fn DeadLockReport() -> !;
    pub fn RememberSimpleDeadLock(
        proc1: *mut PGPROC,
        lockmode: LOCKMODE,
        lock: *mut LOCK,
        proc2: *mut PGPROC,
    );
    pub fn InitDeadLockChecking();
    pub fn LockWaiterCount(locktag: *const LOCKTAG) -> ::std::os::raw::c_int;
    pub fn VirtualXactLockTableInsert(vxid: VirtualTransactionId);
    pub fn VirtualXactLockTableCleanup();
    pub fn VirtualXactLock(vxid: VirtualTransactionId, wait: bool) -> bool;
    pub fn add_reloption_kind() -> relopt_kind;
    pub fn add_bool_reloption(
        kinds: bits32,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        default_val: bool,
        lockmode: LOCKMODE,
    );
    pub fn add_int_reloption(
        kinds: bits32,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        default_val: ::std::os::raw::c_int,
        min_val: ::std::os::raw::c_int,
        max_val: ::std::os::raw::c_int,
        lockmode: LOCKMODE,
    );
    pub fn add_real_reloption(
        kinds: bits32,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        default_val: f64,
        min_val: f64,
        max_val: f64,
        lockmode: LOCKMODE,
    );
    pub fn add_enum_reloption(
        kinds: bits32,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        members: *mut relopt_enum_elt_def,
        default_val: ::std::os::raw::c_int,
        detailmsg: *const ::std::os::raw::c_char,
        lockmode: LOCKMODE,
    );
    pub fn add_string_reloption(
        kinds: bits32,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        default_val: *const ::std::os::raw::c_char,
        validator: validate_string_relopt,
        lockmode: LOCKMODE,
    );
    pub fn init_local_reloptions(relopts: *mut local_relopts, relopt_struct_size: Size);
    pub fn register_reloptions_validator(relopts: *mut local_relopts, validator: relopts_validator);
    pub fn add_local_bool_reloption(
        relopts: *mut local_relopts,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        default_val: bool,
        offset: ::std::os::raw::c_int,
    );
    pub fn add_local_int_reloption(
        relopts: *mut local_relopts,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        default_val: ::std::os::raw::c_int,
        min_val: ::std::os::raw::c_int,
        max_val: ::std::os::raw::c_int,
        offset: ::std::os::raw::c_int,
    );
    pub fn add_local_real_reloption(
        relopts: *mut local_relopts,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        default_val: f64,
        min_val: f64,
        max_val: f64,
        offset: ::std::os::raw::c_int,
    );
    pub fn add_local_enum_reloption(
        relopts: *mut local_relopts,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        members: *mut relopt_enum_elt_def,
        default_val: ::std::os::raw::c_int,
        detailmsg: *const ::std::os::raw::c_char,
        offset: ::std::os::raw::c_int,
    );
    pub fn add_local_string_reloption(
        relopts: *mut local_relopts,
        name: *const ::std::os::raw::c_char,
        desc: *const ::std::os::raw::c_char,
        default_val: *const ::std::os::raw::c_char,
        validator: validate_string_relopt,
        filler: fill_string_relopt,
        offset: ::std::os::raw::c_int,
    );
    pub fn transformRelOptions(
        oldOptions: Datum,
        defList: *mut List,
        namspace: *const ::std::os::raw::c_char,
        validnsps: *mut *mut ::std::os::raw::c_char,
        acceptOidsOff: bool,
        isReset: bool,
    ) -> Datum;
    pub fn untransformRelOptions(options: Datum) -> *mut List;
    pub fn extractRelOptions(
        tuple: HeapTuple,
        tupdesc: TupleDesc,
        amoptions: amoptions_function,
    ) -> *mut bytea;
    pub fn build_reloptions(
        reloptions: Datum,
        validate: bool,
        kind: relopt_kind,
        relopt_struct_size: Size,
        relopt_elems: *const relopt_parse_elt,
        num_relopt_elems: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
    pub fn build_local_reloptions(
        relopts: *mut local_relopts,
        options: Datum,
        validate: bool,
    ) -> *mut ::std::os::raw::c_void;
    pub fn default_reloptions(reloptions: Datum, validate: bool, kind: relopt_kind) -> *mut bytea;
    pub fn heap_reloptions(
        relkind: ::std::os::raw::c_char,
        reloptions: Datum,
        validate: bool,
    ) -> *mut bytea;
    pub fn view_reloptions(reloptions: Datum, validate: bool) -> *mut bytea;
    pub fn partitioned_table_reloptions(reloptions: Datum, validate: bool) -> *mut bytea;
    pub fn index_reloptions(
        amoptions: amoptions_function,
        reloptions: Datum,
        validate: bool,
    ) -> *mut bytea;
    pub fn attribute_reloptions(reloptions: Datum, validate: bool) -> *mut bytea;
    pub fn tablespace_reloptions(reloptions: Datum, validate: bool) -> *mut bytea;
    pub fn AlterTableGetRelOptionsLockLevel(defList: *mut List) -> LOCKMODE;
    pub fn XLogRecoveryShmemSize() -> Size;
    pub fn XLogRecoveryShmemInit();
    pub fn InitWalRecovery(
        ControlFile: *mut ControlFileData,
        wasShutdown_ptr: *mut bool,
        haveBackupLabel_ptr: *mut bool,
        haveTblspcMap_ptr: *mut bool,
    );
    pub fn PerformWalRecovery();
    pub fn FinishWalRecovery() -> *mut EndOfWalRecoveryInfo;
    pub fn ShutdownWalRecovery();
    pub fn RemovePromoteSignalFiles();
    pub fn HotStandbyActive() -> bool;
    pub fn GetXLogReplayRecPtr(replayTLI: *mut TimeLineID) -> XLogRecPtr;
    pub fn GetRecoveryPauseState() -> RecoveryPauseState;
    pub fn SetRecoveryPause(recoveryPause: bool);
    pub fn GetXLogReceiptTime(rtime: *mut TimestampTz, fromStream: *mut bool);
    pub fn GetLatestXTime() -> TimestampTz;
    pub fn GetCurrentChunkReplayStartTime() -> TimestampTz;
    pub fn GetCurrentReplayRecPtr(replayEndTLI: *mut TimeLineID) -> XLogRecPtr;
    pub fn PromoteIsTriggered() -> bool;
    pub fn CheckPromoteSignal() -> bool;
    pub fn WakeupRecovery();
    pub fn StartupRequestWalReceiverRestart();
    pub fn XLogRequestWalReceiverReply();
    pub fn RecoveryRequiresIntParameter(
        param_name: *const ::std::os::raw::c_char,
        currValue: ::std::os::raw::c_int,
        minValue: ::std::os::raw::c_int,
    );
    pub fn xlog_outdesc(buf: StringInfo, record: *mut XLogReaderState);
    pub fn AcquireDeletionLock(object: *const ObjectAddress, flags: ::std::os::raw::c_int);
    pub fn ReleaseDeletionLock(object: *const ObjectAddress);
    pub fn performDeletion(
        object: *const ObjectAddress,
        behavior: DropBehavior,
        flags: ::std::os::raw::c_int,
    );
    pub fn performMultipleDeletions(
        objects: *const ObjectAddresses,
        behavior: DropBehavior,
        flags: ::std::os::raw::c_int,
    );
    pub fn recordDependencyOnExpr(
        depender: *const ObjectAddress,
        expr: *mut Node,
        rtable: *mut List,
        behavior: DependencyType,
    );
    pub fn recordDependencyOnSingleRelExpr(
        depender: *const ObjectAddress,
        expr: *mut Node,
        relId: Oid,
        behavior: DependencyType,
        self_behavior: DependencyType,
        reverse_self: bool,
    );
    pub fn getObjectClass(object: *const ObjectAddress) -> ObjectClass;
    pub fn new_object_addresses() -> *mut ObjectAddresses;
    pub fn add_exact_object_address(object: *const ObjectAddress, addrs: *mut ObjectAddresses);
    pub fn object_address_present(
        object: *const ObjectAddress,
        addrs: *const ObjectAddresses,
    ) -> bool;
    pub fn record_object_address_dependencies(
        depender: *const ObjectAddress,
        referenced: *mut ObjectAddresses,
        behavior: DependencyType,
    );
    pub fn sort_object_addresses(addrs: *mut ObjectAddresses);
    pub fn free_object_addresses(addrs: *mut ObjectAddresses);
    pub fn recordDependencyOn(
        depender: *const ObjectAddress,
        referenced: *const ObjectAddress,
        behavior: DependencyType,
    );
    pub fn recordMultipleDependencies(
        depender: *const ObjectAddress,
        referenced: *const ObjectAddress,
        nreferenced: ::std::os::raw::c_int,
        behavior: DependencyType,
    );
    pub fn recordDependencyOnCurrentExtension(object: *const ObjectAddress, isReplace: bool);
    pub fn checkMembershipInCurrentExtension(object: *const ObjectAddress);
    pub fn deleteDependencyRecordsFor(
        classId: Oid,
        objectId: Oid,
        skipExtensionDeps: bool,
    ) -> ::std::os::raw::c_long;
    pub fn deleteDependencyRecordsForClass(
        classId: Oid,
        objectId: Oid,
        refclassId: Oid,
        deptype: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long;
    pub fn deleteDependencyRecordsForSpecific(
        classId: Oid,
        objectId: Oid,
        deptype: ::std::os::raw::c_char,
        refclassId: Oid,
        refobjectId: Oid,
    ) -> ::std::os::raw::c_long;
    pub fn changeDependencyFor(
        classId: Oid,
        objectId: Oid,
        refClassId: Oid,
        oldRefObjectId: Oid,
        newRefObjectId: Oid,
    ) -> ::std::os::raw::c_long;
    pub fn changeDependenciesOf(
        classId: Oid,
        oldObjectId: Oid,
        newObjectId: Oid,
    ) -> ::std::os::raw::c_long;
    pub fn changeDependenciesOn(
        refClassId: Oid,
        oldRefObjectId: Oid,
        newRefObjectId: Oid,
    ) -> ::std::os::raw::c_long;
    pub fn getExtensionOfObject(classId: Oid, objectId: Oid) -> Oid;
    pub fn getAutoExtensionsOfObject(classId: Oid, objectId: Oid) -> *mut List;
    pub fn sequenceIsOwned(
        seqId: Oid,
        deptype: ::std::os::raw::c_char,
        tableId: *mut Oid,
        colId: *mut int32,
    ) -> bool;
    pub fn getOwnedSequences(relid: Oid) -> *mut List;
    pub fn getIdentitySequence(relid: Oid, attnum: AttrNumber, missing_ok: bool) -> Oid;
    pub fn get_index_constraint(indexId: Oid) -> Oid;
    pub fn get_index_ref_constraints(indexId: Oid) -> *mut List;
    pub fn recordSharedDependencyOn(
        depender: *mut ObjectAddress,
        referenced: *mut ObjectAddress,
        deptype: SharedDependencyType,
    );
    pub fn deleteSharedDependencyRecordsFor(classId: Oid, objectId: Oid, objectSubId: int32);
    pub fn recordDependencyOnOwner(classId: Oid, objectId: Oid, owner: Oid);
    pub fn changeDependencyOnOwner(classId: Oid, objectId: Oid, newOwnerId: Oid);
    pub fn recordDependencyOnTablespace(classId: Oid, objectId: Oid, tablespace: Oid);
    pub fn changeDependencyOnTablespace(classId: Oid, objectId: Oid, newTablespaceId: Oid);
    pub fn updateAclDependencies(
        classId: Oid,
        objectId: Oid,
        objsubId: int32,
        ownerId: Oid,
        noldmembers: ::std::os::raw::c_int,
        oldmembers: *mut Oid,
        nnewmembers: ::std::os::raw::c_int,
        newmembers: *mut Oid,
    );
    pub fn checkSharedDependencies(
        classId: Oid,
        objectId: Oid,
        detail_msg: *mut *mut ::std::os::raw::c_char,
        detail_log_msg: *mut *mut ::std::os::raw::c_char,
    ) -> bool;
    pub fn shdepLockAndCheckObject(classId: Oid, objectId: Oid);
    pub fn copyTemplateDependencies(templateDbId: Oid, newDbId: Oid);
    pub fn dropDatabaseDependencies(databaseId: Oid);
    pub fn shdepDropOwned(roleids: *mut List, behavior: DropBehavior);
    pub fn shdepReassignOwned(roleids: *mut List, newrole: Oid);
    pub fn index_check_primary_key(
        heapRel: Relation,
        indexInfo: *mut IndexInfo,
        is_alter_table: bool,
        stmt: *mut IndexStmt,
    );
    pub fn index_create(
        heapRelation: Relation,
        indexRelationName: *const ::std::os::raw::c_char,
        indexRelationId: Oid,
        parentIndexRelid: Oid,
        parentConstraintId: Oid,
        relFileNumber: RelFileNumber,
        indexInfo: *mut IndexInfo,
        indexColNames: *mut List,
        accessMethodObjectId: Oid,
        tableSpaceId: Oid,
        collationObjectId: *mut Oid,
        classObjectId: *mut Oid,
        coloptions: *mut int16,
        reloptions: Datum,
        flags: bits16,
        constr_flags: bits16,
        allow_system_table_mods: bool,
        is_internal: bool,
        constraintId: *mut Oid,
    ) -> Oid;
    pub fn index_concurrently_create_copy(
        heapRelation: Relation,
        oldIndexId: Oid,
        tablespaceOid: Oid,
        newName: *const ::std::os::raw::c_char,
    ) -> Oid;
    pub fn index_concurrently_build(heapRelationId: Oid, indexRelationId: Oid);
    pub fn index_concurrently_swap(
        newIndexId: Oid,
        oldIndexId: Oid,
        oldName: *const ::std::os::raw::c_char,
    );
    pub fn index_concurrently_set_dead(heapId: Oid, indexId: Oid);
    pub fn index_constraint_create(
        heapRelation: Relation,
        indexRelationId: Oid,
        parentConstraintId: Oid,
        indexInfo: *mut IndexInfo,
        constraintName: *const ::std::os::raw::c_char,
        constraintType: ::std::os::raw::c_char,
        constr_flags: bits16,
        allow_system_table_mods: bool,
        is_internal: bool,
    ) -> ObjectAddress;
    pub fn index_drop(indexId: Oid, concurrent: bool, concurrent_lock_mode: bool);
    pub fn BuildIndexInfo(index: Relation) -> *mut IndexInfo;
    pub fn BuildDummyIndexInfo(index: Relation) -> *mut IndexInfo;
    pub fn CompareIndexInfo(
        info1: *mut IndexInfo,
        info2: *mut IndexInfo,
        collations1: *mut Oid,
        collations2: *mut Oid,
        opfamilies1: *mut Oid,
        opfamilies2: *mut Oid,
        attmap: *mut AttrMap,
    ) -> bool;
    pub fn BuildSpeculativeIndexInfo(index: Relation, ii: *mut IndexInfo);
    pub fn FormIndexDatum(
        indexInfo: *mut IndexInfo,
        slot: *mut TupleTableSlot,
        estate: *mut EState,
        values: *mut Datum,
        isnull: *mut bool,
    );
    pub fn index_build(
        heapRelation: Relation,
        indexRelation: Relation,
        indexInfo: *mut IndexInfo,
        isreindex: bool,
        parallel: bool,
    );
    pub fn validate_index(heapId: Oid, indexId: Oid, snapshot: Snapshot);
    pub fn index_set_state_flags(indexId: Oid, action: IndexStateFlagsAction);
    pub fn IndexGetRelation(indexId: Oid, missing_ok: bool) -> Oid;
    pub fn reindex_index(
        indexId: Oid,
        skip_constraint_checks: bool,
        persistence: ::std::os::raw::c_char,
        params: *mut ReindexParams,
    );
    pub fn reindex_relation(
        relid: Oid,
        flags: ::std::os::raw::c_int,
        params: *mut ReindexParams,
    ) -> bool;
    pub fn ReindexIsProcessingHeap(heapOid: Oid) -> bool;
    pub fn ReindexIsProcessingIndex(indexOid: Oid) -> bool;
    pub fn ResetReindexState(nestLevel: ::std::os::raw::c_int);
    pub fn EstimateReindexStateSpace() -> Size;
    pub fn SerializeReindexState(maxsize: Size, start_address: *mut ::std::os::raw::c_char);
    pub fn RestoreReindexState(reindexstate: *mut ::std::os::raw::c_void);
    pub fn IndexSetParentIndex(partitionIdx: Relation, parentOid: Oid);
    pub fn CatalogOpenIndexes(heapRel: Relation) -> CatalogIndexState;
    pub fn CatalogCloseIndexes(indstate: CatalogIndexState);
    pub fn CatalogTupleInsert(heapRel: Relation, tup: HeapTuple);
    pub fn CatalogTupleInsertWithInfo(
        heapRel: Relation,
        tup: HeapTuple,
        indstate: CatalogIndexState,
    );
    pub fn CatalogTuplesMultiInsertWithInfo(
        heapRel: Relation,
        slot: *mut *mut TupleTableSlot,
        ntuples: ::std::os::raw::c_int,
        indstate: CatalogIndexState,
    );
    pub fn CatalogTupleUpdate(heapRel: Relation, otid: ItemPointer, tup: HeapTuple);
    pub fn CatalogTupleUpdateWithInfo(
        heapRel: Relation,
        otid: ItemPointer,
        tup: HeapTuple,
        indstate: CatalogIndexState,
    );
    pub fn CatalogTupleDelete(heapRel: Relation, tid: ItemPointer);
    pub fn RangeVarGetRelidExtended(
        relation: *const RangeVar,
        lockmode: LOCKMODE,
        flags: uint32,
        callback: RangeVarGetRelidCallback,
        callback_arg: *mut ::std::os::raw::c_void,
    ) -> Oid;
    pub fn RangeVarGetCreationNamespace(newRelation: *const RangeVar) -> Oid;
    pub fn RangeVarGetAndCheckCreationNamespace(
        relation: *mut RangeVar,
        lockmode: LOCKMODE,
        existing_relation_id: *mut Oid,
    ) -> Oid;
    pub fn RangeVarAdjustRelationPersistence(newRelation: *mut RangeVar, nspid: Oid);
    pub fn RelnameGetRelid(relname: *const ::std::os::raw::c_char) -> Oid;
    pub fn RelationIsVisible(relid: Oid) -> bool;
    pub fn TypenameGetTypid(typname: *const ::std::os::raw::c_char) -> Oid;
    pub fn TypenameGetTypidExtended(typname: *const ::std::os::raw::c_char, temp_ok: bool) -> Oid;
    pub fn TypeIsVisible(typid: Oid) -> bool;
    pub fn FuncnameGetCandidates(
        names: *mut List,
        nargs: ::std::os::raw::c_int,
        argnames: *mut List,
        expand_variadic: bool,
        expand_defaults: bool,
        include_out_arguments: bool,
        missing_ok: bool,
    ) -> FuncCandidateList;
    pub fn FunctionIsVisible(funcid: Oid) -> bool;
    pub fn OpernameGetOprid(names: *mut List, oprleft: Oid, oprright: Oid) -> Oid;
    pub fn OpernameGetCandidates(
        names: *mut List,
        oprkind: ::std::os::raw::c_char,
        missing_schema_ok: bool,
    ) -> FuncCandidateList;
    pub fn OperatorIsVisible(oprid: Oid) -> bool;
    pub fn OpclassnameGetOpcid(amid: Oid, opcname: *const ::std::os::raw::c_char) -> Oid;
    pub fn OpclassIsVisible(opcid: Oid) -> bool;
    pub fn OpfamilynameGetOpfid(amid: Oid, opfname: *const ::std::os::raw::c_char) -> Oid;
    pub fn OpfamilyIsVisible(opfid: Oid) -> bool;
    pub fn CollationGetCollid(collname: *const ::std::os::raw::c_char) -> Oid;
    pub fn CollationIsVisible(collid: Oid) -> bool;
    pub fn ConversionGetConid(conname: *const ::std::os::raw::c_char) -> Oid;
    pub fn ConversionIsVisible(conid: Oid) -> bool;
    pub fn get_statistics_object_oid(names: *mut List, missing_ok: bool) -> Oid;
    pub fn StatisticsObjIsVisible(relid: Oid) -> bool;
    pub fn get_ts_parser_oid(names: *mut List, missing_ok: bool) -> Oid;
    pub fn TSParserIsVisible(prsId: Oid) -> bool;
    pub fn get_ts_dict_oid(names: *mut List, missing_ok: bool) -> Oid;
    pub fn TSDictionaryIsVisible(dictId: Oid) -> bool;
    pub fn get_ts_template_oid(names: *mut List, missing_ok: bool) -> Oid;
    pub fn TSTemplateIsVisible(tmplId: Oid) -> bool;
    pub fn get_ts_config_oid(names: *mut List, missing_ok: bool) -> Oid;
    pub fn TSConfigIsVisible(cfgid: Oid) -> bool;
    pub fn DeconstructQualifiedName(
        names: *mut List,
        nspname_p: *mut *mut ::std::os::raw::c_char,
        objname_p: *mut *mut ::std::os::raw::c_char,
    );
    pub fn LookupNamespaceNoError(nspname: *const ::std::os::raw::c_char) -> Oid;
    pub fn LookupExplicitNamespace(nspname: *const ::std::os::raw::c_char, missing_ok: bool)
        -> Oid;
    pub fn get_namespace_oid(nspname: *const ::std::os::raw::c_char, missing_ok: bool) -> Oid;
    pub fn LookupCreationNamespace(nspname: *const ::std::os::raw::c_char) -> Oid;
    pub fn CheckSetNamespace(oldNspOid: Oid, nspOid: Oid);
    pub fn QualifiedNameGetCreationNamespace(
        names: *mut List,
        objname_p: *mut *mut ::std::os::raw::c_char,
    ) -> Oid;
    pub fn makeRangeVarFromNameList(names: *mut List) -> *mut RangeVar;
    pub fn NameListToString(names: *mut List) -> *mut ::std::os::raw::c_char;
    pub fn NameListToQuotedString(names: *mut List) -> *mut ::std::os::raw::c_char;
    pub fn isTempNamespace(namespaceId: Oid) -> bool;
    pub fn isTempToastNamespace(namespaceId: Oid) -> bool;
    pub fn isTempOrTempToastNamespace(namespaceId: Oid) -> bool;
    pub fn isAnyTempNamespace(namespaceId: Oid) -> bool;
    pub fn isOtherTempNamespace(namespaceId: Oid) -> bool;
    pub fn checkTempNamespaceStatus(namespaceId: Oid) -> TempNamespaceStatus;
    pub fn GetTempNamespaceBackendId(namespaceId: Oid) -> ::std::os::raw::c_int;
    pub fn GetTempToastNamespace() -> Oid;
    pub fn GetTempNamespaceState(tempNamespaceId: *mut Oid, tempToastNamespaceId: *mut Oid);
    pub fn SetTempNamespaceState(tempNamespaceId: Oid, tempToastNamespaceId: Oid);
    pub fn ResetTempTableNamespace();
    pub fn GetOverrideSearchPath(context: MemoryContext) -> *mut OverrideSearchPath;
    pub fn CopyOverrideSearchPath(path: *mut OverrideSearchPath) -> *mut OverrideSearchPath;
    pub fn OverrideSearchPathMatchesCurrent(path: *mut OverrideSearchPath) -> bool;
    pub fn PushOverrideSearchPath(newpath: *mut OverrideSearchPath);
    pub fn PopOverrideSearchPath();
    pub fn get_collation_oid(collname: *mut List, missing_ok: bool) -> Oid;
    pub fn get_conversion_oid(conname: *mut List, missing_ok: bool) -> Oid;
    pub fn FindDefaultConversionProc(for_encoding: int32, to_encoding: int32) -> Oid;
    pub fn InitializeSearchPath();
    pub fn AtEOXact_Namespace(isCommit: bool, parallel: bool);
    pub fn AtEOSubXact_Namespace(
        isCommit: bool,
        mySubid: SubTransactionId,
        parentSubid: SubTransactionId,
    );
    pub fn fetch_search_path(includeImplicit: bool) -> *mut List;
    pub fn fetch_search_path_array(
        sarray: *mut Oid,
        sarray_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn RunObjectPostCreateHook(
        classId: Oid,
        objectId: Oid,
        subId: ::std::os::raw::c_int,
        is_internal: bool,
    );
    pub fn RunObjectDropHook(
        classId: Oid,
        objectId: Oid,
        subId: ::std::os::raw::c_int,
        dropflags: ::std::os::raw::c_int,
    );
    pub fn RunObjectTruncateHook(objectId: Oid);
    pub fn RunObjectPostAlterHook(
        classId: Oid,
        objectId: Oid,
        subId: ::std::os::raw::c_int,
        auxiliaryId: Oid,
        is_internal: bool,
    );
    pub fn RunNamespaceSearchHook(objectId: Oid, ereport_on_violation: bool) -> bool;
    pub fn RunFunctionExecuteHook(objectId: Oid);
    pub fn RunObjectPostCreateHookStr(
        classId: Oid,
        objectName: *const ::std::os::raw::c_char,
        subId: ::std::os::raw::c_int,
        is_internal: bool,
    );
    pub fn RunObjectDropHookStr(
        classId: Oid,
        objectName: *const ::std::os::raw::c_char,
        subId: ::std::os::raw::c_int,
        dropflags: ::std::os::raw::c_int,
    );
    pub fn RunObjectTruncateHookStr(objectName: *const ::std::os::raw::c_char);
    pub fn RunObjectPostAlterHookStr(
        classId: Oid,
        objectName: *const ::std::os::raw::c_char,
        subId: ::std::os::raw::c_int,
        auxiliaryId: Oid,
        is_internal: bool,
    );
    pub fn RunNamespaceSearchHookStr(
        objectName: *const ::std::os::raw::c_char,
        ereport_on_violation: bool,
    ) -> bool;
    pub fn RunFunctionExecuteHookStr(objectName: *const ::std::os::raw::c_char);
    pub fn CollationCreate(
        collname: *const ::std::os::raw::c_char,
        collnamespace: Oid,
        collowner: Oid,
        collprovider: ::std::os::raw::c_char,
        collisdeterministic: bool,
        collencoding: int32,
        collcollate: *const ::std::os::raw::c_char,
        collctype: *const ::std::os::raw::c_char,
        colliculocale: *const ::std::os::raw::c_char,
        collicurules: *const ::std::os::raw::c_char,
        collversion: *const ::std::os::raw::c_char,
        if_not_exists: bool,
        quiet: bool,
    ) -> Oid;
    pub fn database_is_invalid_form(datform: Form_pg_database) -> bool;
    pub fn database_is_invalid_oid(dboid: Oid) -> bool;
    pub fn EnumValuesCreate(enumTypeOid: Oid, vals: *mut List);
    pub fn EnumValuesDelete(enumTypeOid: Oid);
    pub fn AddEnumLabel(
        enumTypeOid: Oid,
        newVal: *const ::std::os::raw::c_char,
        neighbor: *const ::std::os::raw::c_char,
        newValIsAfter: bool,
        skipIfExists: bool,
    );
    pub fn RenameEnumLabel(
        enumTypeOid: Oid,
        oldVal: *const ::std::os::raw::c_char,
        newVal: *const ::std::os::raw::c_char,
    );
    pub fn EnumUncommitted(enum_id: Oid) -> bool;
    pub fn EstimateUncommittedEnumsSpace() -> Size;
    pub fn SerializeUncommittedEnums(space: *mut ::std::os::raw::c_void, size: Size);
    pub fn RestoreUncommittedEnums(space: *mut ::std::os::raw::c_void);
    pub fn AtEOXact_Enum();
    pub fn OperatorCreate(
        operatorName: *const ::std::os::raw::c_char,
        operatorNamespace: Oid,
        leftTypeId: Oid,
        rightTypeId: Oid,
        procedureId: Oid,
        commutatorName: *mut List,
        negatorName: *mut List,
        restrictionId: Oid,
        joinId: Oid,
        canMerge: bool,
        canHash: bool,
    ) -> ObjectAddress;
    pub fn makeOperatorDependencies(
        tuple: HeapTuple,
        makeExtensionDep: bool,
        isUpdate: bool,
    ) -> ObjectAddress;
    pub fn OperatorUpd(baseId: Oid, commId: Oid, negId: Oid, isDelete: bool);
    pub fn ProcedureCreate(
        procedureName: *const ::std::os::raw::c_char,
        procNamespace: Oid,
        replace: bool,
        returnsSet: bool,
        returnType: Oid,
        proowner: Oid,
        languageObjectId: Oid,
        languageValidator: Oid,
        prosrc: *const ::std::os::raw::c_char,
        probin: *const ::std::os::raw::c_char,
        prosqlbody: *mut Node,
        prokind: ::std::os::raw::c_char,
        security_definer: bool,
        isLeakProof: bool,
        isStrict: bool,
        volatility: ::std::os::raw::c_char,
        parallel: ::std::os::raw::c_char,
        parameterTypes: *mut oidvector,
        allParameterTypes: Datum,
        parameterModes: Datum,
        parameterNames: Datum,
        parameterDefaults: *mut List,
        trftypes: Datum,
        proconfig: Datum,
        prosupport: Oid,
        procost: float4,
        prorows: float4,
    ) -> ObjectAddress;
    pub fn function_parse_error_transpose(prosrc: *const ::std::os::raw::c_char) -> bool;
    pub fn oid_array_to_list(datum: Datum) -> *mut List;
    pub fn make_parsestate(parentParseState: *mut ParseState) -> *mut ParseState;
    pub fn free_parsestate(pstate: *mut ParseState);
    pub fn parser_errposition(
        pstate: *mut ParseState,
        location: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn setup_parser_errposition_callback(
        pcbstate: *mut ParseCallbackState,
        pstate: *mut ParseState,
        location: ::std::os::raw::c_int,
    );
    pub fn cancel_parser_errposition_callback(pcbstate: *mut ParseCallbackState);
    pub fn transformContainerType(containerType: *mut Oid, containerTypmod: *mut int32);
    pub fn transformContainerSubscripts(
        pstate: *mut ParseState,
        containerBase: *mut Node,
        containerType: Oid,
        containerTypMod: int32,
        indirection: *mut List,
        isAssignment: bool,
    ) -> *mut SubscriptingRef;
    pub fn make_const(pstate: *mut ParseState, aconst: *mut A_Const) -> *mut Const;
    pub fn acldefault(objtype: ObjectType, ownerId: Oid) -> *mut Acl;
    pub fn get_user_default_acl(objtype: ObjectType, ownerId: Oid, nsp_oid: Oid) -> *mut Acl;
    pub fn recordDependencyOnNewAcl(
        classId: Oid,
        objectId: Oid,
        objsubId: int32,
        ownerId: Oid,
        acl: *mut Acl,
    );
    pub fn aclupdate(
        old_acl: *const Acl,
        mod_aip: *const AclItem,
        modechg: ::std::os::raw::c_int,
        ownerId: Oid,
        behavior: DropBehavior,
    ) -> *mut Acl;
    pub fn aclnewowner(old_acl: *const Acl, oldOwnerId: Oid, newOwnerId: Oid) -> *mut Acl;
    pub fn make_empty_acl() -> *mut Acl;
    pub fn aclcopy(orig_acl: *const Acl) -> *mut Acl;
    pub fn aclconcat(left_acl: *const Acl, right_acl: *const Acl) -> *mut Acl;
    pub fn aclmerge(left_acl: *const Acl, right_acl: *const Acl, ownerId: Oid) -> *mut Acl;
    pub fn aclitemsort(acl: *mut Acl);
    pub fn aclequal(left_acl: *const Acl, right_acl: *const Acl) -> bool;
    pub fn aclmask(
        acl: *const Acl,
        roleid: Oid,
        ownerId: Oid,
        mask: AclMode,
        how: AclMaskHow,
    ) -> AclMode;
    pub fn aclmembers(acl: *const Acl, roleids: *mut *mut Oid) -> ::std::os::raw::c_int;
    pub fn has_privs_of_role(member: Oid, role: Oid) -> bool;
    pub fn member_can_set_role(member: Oid, role: Oid) -> bool;
    pub fn check_can_set_role(member: Oid, role: Oid);
    pub fn is_member_of_role(member: Oid, role: Oid) -> bool;
    pub fn is_member_of_role_nosuper(member: Oid, role: Oid) -> bool;
    pub fn is_admin_of_role(member: Oid, role: Oid) -> bool;
    pub fn select_best_admin(member: Oid, role: Oid) -> Oid;
    pub fn get_role_oid(rolname: *const ::std::os::raw::c_char, missing_ok: bool) -> Oid;
    pub fn get_role_oid_or_public(rolname: *const ::std::os::raw::c_char) -> Oid;
    pub fn get_rolespec_oid(role: *const RoleSpec, missing_ok: bool) -> Oid;
    pub fn check_rolespec_name(role: *const RoleSpec, detail_msg: *const ::std::os::raw::c_char);
    pub fn get_rolespec_tuple(role: *const RoleSpec) -> HeapTuple;
    pub fn get_rolespec_name(role: *const RoleSpec) -> *mut ::std::os::raw::c_char;
    pub fn select_best_grantor(
        roleId: Oid,
        privileges: AclMode,
        acl: *const Acl,
        ownerId: Oid,
        grantorId: *mut Oid,
        grantOptions: *mut AclMode,
    );
    pub fn initialize_acl();
    pub fn ExecuteGrantStmt(stmt: *mut GrantStmt);
    pub fn ExecAlterDefaultPrivilegesStmt(
        pstate: *mut ParseState,
        stmt: *mut AlterDefaultPrivilegesStmt,
    );
    pub fn RemoveRoleFromObjectACL(roleid: Oid, classid: Oid, objid: Oid);
    pub fn pg_class_aclmask(table_oid: Oid, roleid: Oid, mask: AclMode, how: AclMaskHow)
        -> AclMode;
    pub fn object_aclcheck(classid: Oid, objectid: Oid, roleid: Oid, mode: AclMode) -> AclResult;
    pub fn pg_attribute_aclcheck(
        table_oid: Oid,
        attnum: AttrNumber,
        roleid: Oid,
        mode: AclMode,
    ) -> AclResult;
    pub fn pg_attribute_aclcheck_ext(
        table_oid: Oid,
        attnum: AttrNumber,
        roleid: Oid,
        mode: AclMode,
        is_missing: *mut bool,
    ) -> AclResult;
    pub fn pg_attribute_aclcheck_all(
        table_oid: Oid,
        roleid: Oid,
        mode: AclMode,
        how: AclMaskHow,
    ) -> AclResult;
    pub fn pg_class_aclcheck(table_oid: Oid, roleid: Oid, mode: AclMode) -> AclResult;
    pub fn pg_class_aclcheck_ext(
        table_oid: Oid,
        roleid: Oid,
        mode: AclMode,
        is_missing: *mut bool,
    ) -> AclResult;
    pub fn pg_parameter_aclcheck(
        name: *const ::std::os::raw::c_char,
        roleid: Oid,
        mode: AclMode,
    ) -> AclResult;
    pub fn pg_largeobject_aclcheck_snapshot(
        lobj_oid: Oid,
        roleid: Oid,
        mode: AclMode,
        snapshot: Snapshot,
    ) -> AclResult;
    pub fn aclcheck_error(
        aclerr: AclResult,
        objtype: ObjectType,
        objectname: *const ::std::os::raw::c_char,
    );
    pub fn aclcheck_error_col(
        aclerr: AclResult,
        objtype: ObjectType,
        objectname: *const ::std::os::raw::c_char,
        colname: *const ::std::os::raw::c_char,
    );
    pub fn aclcheck_error_type(aclerr: AclResult, typeOid: Oid);
    pub fn recordExtObjInitPriv(objoid: Oid, classoid: Oid);
    pub fn removeExtObjInitPriv(objoid: Oid, classoid: Oid);
    pub fn object_ownercheck(classid: Oid, objectid: Oid, roleid: Oid) -> bool;
    pub fn has_createrole_privilege(roleid: Oid) -> bool;
    pub fn has_bypassrls_privilege(roleid: Oid) -> bool;
    pub fn NamespaceCreate(
        nspName: *const ::std::os::raw::c_char,
        ownerId: Oid,
        isTemp: bool,
    ) -> Oid;
    pub fn TypeShellMake(
        typeName: *const ::std::os::raw::c_char,
        typeNamespace: Oid,
        ownerId: Oid,
    ) -> ObjectAddress;
    pub fn TypeCreate(
        newTypeOid: Oid,
        typeName: *const ::std::os::raw::c_char,
        typeNamespace: Oid,
        relationOid: Oid,
        relationKind: ::std::os::raw::c_char,
        ownerId: Oid,
        internalSize: int16,
        typeType: ::std::os::raw::c_char,
        typeCategory: ::std::os::raw::c_char,
        typePreferred: bool,
        typDelim: ::std::os::raw::c_char,
        inputProcedure: Oid,
        outputProcedure: Oid,
        receiveProcedure: Oid,
        sendProcedure: Oid,
        typmodinProcedure: Oid,
        typmodoutProcedure: Oid,
        analyzeProcedure: Oid,
        subscriptProcedure: Oid,
        elementType: Oid,
        isImplicitArray: bool,
        arrayType: Oid,
        baseType: Oid,
        defaultTypeValue: *const ::std::os::raw::c_char,
        defaultTypeBin: *mut ::std::os::raw::c_char,
        passedByValue: bool,
        alignment: ::std::os::raw::c_char,
        storage: ::std::os::raw::c_char,
        typeMod: int32,
        typNDims: int32,
        typeNotNull: bool,
        typeCollation: Oid,
    ) -> ObjectAddress;
    pub fn GenerateTypeDependencies(
        typeTuple: HeapTuple,
        typeCatalog: Relation,
        defaultExpr: *mut Node,
        typacl: *mut ::std::os::raw::c_void,
        relationKind: ::std::os::raw::c_char,
        isImplicitArray: bool,
        isDependentType: bool,
        makeExtensionDep: bool,
        rebuild: bool,
    );
    pub fn RenameTypeInternal(
        typeOid: Oid,
        newTypeName: *const ::std::os::raw::c_char,
        typeNamespace: Oid,
    );
    pub fn makeArrayTypeName(
        typeName: *const ::std::os::raw::c_char,
        typeNamespace: Oid,
    ) -> *mut ::std::os::raw::c_char;
    pub fn moveArrayTypeName(
        typeOid: Oid,
        typeName: *const ::std::os::raw::c_char,
        typeNamespace: Oid,
    ) -> bool;
    pub fn makeMultirangeTypeName(
        rangeTypeName: *const ::std::os::raw::c_char,
        typeNamespace: Oid,
    ) -> *mut ::std::os::raw::c_char;
    pub fn CommentObject(stmt: *mut CommentStmt) -> ObjectAddress;
    pub fn DeleteComments(oid: Oid, classoid: Oid, subid: int32);
    pub fn CreateComments(
        oid: Oid,
        classoid: Oid,
        subid: int32,
        comment: *const ::std::os::raw::c_char,
    );
    pub fn DeleteSharedComments(oid: Oid, classoid: Oid);
    pub fn CreateSharedComments(oid: Oid, classoid: Oid, comment: *const ::std::os::raw::c_char);
    pub fn GetComment(oid: Oid, classoid: Oid, subid: int32) -> *mut ::std::os::raw::c_char;
    pub fn createdb(pstate: *mut ParseState, stmt: *const CreatedbStmt) -> Oid;
    pub fn dropdb(dbname: *const ::std::os::raw::c_char, missing_ok: bool, force: bool);
    pub fn DropDatabase(pstate: *mut ParseState, stmt: *mut DropdbStmt);
    pub fn RenameDatabase(
        oldname: *const ::std::os::raw::c_char,
        newname: *const ::std::os::raw::c_char,
    ) -> ObjectAddress;
    pub fn AlterDatabase(
        pstate: *mut ParseState,
        stmt: *mut AlterDatabaseStmt,
        isTopLevel: bool,
    ) -> Oid;
    pub fn AlterDatabaseRefreshColl(stmt: *mut AlterDatabaseRefreshCollStmt) -> ObjectAddress;
    pub fn AlterDatabaseSet(stmt: *mut AlterDatabaseSetStmt) -> Oid;
    pub fn AlterDatabaseOwner(
        dbname: *const ::std::os::raw::c_char,
        newOwnerId: Oid,
    ) -> ObjectAddress;
    pub fn get_database_oid(dbname: *const ::std::os::raw::c_char, missing_ok: bool) -> Oid;
    pub fn get_database_name(dbid: Oid) -> *mut ::std::os::raw::c_char;
    pub fn have_createdb_privilege() -> bool;
    pub fn check_encoding_locale_matches(
        encoding: ::std::os::raw::c_int,
        collate: *const ::std::os::raw::c_char,
        ctype: *const ::std::os::raw::c_char,
    );
    pub fn DatumGetEOHP(d: Datum) -> *mut ExpandedObjectHeader;
    pub fn EOH_init_header(
        eohptr: *mut ExpandedObjectHeader,
        methods: *const ExpandedObjectMethods,
        obj_context: MemoryContext,
    );
    pub fn EOH_get_flat_size(eohptr: *mut ExpandedObjectHeader) -> Size;
    pub fn EOH_flatten_into(
        eohptr: *mut ExpandedObjectHeader,
        result: *mut ::std::os::raw::c_void,
        allocated_size: Size,
    );
    pub fn MakeExpandedObjectReadOnlyInternal(d: Datum) -> Datum;
    pub fn TransferExpandedObject(d: Datum, new_parent: MemoryContext) -> Datum;
    pub fn DeleteExpandedObject(d: Datum);
    pub fn CopyArrayEls(
        array: *mut ArrayType,
        values: *mut Datum,
        nulls: *mut bool,
        nitems: ::std::os::raw::c_int,
        typlen: ::std::os::raw::c_int,
        typbyval: bool,
        typalign: ::std::os::raw::c_char,
        freedata: bool,
    );
    pub fn array_get_element(
        arraydatum: Datum,
        nSubscripts: ::std::os::raw::c_int,
        indx: *mut ::std::os::raw::c_int,
        arraytyplen: ::std::os::raw::c_int,
        elmlen: ::std::os::raw::c_int,
        elmbyval: bool,
        elmalign: ::std::os::raw::c_char,
        isNull: *mut bool,
    ) -> Datum;
    pub fn array_set_element(
        arraydatum: Datum,
        nSubscripts: ::std::os::raw::c_int,
        indx: *mut ::std::os::raw::c_int,
        dataValue: Datum,
        isNull: bool,
        arraytyplen: ::std::os::raw::c_int,
        elmlen: ::std::os::raw::c_int,
        elmbyval: bool,
        elmalign: ::std::os::raw::c_char,
    ) -> Datum;
    pub fn array_get_slice(
        arraydatum: Datum,
        nSubscripts: ::std::os::raw::c_int,
        upperIndx: *mut ::std::os::raw::c_int,
        lowerIndx: *mut ::std::os::raw::c_int,
        upperProvided: *mut bool,
        lowerProvided: *mut bool,
        arraytyplen: ::std::os::raw::c_int,
        elmlen: ::std::os::raw::c_int,
        elmbyval: bool,
        elmalign: ::std::os::raw::c_char,
    ) -> Datum;
    pub fn array_set_slice(
        arraydatum: Datum,
        nSubscripts: ::std::os::raw::c_int,
        upperIndx: *mut ::std::os::raw::c_int,
        lowerIndx: *mut ::std::os::raw::c_int,
        upperProvided: *mut bool,
        lowerProvided: *mut bool,
        srcArrayDatum: Datum,
        isNull: bool,
        arraytyplen: ::std::os::raw::c_int,
        elmlen: ::std::os::raw::c_int,
        elmbyval: bool,
        elmalign: ::std::os::raw::c_char,
    ) -> Datum;
    pub fn array_ref(
        array: *mut ArrayType,
        nSubscripts: ::std::os::raw::c_int,
        indx: *mut ::std::os::raw::c_int,
        arraytyplen: ::std::os::raw::c_int,
        elmlen: ::std::os::raw::c_int,
        elmbyval: bool,
        elmalign: ::std::os::raw::c_char,
        isNull: *mut bool,
    ) -> Datum;
    pub fn array_set(
        array: *mut ArrayType,
        nSubscripts: ::std::os::raw::c_int,
        indx: *mut ::std::os::raw::c_int,
        dataValue: Datum,
        isNull: bool,
        arraytyplen: ::std::os::raw::c_int,
        elmlen: ::std::os::raw::c_int,
        elmbyval: bool,
        elmalign: ::std::os::raw::c_char,
    ) -> *mut ArrayType;
    pub fn array_map(
        arrayd: Datum,
        exprstate: *mut ExprState,
        econtext: *mut ExprContext,
        retType: Oid,
        amstate: *mut ArrayMapState,
    ) -> Datum;
    pub fn array_bitmap_copy(
        destbitmap: *mut bits8,
        destoffset: ::std::os::raw::c_int,
        srcbitmap: *const bits8,
        srcoffset: ::std::os::raw::c_int,
        nitems: ::std::os::raw::c_int,
    );
    pub fn construct_array(
        elems: *mut Datum,
        nelems: ::std::os::raw::c_int,
        elmtype: Oid,
        elmlen: ::std::os::raw::c_int,
        elmbyval: bool,
        elmalign: ::std::os::raw::c_char,
    ) -> *mut ArrayType;
    pub fn construct_array_builtin(
        elems: *mut Datum,
        nelems: ::std::os::raw::c_int,
        elmtype: Oid,
    ) -> *mut ArrayType;
    pub fn construct_md_array(
        elems: *mut Datum,
        nulls: *mut bool,
        ndims: ::std::os::raw::c_int,
        dims: *mut ::std::os::raw::c_int,
        lbs: *mut ::std::os::raw::c_int,
        elmtype: Oid,
        elmlen: ::std::os::raw::c_int,
        elmbyval: bool,
        elmalign: ::std::os::raw::c_char,
    ) -> *mut ArrayType;
    pub fn construct_empty_array(elmtype: Oid) -> *mut ArrayType;
    pub fn construct_empty_expanded_array(
        element_type: Oid,
        parentcontext: MemoryContext,
        metacache: *mut ArrayMetaState,
    ) -> *mut ExpandedArrayHeader;
    pub fn deconstruct_array(
        array: *mut ArrayType,
        elmtype: Oid,
        elmlen: ::std::os::raw::c_int,
        elmbyval: bool,
        elmalign: ::std::os::raw::c_char,
        elemsp: *mut *mut Datum,
        nullsp: *mut *mut bool,
        nelemsp: *mut ::std::os::raw::c_int,
    );
    pub fn deconstruct_array_builtin(
        array: *mut ArrayType,
        elmtype: Oid,
        elemsp: *mut *mut Datum,
        nullsp: *mut *mut bool,
        nelemsp: *mut ::std::os::raw::c_int,
    );
    pub fn array_contains_nulls(array: *mut ArrayType) -> bool;
    pub fn initArrayResult(
        element_type: Oid,
        rcontext: MemoryContext,
        subcontext: bool,
    ) -> *mut ArrayBuildState;
    pub fn initArrayResultWithSize(
        element_type: Oid,
        rcontext: MemoryContext,
        subcontext: bool,
        initsize: ::std::os::raw::c_int,
    ) -> *mut ArrayBuildState;
    pub fn accumArrayResult(
        astate: *mut ArrayBuildState,
        dvalue: Datum,
        disnull: bool,
        element_type: Oid,
        rcontext: MemoryContext,
    ) -> *mut ArrayBuildState;
    pub fn makeArrayResult(astate: *mut ArrayBuildState, rcontext: MemoryContext) -> Datum;
    pub fn makeMdArrayResult(
        astate: *mut ArrayBuildState,
        ndims: ::std::os::raw::c_int,
        dims: *mut ::std::os::raw::c_int,
        lbs: *mut ::std::os::raw::c_int,
        rcontext: MemoryContext,
        release: bool,
    ) -> Datum;
    pub fn initArrayResultArr(
        array_type: Oid,
        element_type: Oid,
        rcontext: MemoryContext,
        subcontext: bool,
    ) -> *mut ArrayBuildStateArr;
    pub fn accumArrayResultArr(
        astate: *mut ArrayBuildStateArr,
        dvalue: Datum,
        disnull: bool,
        array_type: Oid,
        rcontext: MemoryContext,
    ) -> *mut ArrayBuildStateArr;
    pub fn makeArrayResultArr(
        astate: *mut ArrayBuildStateArr,
        rcontext: MemoryContext,
        release: bool,
    ) -> Datum;
    pub fn initArrayResultAny(
        input_type: Oid,
        rcontext: MemoryContext,
        subcontext: bool,
    ) -> *mut ArrayBuildStateAny;
    pub fn accumArrayResultAny(
        astate: *mut ArrayBuildStateAny,
        dvalue: Datum,
        disnull: bool,
        input_type: Oid,
        rcontext: MemoryContext,
    ) -> *mut ArrayBuildStateAny;
    pub fn makeArrayResultAny(
        astate: *mut ArrayBuildStateAny,
        rcontext: MemoryContext,
        release: bool,
    ) -> Datum;
    pub fn array_create_iterator(
        arr: *mut ArrayType,
        slice_ndim: ::std::os::raw::c_int,
        mstate: *mut ArrayMetaState,
    ) -> ArrayIterator;
    pub fn array_iterate(iterator: ArrayIterator, value: *mut Datum, isnull: *mut bool) -> bool;
    pub fn array_free_iterator(iterator: ArrayIterator);
    pub fn ArrayGetOffset(
        n: ::std::os::raw::c_int,
        dim: *const ::std::os::raw::c_int,
        lb: *const ::std::os::raw::c_int,
        indx: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn ArrayGetOffset0(
        n: ::std::os::raw::c_int,
        tup: *const ::std::os::raw::c_int,
        scale: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn ArrayGetNItems(
        ndim: ::std::os::raw::c_int,
        dims: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn ArrayGetNItemsSafe(
        ndim: ::std::os::raw::c_int,
        dims: *const ::std::os::raw::c_int,
        escontext: *mut Node,
    ) -> ::std::os::raw::c_int;
    pub fn ArrayCheckBounds(
        ndim: ::std::os::raw::c_int,
        dims: *const ::std::os::raw::c_int,
        lb: *const ::std::os::raw::c_int,
    );
    pub fn ArrayCheckBoundsSafe(
        ndim: ::std::os::raw::c_int,
        dims: *const ::std::os::raw::c_int,
        lb: *const ::std::os::raw::c_int,
        escontext: *mut Node,
    ) -> bool;
    pub fn mda_get_range(
        n: ::std::os::raw::c_int,
        span: *mut ::std::os::raw::c_int,
        st: *const ::std::os::raw::c_int,
        endp: *const ::std::os::raw::c_int,
    );
    pub fn mda_get_prod(
        n: ::std::os::raw::c_int,
        range: *const ::std::os::raw::c_int,
        prod: *mut ::std::os::raw::c_int,
    );
    pub fn mda_get_offset_values(
        n: ::std::os::raw::c_int,
        dist: *mut ::std::os::raw::c_int,
        prod: *const ::std::os::raw::c_int,
        span: *const ::std::os::raw::c_int,
    );
    pub fn mda_next_tuple(
        n: ::std::os::raw::c_int,
        curr: *mut ::std::os::raw::c_int,
        span: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn ArrayGetIntegerTypmods(arr: *mut ArrayType, n: *mut ::std::os::raw::c_int)
        -> *mut int32;
    pub fn expand_array(
        arraydatum: Datum,
        parentcontext: MemoryContext,
        metacache: *mut ArrayMetaState,
    ) -> Datum;
    pub fn DatumGetExpandedArray(d: Datum) -> *mut ExpandedArrayHeader;
    pub fn DatumGetExpandedArrayX(
        d: Datum,
        metacache: *mut ArrayMetaState,
    ) -> *mut ExpandedArrayHeader;
    pub fn DatumGetAnyArrayP(d: Datum) -> *mut AnyArrayType;
    pub fn deconstruct_expanded_array(eah: *mut ExpandedArrayHeader);
    pub fn RemoveObjects(stmt: *mut DropStmt);
    pub fn DefineIndex(
        relationId: Oid,
        stmt: *mut IndexStmt,
        indexRelationId: Oid,
        parentIndexId: Oid,
        parentConstraintId: Oid,
        total_parts: ::std::os::raw::c_int,
        is_alter_table: bool,
        check_rights: bool,
        check_not_in_use: bool,
        skip_build: bool,
        quiet: bool,
    ) -> ObjectAddress;
    pub fn ExecReindex(pstate: *mut ParseState, stmt: *mut ReindexStmt, isTopLevel: bool);
    pub fn makeObjectName(
        name1: *const ::std::os::raw::c_char,
        name2: *const ::std::os::raw::c_char,
        label: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn ChooseRelationName(
        name1: *const ::std::os::raw::c_char,
        name2: *const ::std::os::raw::c_char,
        label: *const ::std::os::raw::c_char,
        namespaceid: Oid,
        isconstraint: bool,
    ) -> *mut ::std::os::raw::c_char;
    pub fn CheckIndexCompatible(
        oldId: Oid,
        accessMethodName: *const ::std::os::raw::c_char,
        attributeList: *mut List,
        exclusionOpNames: *mut List,
    ) -> bool;
    pub fn GetDefaultOpClass(type_id: Oid, am_id: Oid) -> Oid;
    pub fn ResolveOpClass(
        opclass: *mut List,
        attrType: Oid,
        accessMethodName: *const ::std::os::raw::c_char,
        accessMethodId: Oid,
    ) -> Oid;
    pub fn CreateFunction(pstate: *mut ParseState, stmt: *mut CreateFunctionStmt) -> ObjectAddress;
    pub fn RemoveFunctionById(funcOid: Oid);
    pub fn AlterFunction(pstate: *mut ParseState, stmt: *mut AlterFunctionStmt) -> ObjectAddress;
    pub fn CreateCast(stmt: *mut CreateCastStmt) -> ObjectAddress;
    pub fn CreateTransform(stmt: *mut CreateTransformStmt) -> ObjectAddress;
    pub fn IsThereFunctionInNamespace(
        proname: *const ::std::os::raw::c_char,
        pronargs: ::std::os::raw::c_int,
        proargtypes: *mut oidvector,
        nspOid: Oid,
    );
    pub fn ExecuteDoStmt(pstate: *mut ParseState, stmt: *mut DoStmt, atomic: bool);
    pub fn ExecuteCallStmt(
        stmt: *mut CallStmt,
        params: ParamListInfo,
        atomic: bool,
        dest: *mut DestReceiver,
    );
    pub fn CallStmtResultDesc(stmt: *mut CallStmt) -> TupleDesc;
    pub fn get_transform_oid(type_id: Oid, lang_id: Oid, missing_ok: bool) -> Oid;
    pub fn interpret_function_parameter_list(
        pstate: *mut ParseState,
        parameters: *mut List,
        languageOid: Oid,
        objtype: ObjectType,
        parameterTypes: *mut *mut oidvector,
        parameterTypes_list: *mut *mut List,
        allParameterTypes: *mut *mut ArrayType,
        parameterModes: *mut *mut ArrayType,
        parameterNames: *mut *mut ArrayType,
        inParameterNames_list: *mut *mut List,
        parameterDefaults: *mut *mut List,
        variadicArgType: *mut Oid,
        requiredResultType: *mut Oid,
    );
    pub fn DefineOperator(names: *mut List, parameters: *mut List) -> ObjectAddress;
    pub fn RemoveOperatorById(operOid: Oid);
    pub fn AlterOperator(stmt: *mut AlterOperatorStmt) -> ObjectAddress;
    pub fn CreateStatistics(stmt: *mut CreateStatsStmt) -> ObjectAddress;
    pub fn AlterStatistics(stmt: *mut AlterStatsStmt) -> ObjectAddress;
    pub fn RemoveStatisticsById(statsOid: Oid);
    pub fn RemoveStatisticsDataById(statsOid: Oid, inh: bool);
    pub fn StatisticsGetRelation(statId: Oid, missing_ok: bool) -> Oid;
    pub fn DefineAggregate(
        pstate: *mut ParseState,
        name: *mut List,
        args: *mut List,
        oldstyle: bool,
        parameters: *mut List,
        replace: bool,
    ) -> ObjectAddress;
    pub fn DefineOpClass(stmt: *mut CreateOpClassStmt) -> ObjectAddress;
    pub fn DefineOpFamily(stmt: *mut CreateOpFamilyStmt) -> ObjectAddress;
    pub fn AlterOpFamily(stmt: *mut AlterOpFamilyStmt) -> Oid;
    pub fn IsThereOpClassInNamespace(
        opcname: *const ::std::os::raw::c_char,
        opcmethod: Oid,
        opcnamespace: Oid,
    );
    pub fn IsThereOpFamilyInNamespace(
        opfname: *const ::std::os::raw::c_char,
        opfmethod: Oid,
        opfnamespace: Oid,
    );
    pub fn get_opclass_oid(amID: Oid, opclassname: *mut List, missing_ok: bool) -> Oid;
    pub fn get_opfamily_oid(amID: Oid, opfamilyname: *mut List, missing_ok: bool) -> Oid;
    pub fn DefineTSParser(names: *mut List, parameters: *mut List) -> ObjectAddress;
    pub fn DefineTSDictionary(names: *mut List, parameters: *mut List) -> ObjectAddress;
    pub fn AlterTSDictionary(stmt: *mut AlterTSDictionaryStmt) -> ObjectAddress;
    pub fn DefineTSTemplate(names: *mut List, parameters: *mut List) -> ObjectAddress;
    pub fn DefineTSConfiguration(
        names: *mut List,
        parameters: *mut List,
        copied: *mut ObjectAddress,
    ) -> ObjectAddress;
    pub fn RemoveTSConfigurationById(cfgId: Oid);
    pub fn AlterTSConfiguration(stmt: *mut AlterTSConfigurationStmt) -> ObjectAddress;
    pub fn serialize_deflist(deflist: *mut List) -> *mut text;
    pub fn deserialize_deflist(txt: Datum) -> *mut List;
    pub fn AlterForeignServerOwner(
        name: *const ::std::os::raw::c_char,
        newOwnerId: Oid,
    ) -> ObjectAddress;
    pub fn AlterForeignServerOwner_oid(arg1: Oid, newOwnerId: Oid);
    pub fn AlterForeignDataWrapperOwner(
        name: *const ::std::os::raw::c_char,
        newOwnerId: Oid,
    ) -> ObjectAddress;
    pub fn AlterForeignDataWrapperOwner_oid(fwdId: Oid, newOwnerId: Oid);
    pub fn CreateForeignDataWrapper(
        pstate: *mut ParseState,
        stmt: *mut CreateFdwStmt,
    ) -> ObjectAddress;
    pub fn AlterForeignDataWrapper(
        pstate: *mut ParseState,
        stmt: *mut AlterFdwStmt,
    ) -> ObjectAddress;
    pub fn CreateForeignServer(stmt: *mut CreateForeignServerStmt) -> ObjectAddress;
    pub fn AlterForeignServer(stmt: *mut AlterForeignServerStmt) -> ObjectAddress;
    pub fn CreateUserMapping(stmt: *mut CreateUserMappingStmt) -> ObjectAddress;
    pub fn AlterUserMapping(stmt: *mut AlterUserMappingStmt) -> ObjectAddress;
    pub fn RemoveUserMapping(stmt: *mut DropUserMappingStmt) -> Oid;
    pub fn CreateForeignTable(stmt: *mut CreateForeignTableStmt, relid: Oid);
    pub fn ImportForeignSchema(stmt: *mut ImportForeignSchemaStmt);
    pub fn transformGenericOptions(
        catalogId: Oid,
        oldOptions: Datum,
        options: *mut List,
        fdwvalidator: Oid,
    ) -> Datum;
    pub fn CreateAccessMethod(stmt: *mut CreateAmStmt) -> ObjectAddress;
    pub fn get_index_am_oid(amname: *const ::std::os::raw::c_char, missing_ok: bool) -> Oid;
    pub fn get_table_am_oid(amname: *const ::std::os::raw::c_char, missing_ok: bool) -> Oid;
    pub fn get_am_oid(amname: *const ::std::os::raw::c_char, missing_ok: bool) -> Oid;
    pub fn get_am_name(amOid: Oid) -> *mut ::std::os::raw::c_char;
    pub fn defGetString(def: *mut DefElem) -> *mut ::std::os::raw::c_char;
    pub fn defGetNumeric(def: *mut DefElem) -> f64;
    pub fn defGetBoolean(def: *mut DefElem) -> bool;
    pub fn defGetInt32(def: *mut DefElem) -> int32;
    pub fn defGetInt64(def: *mut DefElem) -> int64;
    pub fn defGetObjectId(def: *mut DefElem) -> Oid;
    pub fn defGetQualifiedName(def: *mut DefElem) -> *mut List;
    pub fn defGetTypeName(def: *mut DefElem) -> *mut TypeName;
    pub fn defGetTypeLength(def: *mut DefElem) -> ::std::os::raw::c_int;
    pub fn defGetStringList(def: *mut DefElem) -> *mut List;
    pub fn errorConflictingDefElem(defel: *mut DefElem, pstate: *mut ParseState) -> !;
    pub fn CreateEventTrigger(stmt: *mut CreateEventTrigStmt) -> Oid;
    pub fn get_event_trigger_oid(trigname: *const ::std::os::raw::c_char, missing_ok: bool) -> Oid;
    pub fn AlterEventTrigger(stmt: *mut AlterEventTrigStmt) -> Oid;
    pub fn AlterEventTriggerOwner(
        name: *const ::std::os::raw::c_char,
        newOwnerId: Oid,
    ) -> ObjectAddress;
    pub fn AlterEventTriggerOwner_oid(arg1: Oid, newOwnerId: Oid);
    pub fn EventTriggerSupportsObjectType(obtype: ObjectType) -> bool;
    pub fn EventTriggerSupportsObjectClass(objclass: ObjectClass) -> bool;
    pub fn EventTriggerDDLCommandStart(parsetree: *mut Node);
    pub fn EventTriggerDDLCommandEnd(parsetree: *mut Node);
    pub fn EventTriggerSQLDrop(parsetree: *mut Node);
    pub fn EventTriggerTableRewrite(
        parsetree: *mut Node,
        tableOid: Oid,
        reason: ::std::os::raw::c_int,
    );
    pub fn EventTriggerBeginCompleteQuery() -> bool;
    pub fn EventTriggerEndCompleteQuery();
    pub fn trackDroppedObjectsNeeded() -> bool;
    pub fn EventTriggerSQLDropAddObject(object: *const ObjectAddress, original: bool, normal: bool);
    pub fn EventTriggerInhibitCommandCollection();
    pub fn EventTriggerUndoInhibitCommandCollection();
    pub fn EventTriggerCollectSimpleCommand(
        address: ObjectAddress,
        secondaryObject: ObjectAddress,
        parsetree: *mut Node,
    );
    pub fn EventTriggerAlterTableStart(parsetree: *mut Node);
    pub fn EventTriggerAlterTableRelid(objectId: Oid);
    pub fn EventTriggerCollectAlterTableSubcmd(subcmd: *mut Node, address: ObjectAddress);
    pub fn EventTriggerAlterTableEnd();
    pub fn EventTriggerCollectGrant(istmt: *mut InternalGrant);
    pub fn EventTriggerCollectAlterOpFam(
        stmt: *mut AlterOpFamilyStmt,
        opfamoid: Oid,
        operators: *mut List,
        procedures: *mut List,
    );
    pub fn EventTriggerCollectCreateOpClass(
        stmt: *mut CreateOpClassStmt,
        opcoid: Oid,
        operators: *mut List,
        procedures: *mut List,
    );
    pub fn EventTriggerCollectAlterTSConfig(
        stmt: *mut AlterTSConfigurationStmt,
        cfgId: Oid,
        dictIds: *mut Oid,
        ndicts: ::std::os::raw::c_int,
    );
    pub fn EventTriggerCollectAlterDefPrivs(stmt: *mut AlterDefaultPrivilegesStmt);
    pub fn ExplainQuery(
        pstate: *mut ParseState,
        stmt: *mut ExplainStmt,
        params: ParamListInfo,
        dest: *mut DestReceiver,
    );
    pub fn NewExplainState() -> *mut ExplainState;
    pub fn ExplainResultDesc(stmt: *mut ExplainStmt) -> TupleDesc;
    pub fn ExplainOneUtility(
        utilityStmt: *mut Node,
        into: *mut IntoClause,
        es: *mut ExplainState,
        queryString: *const ::std::os::raw::c_char,
        params: ParamListInfo,
        queryEnv: *mut QueryEnvironment,
    );
    pub fn ExplainOnePlan(
        plannedstmt: *mut PlannedStmt,
        into: *mut IntoClause,
        es: *mut ExplainState,
        queryString: *const ::std::os::raw::c_char,
        params: ParamListInfo,
        queryEnv: *mut QueryEnvironment,
        planduration: *const instr_time,
        bufusage: *const BufferUsage,
    );
    pub fn ExplainPrintPlan(es: *mut ExplainState, queryDesc: *mut QueryDesc);
    pub fn ExplainPrintTriggers(es: *mut ExplainState, queryDesc: *mut QueryDesc);
    pub fn ExplainPrintJITSummary(es: *mut ExplainState, queryDesc: *mut QueryDesc);
    pub fn ExplainQueryText(es: *mut ExplainState, queryDesc: *mut QueryDesc);
    pub fn ExplainQueryParameters(
        es: *mut ExplainState,
        params: ParamListInfo,
        maxlen: ::std::os::raw::c_int,
    );
    pub fn ExplainBeginOutput(es: *mut ExplainState);
    pub fn ExplainEndOutput(es: *mut ExplainState);
    pub fn ExplainSeparatePlans(es: *mut ExplainState);
    pub fn ExplainPropertyList(
        qlabel: *const ::std::os::raw::c_char,
        data: *mut List,
        es: *mut ExplainState,
    );
    pub fn ExplainPropertyListNested(
        qlabel: *const ::std::os::raw::c_char,
        data: *mut List,
        es: *mut ExplainState,
    );
    pub fn ExplainPropertyText(
        qlabel: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        es: *mut ExplainState,
    );
    pub fn ExplainPropertyInteger(
        qlabel: *const ::std::os::raw::c_char,
        unit: *const ::std::os::raw::c_char,
        value: int64,
        es: *mut ExplainState,
    );
    pub fn ExplainPropertyUInteger(
        qlabel: *const ::std::os::raw::c_char,
        unit: *const ::std::os::raw::c_char,
        value: uint64,
        es: *mut ExplainState,
    );
    pub fn ExplainPropertyFloat(
        qlabel: *const ::std::os::raw::c_char,
        unit: *const ::std::os::raw::c_char,
        value: f64,
        ndigits: ::std::os::raw::c_int,
        es: *mut ExplainState,
    );
    pub fn ExplainPropertyBool(
        qlabel: *const ::std::os::raw::c_char,
        value: bool,
        es: *mut ExplainState,
    );
    pub fn ExplainOpenGroup(
        objtype: *const ::std::os::raw::c_char,
        labelname: *const ::std::os::raw::c_char,
        labeled: bool,
        es: *mut ExplainState,
    );
    pub fn ExplainCloseGroup(
        objtype: *const ::std::os::raw::c_char,
        labelname: *const ::std::os::raw::c_char,
        labeled: bool,
        es: *mut ExplainState,
    );
    pub fn CreateProceduralLanguage(stmt: *mut CreatePLangStmt) -> ObjectAddress;
    pub fn get_language_oid(langname: *const ::std::os::raw::c_char, missing_ok: bool) -> Oid;
    pub fn GetSecurityLabel(
        object: *const ObjectAddress,
        provider: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn SetSecurityLabel(
        object: *const ObjectAddress,
        provider: *const ::std::os::raw::c_char,
        label: *const ::std::os::raw::c_char,
    );
    pub fn DeleteSecurityLabel(object: *const ObjectAddress);
    pub fn DeleteSharedSecurityLabel(objectId: Oid, classId: Oid);
    pub fn ExecSecLabelStmt(stmt: *mut SecLabelStmt) -> ObjectAddress;
    pub fn register_label_provider(
        provider_name: *const ::std::os::raw::c_char,
        hook: check_object_relabel_type,
    );
    pub fn CreateTableSpace(stmt: *mut CreateTableSpaceStmt) -> Oid;
    pub fn DropTableSpace(stmt: *mut DropTableSpaceStmt);
    pub fn RenameTableSpace(
        oldname: *const ::std::os::raw::c_char,
        newname: *const ::std::os::raw::c_char,
    ) -> ObjectAddress;
    pub fn AlterTableSpaceOptions(stmt: *mut AlterTableSpaceOptionsStmt) -> Oid;
    pub fn TablespaceCreateDbspace(spcOid: Oid, dbOid: Oid, isRedo: bool);
    pub fn GetDefaultTablespace(relpersistence: ::std::os::raw::c_char, partitioned: bool) -> Oid;
    pub fn PrepareTempTablespaces();
    pub fn get_tablespace_oid(
        tablespacename: *const ::std::os::raw::c_char,
        missing_ok: bool,
    ) -> Oid;
    pub fn get_tablespace_name(spc_oid: Oid) -> *mut ::std::os::raw::c_char;
    pub fn directory_is_empty(path: *const ::std::os::raw::c_char) -> bool;
    pub fn remove_tablespace_symlink(linkloc: *const ::std::os::raw::c_char);
    pub fn tblspc_redo(record: *mut XLogReaderState);
    pub fn tblspc_desc(buf: StringInfo, record: *mut XLogReaderState);
    pub fn tblspc_identify(info: uint8) -> *const ::std::os::raw::c_char;
    pub fn DefineRelation(
        stmt: *mut CreateStmt,
        relkind: ::std::os::raw::c_char,
        ownerId: Oid,
        typaddress: *mut ObjectAddress,
        queryString: *const ::std::os::raw::c_char,
    ) -> ObjectAddress;
    pub fn RemoveRelations(drop: *mut DropStmt);
    pub fn AlterTableLookupRelation(stmt: *mut AlterTableStmt, lockmode: LOCKMODE) -> Oid;
    pub fn AlterTable(
        stmt: *mut AlterTableStmt,
        lockmode: LOCKMODE,
        context: *mut AlterTableUtilityContext,
    );
    pub fn AlterTableGetLockLevel(cmds: *mut List) -> LOCKMODE;
    pub fn ATExecChangeOwner(
        relationOid: Oid,
        newOwnerId: Oid,
        recursing: bool,
        lockmode: LOCKMODE,
    );
    pub fn AlterTableInternal(relid: Oid, cmds: *mut List, recurse: bool);
    pub fn AlterTableMoveAll(stmt: *mut AlterTableMoveAllStmt) -> Oid;
    pub fn AlterTableNamespace(
        stmt: *mut AlterObjectSchemaStmt,
        oldschema: *mut Oid,
    ) -> ObjectAddress;
    pub fn AlterTableNamespaceInternal(
        rel: Relation,
        oldNspOid: Oid,
        nspOid: Oid,
        objsMoved: *mut ObjectAddresses,
    );
    pub fn AlterRelationNamespaceInternal(
        classRel: Relation,
        relOid: Oid,
        oldNspOid: Oid,
        newNspOid: Oid,
        hasDependEntry: bool,
        objsMoved: *mut ObjectAddresses,
    );
    pub fn CheckTableNotInUse(rel: Relation, stmt: *const ::std::os::raw::c_char);
    pub fn ExecuteTruncate(stmt: *mut TruncateStmt);
    pub fn ExecuteTruncateGuts(
        explicit_rels: *mut List,
        relids: *mut List,
        relids_logged: *mut List,
        behavior: DropBehavior,
        restart_seqs: bool,
        run_as_table_owner: bool,
    );
    pub fn SetRelationHasSubclass(relationId: Oid, relhassubclass: bool);
    pub fn CheckRelationTableSpaceMove(rel: Relation, newTableSpaceId: Oid) -> bool;
    pub fn SetRelationTableSpace(
        rel: Relation,
        newTableSpaceId: Oid,
        newRelFilenumber: RelFileNumber,
    );
    pub fn renameatt(stmt: *mut RenameStmt) -> ObjectAddress;
    pub fn RenameConstraint(stmt: *mut RenameStmt) -> ObjectAddress;
    pub fn RenameRelation(stmt: *mut RenameStmt) -> ObjectAddress;
    pub fn RenameRelationInternal(
        myrelid: Oid,
        newrelname: *const ::std::os::raw::c_char,
        is_internal: bool,
        is_index: bool,
    );
    pub fn ResetRelRewrite(myrelid: Oid);
    pub fn find_composite_type_dependencies(
        typeOid: Oid,
        origRelation: Relation,
        origTypeName: *const ::std::os::raw::c_char,
    );
    pub fn check_of_type(typetuple: HeapTuple);
    pub fn register_on_commit_action(relid: Oid, action: OnCommitAction);
    pub fn remove_on_commit_action(relid: Oid);
    pub fn PreCommit_on_commit_actions();
    pub fn AtEOXact_on_commit_actions(isCommit: bool);
    pub fn AtEOSubXact_on_commit_actions(
        isCommit: bool,
        mySubid: SubTransactionId,
        parentSubid: SubTransactionId,
    );
    pub fn RangeVarCallbackOwnsTable(
        relation: *const RangeVar,
        relId: Oid,
        oldRelId: Oid,
        arg: *mut ::std::os::raw::c_void,
    );
    pub fn RangeVarCallbackOwnsRelation(
        relation: *const RangeVar,
        relId: Oid,
        oldRelId: Oid,
        arg: *mut ::std::os::raw::c_void,
    );
    pub fn PartConstraintImpliedByRelConstraint(
        scanrel: Relation,
        partConstraint: *mut List,
    ) -> bool;
    pub fn CreateTrigger(
        stmt: *mut CreateTrigStmt,
        queryString: *const ::std::os::raw::c_char,
        relOid: Oid,
        refRelOid: Oid,
        constraintOid: Oid,
        indexOid: Oid,
        funcoid: Oid,
        parentTriggerOid: Oid,
        whenClause: *mut Node,
        isInternal: bool,
        in_partition: bool,
    ) -> ObjectAddress;
    pub fn CreateTriggerFiringOn(
        stmt: *mut CreateTrigStmt,
        queryString: *const ::std::os::raw::c_char,
        relOid: Oid,
        refRelOid: Oid,
        constraintOid: Oid,
        indexOid: Oid,
        funcoid: Oid,
        parentTriggerOid: Oid,
        whenClause: *mut Node,
        isInternal: bool,
        in_partition: bool,
        trigger_fires_when: ::std::os::raw::c_char,
    ) -> ObjectAddress;
    pub fn TriggerSetParentTrigger(
        trigRel: Relation,
        childTrigId: Oid,
        parentTrigId: Oid,
        childTableId: Oid,
    );
    pub fn RemoveTriggerById(trigOid: Oid);
    pub fn get_trigger_oid(
        relid: Oid,
        trigname: *const ::std::os::raw::c_char,
        missing_ok: bool,
    ) -> Oid;
    pub fn renametrig(stmt: *mut RenameStmt) -> ObjectAddress;
    pub fn EnableDisableTrigger(
        rel: Relation,
        tgname: *const ::std::os::raw::c_char,
        tgparent: Oid,
        fires_when: ::std::os::raw::c_char,
        skip_system: bool,
        recurse: bool,
        lockmode: LOCKMODE,
    );
    pub fn RelationBuildTriggers(relation: Relation);
    pub fn CopyTriggerDesc(trigdesc: *mut TriggerDesc) -> *mut TriggerDesc;
    pub fn FindTriggerIncompatibleWithInheritance(
        trigdesc: *mut TriggerDesc,
    ) -> *const ::std::os::raw::c_char;
    pub fn MakeTransitionCaptureState(
        trigdesc: *mut TriggerDesc,
        relid: Oid,
        cmdType: CmdType,
    ) -> *mut TransitionCaptureState;
    pub fn FreeTriggerDesc(trigdesc: *mut TriggerDesc);
    pub fn ExecBSInsertTriggers(estate: *mut EState, relinfo: *mut ResultRelInfo);
    pub fn ExecASInsertTriggers(
        estate: *mut EState,
        relinfo: *mut ResultRelInfo,
        transition_capture: *mut TransitionCaptureState,
    );
    pub fn ExecBRInsertTriggers(
        estate: *mut EState,
        relinfo: *mut ResultRelInfo,
        slot: *mut TupleTableSlot,
    ) -> bool;
    pub fn ExecARInsertTriggers(
        estate: *mut EState,
        relinfo: *mut ResultRelInfo,
        slot: *mut TupleTableSlot,
        recheckIndexes: *mut List,
        transition_capture: *mut TransitionCaptureState,
    );
    pub fn ExecIRInsertTriggers(
        estate: *mut EState,
        relinfo: *mut ResultRelInfo,
        slot: *mut TupleTableSlot,
    ) -> bool;
    pub fn ExecBSDeleteTriggers(estate: *mut EState, relinfo: *mut ResultRelInfo);
    pub fn ExecASDeleteTriggers(
        estate: *mut EState,
        relinfo: *mut ResultRelInfo,
        transition_capture: *mut TransitionCaptureState,
    );
    pub fn ExecBRDeleteTriggers(
        estate: *mut EState,
        epqstate: *mut EPQState,
        relinfo: *mut ResultRelInfo,
        tupleid: ItemPointer,
        fdw_trigtuple: HeapTuple,
        epqslot: *mut *mut TupleTableSlot,
        tmresult: *mut TM_Result,
        tmfd: *mut TM_FailureData,
    ) -> bool;
    pub fn ExecARDeleteTriggers(
        estate: *mut EState,
        relinfo: *mut ResultRelInfo,
        tupleid: ItemPointer,
        fdw_trigtuple: HeapTuple,
        transition_capture: *mut TransitionCaptureState,
        is_crosspart_update: bool,
    );
    pub fn ExecIRDeleteTriggers(
        estate: *mut EState,
        relinfo: *mut ResultRelInfo,
        trigtuple: HeapTuple,
    ) -> bool;
    pub fn ExecBSUpdateTriggers(estate: *mut EState, relinfo: *mut ResultRelInfo);
    pub fn ExecASUpdateTriggers(
        estate: *mut EState,
        relinfo: *mut ResultRelInfo,
        transition_capture: *mut TransitionCaptureState,
    );
    pub fn ExecBRUpdateTriggers(
        estate: *mut EState,
        epqstate: *mut EPQState,
        relinfo: *mut ResultRelInfo,
        tupleid: ItemPointer,
        fdw_trigtuple: HeapTuple,
        newslot: *mut TupleTableSlot,
        tmresult: *mut TM_Result,
        tmfd: *mut TM_FailureData,
    ) -> bool;
    pub fn ExecARUpdateTriggers(
        estate: *mut EState,
        relinfo: *mut ResultRelInfo,
        src_partinfo: *mut ResultRelInfo,
        dst_partinfo: *mut ResultRelInfo,
        tupleid: ItemPointer,
        fdw_trigtuple: HeapTuple,
        newslot: *mut TupleTableSlot,
        recheckIndexes: *mut List,
        transition_capture: *mut TransitionCaptureState,
        is_crosspart_update: bool,
    );
    pub fn ExecIRUpdateTriggers(
        estate: *mut EState,
        relinfo: *mut ResultRelInfo,
        trigtuple: HeapTuple,
        newslot: *mut TupleTableSlot,
    ) -> bool;
    pub fn ExecBSTruncateTriggers(estate: *mut EState, relinfo: *mut ResultRelInfo);
    pub fn ExecASTruncateTriggers(estate: *mut EState, relinfo: *mut ResultRelInfo);
    pub fn AfterTriggerBeginXact();
    pub fn AfterTriggerBeginQuery();
    pub fn AfterTriggerEndQuery(estate: *mut EState);
    pub fn AfterTriggerFireDeferred();
    pub fn AfterTriggerEndXact(isCommit: bool);
    pub fn AfterTriggerBeginSubXact();
    pub fn AfterTriggerEndSubXact(isCommit: bool);
    pub fn AfterTriggerSetState(stmt: *mut ConstraintsSetStmt);
    pub fn AfterTriggerPendingOnRel(relid: Oid) -> bool;
    pub fn RI_FKey_pk_upd_check_required(
        trigger: *mut Trigger,
        pk_rel: Relation,
        oldslot: *mut TupleTableSlot,
        newslot: *mut TupleTableSlot,
    ) -> bool;
    pub fn RI_FKey_fk_upd_check_required(
        trigger: *mut Trigger,
        fk_rel: Relation,
        oldslot: *mut TupleTableSlot,
        newslot: *mut TupleTableSlot,
    ) -> bool;
    pub fn RI_Initial_Check(trigger: *mut Trigger, fk_rel: Relation, pk_rel: Relation) -> bool;
    pub fn RI_PartitionRemove_Check(trigger: *mut Trigger, fk_rel: Relation, pk_rel: Relation);
    pub fn RI_FKey_trigger_type(tgfoid: Oid) -> ::std::os::raw::c_int;
    pub fn get_password_type(shadow_pass: *const ::std::os::raw::c_char) -> PasswordType;
    pub fn encrypt_password(
        target_type: PasswordType,
        role: *const ::std::os::raw::c_char,
        password: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn get_role_password(
        role: *const ::std::os::raw::c_char,
        logdetail: *mut *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn md5_crypt_verify(
        role: *const ::std::os::raw::c_char,
        shadow_pass: *const ::std::os::raw::c_char,
        client_pass: *const ::std::os::raw::c_char,
        md5_salt: *const ::std::os::raw::c_char,
        md5_salt_len: ::std::os::raw::c_int,
        logdetail: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn plain_crypt_verify(
        role: *const ::std::os::raw::c_char,
        shadow_pass: *const ::std::os::raw::c_char,
        client_pass: *const ::std::os::raw::c_char,
        logdetail: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn ParseConfigFile(
        config_file: *const ::std::os::raw::c_char,
        strict: bool,
        calling_file: *const ::std::os::raw::c_char,
        calling_lineno: ::std::os::raw::c_int,
        depth: ::std::os::raw::c_int,
        elevel: ::std::os::raw::c_int,
        head_p: *mut *mut ConfigVariable,
        tail_p: *mut *mut ConfigVariable,
    ) -> bool;
    pub fn ParseConfigFp(
        fp: *mut FILE,
        config_file: *const ::std::os::raw::c_char,
        depth: ::std::os::raw::c_int,
        elevel: ::std::os::raw::c_int,
        head_p: *mut *mut ConfigVariable,
        tail_p: *mut *mut ConfigVariable,
    ) -> bool;
    pub fn ParseConfigDirectory(
        includedir: *const ::std::os::raw::c_char,
        calling_file: *const ::std::os::raw::c_char,
        calling_lineno: ::std::os::raw::c_int,
        depth: ::std::os::raw::c_int,
        elevel: ::std::os::raw::c_int,
        head_p: *mut *mut ConfigVariable,
        tail_p: *mut *mut ConfigVariable,
    ) -> bool;
    pub fn FreeConfigVariables(list: *mut ConfigVariable);
    pub fn DeescapeQuotedString(s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    pub fn SetConfigOption(
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        context: GucContext,
        source: GucSource,
    );
    pub fn DefineCustomBoolVariable(
        name: *const ::std::os::raw::c_char,
        short_desc: *const ::std::os::raw::c_char,
        long_desc: *const ::std::os::raw::c_char,
        valueAddr: *mut bool,
        bootValue: bool,
        context: GucContext,
        flags: ::std::os::raw::c_int,
        check_hook: GucBoolCheckHook,
        assign_hook: GucBoolAssignHook,
        show_hook: GucShowHook,
    );
    pub fn DefineCustomIntVariable(
        name: *const ::std::os::raw::c_char,
        short_desc: *const ::std::os::raw::c_char,
        long_desc: *const ::std::os::raw::c_char,
        valueAddr: *mut ::std::os::raw::c_int,
        bootValue: ::std::os::raw::c_int,
        minValue: ::std::os::raw::c_int,
        maxValue: ::std::os::raw::c_int,
        context: GucContext,
        flags: ::std::os::raw::c_int,
        check_hook: GucIntCheckHook,
        assign_hook: GucIntAssignHook,
        show_hook: GucShowHook,
    );
    pub fn DefineCustomRealVariable(
        name: *const ::std::os::raw::c_char,
        short_desc: *const ::std::os::raw::c_char,
        long_desc: *const ::std::os::raw::c_char,
        valueAddr: *mut f64,
        bootValue: f64,
        minValue: f64,
        maxValue: f64,
        context: GucContext,
        flags: ::std::os::raw::c_int,
        check_hook: GucRealCheckHook,
        assign_hook: GucRealAssignHook,
        show_hook: GucShowHook,
    );
    pub fn DefineCustomStringVariable(
        name: *const ::std::os::raw::c_char,
        short_desc: *const ::std::os::raw::c_char,
        long_desc: *const ::std::os::raw::c_char,
        valueAddr: *mut *mut ::std::os::raw::c_char,
        bootValue: *const ::std::os::raw::c_char,
        context: GucContext,
        flags: ::std::os::raw::c_int,
        check_hook: GucStringCheckHook,
        assign_hook: GucStringAssignHook,
        show_hook: GucShowHook,
    );
    pub fn DefineCustomEnumVariable(
        name: *const ::std::os::raw::c_char,
        short_desc: *const ::std::os::raw::c_char,
        long_desc: *const ::std::os::raw::c_char,
        valueAddr: *mut ::std::os::raw::c_int,
        bootValue: ::std::os::raw::c_int,
        options: *const config_enum_entry,
        context: GucContext,
        flags: ::std::os::raw::c_int,
        check_hook: GucEnumCheckHook,
        assign_hook: GucEnumAssignHook,
        show_hook: GucShowHook,
    );
    pub fn MarkGUCPrefixReserved(className: *const ::std::os::raw::c_char);
    pub fn GetConfigOption(
        name: *const ::std::os::raw::c_char,
        missing_ok: bool,
        restrict_privileged: bool,
    ) -> *const ::std::os::raw::c_char;
    pub fn GetConfigOptionResetString(
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
    pub fn GetConfigOptionFlags(
        name: *const ::std::os::raw::c_char,
        missing_ok: bool,
    ) -> ::std::os::raw::c_int;
    pub fn ProcessConfigFile(context: GucContext);
    pub fn convert_GUC_name_for_parameter_acl(
        name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn check_GUC_name_for_parameter_acl(name: *const ::std::os::raw::c_char) -> bool;
    pub fn InitializeGUCOptions();
    pub fn SelectConfigFiles(
        userDoption: *const ::std::os::raw::c_char,
        progname: *const ::std::os::raw::c_char,
    ) -> bool;
    pub fn ResetAllOptions();
    pub fn AtStart_GUC();
    pub fn NewGUCNestLevel() -> ::std::os::raw::c_int;
    pub fn AtEOXact_GUC(isCommit: bool, nestLevel: ::std::os::raw::c_int);
    pub fn BeginReportingGUCOptions();
    pub fn ReportChangedGUCOptions();
    pub fn ParseLongOption(
        string: *const ::std::os::raw::c_char,
        name: *mut *mut ::std::os::raw::c_char,
        value: *mut *mut ::std::os::raw::c_char,
    );
    pub fn get_config_unit_name(flags: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
    pub fn parse_int(
        value: *const ::std::os::raw::c_char,
        result: *mut ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        hintmsg: *mut *const ::std::os::raw::c_char,
    ) -> bool;
    pub fn parse_real(
        value: *const ::std::os::raw::c_char,
        result: *mut f64,
        flags: ::std::os::raw::c_int,
        hintmsg: *mut *const ::std::os::raw::c_char,
    ) -> bool;
    pub fn set_config_option(
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        context: GucContext,
        source: GucSource,
        action: GucAction,
        changeVal: bool,
        elevel: ::std::os::raw::c_int,
        is_reload: bool,
    ) -> ::std::os::raw::c_int;
    pub fn set_config_option_ext(
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        context: GucContext,
        source: GucSource,
        srole: Oid,
        action: GucAction,
        changeVal: bool,
        elevel: ::std::os::raw::c_int,
        is_reload: bool,
    ) -> ::std::os::raw::c_int;
    pub fn AlterSystemSetConfigFile(altersysstmt: *mut AlterSystemStmt);
    pub fn GetConfigOptionByName(
        name: *const ::std::os::raw::c_char,
        varname: *mut *const ::std::os::raw::c_char,
        missing_ok: bool,
    ) -> *mut ::std::os::raw::c_char;
    pub fn ProcessGUCArray(
        array: *mut ArrayType,
        context: GucContext,
        source: GucSource,
        action: GucAction,
    );
    pub fn GUCArrayAdd(
        array: *mut ArrayType,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> *mut ArrayType;
    pub fn GUCArrayDelete(
        array: *mut ArrayType,
        name: *const ::std::os::raw::c_char,
    ) -> *mut ArrayType;
    pub fn GUCArrayReset(array: *mut ArrayType) -> *mut ArrayType;
    pub fn guc_malloc(elevel: ::std::os::raw::c_int, size: usize) -> *mut ::std::os::raw::c_void;
    pub fn guc_realloc(
        elevel: ::std::os::raw::c_int,
        old: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
    pub fn guc_strdup(
        elevel: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn guc_free(ptr: *mut ::std::os::raw::c_void);
    pub fn EstimateGUCStateSpace() -> Size;
    pub fn SerializeGUCState(maxsize: Size, start_address: *mut ::std::os::raw::c_char);
    pub fn RestoreGUCState(gucstate: *mut ::std::os::raw::c_void);
    pub fn ExecSetVariableStmt(stmt: *mut VariableSetStmt, isTopLevel: bool);
    pub fn ExtractSetVariableArgs(stmt: *mut VariableSetStmt) -> *mut ::std::os::raw::c_char;
    pub fn SetPGVariable(name: *const ::std::os::raw::c_char, args: *mut List, is_local: bool);
    pub fn GetPGVariable(name: *const ::std::os::raw::c_char, dest: *mut DestReceiver);
    pub fn GetPGVariableResultDesc(name: *const ::std::os::raw::c_char) -> TupleDesc;
    pub fn GUC_check_errcode(sqlerrcode: ::std::os::raw::c_int);
    pub fn CreateRole(pstate: *mut ParseState, stmt: *mut CreateRoleStmt) -> Oid;
    pub fn AlterRole(pstate: *mut ParseState, stmt: *mut AlterRoleStmt) -> Oid;
    pub fn AlterRoleSet(stmt: *mut AlterRoleSetStmt) -> Oid;
    pub fn DropRole(stmt: *mut DropRoleStmt);
    pub fn GrantRole(pstate: *mut ParseState, stmt: *mut GrantRoleStmt);
    pub fn RenameRole(
        oldname: *const ::std::os::raw::c_char,
        newname: *const ::std::os::raw::c_char,
    ) -> ObjectAddress;
    pub fn DropOwnedObjects(stmt: *mut DropOwnedStmt);
    pub fn ReassignOwnedObjects(stmt: *mut ReassignOwnedStmt);
    pub fn roleSpecsToIds(memberNames: *mut List) -> *mut List;
    pub fn check_createrole_self_grant(
        newval: *mut *mut ::std::os::raw::c_char,
        extra: *mut *mut ::std::os::raw::c_void,
        source: GucSource,
    ) -> bool;
    pub fn assign_createrole_self_grant(
        newval: *const ::std::os::raw::c_char,
        extra: *mut ::std::os::raw::c_void,
    );
    pub fn RegisterBackgroundWorker(worker: *mut BackgroundWorker);
    pub fn RegisterDynamicBackgroundWorker(
        worker: *mut BackgroundWorker,
        handle: *mut *mut BackgroundWorkerHandle,
    ) -> bool;
    pub fn GetBackgroundWorkerPid(
        handle: *mut BackgroundWorkerHandle,
        pidp: *mut pid_t,
    ) -> BgwHandleStatus;
    pub fn WaitForBackgroundWorkerStartup(
        handle: *mut BackgroundWorkerHandle,
        pidp: *mut pid_t,
    ) -> BgwHandleStatus;
    pub fn WaitForBackgroundWorkerShutdown(arg1: *mut BackgroundWorkerHandle) -> BgwHandleStatus;
    pub fn GetBackgroundWorkerTypeByPid(pid: pid_t) -> *const ::std::os::raw::c_char;
    pub fn TerminateBackgroundWorker(handle: *mut BackgroundWorkerHandle);
    pub fn BackgroundWorkerInitializeConnection(
        dbname: *const ::std::os::raw::c_char,
        username: *const ::std::os::raw::c_char,
        flags: uint32,
    );
    pub fn BackgroundWorkerInitializeConnectionByOid(dboid: Oid, useroid: Oid, flags: uint32);
    pub fn BackgroundWorkerBlockSignals();
    pub fn BackgroundWorkerUnblockSignals();
    pub fn InitSync();
    pub fn SyncPreCheckpoint();
    pub fn SyncPostCheckpoint();
    pub fn ProcessSyncRequests();
    pub fn RememberSyncRequest(ftag: *const FileTag, type_: SyncRequestType);
    pub fn RegisterSyncRequest(
        ftag: *const FileTag,
        type_: SyncRequestType,
        retryOnError: bool,
    ) -> bool;
    pub fn TransactionIdSetTreeStatus(
        xid: TransactionId,
        nsubxids: ::std::os::raw::c_int,
        subxids: *mut TransactionId,
        status: XidStatus,
        lsn: XLogRecPtr,
    );
    pub fn TransactionIdGetStatus(xid: TransactionId, lsn: *mut XLogRecPtr) -> XidStatus;
    pub fn CLOGShmemBuffers() -> Size;
    pub fn CLOGShmemSize() -> Size;
    pub fn CLOGShmemInit();
    pub fn BootStrapCLOG();
    pub fn StartupCLOG();
    pub fn TrimCLOG();
    pub fn CheckPointCLOG();
    pub fn ExtendCLOG(newestXact: TransactionId);
    pub fn TruncateCLOG(oldestXact: TransactionId, oldestxid_datoid: Oid);
    pub fn clogsyncfiletag(
        ftag: *const FileTag,
        path: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn clog_redo(record: *mut XLogReaderState);
    pub fn clog_desc(buf: StringInfo, record: *mut XLogReaderState);
    pub fn clog_identify(info: uint8) -> *const ::std::os::raw::c_char;
    pub fn InitializeLatchSupport();
    pub fn InitLatch(latch: *mut Latch);
    pub fn InitSharedLatch(latch: *mut Latch);
    pub fn OwnLatch(latch: *mut Latch);
    pub fn DisownLatch(latch: *mut Latch);
    pub fn SetLatch(latch: *mut Latch);
    pub fn ResetLatch(latch: *mut Latch);
    pub fn ShutdownLatchSupport();
    pub fn CreateWaitEventSet(
        context: MemoryContext,
        nevents: ::std::os::raw::c_int,
    ) -> *mut WaitEventSet;
    pub fn FreeWaitEventSet(set: *mut WaitEventSet);
    pub fn FreeWaitEventSetAfterFork(set: *mut WaitEventSet);
    pub fn AddWaitEventToSet(
        set: *mut WaitEventSet,
        events: uint32,
        fd: pgsocket,
        latch: *mut Latch,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
    pub fn ModifyWaitEvent(
        set: *mut WaitEventSet,
        pos: ::std::os::raw::c_int,
        events: uint32,
        latch: *mut Latch,
    );
    pub fn WaitEventSetWait(
        set: *mut WaitEventSet,
        timeout: ::std::os::raw::c_long,
        occurred_events: *mut WaitEvent,
        nevents: ::std::os::raw::c_int,
        wait_event_info: uint32,
    ) -> ::std::os::raw::c_int;
    pub fn WaitLatch(
        latch: *mut Latch,
        wakeEvents: ::std::os::raw::c_int,
        timeout: ::std::os::raw::c_long,
        wait_event_info: uint32,
    ) -> ::std::os::raw::c_int;
    pub fn WaitLatchOrSocket(
        latch: *mut Latch,
        wakeEvents: ::std::os::raw::c_int,
        sock: pgsocket,
        timeout: ::std::os::raw::c_long,
        wait_event_info: uint32,
    ) -> ::std::os::raw::c_int;
    pub fn InitializeLatchWaitSet();
    pub fn GetNumRegisteredWaitEvents(set: *mut WaitEventSet) -> ::std::os::raw::c_int;
    pub fn WaitEventSetCanReportClosed() -> bool;
    pub fn PGSemaphoreShmemSize(maxSemas: ::std::os::raw::c_int) -> Size;
    pub fn PGReserveSemaphores(maxSemas: ::std::os::raw::c_int);
    pub fn PGSemaphoreCreate() -> PGSemaphore;
    pub fn PGSemaphoreReset(sema: PGSemaphore);
    pub fn PGSemaphoreLock(sema: PGSemaphore);
    pub fn PGSemaphoreUnlock(sema: PGSemaphore);
    pub fn PGSemaphoreTryLock(sema: PGSemaphore) -> bool;
    pub fn ProcGlobalSemas() -> ::std::os::raw::c_int;
    pub fn ProcGlobalShmemSize() -> Size;
    pub fn InitProcGlobal();
    pub fn InitProcess();
    pub fn InitProcessPhase2();
    pub fn InitAuxiliaryProcess();
    pub fn SetStartupBufferPinWaitBufId(bufid: ::std::os::raw::c_int);
    pub fn GetStartupBufferPinWaitBufId() -> ::std::os::raw::c_int;
    pub fn HaveNFreeProcs(n: ::std::os::raw::c_int, nfree: *mut ::std::os::raw::c_int) -> bool;
    pub fn ProcReleaseLocks(isCommit: bool);
    pub fn ProcSleep(locallock: *mut LOCALLOCK, lockMethodTable: LockMethod) -> ProcWaitStatus;
    pub fn ProcWakeup(proc_: *mut PGPROC, waitStatus: ProcWaitStatus);
    pub fn ProcLockWakeup(lockMethodTable: LockMethod, lock: *mut LOCK);
    pub fn CheckDeadLockAlert();
    pub fn IsWaitingForLock() -> bool;
    pub fn LockErrorCleanup();
    pub fn ProcWaitForSignal(wait_event_info: uint32);
    pub fn ProcSendSignal(pgprocno: ::std::os::raw::c_int);
    pub fn AuxiliaryPidGetProc(pid: ::std::os::raw::c_int) -> *mut PGPROC;
    pub fn BecomeLockGroupLeader();
    pub fn BecomeLockGroupMember(leader: *mut PGPROC, pid: ::std::os::raw::c_int) -> bool;
    pub fn shm_mq_create(address: *mut ::std::os::raw::c_void, size: Size) -> *mut shm_mq;
    pub fn shm_mq_set_receiver(mq: *mut shm_mq, arg1: *mut PGPROC);
    pub fn shm_mq_set_sender(mq: *mut shm_mq, arg1: *mut PGPROC);
    pub fn shm_mq_get_receiver(arg1: *mut shm_mq) -> *mut PGPROC;
    pub fn shm_mq_get_sender(arg1: *mut shm_mq) -> *mut PGPROC;
    pub fn shm_mq_attach(
        mq: *mut shm_mq,
        seg: *mut dsm_segment,
        handle: *mut BackgroundWorkerHandle,
    ) -> *mut shm_mq_handle;
    pub fn shm_mq_set_handle(arg1: *mut shm_mq_handle, arg2: *mut BackgroundWorkerHandle);
    pub fn shm_mq_detach(mqh: *mut shm_mq_handle);
    pub fn shm_mq_get_queue(mqh: *mut shm_mq_handle) -> *mut shm_mq;
    pub fn shm_mq_send(
        mqh: *mut shm_mq_handle,
        nbytes: Size,
        data: *const ::std::os::raw::c_void,
        nowait: bool,
        force_flush: bool,
    ) -> shm_mq_result;
    pub fn shm_mq_sendv(
        mqh: *mut shm_mq_handle,
        iov: *mut shm_mq_iovec,
        iovcnt: ::std::os::raw::c_int,
        nowait: bool,
        force_flush: bool,
    ) -> shm_mq_result;
    pub fn shm_mq_receive(
        mqh: *mut shm_mq_handle,
        nbytesp: *mut Size,
        datap: *mut *mut ::std::os::raw::c_void,
        nowait: bool,
    ) -> shm_mq_result;
    pub fn shm_mq_wait_for_attach(mqh: *mut shm_mq_handle) -> shm_mq_result;
    pub fn CreateParallelContext(
        library_name: *const ::std::os::raw::c_char,
        function_name: *const ::std::os::raw::c_char,
        nworkers: ::std::os::raw::c_int,
    ) -> *mut ParallelContext;
    pub fn InitializeParallelDSM(pcxt: *mut ParallelContext);
    pub fn ReinitializeParallelDSM(pcxt: *mut ParallelContext);
    pub fn ReinitializeParallelWorkers(
        pcxt: *mut ParallelContext,
        nworkers_to_launch: ::std::os::raw::c_int,
    );
    pub fn LaunchParallelWorkers(pcxt: *mut ParallelContext);
    pub fn WaitForParallelWorkersToAttach(pcxt: *mut ParallelContext);
    pub fn WaitForParallelWorkersToFinish(pcxt: *mut ParallelContext);
    pub fn DestroyParallelContext(pcxt: *mut ParallelContext);
    pub fn ParallelContextActive() -> bool;
    pub fn HandleParallelMessageInterrupt();
    pub fn HandleParallelMessages();
    pub fn AtEOXact_Parallel(isCommit: bool);
    pub fn AtEOSubXact_Parallel(isCommit: bool, mySubId: SubTransactionId);
    pub fn ParallelWorkerReportLastRecEnd(last_xlog_end: XLogRecPtr);
    pub fn ParallelWorkerMain(main_arg: Datum);
    pub fn ExecVacuum(pstate: *mut ParseState, vacstmt: *mut VacuumStmt, isTopLevel: bool);
    pub fn vacuum(
        relations: *mut List,
        params: *mut VacuumParams,
        bstrategy: BufferAccessStrategy,
        vac_context: MemoryContext,
        isTopLevel: bool,
    );
    pub fn vac_open_indexes(
        relation: Relation,
        lockmode: LOCKMODE,
        nindexes: *mut ::std::os::raw::c_int,
        Irel: *mut *mut Relation,
    );
    pub fn vac_close_indexes(
        nindexes: ::std::os::raw::c_int,
        Irel: *mut Relation,
        lockmode: LOCKMODE,
    );
    pub fn vac_estimate_reltuples(
        relation: Relation,
        total_pages: BlockNumber,
        scanned_pages: BlockNumber,
        scanned_tuples: f64,
    ) -> f64;
    pub fn vac_update_relstats(
        relation: Relation,
        num_pages: BlockNumber,
        num_tuples: f64,
        num_all_visible_pages: BlockNumber,
        hasindex: bool,
        frozenxid: TransactionId,
        minmulti: MultiXactId,
        frozenxid_updated: *mut bool,
        minmulti_updated: *mut bool,
        in_outer_xact: bool,
    );
    pub fn vacuum_get_cutoffs(
        rel: Relation,
        params: *const VacuumParams,
        cutoffs: *mut VacuumCutoffs,
    ) -> bool;
    pub fn vacuum_xid_failsafe_check(cutoffs: *const VacuumCutoffs) -> bool;
    pub fn vac_update_datfrozenxid();
    pub fn vacuum_delay_point();
    pub fn vacuum_is_relation_owner(relid: Oid, reltuple: Form_pg_class, options: bits32) -> bool;
    pub fn vacuum_open_relation(
        relid: Oid,
        relation: *mut RangeVar,
        options: bits32,
        verbose: bool,
        lmode: LOCKMODE,
    ) -> Relation;
    pub fn vac_bulkdel_one_index(
        ivinfo: *mut IndexVacuumInfo,
        istat: *mut IndexBulkDeleteResult,
        dead_items: *mut VacDeadItems,
    ) -> *mut IndexBulkDeleteResult;
    pub fn vac_cleanup_one_index(
        ivinfo: *mut IndexVacuumInfo,
        istat: *mut IndexBulkDeleteResult,
    ) -> *mut IndexBulkDeleteResult;
    pub fn vac_max_items_to_alloc_size(max_items: ::std::os::raw::c_int) -> Size;
    pub fn AutoVacuumUpdateCostLimit();
    pub fn VacuumUpdateCosts();
    pub fn parallel_vacuum_init(
        rel: Relation,
        indrels: *mut Relation,
        nindexes: ::std::os::raw::c_int,
        nrequested_workers: ::std::os::raw::c_int,
        max_items: ::std::os::raw::c_int,
        elevel: ::std::os::raw::c_int,
        bstrategy: BufferAccessStrategy,
    ) -> *mut ParallelVacuumState;
    pub fn parallel_vacuum_end(
        pvs: *mut ParallelVacuumState,
        istats: *mut *mut IndexBulkDeleteResult,
    );
    pub fn parallel_vacuum_get_dead_items(pvs: *mut ParallelVacuumState) -> *mut VacDeadItems;
    pub fn parallel_vacuum_bulkdel_all_indexes(
        pvs: *mut ParallelVacuumState,
        num_table_tuples: ::std::os::raw::c_long,
        num_index_scans: ::std::os::raw::c_int,
    );
    pub fn parallel_vacuum_cleanup_all_indexes(
        pvs: *mut ParallelVacuumState,
        num_table_tuples: ::std::os::raw::c_long,
        num_index_scans: ::std::os::raw::c_int,
        estimated_count: bool,
    );
    pub fn parallel_vacuum_main(seg: *mut dsm_segment, toc: *mut shm_toc);
    pub fn analyze_rel(
        relid: Oid,
        relation: *mut RangeVar,
        params: *mut VacuumParams,
        va_cols: *mut List,
        in_outer_xact: bool,
        bstrategy: BufferAccessStrategy,
    );
    pub fn std_typanalyze(stats: *mut VacAttrStats) -> bool;
    pub fn anl_random_fract() -> f64;
    pub fn anl_init_selection_state(n: ::std::os::raw::c_int) -> f64;
    pub fn anl_get_next_S(t: f64, n: ::std::os::raw::c_int, stateptr: *mut f64) -> f64;
    pub fn get_configdata(
        my_exec_path: *const ::std::os::raw::c_char,
        configdata_len: *mut usize,
    ) -> *mut ConfigData;
    pub fn get_controlfile(
        DataDir: *const ::std::os::raw::c_char,
        crc_ok_p: *mut bool,
    ) -> *mut ControlFileData;
    pub fn update_controlfile(
        DataDir: *const ::std::os::raw::c_char,
        ControlFile: *mut ControlFileData,
        do_sync: bool,
    );
    pub fn raw_parser(str_: *const ::std::os::raw::c_char, mode: RawParseMode) -> *mut List;
    pub fn SystemFuncName(name: *mut ::std::os::raw::c_char) -> *mut List;
    pub fn SystemTypeName(name: *mut ::std::os::raw::c_char) -> *mut TypeName;
    pub fn ResourceOwnerCreate(
        parent: ResourceOwner,
        name: *const ::std::os::raw::c_char,
    ) -> ResourceOwner;
    pub fn ResourceOwnerRelease(
        owner: ResourceOwner,
        phase: ResourceReleasePhase,
        isCommit: bool,
        isTopLevel: bool,
    );
    pub fn ResourceOwnerReleaseAllPlanCacheRefs(owner: ResourceOwner);
    pub fn ResourceOwnerDelete(owner: ResourceOwner);
    pub fn ResourceOwnerGetParent(owner: ResourceOwner) -> ResourceOwner;
    pub fn ResourceOwnerNewParent(owner: ResourceOwner, newparent: ResourceOwner);
    pub fn RegisterResourceReleaseCallback(
        callback: ResourceReleaseCallback,
        arg: *mut ::std::os::raw::c_void,
    );
    pub fn UnregisterResourceReleaseCallback(
        callback: ResourceReleaseCallback,
        arg: *mut ::std::os::raw::c_void,
    );
    pub fn CreateAuxProcessResourceOwner();
    pub fn ReleaseAuxProcessResources(isCommit: bool);
    pub fn InitPlanCache();
    pub fn ResetPlanCache();
    pub fn CreateCachedPlan(
        raw_parse_tree: *mut RawStmt,
        query_string: *const ::std::os::raw::c_char,
        commandTag: CommandTag,
    ) -> *mut CachedPlanSource;
    pub fn CreateOneShotCachedPlan(
        raw_parse_tree: *mut RawStmt,
        query_string: *const ::std::os::raw::c_char,
        commandTag: CommandTag,
    ) -> *mut CachedPlanSource;
    pub fn CompleteCachedPlan(
        plansource: *mut CachedPlanSource,
        querytree_list: *mut List,
        querytree_context: MemoryContext,
        param_types: *mut Oid,
        num_params: ::std::os::raw::c_int,
        parserSetup: ParserSetupHook,
        parserSetupArg: *mut ::std::os::raw::c_void,
        cursor_options: ::std::os::raw::c_int,
        fixed_result: bool,
    );
    pub fn SaveCachedPlan(plansource: *mut CachedPlanSource);
    pub fn DropCachedPlan(plansource: *mut CachedPlanSource);
    pub fn CachedPlanSetParentContext(plansource: *mut CachedPlanSource, newcontext: MemoryContext);
    pub fn CopyCachedPlan(plansource: *mut CachedPlanSource) -> *mut CachedPlanSource;
    pub fn CachedPlanIsValid(plansource: *mut CachedPlanSource) -> bool;
    pub fn CachedPlanGetTargetList(
        plansource: *mut CachedPlanSource,
        queryEnv: *mut QueryEnvironment,
    ) -> *mut List;
    pub fn GetCachedPlan(
        plansource: *mut CachedPlanSource,
        boundParams: ParamListInfo,
        owner: ResourceOwner,
        queryEnv: *mut QueryEnvironment,
    ) -> *mut CachedPlan;
    pub fn ReleaseCachedPlan(plan: *mut CachedPlan, owner: ResourceOwner);
    pub fn CachedPlanAllowsSimpleValidityCheck(
        plansource: *mut CachedPlanSource,
        plan: *mut CachedPlan,
        owner: ResourceOwner,
    ) -> bool;
    pub fn CachedPlanIsSimplyValid(
        plansource: *mut CachedPlanSource,
        plan: *mut CachedPlan,
        owner: ResourceOwner,
    ) -> bool;
    pub fn GetCachedExpression(expr: *mut Node) -> *mut CachedExpression;
    pub fn FreeCachedExpression(cexpr: *mut CachedExpression);
    pub fn EnablePortalManager();
    pub fn PreCommit_Portals(isPrepare: bool) -> bool;
    pub fn AtAbort_Portals();
    pub fn AtCleanup_Portals();
    pub fn PortalErrorCleanup();
    pub fn AtSubCommit_Portals(
        mySubid: SubTransactionId,
        parentSubid: SubTransactionId,
        parentLevel: ::std::os::raw::c_int,
        parentXactOwner: ResourceOwner,
    );
    pub fn AtSubAbort_Portals(
        mySubid: SubTransactionId,
        parentSubid: SubTransactionId,
        myXactOwner: ResourceOwner,
        parentXactOwner: ResourceOwner,
    );
    pub fn AtSubCleanup_Portals(mySubid: SubTransactionId);
    pub fn CreatePortal(
        name: *const ::std::os::raw::c_char,
        allowDup: bool,
        dupSilent: bool,
    ) -> Portal;
    pub fn CreateNewPortal() -> Portal;
    pub fn PinPortal(portal: Portal);
    pub fn UnpinPortal(portal: Portal);
    pub fn MarkPortalActive(portal: Portal);
    pub fn MarkPortalDone(portal: Portal);
    pub fn MarkPortalFailed(portal: Portal);
    pub fn PortalDrop(portal: Portal, isTopCommit: bool);
    pub fn GetPortalByName(name: *const ::std::os::raw::c_char) -> Portal;
    pub fn PortalDefineQuery(
        portal: Portal,
        prepStmtName: *const ::std::os::raw::c_char,
        sourceText: *const ::std::os::raw::c_char,
        commandTag: CommandTag,
        stmts: *mut List,
        cplan: *mut CachedPlan,
    );
    pub fn PortalGetPrimaryStmt(portal: Portal) -> *mut PlannedStmt;
    pub fn PortalCreateHoldStore(portal: Portal);
    pub fn PortalHashTableDeleteAll();
    pub fn ThereAreNoReadyPortals() -> bool;
    pub fn HoldPinnedPortals();
    pub fn ForgetPortalSnapshots();
    pub fn SPI_connect() -> ::std::os::raw::c_int;
    pub fn SPI_connect_ext(options: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn SPI_finish() -> ::std::os::raw::c_int;
    pub fn SPI_execute(
        src: *const ::std::os::raw::c_char,
        read_only: bool,
        tcount: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
    pub fn SPI_execute_extended(
        src: *const ::std::os::raw::c_char,
        options: *const SPIExecuteOptions,
    ) -> ::std::os::raw::c_int;
    pub fn SPI_execute_plan(
        plan: SPIPlanPtr,
        Values: *mut Datum,
        Nulls: *const ::std::os::raw::c_char,
        read_only: bool,
        tcount: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
    pub fn SPI_execute_plan_extended(
        plan: SPIPlanPtr,
        options: *const SPIExecuteOptions,
    ) -> ::std::os::raw::c_int;
    pub fn SPI_execute_plan_with_paramlist(
        plan: SPIPlanPtr,
        params: ParamListInfo,
        read_only: bool,
        tcount: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
    pub fn SPI_exec(
        src: *const ::std::os::raw::c_char,
        tcount: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
    pub fn SPI_execp(
        plan: SPIPlanPtr,
        Values: *mut Datum,
        Nulls: *const ::std::os::raw::c_char,
        tcount: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
    pub fn SPI_execute_snapshot(
        plan: SPIPlanPtr,
        Values: *mut Datum,
        Nulls: *const ::std::os::raw::c_char,
        snapshot: Snapshot,
        crosscheck_snapshot: Snapshot,
        read_only: bool,
        fire_triggers: bool,
        tcount: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
    pub fn SPI_execute_with_args(
        src: *const ::std::os::raw::c_char,
        nargs: ::std::os::raw::c_int,
        argtypes: *mut Oid,
        Values: *mut Datum,
        Nulls: *const ::std::os::raw::c_char,
        read_only: bool,
        tcount: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
    pub fn SPI_prepare(
        src: *const ::std::os::raw::c_char,
        nargs: ::std::os::raw::c_int,
        argtypes: *mut Oid,
    ) -> SPIPlanPtr;
    pub fn SPI_prepare_cursor(
        src: *const ::std::os::raw::c_char,
        nargs: ::std::os::raw::c_int,
        argtypes: *mut Oid,
        cursorOptions: ::std::os::raw::c_int,
    ) -> SPIPlanPtr;
    pub fn SPI_prepare_extended(
        src: *const ::std::os::raw::c_char,
        options: *const SPIPrepareOptions,
    ) -> SPIPlanPtr;
    pub fn SPI_prepare_params(
        src: *const ::std::os::raw::c_char,
        parserSetup: ParserSetupHook,
        parserSetupArg: *mut ::std::os::raw::c_void,
        cursorOptions: ::std::os::raw::c_int,
    ) -> SPIPlanPtr;
    pub fn SPI_keepplan(plan: SPIPlanPtr) -> ::std::os::raw::c_int;
    pub fn SPI_saveplan(plan: SPIPlanPtr) -> SPIPlanPtr;
    pub fn SPI_freeplan(plan: SPIPlanPtr) -> ::std::os::raw::c_int;
    pub fn SPI_getargtypeid(plan: SPIPlanPtr, argIndex: ::std::os::raw::c_int) -> Oid;
    pub fn SPI_getargcount(plan: SPIPlanPtr) -> ::std::os::raw::c_int;
    pub fn SPI_is_cursor_plan(plan: SPIPlanPtr) -> bool;
    pub fn SPI_plan_is_valid(plan: SPIPlanPtr) -> bool;
    pub fn SPI_result_code_string(code: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
    pub fn SPI_plan_get_plan_sources(plan: SPIPlanPtr) -> *mut List;
    pub fn SPI_plan_get_cached_plan(plan: SPIPlanPtr) -> *mut CachedPlan;
    pub fn SPI_copytuple(tuple: HeapTuple) -> HeapTuple;
    pub fn SPI_returntuple(tuple: HeapTuple, tupdesc: TupleDesc) -> HeapTupleHeader;
    pub fn SPI_modifytuple(
        rel: Relation,
        tuple: HeapTuple,
        natts: ::std::os::raw::c_int,
        attnum: *mut ::std::os::raw::c_int,
        Values: *mut Datum,
        Nulls: *const ::std::os::raw::c_char,
    ) -> HeapTuple;
    pub fn SPI_fnumber(
        tupdesc: TupleDesc,
        fname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn SPI_fname(
        tupdesc: TupleDesc,
        fnumber: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
    pub fn SPI_getvalue(
        tuple: HeapTuple,
        tupdesc: TupleDesc,
        fnumber: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
    pub fn SPI_getbinval(
        tuple: HeapTuple,
        tupdesc: TupleDesc,
        fnumber: ::std::os::raw::c_int,
        isnull: *mut bool,
    ) -> Datum;
    pub fn SPI_gettype(
        tupdesc: TupleDesc,
        fnumber: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
    pub fn SPI_gettypeid(tupdesc: TupleDesc, fnumber: ::std::os::raw::c_int) -> Oid;
    pub fn SPI_getrelname(rel: Relation) -> *mut ::std::os::raw::c_char;
    pub fn SPI_getnspname(rel: Relation) -> *mut ::std::os::raw::c_char;
    pub fn SPI_palloc(size: Size) -> *mut ::std::os::raw::c_void;
    pub fn SPI_repalloc(
        pointer: *mut ::std::os::raw::c_void,
        size: Size,
    ) -> *mut ::std::os::raw::c_void;
    pub fn SPI_pfree(pointer: *mut ::std::os::raw::c_void);
    pub fn SPI_datumTransfer(value: Datum, typByVal: bool, typLen: ::std::os::raw::c_int) -> Datum;
    pub fn SPI_freetuple(tuple: HeapTuple);
    pub fn SPI_freetuptable(tuptable: *mut SPITupleTable);
    pub fn SPI_cursor_open(
        name: *const ::std::os::raw::c_char,
        plan: SPIPlanPtr,
        Values: *mut Datum,
        Nulls: *const ::std::os::raw::c_char,
        read_only: bool,
    ) -> Portal;
    pub fn SPI_cursor_open_with_args(
        name: *const ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        nargs: ::std::os::raw::c_int,
        argtypes: *mut Oid,
        Values: *mut Datum,
        Nulls: *const ::std::os::raw::c_char,
        read_only: bool,
        cursorOptions: ::std::os::raw::c_int,
    ) -> Portal;
    pub fn SPI_cursor_open_with_paramlist(
        name: *const ::std::os::raw::c_char,
        plan: SPIPlanPtr,
        params: ParamListInfo,
        read_only: bool,
    ) -> Portal;
    pub fn SPI_cursor_parse_open(
        name: *const ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        options: *const SPIParseOpenOptions,
    ) -> Portal;
    pub fn SPI_cursor_find(name: *const ::std::os::raw::c_char) -> Portal;
    pub fn SPI_cursor_fetch(portal: Portal, forward: bool, count: ::std::os::raw::c_long);
    pub fn SPI_cursor_move(portal: Portal, forward: bool, count: ::std::os::raw::c_long);
    pub fn SPI_scroll_cursor_fetch(
        arg1: Portal,
        direction: FetchDirection,
        count: ::std::os::raw::c_long,
    );
    pub fn SPI_scroll_cursor_move(
        arg1: Portal,
        direction: FetchDirection,
        count: ::std::os::raw::c_long,
    );
    pub fn SPI_cursor_close(portal: Portal);
    pub fn SPI_register_relation(enr: EphemeralNamedRelation) -> ::std::os::raw::c_int;
    pub fn SPI_unregister_relation(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn SPI_register_trigger_data(tdata: *mut TriggerData) -> ::std::os::raw::c_int;
    pub fn SPI_start_transaction();
    pub fn SPI_commit();
    pub fn SPI_commit_and_chain();
    pub fn SPI_rollback();
    pub fn SPI_rollback_and_chain();
    pub fn AtEOXact_SPI(isCommit: bool);
    pub fn AtEOSubXact_SPI(isCommit: bool, mySubid: SubTransactionId);
    pub fn SPI_inside_nonatomic_context() -> bool;
    pub fn is_dummy_rel(rel: *mut RelOptInfo) -> bool;
    pub fn GetFdwRoutine(fdwhandler: Oid) -> *mut FdwRoutine;
    pub fn GetForeignServerIdByRelId(relid: Oid) -> Oid;
    pub fn GetFdwRoutineByServerId(serverid: Oid) -> *mut FdwRoutine;
    pub fn GetFdwRoutineByRelId(relid: Oid) -> *mut FdwRoutine;
    pub fn GetFdwRoutineForRelation(relation: Relation, makecopy: bool) -> *mut FdwRoutine;
    pub fn IsImportableForeignTable(
        tablename: *const ::std::os::raw::c_char,
        stmt: *mut ImportForeignSchemaStmt,
    ) -> bool;
    pub fn GetExistingLocalJoinPath(joinrel: *mut RelOptInfo) -> *mut Path;
    pub fn GetForeignServer(serverid: Oid) -> *mut ForeignServer;
    pub fn GetForeignServerExtended(serverid: Oid, flags: bits16) -> *mut ForeignServer;
    pub fn GetForeignServerByName(
        srvname: *const ::std::os::raw::c_char,
        missing_ok: bool,
    ) -> *mut ForeignServer;
    pub fn GetUserMapping(userid: Oid, serverid: Oid) -> *mut UserMapping;
    pub fn GetForeignDataWrapper(fdwid: Oid) -> *mut ForeignDataWrapper;
    pub fn GetForeignDataWrapperExtended(fdwid: Oid, flags: bits16) -> *mut ForeignDataWrapper;
    pub fn GetForeignDataWrapperByName(
        fdwname: *const ::std::os::raw::c_char,
        missing_ok: bool,
    ) -> *mut ForeignDataWrapper;
    pub fn GetForeignTable(relid: Oid) -> *mut ForeignTable;
    pub fn GetForeignColumnOptions(relid: Oid, attnum: AttrNumber) -> *mut List;
    pub fn get_foreign_data_wrapper_oid(
        fdwname: *const ::std::os::raw::c_char,
        missing_ok: bool,
    ) -> Oid;
    pub fn get_foreign_server_oid(
        servername: *const ::std::os::raw::c_char,
        missing_ok: bool,
    ) -> Oid;
    pub fn _mm_sfence();
    pub fn _mm_getcsr() -> ::std::os::raw::c_uint;
    pub fn _mm_setcsr(__i: ::std::os::raw::c_uint);
    pub fn _mm_clflush(__p: *const ::std::os::raw::c_void);
    pub fn _mm_lfence();
    pub fn _mm_mfence();
    pub fn _mm_pause();
    pub fn pg_char_to_encoding(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn pg_encoding_to_char(encoding: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
    pub fn pg_valid_server_encoding_id(encoding: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn pg_encoding_mblen(
        encoding: ::std::os::raw::c_int,
        mbstr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn pg_encoding_mblen_bounded(
        encoding: ::std::os::raw::c_int,
        mbstr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn pg_encoding_dsplen(
        encoding: ::std::os::raw::c_int,
        mbstr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn pg_encoding_verifymbchar(
        encoding: ::std::os::raw::c_int,
        mbstr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn pg_encoding_verifymbstr(
        encoding: ::std::os::raw::c_int,
        mbstr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn pg_encoding_max_length(encoding: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn pg_valid_client_encoding(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn pg_valid_server_encoding(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn is_encoding_supported_by_icu(encoding: ::std::os::raw::c_int) -> bool;
    pub fn get_encoding_name_for_icu(
        encoding: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
    pub fn unicode_to_utf8(
        c: pg_wchar,
        utf8string: *mut ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
    pub fn utf8_to_unicode(c: *const ::std::os::raw::c_uchar) -> pg_wchar;
    pub fn pg_utf8_islegal(
        source: *const ::std::os::raw::c_uchar,
        length: ::std::os::raw::c_int,
    ) -> bool;
    pub fn pg_utf_mblen(s: *const ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
    pub fn pg_mule_mblen(s: *const ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
    pub fn pg_mb2wchar(
        from: *const ::std::os::raw::c_char,
        to: *mut pg_wchar,
    ) -> ::std::os::raw::c_int;
    pub fn pg_mb2wchar_with_len(
        from: *const ::std::os::raw::c_char,
        to: *mut pg_wchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn pg_encoding_mb2wchar_with_len(
        encoding: ::std::os::raw::c_int,
        from: *const ::std::os::raw::c_char,
        to: *mut pg_wchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn pg_wchar2mb(
        from: *const pg_wchar,
        to: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn pg_wchar2mb_with_len(
        from: *const pg_wchar,
        to: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn pg_encoding_wchar2mb_with_len(
        encoding: ::std::os::raw::c_int,
        from: *const pg_wchar,
        to: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn pg_char_and_wchar_strcmp(
        s1: *const ::std::os::raw::c_char,
        s2: *const pg_wchar,
    ) -> ::std::os::raw::c_int;
    pub fn pg_wchar_strncmp(
        s1: *const pg_wchar,
        s2: *const pg_wchar,
        n: usize,
    ) -> ::std::os::raw::c_int;
    pub fn pg_char_and_wchar_strncmp(
        s1: *const ::std::os::raw::c_char,
        s2: *const pg_wchar,
        n: usize,
    ) -> ::std::os::raw::c_int;
    pub fn pg_wchar_strlen(str_: *const pg_wchar) -> usize;
    pub fn pg_mblen(mbstr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn pg_dsplen(mbstr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn pg_mbstrlen(mbstr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn pg_mbstrlen_with_len(
        mbstr: *const ::std::os::raw::c_char,
        limit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn pg_mbcliplen(
        mbstr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        limit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn pg_encoding_mbcliplen(
        encoding: ::std::os::raw::c_int,
        mbstr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        limit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn pg_mbcharcliplen(
        mbstr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        limit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn pg_database_encoding_max_length() -> ::std::os::raw::c_int;
    pub fn pg_database_encoding_character_incrementer() -> mbcharacter_incrementer;
    pub fn PrepareClientEncoding(encoding: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn SetClientEncoding(encoding: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn InitializeClientEncoding();
    pub fn pg_get_client_encoding() -> ::std::os::raw::c_int;
    pub fn pg_get_client_encoding_name() -> *const ::std::os::raw::c_char;
    pub fn SetDatabaseEncoding(encoding: ::std::os::raw::c_int);
    pub fn GetDatabaseEncoding() -> ::std::os::raw::c_int;
    pub fn GetDatabaseEncodingName() -> *const ::std::os::raw::c_char;
    pub fn SetMessageEncoding(encoding: ::std::os::raw::c_int);
    pub fn GetMessageEncoding() -> ::std::os::raw::c_int;
    pub fn pg_do_encoding_conversion(
        src: *mut ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        src_encoding: ::std::os::raw::c_int,
        dest_encoding: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_uchar;
    pub fn pg_do_encoding_conversion_buf(
        proc_: Oid,
        src_encoding: ::std::os::raw::c_int,
        dest_encoding: ::std::os::raw::c_int,
        src: *mut ::std::os::raw::c_uchar,
        srclen: ::std::os::raw::c_int,
        dest: *mut ::std::os::raw::c_uchar,
        destlen: ::std::os::raw::c_int,
        noError: bool,
    ) -> ::std::os::raw::c_int;
    pub fn pg_client_to_server(
        s: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
    pub fn pg_server_to_client(
        s: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
    pub fn pg_any_to_server(
        s: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        encoding: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
    pub fn pg_server_to_any(
        s: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        encoding: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
    pub fn pg_unicode_to_server(c: pg_wchar, s: *mut ::std::os::raw::c_uchar);
    pub fn pg_unicode_to_server_noerror(c: pg_wchar, s: *mut ::std::os::raw::c_uchar) -> bool;
    pub fn BIG5toCNS(
        big5: ::std::os::raw::c_ushort,
        lc: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_ushort;
    pub fn CNStoBIG5(
        cns: ::std::os::raw::c_ushort,
        lc: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_ushort;
    pub fn UtfToLocal(
        utf: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        iso: *mut ::std::os::raw::c_uchar,
        map: *const pg_mb_radix_tree,
        cmap: *const pg_utf_to_local_combined,
        cmapsize: ::std::os::raw::c_int,
        conv_func: utf_local_conversion_func,
        encoding: ::std::os::raw::c_int,
        noError: bool,
    ) -> ::std::os::raw::c_int;
    pub fn LocalToUtf(
        iso: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        utf: *mut ::std::os::raw::c_uchar,
        map: *const pg_mb_radix_tree,
        cmap: *const pg_local_to_utf_combined,
        cmapsize: ::std::os::raw::c_int,
        conv_func: utf_local_conversion_func,
        encoding: ::std::os::raw::c_int,
        noError: bool,
    ) -> ::std::os::raw::c_int;
    pub fn pg_verifymbstr(
        mbstr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        noError: bool,
    ) -> bool;
    pub fn pg_verify_mbstr(
        encoding: ::std::os::raw::c_int,
        mbstr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        noError: bool,
    ) -> bool;
    pub fn pg_verify_mbstr_len(
        encoding: ::std::os::raw::c_int,
        mbstr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        noError: bool,
    ) -> ::std::os::raw::c_int;
    pub fn check_encoding_conversion_args(
        src_encoding: ::std::os::raw::c_int,
        dest_encoding: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
        expected_src_encoding: ::std::os::raw::c_int,
        expected_dest_encoding: ::std::os::raw::c_int,
    );
    pub fn report_invalid_encoding(
        encoding: ::std::os::raw::c_int,
        mbstr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> !;
    pub fn report_untranslatable_char(
        src_encoding: ::std::os::raw::c_int,
        dest_encoding: ::std::os::raw::c_int,
        mbstr: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> !;
    pub fn local2local(
        l: *const ::std::os::raw::c_uchar,
        p: *mut ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        src_encoding: ::std::os::raw::c_int,
        dest_encoding: ::std::os::raw::c_int,
        tab: *const ::std::os::raw::c_uchar,
        noError: bool,
    ) -> ::std::os::raw::c_int;
    pub fn latin2mic(
        l: *const ::std::os::raw::c_uchar,
        p: *mut ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        lc: ::std::os::raw::c_int,
        encoding: ::std::os::raw::c_int,
        noError: bool,
    ) -> ::std::os::raw::c_int;
    pub fn mic2latin(
        mic: *const ::std::os::raw::c_uchar,
        p: *mut ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        lc: ::std::os::raw::c_int,
        encoding: ::std::os::raw::c_int,
        noError: bool,
    ) -> ::std::os::raw::c_int;
    pub fn latin2mic_with_table(
        l: *const ::std::os::raw::c_uchar,
        p: *mut ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        lc: ::std::os::raw::c_int,
        encoding: ::std::os::raw::c_int,
        tab: *const ::std::os::raw::c_uchar,
        noError: bool,
    ) -> ::std::os::raw::c_int;
    pub fn mic2latin_with_table(
        mic: *const ::std::os::raw::c_uchar,
        p: *mut ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
        lc: ::std::os::raw::c_int,
        encoding: ::std::os::raw::c_int,
        tab: *const ::std::os::raw::c_uchar,
        noError: bool,
    ) -> ::std::os::raw::c_int;
    pub fn RegisterExtensibleNodeMethods(methods: *const ExtensibleNodeMethods);
    pub fn GetExtensibleNodeMethods(
        extnodename: *const ::std::os::raw::c_char,
        missing_ok: bool,
    ) -> *const ExtensibleNodeMethods;
    pub fn RegisterCustomScanMethods(methods: *const CustomScanMethods);
    pub fn GetCustomScanMethods(
        CustomName: *const ::std::os::raw::c_char,
        missing_ok: bool,
    ) -> *const CustomScanMethods;
    pub fn makeA_Expr(
        kind: A_Expr_Kind,
        name: *mut List,
        lexpr: *mut Node,
        rexpr: *mut Node,
        location: ::std::os::raw::c_int,
    ) -> *mut A_Expr;
    pub fn makeSimpleA_Expr(
        kind: A_Expr_Kind,
        name: *mut ::std::os::raw::c_char,
        lexpr: *mut Node,
        rexpr: *mut Node,
        location: ::std::os::raw::c_int,
    ) -> *mut A_Expr;
    pub fn makeVar(
        varno: ::std::os::raw::c_int,
        varattno: AttrNumber,
        vartype: Oid,
        vartypmod: int32,
        varcollid: Oid,
        varlevelsup: Index,
    ) -> *mut Var;
    pub fn makeVarFromTargetEntry(varno: ::std::os::raw::c_int, tle: *mut TargetEntry) -> *mut Var;
    pub fn makeWholeRowVar(
        rte: *mut RangeTblEntry,
        varno: ::std::os::raw::c_int,
        varlevelsup: Index,
        allowScalar: bool,
    ) -> *mut Var;
    pub fn makeTargetEntry(
        expr: *mut Expr,
        resno: AttrNumber,
        resname: *mut ::std::os::raw::c_char,
        resjunk: bool,
    ) -> *mut TargetEntry;
    pub fn flatCopyTargetEntry(src_tle: *mut TargetEntry) -> *mut TargetEntry;
    pub fn makeFromExpr(fromlist: *mut List, quals: *mut Node) -> *mut FromExpr;
    pub fn makeConst(
        consttype: Oid,
        consttypmod: int32,
        constcollid: Oid,
        constlen: ::std::os::raw::c_int,
        constvalue: Datum,
        constisnull: bool,
        constbyval: bool,
    ) -> *mut Const;
    pub fn makeNullConst(consttype: Oid, consttypmod: int32, constcollid: Oid) -> *mut Const;
    pub fn makeBoolConst(value: bool, isnull: bool) -> *mut Node;
    pub fn makeBoolExpr(
        boolop: BoolExprType,
        args: *mut List,
        location: ::std::os::raw::c_int,
    ) -> *mut Expr;
    pub fn makeAlias(aliasname: *const ::std::os::raw::c_char, colnames: *mut List) -> *mut Alias;
    pub fn makeRelabelType(
        arg: *mut Expr,
        rtype: Oid,
        rtypmod: int32,
        rcollid: Oid,
        rformat: CoercionForm,
    ) -> *mut RelabelType;
    pub fn makeRangeVar(
        schemaname: *mut ::std::os::raw::c_char,
        relname: *mut ::std::os::raw::c_char,
        location: ::std::os::raw::c_int,
    ) -> *mut RangeVar;
    pub fn makeTypeName(typnam: *mut ::std::os::raw::c_char) -> *mut TypeName;
    pub fn makeTypeNameFromNameList(names: *mut List) -> *mut TypeName;
    pub fn makeTypeNameFromOid(typeOid: Oid, typmod: int32) -> *mut TypeName;
    pub fn makeColumnDef(
        colname: *const ::std::os::raw::c_char,
        typeOid: Oid,
        typmod: int32,
        collOid: Oid,
    ) -> *mut ColumnDef;
    pub fn makeFuncExpr(
        funcid: Oid,
        rettype: Oid,
        args: *mut List,
        funccollid: Oid,
        inputcollid: Oid,
        fformat: CoercionForm,
    ) -> *mut FuncExpr;
    pub fn makeFuncCall(
        name: *mut List,
        args: *mut List,
        funcformat: CoercionForm,
        location: ::std::os::raw::c_int,
    ) -> *mut FuncCall;
    pub fn make_opclause(
        opno: Oid,
        opresulttype: Oid,
        opretset: bool,
        leftop: *mut Expr,
        rightop: *mut Expr,
        opcollid: Oid,
        inputcollid: Oid,
    ) -> *mut Expr;
    pub fn make_andclause(andclauses: *mut List) -> *mut Expr;
    pub fn make_orclause(orclauses: *mut List) -> *mut Expr;
    pub fn make_notclause(notclause: *mut Expr) -> *mut Expr;
    pub fn make_and_qual(qual1: *mut Node, qual2: *mut Node) -> *mut Node;
    pub fn make_ands_explicit(andclauses: *mut List) -> *mut Expr;
    pub fn make_ands_implicit(clause: *mut Expr) -> *mut List;
    pub fn makeIndexInfo(
        numattrs: ::std::os::raw::c_int,
        numkeyattrs: ::std::os::raw::c_int,
        amoid: Oid,
        expressions: *mut List,
        predicates: *mut List,
        unique: bool,
        nulls_not_distinct: bool,
        isready: bool,
        concurrent: bool,
        summarizing: bool,
    ) -> *mut IndexInfo;
    pub fn makeDefElem(
        name: *mut ::std::os::raw::c_char,
        arg: *mut Node,
        location: ::std::os::raw::c_int,
    ) -> *mut DefElem;
    pub fn makeDefElemExtended(
        nameSpace: *mut ::std::os::raw::c_char,
        name: *mut ::std::os::raw::c_char,
        arg: *mut Node,
        defaction: DefElemAction,
        location: ::std::os::raw::c_int,
    ) -> *mut DefElem;
    pub fn makeGroupingSet(
        kind: GroupingSetKind,
        content: *mut List,
        location: ::std::os::raw::c_int,
    ) -> *mut GroupingSet;
    pub fn makeVacuumRelation(
        relation: *mut RangeVar,
        oid: Oid,
        va_cols: *mut List,
    ) -> *mut VacuumRelation;
    pub fn makeJsonFormat(
        type_: JsonFormatType,
        encoding: JsonEncoding,
        location: ::std::os::raw::c_int,
    ) -> *mut JsonFormat;
    pub fn makeJsonValueExpr(
        raw_expr: *mut Expr,
        formatted_expr: *mut Expr,
        format: *mut JsonFormat,
    ) -> *mut JsonValueExpr;
    pub fn makeJsonKeyValue(key: *mut Node, value: *mut Node) -> *mut Node;
    pub fn makeJsonIsPredicate(
        expr: *mut Node,
        format: *mut JsonFormat,
        item_type: JsonValueType,
        unique_keys: bool,
        location: ::std::os::raw::c_int,
    ) -> *mut Node;
    pub fn makeJsonEncoding(name: *mut ::std::os::raw::c_char) -> JsonEncoding;
    pub fn exprType(expr: *const Node) -> Oid;
    pub fn exprTypmod(expr: *const Node) -> int32;
    pub fn exprIsLengthCoercion(expr: *const Node, coercedTypmod: *mut int32) -> bool;
    pub fn applyRelabelType(
        arg: *mut Node,
        rtype: Oid,
        rtypmod: int32,
        rcollid: Oid,
        rformat: CoercionForm,
        rlocation: ::std::os::raw::c_int,
        overwrite_ok: bool,
    ) -> *mut Node;
    pub fn relabel_to_typmod(expr: *mut Node, typmod: int32) -> *mut Node;
    pub fn strip_implicit_coercions(node: *mut Node) -> *mut Node;
    pub fn expression_returns_set(clause: *mut Node) -> bool;
    pub fn exprCollation(expr: *const Node) -> Oid;
    pub fn exprInputCollation(expr: *const Node) -> Oid;
    pub fn exprSetCollation(expr: *mut Node, collation: Oid);
    pub fn exprSetInputCollation(expr: *mut Node, inputcollation: Oid);
    pub fn exprLocation(expr: *const Node) -> ::std::os::raw::c_int;
    pub fn fix_opfuncids(node: *mut Node);
    pub fn set_opfuncid(opexpr: *mut OpExpr);
    pub fn set_sa_opfuncid(opexpr: *mut ScalarArrayOpExpr);
    pub fn check_functions_in_node(
        node: *mut Node,
        checker: check_function_callback,
        context: *mut ::std::os::raw::c_void,
    ) -> bool;
    pub fn expression_tree_walker_impl(
        node: *mut Node,
        walker: tree_walker_callback,
        context: *mut ::std::os::raw::c_void,
    ) -> bool;
    pub fn expression_tree_mutator_impl(
        node: *mut Node,
        mutator: tree_mutator_callback,
        context: *mut ::std::os::raw::c_void,
    ) -> *mut Node;
    pub fn query_tree_walker_impl(
        query: *mut Query,
        walker: tree_walker_callback,
        context: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_int,
    ) -> bool;
    pub fn query_tree_mutator_impl(
        query: *mut Query,
        mutator: tree_mutator_callback,
        context: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_int,
    ) -> *mut Query;
    pub fn range_table_walker_impl(
        rtable: *mut List,
        walker: tree_walker_callback,
        context: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_int,
    ) -> bool;
    pub fn range_table_mutator_impl(
        rtable: *mut List,
        mutator: tree_mutator_callback,
        context: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_int,
    ) -> *mut List;
    pub fn range_table_entry_walker_impl(
        rte: *mut RangeTblEntry,
        walker: tree_walker_callback,
        context: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_int,
    ) -> bool;
    pub fn query_or_expression_tree_walker_impl(
        node: *mut Node,
        walker: tree_walker_callback,
        context: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_int,
    ) -> bool;
    pub fn query_or_expression_tree_mutator_impl(
        node: *mut Node,
        mutator: tree_mutator_callback,
        context: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_int,
    ) -> *mut Node;
    pub fn raw_expression_tree_walker_impl(
        node: *mut Node,
        walker: tree_walker_callback,
        context: *mut ::std::os::raw::c_void,
    ) -> bool;
    pub fn planstate_tree_walker_impl(
        planstate: *mut PlanState,
        walker: planstate_tree_walker_callback,
        context: *mut ::std::os::raw::c_void,
    ) -> bool;
    pub fn print(obj: *const ::std::os::raw::c_void);
    pub fn pprint(obj: *const ::std::os::raw::c_void);
    pub fn elog_node_display(
        lev: ::std::os::raw::c_int,
        title: *const ::std::os::raw::c_char,
        obj: *const ::std::os::raw::c_void,
        pretty: bool,
    );
    pub fn format_node_dump(dump: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
    pub fn pretty_format_node_dump(
        dump: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn print_rt(rtable: *const List);
    pub fn print_expr(expr: *const Node, rtable: *const List);
    pub fn print_pathkeys(pathkeys: *const List, rtable: *const List);
    pub fn print_tl(tlist: *const List, rtable: *const List);
    pub fn print_slot(slot: *mut TupleTableSlot);
    pub fn make_append_rel_info(
        parentrel: Relation,
        childrel: Relation,
        parentRTindex: Index,
        childRTindex: Index,
    ) -> *mut AppendRelInfo;
    pub fn adjust_appendrel_attrs(
        root: *mut PlannerInfo,
        node: *mut Node,
        nappinfos: ::std::os::raw::c_int,
        appinfos: *mut *mut AppendRelInfo,
    ) -> *mut Node;
    pub fn adjust_appendrel_attrs_multilevel(
        root: *mut PlannerInfo,
        node: *mut Node,
        childrel: *mut RelOptInfo,
        parentrel: *mut RelOptInfo,
    ) -> *mut Node;
    pub fn adjust_child_relids(
        relids: Relids,
        nappinfos: ::std::os::raw::c_int,
        appinfos: *mut *mut AppendRelInfo,
    ) -> Relids;
    pub fn adjust_child_relids_multilevel(
        root: *mut PlannerInfo,
        relids: Relids,
        childrel: *mut RelOptInfo,
        parentrel: *mut RelOptInfo,
    ) -> Relids;
    pub fn adjust_inherited_attnums(attnums: *mut List, context: *mut AppendRelInfo) -> *mut List;
    pub fn adjust_inherited_attnums_multilevel(
        root: *mut PlannerInfo,
        attnums: *mut List,
        child_relid: Index,
        top_parent_relid: Index,
    ) -> *mut List;
    pub fn get_translated_update_targetlist(
        root: *mut PlannerInfo,
        relid: Index,
        processed_tlist: *mut *mut List,
        update_colnos: *mut *mut List,
    );
    pub fn find_appinfos_by_relids(
        root: *mut PlannerInfo,
        relids: Relids,
        nappinfos: *mut ::std::os::raw::c_int,
    ) -> *mut *mut AppendRelInfo;
    pub fn add_row_identity_var(
        root: *mut PlannerInfo,
        orig_var: *mut Var,
        rtindex: Index,
        rowid_name: *const ::std::os::raw::c_char,
    );
    pub fn add_row_identity_columns(
        root: *mut PlannerInfo,
        rtindex: Index,
        target_rte: *mut RangeTblEntry,
        target_relation: Relation,
    );
    pub fn distribute_row_identity_vars(root: *mut PlannerInfo);
    pub fn contain_agg_clause(clause: *mut Node) -> bool;
    pub fn contain_window_function(clause: *mut Node) -> bool;
    pub fn find_window_functions(clause: *mut Node, maxWinRef: Index) -> *mut WindowFuncLists;
    pub fn expression_returns_set_rows(root: *mut PlannerInfo, clause: *mut Node) -> f64;
    pub fn contain_subplans(clause: *mut Node) -> bool;
    pub fn max_parallel_hazard(parse: *mut Query) -> ::std::os::raw::c_char;
    pub fn is_parallel_safe(root: *mut PlannerInfo, node: *mut Node) -> bool;
    pub fn contain_nonstrict_functions(clause: *mut Node) -> bool;
    pub fn contain_exec_param(clause: *mut Node, param_ids: *mut List) -> bool;
    pub fn contain_leaked_vars(clause: *mut Node) -> bool;
    pub fn find_nonnullable_rels(clause: *mut Node) -> Relids;
    pub fn find_nonnullable_vars(clause: *mut Node) -> *mut List;
    pub fn find_forced_null_vars(node: *mut Node) -> *mut List;
    pub fn find_forced_null_var(node: *mut Node) -> *mut Var;
    pub fn is_pseudo_constant_clause(clause: *mut Node) -> bool;
    pub fn is_pseudo_constant_clause_relids(clause: *mut Node, relids: Relids) -> bool;
    pub fn NumRelids(root: *mut PlannerInfo, clause: *mut Node) -> ::std::os::raw::c_int;
    pub fn CommuteOpExpr(clause: *mut OpExpr);
    pub fn inline_set_returning_function(
        root: *mut PlannerInfo,
        rte: *mut RangeTblEntry,
    ) -> *mut Query;
    pub fn pull_paramids(expr: *mut Expr) -> *mut Bitmapset;
    pub fn index_pages_fetched(
        tuples_fetched: f64,
        pages: BlockNumber,
        index_pages: f64,
        root: *mut PlannerInfo,
    ) -> f64;
    pub fn cost_seqscan(
        path: *mut Path,
        root: *mut PlannerInfo,
        baserel: *mut RelOptInfo,
        param_info: *mut ParamPathInfo,
    );
    pub fn cost_samplescan(
        path: *mut Path,
        root: *mut PlannerInfo,
        baserel: *mut RelOptInfo,
        param_info: *mut ParamPathInfo,
    );
    pub fn cost_index(
        path: *mut IndexPath,
        root: *mut PlannerInfo,
        loop_count: f64,
        partial_path: bool,
    );
    pub fn cost_bitmap_heap_scan(
        path: *mut Path,
        root: *mut PlannerInfo,
        baserel: *mut RelOptInfo,
        param_info: *mut ParamPathInfo,
        bitmapqual: *mut Path,
        loop_count: f64,
    );
    pub fn cost_bitmap_and_node(path: *mut BitmapAndPath, root: *mut PlannerInfo);
    pub fn cost_bitmap_or_node(path: *mut BitmapOrPath, root: *mut PlannerInfo);
    pub fn cost_bitmap_tree_node(path: *mut Path, cost: *mut Cost, selec: *mut Selectivity);
    pub fn cost_tidscan(
        path: *mut Path,
        root: *mut PlannerInfo,
        baserel: *mut RelOptInfo,
        tidquals: *mut List,
        param_info: *mut ParamPathInfo,
    );
    pub fn cost_tidrangescan(
        path: *mut Path,
        root: *mut PlannerInfo,
        baserel: *mut RelOptInfo,
        tidrangequals: *mut List,
        param_info: *mut ParamPathInfo,
    );
    pub fn cost_subqueryscan(
        path: *mut SubqueryScanPath,
        root: *mut PlannerInfo,
        baserel: *mut RelOptInfo,
        param_info: *mut ParamPathInfo,
        trivial_pathtarget: bool,
    );
    pub fn cost_functionscan(
        path: *mut Path,
        root: *mut PlannerInfo,
        baserel: *mut RelOptInfo,
        param_info: *mut ParamPathInfo,
    );
    pub fn cost_valuesscan(
        path: *mut Path,
        root: *mut PlannerInfo,
        baserel: *mut RelOptInfo,
        param_info: *mut ParamPathInfo,
    );
    pub fn cost_tablefuncscan(
        path: *mut Path,
        root: *mut PlannerInfo,
        baserel: *mut RelOptInfo,
        param_info: *mut ParamPathInfo,
    );
    pub fn cost_ctescan(
        path: *mut Path,
        root: *mut PlannerInfo,
        baserel: *mut RelOptInfo,
        param_info: *mut ParamPathInfo,
    );
    pub fn cost_namedtuplestorescan(
        path: *mut Path,
        root: *mut PlannerInfo,
        baserel: *mut RelOptInfo,
        param_info: *mut ParamPathInfo,
    );
    pub fn cost_resultscan(
        path: *mut Path,
        root: *mut PlannerInfo,
        baserel: *mut RelOptInfo,
        param_info: *mut ParamPathInfo,
    );
    pub fn cost_recursive_union(runion: *mut Path, nrterm: *mut Path, rterm: *mut Path);
    pub fn cost_sort(
        path: *mut Path,
        root: *mut PlannerInfo,
        pathkeys: *mut List,
        input_cost: Cost,
        tuples: f64,
        width: ::std::os::raw::c_int,
        comparison_cost: Cost,
        sort_mem: ::std::os::raw::c_int,
        limit_tuples: f64,
    );
    pub fn cost_incremental_sort(
        path: *mut Path,
        root: *mut PlannerInfo,
        pathkeys: *mut List,
        presorted_keys: ::std::os::raw::c_int,
        input_startup_cost: Cost,
        input_total_cost: Cost,
        input_tuples: f64,
        width: ::std::os::raw::c_int,
        comparison_cost: Cost,
        sort_mem: ::std::os::raw::c_int,
        limit_tuples: f64,
    );
    pub fn cost_append(apath: *mut AppendPath);
    pub fn cost_merge_append(
        path: *mut Path,
        root: *mut PlannerInfo,
        pathkeys: *mut List,
        n_streams: ::std::os::raw::c_int,
        input_startup_cost: Cost,
        input_total_cost: Cost,
        tuples: f64,
    );
    pub fn cost_material(
        path: *mut Path,
        input_startup_cost: Cost,
        input_total_cost: Cost,
        tuples: f64,
        width: ::std::os::raw::c_int,
    );
    pub fn cost_agg(
        path: *mut Path,
        root: *mut PlannerInfo,
        aggstrategy: AggStrategy,
        aggcosts: *const AggClauseCosts,
        numGroupCols: ::std::os::raw::c_int,
        numGroups: f64,
        quals: *mut List,
        input_startup_cost: Cost,
        input_total_cost: Cost,
        input_tuples: f64,
        input_width: f64,
    );
    pub fn cost_windowagg(
        path: *mut Path,
        root: *mut PlannerInfo,
        windowFuncs: *mut List,
        numPartCols: ::std::os::raw::c_int,
        numOrderCols: ::std::os::raw::c_int,
        input_startup_cost: Cost,
        input_total_cost: Cost,
        input_tuples: f64,
    );
    pub fn cost_group(
        path: *mut Path,
        root: *mut PlannerInfo,
        numGroupCols: ::std::os::raw::c_int,
        numGroups: f64,
        quals: *mut List,
        input_startup_cost: Cost,
        input_total_cost: Cost,
        input_tuples: f64,
    );
    pub fn initial_cost_nestloop(
        root: *mut PlannerInfo,
        workspace: *mut JoinCostWorkspace,
        jointype: JoinType,
        outer_path: *mut Path,
        inner_path: *mut Path,
        extra: *mut JoinPathExtraData,
    );
    pub fn final_cost_nestloop(
        root: *mut PlannerInfo,
        path: *mut NestPath,
        workspace: *mut JoinCostWorkspace,
        extra: *mut JoinPathExtraData,
    );
    pub fn initial_cost_mergejoin(
        root: *mut PlannerInfo,
        workspace: *mut JoinCostWorkspace,
        jointype: JoinType,
        mergeclauses: *mut List,
        outer_path: *mut Path,
        inner_path: *mut Path,
        outersortkeys: *mut List,
        innersortkeys: *mut List,
        extra: *mut JoinPathExtraData,
    );
    pub fn final_cost_mergejoin(
        root: *mut PlannerInfo,
        path: *mut MergePath,
        workspace: *mut JoinCostWorkspace,
        extra: *mut JoinPathExtraData,
    );
    pub fn initial_cost_hashjoin(
        root: *mut PlannerInfo,
        workspace: *mut JoinCostWorkspace,
        jointype: JoinType,
        hashclauses: *mut List,
        outer_path: *mut Path,
        inner_path: *mut Path,
        extra: *mut JoinPathExtraData,
        parallel_hash: bool,
    );
    pub fn final_cost_hashjoin(
        root: *mut PlannerInfo,
        path: *mut HashPath,
        workspace: *mut JoinCostWorkspace,
        extra: *mut JoinPathExtraData,
    );
    pub fn cost_gather(
        path: *mut GatherPath,
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        param_info: *mut ParamPathInfo,
        rows: *mut f64,
    );
    pub fn cost_gather_merge(
        path: *mut GatherMergePath,
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        param_info: *mut ParamPathInfo,
        input_startup_cost: Cost,
        input_total_cost: Cost,
        rows: *mut f64,
    );
    pub fn cost_subplan(root: *mut PlannerInfo, subplan: *mut SubPlan, plan: *mut Plan);
    pub fn cost_qual_eval(cost: *mut QualCost, quals: *mut List, root: *mut PlannerInfo);
    pub fn cost_qual_eval_node(cost: *mut QualCost, qual: *mut Node, root: *mut PlannerInfo);
    pub fn compute_semi_anti_join_factors(
        root: *mut PlannerInfo,
        joinrel: *mut RelOptInfo,
        outerrel: *mut RelOptInfo,
        innerrel: *mut RelOptInfo,
        jointype: JoinType,
        sjinfo: *mut SpecialJoinInfo,
        restrictlist: *mut List,
        semifactors: *mut SemiAntiJoinFactors,
    );
    pub fn set_baserel_size_estimates(root: *mut PlannerInfo, rel: *mut RelOptInfo);
    pub fn get_parameterized_baserel_size(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        param_clauses: *mut List,
    ) -> f64;
    pub fn get_parameterized_joinrel_size(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        outer_path: *mut Path,
        inner_path: *mut Path,
        sjinfo: *mut SpecialJoinInfo,
        restrict_clauses: *mut List,
    ) -> f64;
    pub fn set_joinrel_size_estimates(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        outer_rel: *mut RelOptInfo,
        inner_rel: *mut RelOptInfo,
        sjinfo: *mut SpecialJoinInfo,
        restrictlist: *mut List,
    );
    pub fn set_subquery_size_estimates(root: *mut PlannerInfo, rel: *mut RelOptInfo);
    pub fn set_function_size_estimates(root: *mut PlannerInfo, rel: *mut RelOptInfo);
    pub fn set_values_size_estimates(root: *mut PlannerInfo, rel: *mut RelOptInfo);
    pub fn set_cte_size_estimates(root: *mut PlannerInfo, rel: *mut RelOptInfo, cte_rows: f64);
    pub fn set_tablefunc_size_estimates(root: *mut PlannerInfo, rel: *mut RelOptInfo);
    pub fn set_namedtuplestore_size_estimates(root: *mut PlannerInfo, rel: *mut RelOptInfo);
    pub fn set_result_size_estimates(root: *mut PlannerInfo, rel: *mut RelOptInfo);
    pub fn set_foreign_size_estimates(root: *mut PlannerInfo, rel: *mut RelOptInfo);
    pub fn set_pathtarget_cost_width(
        root: *mut PlannerInfo,
        target: *mut PathTarget,
    ) -> *mut PathTarget;
    pub fn compute_bitmap_pages(
        root: *mut PlannerInfo,
        baserel: *mut RelOptInfo,
        bitmapqual: *mut Path,
        loop_count: ::std::os::raw::c_int,
        cost: *mut Cost,
        tuple: *mut f64,
    ) -> f64;
    pub fn clause_selectivity(
        root: *mut PlannerInfo,
        clause: *mut Node,
        varRelid: ::std::os::raw::c_int,
        jointype: JoinType,
        sjinfo: *mut SpecialJoinInfo,
    ) -> Selectivity;
    pub fn clause_selectivity_ext(
        root: *mut PlannerInfo,
        clause: *mut Node,
        varRelid: ::std::os::raw::c_int,
        jointype: JoinType,
        sjinfo: *mut SpecialJoinInfo,
        use_extended_stats: bool,
    ) -> Selectivity;
    pub fn clauselist_selectivity(
        root: *mut PlannerInfo,
        clauses: *mut List,
        varRelid: ::std::os::raw::c_int,
        jointype: JoinType,
        sjinfo: *mut SpecialJoinInfo,
    ) -> Selectivity;
    pub fn clauselist_selectivity_ext(
        root: *mut PlannerInfo,
        clauses: *mut List,
        varRelid: ::std::os::raw::c_int,
        jointype: JoinType,
        sjinfo: *mut SpecialJoinInfo,
        use_extended_stats: bool,
    ) -> Selectivity;
    pub fn clamp_row_est(nrows: f64) -> f64;
    pub fn clamp_cardinality_to_long(x: Cardinality) -> ::std::os::raw::c_long;
    pub fn is_pseudo_constant_for_index(
        root: *mut PlannerInfo,
        expr: *mut Node,
        index: *mut IndexOptInfo,
    ) -> bool;
    pub fn planner(
        parse: *mut Query,
        query_string: *const ::std::os::raw::c_char,
        cursorOptions: ::std::os::raw::c_int,
        boundParams: *mut ParamListInfoData,
    ) -> *mut PlannedStmt;
    pub fn expression_planner(expr: *mut Expr) -> *mut Expr;
    pub fn expression_planner_with_deps(
        expr: *mut Expr,
        relationOids: *mut *mut List,
        invalItems: *mut *mut List,
    ) -> *mut Expr;
    pub fn plan_cluster_use_sort(tableOid: Oid, indexOid: Oid) -> bool;
    pub fn plan_create_index_workers(tableOid: Oid, indexOid: Oid) -> ::std::os::raw::c_int;
    pub fn extract_query_dependencies(
        query: *mut Node,
        relationOids: *mut *mut List,
        invalItems: *mut *mut List,
        hasRowSecurity: *mut bool,
    );
    pub fn negate_clause(node: *mut Node) -> *mut Node;
    pub fn canonicalize_qual(qual: *mut Expr, is_check: bool) -> *mut Expr;
    pub fn contain_mutable_functions(clause: *mut Node) -> bool;
    pub fn contain_volatile_functions(clause: *mut Node) -> bool;
    pub fn contain_volatile_functions_not_nextval(clause: *mut Node) -> bool;
    pub fn eval_const_expressions(root: *mut PlannerInfo, node: *mut Node) -> *mut Node;
    pub fn convert_saop_to_hashed_saop(node: *mut Node);
    pub fn estimate_expression_value(root: *mut PlannerInfo, node: *mut Node) -> *mut Node;
    pub fn evaluate_expr(
        expr: *mut Expr,
        result_type: Oid,
        result_typmod: int32,
        result_collation: Oid,
    ) -> *mut Expr;
    pub fn expand_function_arguments(
        args: *mut List,
        include_out_arguments: bool,
        result_type: Oid,
        func_tuple: *mut HeapTupleData,
    ) -> *mut List;
    pub fn predicate_implied_by(
        predicate_list: *mut List,
        clause_list: *mut List,
        weak: bool,
    ) -> bool;
    pub fn predicate_refuted_by(
        predicate_list: *mut List,
        clause_list: *mut List,
        weak: bool,
    ) -> bool;
    pub fn count_nonjunk_tlist_entries(tlist: *mut List) -> ::std::os::raw::c_int;
    pub fn get_sortgroupref_tle(sortref: Index, targetList: *mut List) -> *mut TargetEntry;
    pub fn get_sortgroupclause_tle(
        sgClause: *mut SortGroupClause,
        targetList: *mut List,
    ) -> *mut TargetEntry;
    pub fn get_sortgroupclause_expr(
        sgClause: *mut SortGroupClause,
        targetList: *mut List,
    ) -> *mut Node;
    pub fn get_sortgrouplist_exprs(sgClauses: *mut List, targetList: *mut List) -> *mut List;
    pub fn get_sortgroupref_clause(sortref: Index, clauses: *mut List) -> *mut SortGroupClause;
    pub fn get_sortgroupref_clause_noerr(
        sortref: Index,
        clauses: *mut List,
    ) -> *mut SortGroupClause;
    pub fn pull_varnos(root: *mut PlannerInfo, node: *mut Node) -> *mut Bitmapset;
    pub fn pull_varnos_of_level(
        root: *mut PlannerInfo,
        node: *mut Node,
        levelsup: ::std::os::raw::c_int,
    ) -> *mut Bitmapset;
    pub fn pull_varattnos(node: *mut Node, varno: Index, varattnos: *mut *mut Bitmapset);
    pub fn pull_vars_of_level(node: *mut Node, levelsup: ::std::os::raw::c_int) -> *mut List;
    pub fn contain_var_clause(node: *mut Node) -> bool;
    pub fn contain_vars_of_level(node: *mut Node, levelsup: ::std::os::raw::c_int) -> bool;
    pub fn locate_var_of_level(
        node: *mut Node,
        levelsup: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn pull_var_clause(node: *mut Node, flags: ::std::os::raw::c_int) -> *mut List;
    pub fn flatten_join_alias_vars(
        root: *mut PlannerInfo,
        query: *mut Query,
        node: *mut Node,
    ) -> *mut Node;
    pub fn compare_path_costs(
        path1: *mut Path,
        path2: *mut Path,
        criterion: CostSelector,
    ) -> ::std::os::raw::c_int;
    pub fn compare_fractional_path_costs(
        path1: *mut Path,
        path2: *mut Path,
        fraction: f64,
    ) -> ::std::os::raw::c_int;
    pub fn set_cheapest(parent_rel: *mut RelOptInfo);
    pub fn add_path(parent_rel: *mut RelOptInfo, new_path: *mut Path);
    pub fn add_path_precheck(
        parent_rel: *mut RelOptInfo,
        startup_cost: Cost,
        total_cost: Cost,
        pathkeys: *mut List,
        required_outer: Relids,
    ) -> bool;
    pub fn add_partial_path(parent_rel: *mut RelOptInfo, new_path: *mut Path);
    pub fn add_partial_path_precheck(
        parent_rel: *mut RelOptInfo,
        total_cost: Cost,
        pathkeys: *mut List,
    ) -> bool;
    pub fn create_seqscan_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        required_outer: Relids,
        parallel_workers: ::std::os::raw::c_int,
    ) -> *mut Path;
    pub fn create_samplescan_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        required_outer: Relids,
    ) -> *mut Path;
    pub fn create_index_path(
        root: *mut PlannerInfo,
        index: *mut IndexOptInfo,
        indexclauses: *mut List,
        indexorderbys: *mut List,
        indexorderbycols: *mut List,
        pathkeys: *mut List,
        indexscandir: ScanDirection,
        indexonly: bool,
        required_outer: Relids,
        loop_count: f64,
        partial_path: bool,
    ) -> *mut IndexPath;
    pub fn create_bitmap_heap_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        bitmapqual: *mut Path,
        required_outer: Relids,
        loop_count: f64,
        parallel_degree: ::std::os::raw::c_int,
    ) -> *mut BitmapHeapPath;
    pub fn create_bitmap_and_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        bitmapquals: *mut List,
    ) -> *mut BitmapAndPath;
    pub fn create_bitmap_or_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        bitmapquals: *mut List,
    ) -> *mut BitmapOrPath;
    pub fn create_tidscan_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        tidquals: *mut List,
        required_outer: Relids,
    ) -> *mut TidPath;
    pub fn create_tidrangescan_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        tidrangequals: *mut List,
        required_outer: Relids,
    ) -> *mut TidRangePath;
    pub fn create_append_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpaths: *mut List,
        partial_subpaths: *mut List,
        pathkeys: *mut List,
        required_outer: Relids,
        parallel_workers: ::std::os::raw::c_int,
        parallel_aware: bool,
        rows: f64,
    ) -> *mut AppendPath;
    pub fn create_merge_append_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpaths: *mut List,
        pathkeys: *mut List,
        required_outer: Relids,
    ) -> *mut MergeAppendPath;
    pub fn create_group_result_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        target: *mut PathTarget,
        havingqual: *mut List,
    ) -> *mut GroupResultPath;
    pub fn create_material_path(rel: *mut RelOptInfo, subpath: *mut Path) -> *mut MaterialPath;
    pub fn create_memoize_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        param_exprs: *mut List,
        hash_operators: *mut List,
        singlerow: bool,
        binary_mode: bool,
        calls: f64,
    ) -> *mut MemoizePath;
    pub fn create_unique_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        sjinfo: *mut SpecialJoinInfo,
    ) -> *mut UniquePath;
    pub fn create_gather_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        target: *mut PathTarget,
        required_outer: Relids,
        rows: *mut f64,
    ) -> *mut GatherPath;
    pub fn create_gather_merge_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        target: *mut PathTarget,
        pathkeys: *mut List,
        required_outer: Relids,
        rows: *mut f64,
    ) -> *mut GatherMergePath;
    pub fn create_subqueryscan_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        trivial_pathtarget: bool,
        pathkeys: *mut List,
        required_outer: Relids,
    ) -> *mut SubqueryScanPath;
    pub fn create_functionscan_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        pathkeys: *mut List,
        required_outer: Relids,
    ) -> *mut Path;
    pub fn create_valuesscan_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        required_outer: Relids,
    ) -> *mut Path;
    pub fn create_tablefuncscan_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        required_outer: Relids,
    ) -> *mut Path;
    pub fn create_ctescan_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        required_outer: Relids,
    ) -> *mut Path;
    pub fn create_namedtuplestorescan_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        required_outer: Relids,
    ) -> *mut Path;
    pub fn create_resultscan_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        required_outer: Relids,
    ) -> *mut Path;
    pub fn create_worktablescan_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        required_outer: Relids,
    ) -> *mut Path;
    pub fn create_foreignscan_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        target: *mut PathTarget,
        rows: f64,
        startup_cost: Cost,
        total_cost: Cost,
        pathkeys: *mut List,
        required_outer: Relids,
        fdw_outerpath: *mut Path,
        fdw_private: *mut List,
    ) -> *mut ForeignPath;
    pub fn create_foreign_join_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        target: *mut PathTarget,
        rows: f64,
        startup_cost: Cost,
        total_cost: Cost,
        pathkeys: *mut List,
        required_outer: Relids,
        fdw_outerpath: *mut Path,
        fdw_private: *mut List,
    ) -> *mut ForeignPath;
    pub fn create_foreign_upper_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        target: *mut PathTarget,
        rows: f64,
        startup_cost: Cost,
        total_cost: Cost,
        pathkeys: *mut List,
        fdw_outerpath: *mut Path,
        fdw_private: *mut List,
    ) -> *mut ForeignPath;
    pub fn calc_nestloop_required_outer(
        outerrelids: Relids,
        outer_paramrels: Relids,
        innerrelids: Relids,
        inner_paramrels: Relids,
    ) -> Relids;
    pub fn calc_non_nestloop_required_outer(outer_path: *mut Path, inner_path: *mut Path)
        -> Relids;
    pub fn create_nestloop_path(
        root: *mut PlannerInfo,
        joinrel: *mut RelOptInfo,
        jointype: JoinType,
        workspace: *mut JoinCostWorkspace,
        extra: *mut JoinPathExtraData,
        outer_path: *mut Path,
        inner_path: *mut Path,
        restrict_clauses: *mut List,
        pathkeys: *mut List,
        required_outer: Relids,
    ) -> *mut NestPath;
    pub fn create_mergejoin_path(
        root: *mut PlannerInfo,
        joinrel: *mut RelOptInfo,
        jointype: JoinType,
        workspace: *mut JoinCostWorkspace,
        extra: *mut JoinPathExtraData,
        outer_path: *mut Path,
        inner_path: *mut Path,
        restrict_clauses: *mut List,
        pathkeys: *mut List,
        required_outer: Relids,
        mergeclauses: *mut List,
        outersortkeys: *mut List,
        innersortkeys: *mut List,
    ) -> *mut MergePath;
    pub fn create_hashjoin_path(
        root: *mut PlannerInfo,
        joinrel: *mut RelOptInfo,
        jointype: JoinType,
        workspace: *mut JoinCostWorkspace,
        extra: *mut JoinPathExtraData,
        outer_path: *mut Path,
        inner_path: *mut Path,
        parallel_hash: bool,
        restrict_clauses: *mut List,
        required_outer: Relids,
        hashclauses: *mut List,
    ) -> *mut HashPath;
    pub fn create_projection_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        target: *mut PathTarget,
    ) -> *mut ProjectionPath;
    pub fn apply_projection_to_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        path: *mut Path,
        target: *mut PathTarget,
    ) -> *mut Path;
    pub fn create_set_projection_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        target: *mut PathTarget,
    ) -> *mut ProjectSetPath;
    pub fn create_sort_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        pathkeys: *mut List,
        limit_tuples: f64,
    ) -> *mut SortPath;
    pub fn create_incremental_sort_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        pathkeys: *mut List,
        presorted_keys: ::std::os::raw::c_int,
        limit_tuples: f64,
    ) -> *mut IncrementalSortPath;
    pub fn create_group_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        groupClause: *mut List,
        qual: *mut List,
        numGroups: f64,
    ) -> *mut GroupPath;
    pub fn create_upper_unique_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        numCols: ::std::os::raw::c_int,
        numGroups: f64,
    ) -> *mut UpperUniquePath;
    pub fn create_agg_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        target: *mut PathTarget,
        aggstrategy: AggStrategy,
        aggsplit: AggSplit,
        groupClause: *mut List,
        qual: *mut List,
        aggcosts: *const AggClauseCosts,
        numGroups: f64,
    ) -> *mut AggPath;
    pub fn create_groupingsets_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        having_qual: *mut List,
        aggstrategy: AggStrategy,
        rollups: *mut List,
        agg_costs: *const AggClauseCosts,
    ) -> *mut GroupingSetsPath;
    pub fn create_minmaxagg_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        target: *mut PathTarget,
        mmaggregates: *mut List,
        quals: *mut List,
    ) -> *mut MinMaxAggPath;
    pub fn create_windowagg_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        target: *mut PathTarget,
        windowFuncs: *mut List,
        winclause: *mut WindowClause,
        qual: *mut List,
        topwindow: bool,
    ) -> *mut WindowAggPath;
    pub fn create_setop_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        cmd: SetOpCmd,
        strategy: SetOpStrategy,
        distinctList: *mut List,
        flagColIdx: AttrNumber,
        firstFlag: ::std::os::raw::c_int,
        numGroups: f64,
        outputRows: f64,
    ) -> *mut SetOpPath;
    pub fn create_recursiveunion_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        leftpath: *mut Path,
        rightpath: *mut Path,
        target: *mut PathTarget,
        distinctList: *mut List,
        wtParam: ::std::os::raw::c_int,
        numGroups: f64,
    ) -> *mut RecursiveUnionPath;
    pub fn create_lockrows_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        rowMarks: *mut List,
        epqParam: ::std::os::raw::c_int,
    ) -> *mut LockRowsPath;
    pub fn create_modifytable_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        operation: CmdType,
        canSetTag: bool,
        nominalRelation: Index,
        rootRelation: Index,
        partColsUpdated: bool,
        resultRelations: *mut List,
        updateColnosLists: *mut List,
        withCheckOptionLists: *mut List,
        returningLists: *mut List,
        rowMarks: *mut List,
        onconflict: *mut OnConflictExpr,
        mergeActionLists: *mut List,
        epqParam: ::std::os::raw::c_int,
    ) -> *mut ModifyTablePath;
    pub fn create_limit_path(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subpath: *mut Path,
        limitOffset: *mut Node,
        limitCount: *mut Node,
        limitOption: LimitOption,
        offset_est: int64,
        count_est: int64,
    ) -> *mut LimitPath;
    pub fn adjust_limit_rows_costs(
        rows: *mut f64,
        startup_cost: *mut Cost,
        total_cost: *mut Cost,
        offset_est: int64,
        count_est: int64,
    );
    pub fn reparameterize_path(
        root: *mut PlannerInfo,
        path: *mut Path,
        required_outer: Relids,
        loop_count: f64,
    ) -> *mut Path;
    pub fn reparameterize_path_by_child(
        root: *mut PlannerInfo,
        path: *mut Path,
        child_rel: *mut RelOptInfo,
    ) -> *mut Path;
    pub fn setup_simple_rel_arrays(root: *mut PlannerInfo);
    pub fn expand_planner_arrays(root: *mut PlannerInfo, add_size: ::std::os::raw::c_int);
    pub fn build_simple_rel(
        root: *mut PlannerInfo,
        relid: ::std::os::raw::c_int,
        parent: *mut RelOptInfo,
    ) -> *mut RelOptInfo;
    pub fn find_base_rel(root: *mut PlannerInfo, relid: ::std::os::raw::c_int) -> *mut RelOptInfo;
    pub fn find_base_rel_ignore_join(
        root: *mut PlannerInfo,
        relid: ::std::os::raw::c_int,
    ) -> *mut RelOptInfo;
    pub fn find_join_rel(root: *mut PlannerInfo, relids: Relids) -> *mut RelOptInfo;
    pub fn build_join_rel(
        root: *mut PlannerInfo,
        joinrelids: Relids,
        outer_rel: *mut RelOptInfo,
        inner_rel: *mut RelOptInfo,
        sjinfo: *mut SpecialJoinInfo,
        pushed_down_joins: *mut List,
        restrictlist_ptr: *mut *mut List,
    ) -> *mut RelOptInfo;
    pub fn min_join_parameterization(
        root: *mut PlannerInfo,
        joinrelids: Relids,
        outer_rel: *mut RelOptInfo,
        inner_rel: *mut RelOptInfo,
    ) -> Relids;
    pub fn fetch_upper_rel(
        root: *mut PlannerInfo,
        kind: UpperRelationKind,
        relids: Relids,
    ) -> *mut RelOptInfo;
    pub fn find_childrel_parents(root: *mut PlannerInfo, rel: *mut RelOptInfo) -> Relids;
    pub fn get_baserel_parampathinfo(
        root: *mut PlannerInfo,
        baserel: *mut RelOptInfo,
        required_outer: Relids,
    ) -> *mut ParamPathInfo;
    pub fn get_joinrel_parampathinfo(
        root: *mut PlannerInfo,
        joinrel: *mut RelOptInfo,
        outer_path: *mut Path,
        inner_path: *mut Path,
        sjinfo: *mut SpecialJoinInfo,
        required_outer: Relids,
        restrict_clauses: *mut *mut List,
    ) -> *mut ParamPathInfo;
    pub fn get_appendrel_parampathinfo(
        appendrel: *mut RelOptInfo,
        required_outer: Relids,
    ) -> *mut ParamPathInfo;
    pub fn find_param_path_info(rel: *mut RelOptInfo, required_outer: Relids)
        -> *mut ParamPathInfo;
    pub fn get_param_path_clause_serials(path: *mut Path) -> *mut Bitmapset;
    pub fn build_child_join_rel(
        root: *mut PlannerInfo,
        outer_rel: *mut RelOptInfo,
        inner_rel: *mut RelOptInfo,
        parent_joinrel: *mut RelOptInfo,
        restrictlist: *mut List,
        sjinfo: *mut SpecialJoinInfo,
    ) -> *mut RelOptInfo;
    pub fn make_one_rel(root: *mut PlannerInfo, joinlist: *mut List) -> *mut RelOptInfo;
    pub fn standard_join_search(
        root: *mut PlannerInfo,
        levels_needed: ::std::os::raw::c_int,
        initial_rels: *mut List,
    ) -> *mut RelOptInfo;
    pub fn generate_gather_paths(root: *mut PlannerInfo, rel: *mut RelOptInfo, override_rows: bool);
    pub fn generate_useful_gather_paths(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        override_rows: bool,
    );
    pub fn compute_parallel_worker(
        rel: *mut RelOptInfo,
        heap_pages: f64,
        index_pages: f64,
        max_workers: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn create_partial_bitmap_paths(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        bitmapqual: *mut Path,
    );
    pub fn generate_partitionwise_join_paths(root: *mut PlannerInfo, rel: *mut RelOptInfo);
    pub fn create_index_paths(root: *mut PlannerInfo, rel: *mut RelOptInfo);
    pub fn relation_has_unique_index_for(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        restrictlist: *mut List,
        exprlist: *mut List,
        oprlist: *mut List,
    ) -> bool;
    pub fn indexcol_is_bool_constant_for_query(
        root: *mut PlannerInfo,
        index: *mut IndexOptInfo,
        indexcol: ::std::os::raw::c_int,
    ) -> bool;
    pub fn match_index_to_operand(
        operand: *mut Node,
        indexcol: ::std::os::raw::c_int,
        index: *mut IndexOptInfo,
    ) -> bool;
    pub fn check_index_predicates(root: *mut PlannerInfo, rel: *mut RelOptInfo);
    pub fn create_tidscan_paths(root: *mut PlannerInfo, rel: *mut RelOptInfo);
    pub fn add_paths_to_joinrel(
        root: *mut PlannerInfo,
        joinrel: *mut RelOptInfo,
        outerrel: *mut RelOptInfo,
        innerrel: *mut RelOptInfo,
        jointype: JoinType,
        sjinfo: *mut SpecialJoinInfo,
        restrictlist: *mut List,
    );
    pub fn join_search_one_level(root: *mut PlannerInfo, level: ::std::os::raw::c_int);
    pub fn make_join_rel(
        root: *mut PlannerInfo,
        rel1: *mut RelOptInfo,
        rel2: *mut RelOptInfo,
    ) -> *mut RelOptInfo;
    pub fn add_outer_joins_to_relids(
        root: *mut PlannerInfo,
        input_relids: Relids,
        sjinfo: *mut SpecialJoinInfo,
        pushed_down_joins: *mut *mut List,
    ) -> Relids;
    pub fn have_join_order_restriction(
        root: *mut PlannerInfo,
        rel1: *mut RelOptInfo,
        rel2: *mut RelOptInfo,
    ) -> bool;
    pub fn have_dangerous_phv(
        root: *mut PlannerInfo,
        outer_relids: Relids,
        inner_params: Relids,
    ) -> bool;
    pub fn mark_dummy_rel(rel: *mut RelOptInfo);
    pub fn process_equivalence(
        root: *mut PlannerInfo,
        p_restrictinfo: *mut *mut RestrictInfo,
        jdomain: *mut JoinDomain,
    ) -> bool;
    pub fn canonicalize_ec_expression(
        expr: *mut Expr,
        req_type: Oid,
        req_collation: Oid,
    ) -> *mut Expr;
    pub fn reconsider_outer_join_clauses(root: *mut PlannerInfo);
    pub fn get_eclass_for_sort_expr(
        root: *mut PlannerInfo,
        expr: *mut Expr,
        opfamilies: *mut List,
        opcintype: Oid,
        collation: Oid,
        sortref: Index,
        rel: Relids,
        create_it: bool,
    ) -> *mut EquivalenceClass;
    pub fn find_ec_member_matching_expr(
        ec: *mut EquivalenceClass,
        expr: *mut Expr,
        relids: Relids,
    ) -> *mut EquivalenceMember;
    pub fn find_computable_ec_member(
        root: *mut PlannerInfo,
        ec: *mut EquivalenceClass,
        exprs: *mut List,
        relids: Relids,
        require_parallel_safe: bool,
    ) -> *mut EquivalenceMember;
    pub fn relation_can_be_sorted_early(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        ec: *mut EquivalenceClass,
        require_parallel_safe: bool,
    ) -> bool;
    pub fn generate_base_implied_equalities(root: *mut PlannerInfo);
    pub fn generate_join_implied_equalities(
        root: *mut PlannerInfo,
        join_relids: Relids,
        outer_relids: Relids,
        inner_rel: *mut RelOptInfo,
        sjinfo: *mut SpecialJoinInfo,
    ) -> *mut List;
    pub fn generate_join_implied_equalities_for_ecs(
        root: *mut PlannerInfo,
        eclasses: *mut List,
        join_relids: Relids,
        outer_relids: Relids,
        inner_rel: *mut RelOptInfo,
    ) -> *mut List;
    pub fn exprs_known_equal(root: *mut PlannerInfo, item1: *mut Node, item2: *mut Node) -> bool;
    pub fn match_eclasses_to_foreign_key_col(
        root: *mut PlannerInfo,
        fkinfo: *mut ForeignKeyOptInfo,
        colno: ::std::os::raw::c_int,
    ) -> *mut EquivalenceClass;
    pub fn find_derived_clause_for_ec_member(
        ec: *mut EquivalenceClass,
        em: *mut EquivalenceMember,
    ) -> *mut RestrictInfo;
    pub fn add_child_rel_equivalences(
        root: *mut PlannerInfo,
        appinfo: *mut AppendRelInfo,
        parent_rel: *mut RelOptInfo,
        child_rel: *mut RelOptInfo,
    );
    pub fn add_child_join_rel_equivalences(
        root: *mut PlannerInfo,
        nappinfos: ::std::os::raw::c_int,
        appinfos: *mut *mut AppendRelInfo,
        parent_joinrel: *mut RelOptInfo,
        child_joinrel: *mut RelOptInfo,
    );
    pub fn generate_implied_equalities_for_column(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        callback: ec_matches_callback_type,
        callback_arg: *mut ::std::os::raw::c_void,
        prohibited_rels: Relids,
    ) -> *mut List;
    pub fn have_relevant_eclass_joinclause(
        root: *mut PlannerInfo,
        rel1: *mut RelOptInfo,
        rel2: *mut RelOptInfo,
    ) -> bool;
    pub fn has_relevant_eclass_joinclause(root: *mut PlannerInfo, rel1: *mut RelOptInfo) -> bool;
    pub fn eclass_useful_for_merging(
        root: *mut PlannerInfo,
        eclass: *mut EquivalenceClass,
        rel: *mut RelOptInfo,
    ) -> bool;
    pub fn is_redundant_derived_clause(rinfo: *mut RestrictInfo, clauselist: *mut List) -> bool;
    pub fn is_redundant_with_indexclauses(
        rinfo: *mut RestrictInfo,
        indexclauses: *mut List,
    ) -> bool;
    pub fn compare_pathkeys(keys1: *mut List, keys2: *mut List) -> PathKeysComparison;
    pub fn pathkeys_contained_in(keys1: *mut List, keys2: *mut List) -> bool;
    pub fn pathkeys_count_contained_in(
        keys1: *mut List,
        keys2: *mut List,
        n_common: *mut ::std::os::raw::c_int,
    ) -> bool;
    pub fn get_cheapest_path_for_pathkeys(
        paths: *mut List,
        pathkeys: *mut List,
        required_outer: Relids,
        cost_criterion: CostSelector,
        require_parallel_safe: bool,
    ) -> *mut Path;
    pub fn get_cheapest_fractional_path_for_pathkeys(
        paths: *mut List,
        pathkeys: *mut List,
        required_outer: Relids,
        fraction: f64,
    ) -> *mut Path;
    pub fn get_cheapest_parallel_safe_total_inner(paths: *mut List) -> *mut Path;
    pub fn build_index_pathkeys(
        root: *mut PlannerInfo,
        index: *mut IndexOptInfo,
        scandir: ScanDirection,
    ) -> *mut List;
    pub fn build_partition_pathkeys(
        root: *mut PlannerInfo,
        partrel: *mut RelOptInfo,
        scandir: ScanDirection,
        partialkeys: *mut bool,
    ) -> *mut List;
    pub fn build_expression_pathkey(
        root: *mut PlannerInfo,
        expr: *mut Expr,
        opno: Oid,
        rel: Relids,
        create_it: bool,
    ) -> *mut List;
    pub fn convert_subquery_pathkeys(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        subquery_pathkeys: *mut List,
        subquery_tlist: *mut List,
    ) -> *mut List;
    pub fn build_join_pathkeys(
        root: *mut PlannerInfo,
        joinrel: *mut RelOptInfo,
        jointype: JoinType,
        outer_pathkeys: *mut List,
    ) -> *mut List;
    pub fn make_pathkeys_for_sortclauses(
        root: *mut PlannerInfo,
        sortclauses: *mut List,
        tlist: *mut List,
    ) -> *mut List;
    pub fn make_pathkeys_for_sortclauses_extended(
        root: *mut PlannerInfo,
        sortclauses: *mut *mut List,
        tlist: *mut List,
        remove_redundant: bool,
        sortable: *mut bool,
    ) -> *mut List;
    pub fn initialize_mergeclause_eclasses(root: *mut PlannerInfo, restrictinfo: *mut RestrictInfo);
    pub fn update_mergeclause_eclasses(root: *mut PlannerInfo, restrictinfo: *mut RestrictInfo);
    pub fn find_mergeclauses_for_outer_pathkeys(
        root: *mut PlannerInfo,
        pathkeys: *mut List,
        restrictinfos: *mut List,
    ) -> *mut List;
    pub fn select_outer_pathkeys_for_merge(
        root: *mut PlannerInfo,
        mergeclauses: *mut List,
        joinrel: *mut RelOptInfo,
    ) -> *mut List;
    pub fn make_inner_pathkeys_for_merge(
        root: *mut PlannerInfo,
        mergeclauses: *mut List,
        outer_pathkeys: *mut List,
    ) -> *mut List;
    pub fn trim_mergeclauses_for_inner_pathkeys(
        root: *mut PlannerInfo,
        mergeclauses: *mut List,
        pathkeys: *mut List,
    ) -> *mut List;
    pub fn truncate_useless_pathkeys(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        pathkeys: *mut List,
    ) -> *mut List;
    pub fn has_useful_pathkeys(root: *mut PlannerInfo, rel: *mut RelOptInfo) -> bool;
    pub fn append_pathkeys(target: *mut List, source: *mut List) -> *mut List;
    pub fn make_canonical_pathkey(
        root: *mut PlannerInfo,
        eclass: *mut EquivalenceClass,
        opfamily: Oid,
        strategy: ::std::os::raw::c_int,
        nulls_first: bool,
    ) -> *mut PathKey;
    pub fn add_paths_to_append_rel(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        live_childrels: *mut List,
    );
    pub fn get_relation_info(
        root: *mut PlannerInfo,
        relationObjectId: Oid,
        inhparent: bool,
        rel: *mut RelOptInfo,
    );
    pub fn infer_arbiter_indexes(root: *mut PlannerInfo) -> *mut List;
    pub fn estimate_rel_size(
        rel: Relation,
        attr_widths: *mut int32,
        pages: *mut BlockNumber,
        tuples: *mut f64,
        allvisfrac: *mut f64,
    );
    pub fn get_rel_data_width(rel: Relation, attr_widths: *mut int32) -> int32;
    pub fn get_relation_data_width(relid: Oid, attr_widths: *mut int32) -> int32;
    pub fn relation_excluded_by_constraints(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        rte: *mut RangeTblEntry,
    ) -> bool;
    pub fn build_physical_tlist(root: *mut PlannerInfo, rel: *mut RelOptInfo) -> *mut List;
    pub fn has_unique_index(rel: *mut RelOptInfo, attno: AttrNumber) -> bool;
    pub fn restriction_selectivity(
        root: *mut PlannerInfo,
        operatorid: Oid,
        args: *mut List,
        inputcollid: Oid,
        varRelid: ::std::os::raw::c_int,
    ) -> Selectivity;
    pub fn join_selectivity(
        root: *mut PlannerInfo,
        operatorid: Oid,
        args: *mut List,
        inputcollid: Oid,
        jointype: JoinType,
        sjinfo: *mut SpecialJoinInfo,
    ) -> Selectivity;
    pub fn function_selectivity(
        root: *mut PlannerInfo,
        funcid: Oid,
        args: *mut List,
        inputcollid: Oid,
        is_join: bool,
        varRelid: ::std::os::raw::c_int,
        jointype: JoinType,
        sjinfo: *mut SpecialJoinInfo,
    ) -> Selectivity;
    pub fn add_function_cost(
        root: *mut PlannerInfo,
        funcid: Oid,
        node: *mut Node,
        cost: *mut QualCost,
    );
    pub fn get_function_rows(root: *mut PlannerInfo, funcid: Oid, node: *mut Node) -> f64;
    pub fn has_row_triggers(root: *mut PlannerInfo, rti: Index, event: CmdType) -> bool;
    pub fn has_stored_generated_columns(root: *mut PlannerInfo, rti: Index) -> bool;
    pub fn get_dependent_generated_columns(
        root: *mut PlannerInfo,
        rti: Index,
        target_cols: *mut Bitmapset,
    ) -> *mut Bitmapset;
    pub fn query_planner(
        root: *mut PlannerInfo,
        qp_callback: query_pathkeys_callback,
        qp_extra: *mut ::std::os::raw::c_void,
    ) -> *mut RelOptInfo;
    pub fn preprocess_minmax_aggregates(root: *mut PlannerInfo);
    pub fn create_plan(root: *mut PlannerInfo, best_path: *mut Path) -> *mut Plan;
    pub fn make_foreignscan(
        qptlist: *mut List,
        qpqual: *mut List,
        scanrelid: Index,
        fdw_exprs: *mut List,
        fdw_private: *mut List,
        fdw_scan_tlist: *mut List,
        fdw_recheck_quals: *mut List,
        outer_plan: *mut Plan,
    ) -> *mut ForeignScan;
    pub fn change_plan_targetlist(
        subplan: *mut Plan,
        tlist: *mut List,
        tlist_parallel_safe: bool,
    ) -> *mut Plan;
    pub fn materialize_finished_plan(subplan: *mut Plan) -> *mut Plan;
    pub fn is_projection_capable_path(path: *mut Path) -> bool;
    pub fn is_projection_capable_plan(plan: *mut Plan) -> bool;
    pub fn make_sort_from_sortclauses(sortcls: *mut List, lefttree: *mut Plan) -> *mut Sort;
    pub fn make_agg(
        tlist: *mut List,
        qual: *mut List,
        aggstrategy: AggStrategy,
        aggsplit: AggSplit,
        numGroupCols: ::std::os::raw::c_int,
        grpColIdx: *mut AttrNumber,
        grpOperators: *mut Oid,
        grpCollations: *mut Oid,
        groupingSets: *mut List,
        chain: *mut List,
        dNumGroups: f64,
        transitionSpace: Size,
        lefttree: *mut Plan,
    ) -> *mut Agg;
    pub fn make_limit(
        lefttree: *mut Plan,
        limitOffset: *mut Node,
        limitCount: *mut Node,
        limitOption: LimitOption,
        uniqNumCols: ::std::os::raw::c_int,
        uniqColIdx: *mut AttrNumber,
        uniqOperators: *mut Oid,
        uniqCollations: *mut Oid,
    ) -> *mut Limit;
    pub fn add_base_rels_to_query(root: *mut PlannerInfo, jtnode: *mut Node);
    pub fn add_other_rels_to_query(root: *mut PlannerInfo);
    pub fn build_base_rel_tlists(root: *mut PlannerInfo, final_tlist: *mut List);
    pub fn add_vars_to_targetlist(root: *mut PlannerInfo, vars: *mut List, where_needed: Relids);
    pub fn find_lateral_references(root: *mut PlannerInfo);
    pub fn create_lateral_join_info(root: *mut PlannerInfo);
    pub fn deconstruct_jointree(root: *mut PlannerInfo) -> *mut List;
    pub fn distribute_restrictinfo_to_rels(root: *mut PlannerInfo, restrictinfo: *mut RestrictInfo);
    pub fn process_implied_equality(
        root: *mut PlannerInfo,
        opno: Oid,
        collation: Oid,
        item1: *mut Expr,
        item2: *mut Expr,
        qualscope: Relids,
        security_level: Index,
        both_const: bool,
    ) -> *mut RestrictInfo;
    pub fn build_implied_join_equality(
        root: *mut PlannerInfo,
        opno: Oid,
        collation: Oid,
        item1: *mut Expr,
        item2: *mut Expr,
        qualscope: Relids,
        security_level: Index,
    ) -> *mut RestrictInfo;
    pub fn match_foreign_keys_to_quals(root: *mut PlannerInfo);
    pub fn remove_useless_joins(root: *mut PlannerInfo, joinlist: *mut List) -> *mut List;
    pub fn reduce_unique_semijoins(root: *mut PlannerInfo);
    pub fn query_supports_distinctness(query: *mut Query) -> bool;
    pub fn query_is_distinct_for(query: *mut Query, colnos: *mut List, opids: *mut List) -> bool;
    pub fn innerrel_is_unique(
        root: *mut PlannerInfo,
        joinrelids: Relids,
        outerrelids: Relids,
        innerrel: *mut RelOptInfo,
        jointype: JoinType,
        restrictlist: *mut List,
        force_cache: bool,
    ) -> bool;
    pub fn set_plan_references(root: *mut PlannerInfo, plan: *mut Plan) -> *mut Plan;
    pub fn trivial_subqueryscan(plan: *mut SubqueryScan) -> bool;
    pub fn record_plan_function_dependency(root: *mut PlannerInfo, funcid: Oid);
    pub fn record_plan_type_dependency(root: *mut PlannerInfo, typid: Oid);
    pub fn extract_query_dependencies_walker(node: *mut Node, context: *mut PlannerInfo) -> bool;
    pub fn standard_planner(
        parse: *mut Query,
        query_string: *const ::std::os::raw::c_char,
        cursorOptions: ::std::os::raw::c_int,
        boundParams: ParamListInfo,
    ) -> *mut PlannedStmt;
    pub fn subquery_planner(
        glob: *mut PlannerGlobal,
        parse: *mut Query,
        parent_root: *mut PlannerInfo,
        hasRecursion: bool,
        tuple_fraction: f64,
    ) -> *mut PlannerInfo;
    pub fn select_rowmark_type(
        rte: *mut RangeTblEntry,
        strength: LockClauseStrength,
    ) -> RowMarkType;
    pub fn limit_needed(parse: *mut Query) -> bool;
    pub fn mark_partial_aggref(agg: *mut Aggref, aggsplit: AggSplit);
    pub fn get_cheapest_fractional_path(rel: *mut RelOptInfo, tuple_fraction: f64) -> *mut Path;
    pub fn preprocess_phv_expression(root: *mut PlannerInfo, expr: *mut Expr) -> *mut Expr;
    pub fn make_restrictinfo(
        root: *mut PlannerInfo,
        clause: *mut Expr,
        is_pushed_down: bool,
        has_clone: bool,
        is_clone: bool,
        pseudoconstant: bool,
        security_level: Index,
        required_relids: Relids,
        incompatible_relids: Relids,
        outer_relids: Relids,
    ) -> *mut RestrictInfo;
    pub fn commute_restrictinfo(rinfo: *mut RestrictInfo, comm_op: Oid) -> *mut RestrictInfo;
    pub fn restriction_is_or_clause(restrictinfo: *mut RestrictInfo) -> bool;
    pub fn restriction_is_securely_promotable(
        restrictinfo: *mut RestrictInfo,
        rel: *mut RelOptInfo,
    ) -> bool;
    pub fn get_actual_clauses(restrictinfo_list: *mut List) -> *mut List;
    pub fn extract_actual_clauses(restrictinfo_list: *mut List, pseudoconstant: bool) -> *mut List;
    pub fn extract_actual_join_clauses(
        restrictinfo_list: *mut List,
        joinrelids: Relids,
        joinquals: *mut *mut List,
        otherquals: *mut *mut List,
    );
    pub fn has_pseudoconstant_clauses(root: *mut PlannerInfo, restrictinfo_list: *mut List)
        -> bool;
    pub fn join_clause_is_movable_to(rinfo: *mut RestrictInfo, baserel: *mut RelOptInfo) -> bool;
    pub fn join_clause_is_movable_into(
        rinfo: *mut RestrictInfo,
        currentrelids: Relids,
        current_and_outer: Relids,
    ) -> bool;
    pub fn tlist_member(node: *mut Expr, targetlist: *mut List) -> *mut TargetEntry;
    pub fn add_to_flat_tlist(tlist: *mut List, exprs: *mut List) -> *mut List;
    pub fn get_tlist_exprs(tlist: *mut List, includeJunk: bool) -> *mut List;
    pub fn tlist_same_exprs(tlist1: *mut List, tlist2: *mut List) -> bool;
    pub fn tlist_same_datatypes(tlist: *mut List, colTypes: *mut List, junkOK: bool) -> bool;
    pub fn tlist_same_collations(tlist: *mut List, colCollations: *mut List, junkOK: bool) -> bool;
    pub fn apply_tlist_labeling(dest_tlist: *mut List, src_tlist: *mut List);
    pub fn extract_grouping_ops(groupClause: *mut List) -> *mut Oid;
    pub fn extract_grouping_collations(groupClause: *mut List, tlist: *mut List) -> *mut Oid;
    pub fn extract_grouping_cols(groupClause: *mut List, tlist: *mut List) -> *mut AttrNumber;
    pub fn grouping_is_sortable(groupClause: *mut List) -> bool;
    pub fn grouping_is_hashable(groupClause: *mut List) -> bool;
    pub fn make_pathtarget_from_tlist(tlist: *mut List) -> *mut PathTarget;
    pub fn make_tlist_from_pathtarget(target: *mut PathTarget) -> *mut List;
    pub fn copy_pathtarget(src: *mut PathTarget) -> *mut PathTarget;
    pub fn create_empty_pathtarget() -> *mut PathTarget;
    pub fn add_column_to_pathtarget(target: *mut PathTarget, expr: *mut Expr, sortgroupref: Index);
    pub fn add_new_column_to_pathtarget(target: *mut PathTarget, expr: *mut Expr);
    pub fn add_new_columns_to_pathtarget(target: *mut PathTarget, exprs: *mut List);
    pub fn apply_pathtarget_labeling_to_tlist(tlist: *mut List, target: *mut PathTarget);
    pub fn split_pathtarget_at_srfs(
        root: *mut PlannerInfo,
        target: *mut PathTarget,
        input_target: *mut PathTarget,
        targets: *mut *mut List,
        targets_contain_srfs: *mut *mut List,
    );
    pub fn CleanQuerytext(
        query: *const ::std::os::raw::c_char,
        location: *mut ::std::os::raw::c_int,
        len: *mut ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
    pub fn JumbleQuery(query: *mut Query) -> *mut JumbleState;
    pub fn EnableQueryId();
    pub fn parse_analyze_fixedparams(
        parseTree: *mut RawStmt,
        sourceText: *const ::std::os::raw::c_char,
        paramTypes: *const Oid,
        numParams: ::std::os::raw::c_int,
        queryEnv: *mut QueryEnvironment,
    ) -> *mut Query;
    pub fn parse_analyze_varparams(
        parseTree: *mut RawStmt,
        sourceText: *const ::std::os::raw::c_char,
        paramTypes: *mut *mut Oid,
        numParams: *mut ::std::os::raw::c_int,
        queryEnv: *mut QueryEnvironment,
    ) -> *mut Query;
    pub fn parse_analyze_withcb(
        parseTree: *mut RawStmt,
        sourceText: *const ::std::os::raw::c_char,
        parserSetup: ParserSetupHook,
        parserSetupArg: *mut ::std::os::raw::c_void,
        queryEnv: *mut QueryEnvironment,
    ) -> *mut Query;
    pub fn parse_sub_analyze(
        parseTree: *mut Node,
        parentParseState: *mut ParseState,
        parentCTE: *mut CommonTableExpr,
        locked_from_parent: bool,
        resolve_unknowns: bool,
    ) -> *mut Query;
    pub fn transformInsertRow(
        pstate: *mut ParseState,
        exprlist: *mut List,
        stmtcols: *mut List,
        icolumns: *mut List,
        attrnos: *mut List,
        strip_indirection: bool,
    ) -> *mut List;
    pub fn transformUpdateTargetList(pstate: *mut ParseState, origTlist: *mut List) -> *mut List;
    pub fn transformTopLevelStmt(pstate: *mut ParseState, parseTree: *mut RawStmt) -> *mut Query;
    pub fn transformStmt(pstate: *mut ParseState, parseTree: *mut Node) -> *mut Query;
    pub fn stmt_requires_parse_analysis(parseTree: *mut RawStmt) -> bool;
    pub fn analyze_requires_snapshot(parseTree: *mut RawStmt) -> bool;
    pub fn LCS_asString(strength: LockClauseStrength) -> *const ::std::os::raw::c_char;
    pub fn CheckSelectLocking(qry: *mut Query, strength: LockClauseStrength);
    pub fn applyLockingClause(
        qry: *mut Query,
        rtindex: Index,
        strength: LockClauseStrength,
        waitPolicy: LockWaitPolicy,
        pushedDown: bool,
    );
    pub fn BuildOnConflictExcludedTargetlist(targetrel: Relation, exclRelIndex: Index)
        -> *mut List;
    pub fn makeSortGroupClauseForSetOp(rescoltype: Oid, require_hash: bool)
        -> *mut SortGroupClause;
    pub fn ParseFuncOrColumn(
        pstate: *mut ParseState,
        funcname: *mut List,
        fargs: *mut List,
        last_srf: *mut Node,
        fn_: *mut FuncCall,
        proc_call: bool,
        location: ::std::os::raw::c_int,
    ) -> *mut Node;
    pub fn func_get_detail(
        funcname: *mut List,
        fargs: *mut List,
        fargnames: *mut List,
        nargs: ::std::os::raw::c_int,
        argtypes: *mut Oid,
        expand_variadic: bool,
        expand_defaults: bool,
        include_out_arguments: bool,
        funcid: *mut Oid,
        rettype: *mut Oid,
        retset: *mut bool,
        nvargs: *mut ::std::os::raw::c_int,
        vatype: *mut Oid,
        true_typeids: *mut *mut Oid,
        argdefaults: *mut *mut List,
    ) -> FuncDetailCode;
    pub fn func_match_argtypes(
        nargs: ::std::os::raw::c_int,
        input_typeids: *mut Oid,
        raw_candidates: FuncCandidateList,
        candidates: *mut FuncCandidateList,
    ) -> ::std::os::raw::c_int;
    pub fn func_select_candidate(
        nargs: ::std::os::raw::c_int,
        input_typeids: *mut Oid,
        candidates: FuncCandidateList,
    ) -> FuncCandidateList;
    pub fn make_fn_arguments(
        pstate: *mut ParseState,
        fargs: *mut List,
        actual_arg_types: *mut Oid,
        declared_arg_types: *mut Oid,
    );
    pub fn funcname_signature_string(
        funcname: *const ::std::os::raw::c_char,
        nargs: ::std::os::raw::c_int,
        argnames: *mut List,
        argtypes: *const Oid,
    ) -> *const ::std::os::raw::c_char;
    pub fn func_signature_string(
        funcname: *mut List,
        nargs: ::std::os::raw::c_int,
        argnames: *mut List,
        argtypes: *const Oid,
    ) -> *const ::std::os::raw::c_char;
    pub fn LookupFuncName(
        funcname: *mut List,
        nargs: ::std::os::raw::c_int,
        argtypes: *const Oid,
        missing_ok: bool,
    ) -> Oid;
    pub fn LookupFuncWithArgs(
        objtype: ObjectType,
        func: *mut ObjectWithArgs,
        missing_ok: bool,
    ) -> Oid;
    pub fn check_srf_call_placement(
        pstate: *mut ParseState,
        last_srf: *mut Node,
        location: ::std::os::raw::c_int,
    );
    pub fn LookupOperName(
        pstate: *mut ParseState,
        opername: *mut List,
        oprleft: Oid,
        oprright: Oid,
        noError: bool,
        location: ::std::os::raw::c_int,
    ) -> Oid;
    pub fn LookupOperWithArgs(oper: *mut ObjectWithArgs, noError: bool) -> Oid;
    pub fn oper(
        pstate: *mut ParseState,
        opname: *mut List,
        ltypeId: Oid,
        rtypeId: Oid,
        noError: bool,
        location: ::std::os::raw::c_int,
    ) -> Operator;
    pub fn left_oper(
        pstate: *mut ParseState,
        op: *mut List,
        arg: Oid,
        noError: bool,
        location: ::std::os::raw::c_int,
    ) -> Operator;
    pub fn compatible_oper(
        pstate: *mut ParseState,
        op: *mut List,
        arg1: Oid,
        arg2: Oid,
        noError: bool,
        location: ::std::os::raw::c_int,
    ) -> Operator;
    pub fn get_sort_group_operators(
        argtype: Oid,
        needLT: bool,
        needEQ: bool,
        needGT: bool,
        ltOpr: *mut Oid,
        eqOpr: *mut Oid,
        gtOpr: *mut Oid,
        isHashable: *mut bool,
    );
    pub fn compatible_oper_opid(op: *mut List, arg1: Oid, arg2: Oid, noError: bool) -> Oid;
    pub fn oprid(op: Operator) -> Oid;
    pub fn oprfuncid(op: Operator) -> Oid;
    pub fn make_op(
        pstate: *mut ParseState,
        opname: *mut List,
        ltree: *mut Node,
        rtree: *mut Node,
        last_srf: *mut Node,
        location: ::std::os::raw::c_int,
    ) -> *mut Expr;
    pub fn make_scalar_array_op(
        pstate: *mut ParseState,
        opname: *mut List,
        useOr: bool,
        ltree: *mut Node,
        rtree: *mut Node,
        location: ::std::os::raw::c_int,
    ) -> *mut Expr;
    pub fn LookupTypeName(
        pstate: *mut ParseState,
        typeName: *const TypeName,
        typmod_p: *mut int32,
        missing_ok: bool,
    ) -> Type;
    pub fn LookupTypeNameExtended(
        pstate: *mut ParseState,
        typeName: *const TypeName,
        typmod_p: *mut int32,
        temp_ok: bool,
        missing_ok: bool,
    ) -> Type;
    pub fn LookupTypeNameOid(
        pstate: *mut ParseState,
        typeName: *const TypeName,
        missing_ok: bool,
    ) -> Oid;
    pub fn typenameType(
        pstate: *mut ParseState,
        typeName: *const TypeName,
        typmod_p: *mut int32,
    ) -> Type;
    pub fn typenameTypeId(pstate: *mut ParseState, typeName: *const TypeName) -> Oid;
    pub fn typenameTypeIdAndMod(
        pstate: *mut ParseState,
        typeName: *const TypeName,
        typeid_p: *mut Oid,
        typmod_p: *mut int32,
    );
    pub fn TypeNameToString(typeName: *const TypeName) -> *mut ::std::os::raw::c_char;
    pub fn TypeNameListToString(typenames: *mut List) -> *mut ::std::os::raw::c_char;
    pub fn LookupCollation(
        pstate: *mut ParseState,
        collnames: *mut List,
        location: ::std::os::raw::c_int,
    ) -> Oid;
    pub fn GetColumnDefCollation(
        pstate: *mut ParseState,
        coldef: *mut ColumnDef,
        typeOid: Oid,
    ) -> Oid;
    pub fn typeidType(id: Oid) -> Type;
    pub fn typeTypeId(tp: Type) -> Oid;
    pub fn typeLen(t: Type) -> int16;
    pub fn typeByVal(t: Type) -> bool;
    pub fn typeTypeName(t: Type) -> *mut ::std::os::raw::c_char;
    pub fn typeTypeRelid(typ: Type) -> Oid;
    pub fn typeTypeCollation(typ: Type) -> Oid;
    pub fn stringTypeDatum(
        tp: Type,
        string: *mut ::std::os::raw::c_char,
        atttypmod: int32,
    ) -> Datum;
    pub fn typeidTypeRelid(type_id: Oid) -> Oid;
    pub fn typeOrDomainTypeRelid(type_id: Oid) -> Oid;
    pub fn typeStringToTypeName(
        str_: *const ::std::os::raw::c_char,
        escontext: *mut Node,
    ) -> *mut TypeName;
    pub fn parseTypeString(
        str_: *const ::std::os::raw::c_char,
        typeid_p: *mut Oid,
        typmod_p: *mut int32,
        escontext: *mut Node,
    ) -> bool;
    pub fn IsBinaryCoercible(srctype: Oid, targettype: Oid) -> bool;
    pub fn IsBinaryCoercibleWithCast(srctype: Oid, targettype: Oid, castoid: *mut Oid) -> bool;
    pub fn IsPreferredType(category: TYPCATEGORY, type_: Oid) -> bool;
    pub fn TypeCategory(type_: Oid) -> TYPCATEGORY;
    pub fn coerce_to_target_type(
        pstate: *mut ParseState,
        expr: *mut Node,
        exprtype: Oid,
        targettype: Oid,
        targettypmod: int32,
        ccontext: CoercionContext,
        cformat: CoercionForm,
        location: ::std::os::raw::c_int,
    ) -> *mut Node;
    pub fn can_coerce_type(
        nargs: ::std::os::raw::c_int,
        input_typeids: *const Oid,
        target_typeids: *const Oid,
        ccontext: CoercionContext,
    ) -> bool;
    pub fn coerce_type(
        pstate: *mut ParseState,
        node: *mut Node,
        inputTypeId: Oid,
        targetTypeId: Oid,
        targetTypeMod: int32,
        ccontext: CoercionContext,
        cformat: CoercionForm,
        location: ::std::os::raw::c_int,
    ) -> *mut Node;
    pub fn coerce_to_domain(
        arg: *mut Node,
        baseTypeId: Oid,
        baseTypeMod: int32,
        typeId: Oid,
        ccontext: CoercionContext,
        cformat: CoercionForm,
        location: ::std::os::raw::c_int,
        hideInputCoercion: bool,
    ) -> *mut Node;
    pub fn coerce_to_boolean(
        pstate: *mut ParseState,
        node: *mut Node,
        constructName: *const ::std::os::raw::c_char,
    ) -> *mut Node;
    pub fn coerce_to_specific_type(
        pstate: *mut ParseState,
        node: *mut Node,
        targetTypeId: Oid,
        constructName: *const ::std::os::raw::c_char,
    ) -> *mut Node;
    pub fn coerce_to_specific_type_typmod(
        pstate: *mut ParseState,
        node: *mut Node,
        targetTypeId: Oid,
        targetTypmod: int32,
        constructName: *const ::std::os::raw::c_char,
    ) -> *mut Node;
    pub fn parser_coercion_errposition(
        pstate: *mut ParseState,
        coerce_location: ::std::os::raw::c_int,
        input_expr: *mut Node,
    ) -> ::std::os::raw::c_int;
    pub fn select_common_type(
        pstate: *mut ParseState,
        exprs: *mut List,
        context: *const ::std::os::raw::c_char,
        which_expr: *mut *mut Node,
    ) -> Oid;
    pub fn coerce_to_common_type(
        pstate: *mut ParseState,
        node: *mut Node,
        targetTypeId: Oid,
        context: *const ::std::os::raw::c_char,
    ) -> *mut Node;
    pub fn verify_common_type(common_type: Oid, exprs: *mut List) -> bool;
    pub fn select_common_typmod(
        pstate: *mut ParseState,
        exprs: *mut List,
        common_type: Oid,
    ) -> int32;
    pub fn check_generic_type_consistency(
        actual_arg_types: *const Oid,
        declared_arg_types: *const Oid,
        nargs: ::std::os::raw::c_int,
    ) -> bool;
    pub fn enforce_generic_type_consistency(
        actual_arg_types: *const Oid,
        declared_arg_types: *mut Oid,
        nargs: ::std::os::raw::c_int,
        rettype: Oid,
        allow_poly: bool,
    ) -> Oid;
    pub fn check_valid_polymorphic_signature(
        ret_type: Oid,
        declared_arg_types: *const Oid,
        nargs: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
    pub fn check_valid_internal_signature(
        ret_type: Oid,
        declared_arg_types: *const Oid,
        nargs: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
    pub fn find_coercion_pathway(
        targetTypeId: Oid,
        sourceTypeId: Oid,
        ccontext: CoercionContext,
        funcid: *mut Oid,
    ) -> CoercionPathType;
    pub fn find_typmod_coercion_function(typeId: Oid, funcid: *mut Oid) -> CoercionPathType;
    pub fn get_rte_attribute_name(
        rte: *mut RangeTblEntry,
        attnum: AttrNumber,
    ) -> *mut ::std::os::raw::c_char;
    pub fn get_rte_attribute_is_dropped(rte: *mut RangeTblEntry, attnum: AttrNumber) -> bool;
    pub fn get_tle_by_resno(tlist: *mut List, resno: AttrNumber) -> *mut TargetEntry;
    pub fn get_parse_rowmark(qry: *mut Query, rtindex: Index) -> *mut RowMarkClause;
    pub fn downcase_truncate_identifier(
        ident: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        warn: bool,
    ) -> *mut ::std::os::raw::c_char;
    pub fn downcase_identifier(
        ident: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        warn: bool,
        truncate: bool,
    ) -> *mut ::std::os::raw::c_char;
    pub fn truncate_identifier(
        ident: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        warn: bool,
    );
    pub fn scanner_isspace(ch: ::std::os::raw::c_char) -> bool;
    pub fn make_expanded_record_from_typeid(
        type_id: Oid,
        typmod: int32,
        parentcontext: MemoryContext,
    ) -> *mut ExpandedRecordHeader;
    pub fn make_expanded_record_from_tupdesc(
        tupdesc: TupleDesc,
        parentcontext: MemoryContext,
    ) -> *mut ExpandedRecordHeader;
    pub fn make_expanded_record_from_exprecord(
        olderh: *mut ExpandedRecordHeader,
        parentcontext: MemoryContext,
    ) -> *mut ExpandedRecordHeader;
    pub fn expanded_record_set_tuple(
        erh: *mut ExpandedRecordHeader,
        tuple: HeapTuple,
        copy: bool,
        expand_external: bool,
    );
    pub fn make_expanded_record_from_datum(
        recorddatum: Datum,
        parentcontext: MemoryContext,
    ) -> Datum;
    pub fn expanded_record_fetch_tupdesc(erh: *mut ExpandedRecordHeader) -> TupleDesc;
    pub fn expanded_record_get_tuple(erh: *mut ExpandedRecordHeader) -> HeapTuple;
    pub fn DatumGetExpandedRecord(d: Datum) -> *mut ExpandedRecordHeader;
    pub fn deconstruct_expanded_record(erh: *mut ExpandedRecordHeader);
    pub fn expanded_record_lookup_field(
        erh: *mut ExpandedRecordHeader,
        fieldname: *const ::std::os::raw::c_char,
        finfo: *mut ExpandedRecordFieldInfo,
    ) -> bool;
    pub fn expanded_record_fetch_field(
        erh: *mut ExpandedRecordHeader,
        fnumber: ::std::os::raw::c_int,
        isnull: *mut bool,
    ) -> Datum;
    pub fn expanded_record_set_field_internal(
        erh: *mut ExpandedRecordHeader,
        fnumber: ::std::os::raw::c_int,
        newValue: Datum,
        isnull: bool,
        expand_external: bool,
        check_constraints: bool,
    );
    pub fn expanded_record_set_fields(
        erh: *mut ExpandedRecordHeader,
        newValues: *const Datum,
        isnulls: *const bool,
        expand_external: bool,
    );
    pub fn lookup_type_cache(type_id: Oid, flags: ::std::os::raw::c_int) -> *mut TypeCacheEntry;
    pub fn InitDomainConstraintRef(
        type_id: Oid,
        ref_: *mut DomainConstraintRef,
        refctx: MemoryContext,
        need_exprstate: bool,
    );
    pub fn UpdateDomainConstraintRef(ref_: *mut DomainConstraintRef);
    pub fn DomainHasConstraints(type_id: Oid) -> bool;
    pub fn lookup_rowtype_tupdesc(type_id: Oid, typmod: int32) -> TupleDesc;
    pub fn lookup_rowtype_tupdesc_noerror(type_id: Oid, typmod: int32, noError: bool) -> TupleDesc;
    pub fn lookup_rowtype_tupdesc_copy(type_id: Oid, typmod: int32) -> TupleDesc;
    pub fn lookup_rowtype_tupdesc_domain(type_id: Oid, typmod: int32, noError: bool) -> TupleDesc;
    pub fn assign_record_type_typmod(tupDesc: TupleDesc);
    pub fn assign_record_type_identifier(type_id: Oid, typmod: int32) -> uint64;
    pub fn compare_values_of_enum(
        tcache: *mut TypeCacheEntry,
        arg1: Oid,
        arg2: Oid,
    ) -> ::std::os::raw::c_int;
    pub fn SharedRecordTypmodRegistryEstimate() -> usize;
    pub fn SharedRecordTypmodRegistryInit(
        arg1: *mut SharedRecordTypmodRegistry,
        segment: *mut dsm_segment,
        area: *mut dsa_area,
    );
    pub fn SharedRecordTypmodRegistryAttach(arg1: *mut SharedRecordTypmodRegistry);
    #[doc = " Function declarations"]
    pub fn plpgsql_compile(fcinfo: FunctionCallInfo, forValidator: bool) -> *mut PLpgSQL_function;
    pub fn plpgsql_compile_inline(
        proc_source: *mut ::std::os::raw::c_char,
    ) -> *mut PLpgSQL_function;
    pub fn plpgsql_parser_setup(pstate: *mut ParseState, expr: *mut PLpgSQL_expr);
    pub fn plpgsql_parse_word(
        word1: *mut ::std::os::raw::c_char,
        yytxt: *const ::std::os::raw::c_char,
        lookup: bool,
        wdatum: *mut PLwdatum,
        word: *mut PLword,
    ) -> bool;
    pub fn plpgsql_parse_dblword(
        word1: *mut ::std::os::raw::c_char,
        word2: *mut ::std::os::raw::c_char,
        wdatum: *mut PLwdatum,
        cword: *mut PLcword,
    ) -> bool;
    pub fn plpgsql_parse_tripword(
        word1: *mut ::std::os::raw::c_char,
        word2: *mut ::std::os::raw::c_char,
        word3: *mut ::std::os::raw::c_char,
        wdatum: *mut PLwdatum,
        cword: *mut PLcword,
    ) -> bool;
    pub fn plpgsql_parse_wordtype(ident: *mut ::std::os::raw::c_char) -> *mut PLpgSQL_type;
    pub fn plpgsql_parse_cwordtype(idents: *mut List) -> *mut PLpgSQL_type;
    pub fn plpgsql_parse_wordrowtype(ident: *mut ::std::os::raw::c_char) -> *mut PLpgSQL_type;
    pub fn plpgsql_parse_cwordrowtype(idents: *mut List) -> *mut PLpgSQL_type;
    pub fn plpgsql_build_datatype(
        typeOid: Oid,
        typmod: int32,
        collation: Oid,
        origtypname: *mut TypeName,
    ) -> *mut PLpgSQL_type;
    pub fn plpgsql_build_variable(
        refname: *const ::std::os::raw::c_char,
        lineno: ::std::os::raw::c_int,
        dtype: *mut PLpgSQL_type,
        add2namespace: bool,
    ) -> *mut PLpgSQL_variable;
    pub fn plpgsql_build_record(
        refname: *const ::std::os::raw::c_char,
        lineno: ::std::os::raw::c_int,
        dtype: *mut PLpgSQL_type,
        rectypeid: Oid,
        add2namespace: bool,
    ) -> *mut PLpgSQL_rec;
    pub fn plpgsql_build_recfield(
        rec: *mut PLpgSQL_rec,
        fldname: *const ::std::os::raw::c_char,
    ) -> *mut PLpgSQL_recfield;
    pub fn plpgsql_recognize_err_condition(
        condname: *const ::std::os::raw::c_char,
        allow_sqlstate: bool,
    ) -> ::std::os::raw::c_int;
    pub fn plpgsql_parse_err_condition(
        condname: *mut ::std::os::raw::c_char,
    ) -> *mut PLpgSQL_condition;
    pub fn plpgsql_adddatum(newdatum: *mut PLpgSQL_datum);
    pub fn plpgsql_add_initdatums(varnos: *mut *mut ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
    pub fn plpgsql_HashTableInit();
    pub fn plpgsql_exec_function(
        func: *mut PLpgSQL_function,
        fcinfo: FunctionCallInfo,
        simple_eval_estate: *mut EState,
        simple_eval_resowner: ResourceOwner,
        procedure_resowner: ResourceOwner,
        atomic: bool,
    ) -> Datum;
    pub fn plpgsql_exec_trigger(
        func: *mut PLpgSQL_function,
        trigdata: *mut TriggerData,
    ) -> HeapTuple;
    pub fn plpgsql_exec_event_trigger(func: *mut PLpgSQL_function, trigdata: *mut EventTriggerData);
    pub fn plpgsql_xact_cb(event: XactEvent, arg: *mut ::std::os::raw::c_void);
    pub fn plpgsql_subxact_cb(
        event: SubXactEvent,
        mySubid: SubTransactionId,
        parentSubid: SubTransactionId,
        arg: *mut ::std::os::raw::c_void,
    );
    pub fn plpgsql_exec_get_datum_type(
        estate: *mut PLpgSQL_execstate,
        datum: *mut PLpgSQL_datum,
    ) -> Oid;
    pub fn plpgsql_exec_get_datum_type_info(
        estate: *mut PLpgSQL_execstate,
        datum: *mut PLpgSQL_datum,
        typeId: *mut Oid,
        typMod: *mut int32,
        collation: *mut Oid,
    );
    pub fn plpgsql_ns_init();
    pub fn plpgsql_ns_push(label: *const ::std::os::raw::c_char, label_type: PLpgSQL_label_type);
    pub fn plpgsql_ns_pop();
    pub fn plpgsql_ns_top() -> *mut PLpgSQL_nsitem;
    pub fn plpgsql_ns_additem(
        itemtype: PLpgSQL_nsitem_type,
        itemno: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
    );
    pub fn plpgsql_ns_lookup(
        ns_cur: *mut PLpgSQL_nsitem,
        localmode: bool,
        name1: *const ::std::os::raw::c_char,
        name2: *const ::std::os::raw::c_char,
        name3: *const ::std::os::raw::c_char,
        names_used: *mut ::std::os::raw::c_int,
    ) -> *mut PLpgSQL_nsitem;
    pub fn plpgsql_ns_lookup_label(
        ns_cur: *mut PLpgSQL_nsitem,
        name: *const ::std::os::raw::c_char,
    ) -> *mut PLpgSQL_nsitem;
    pub fn plpgsql_ns_find_nearest_loop(ns_cur: *mut PLpgSQL_nsitem) -> *mut PLpgSQL_nsitem;
    pub fn plpgsql_stmt_typename(stmt: *mut PLpgSQL_stmt) -> *const ::std::os::raw::c_char;
    pub fn plpgsql_getdiag_kindname(kind: PLpgSQL_getdiag_kind) -> *const ::std::os::raw::c_char;
    pub fn plpgsql_free_function_memory(func: *mut PLpgSQL_function);
    pub fn plpgsql_dumptree(func: *mut PLpgSQL_function);
    pub fn plpgsql_base_yylex() -> ::std::os::raw::c_int;
    pub fn plpgsql_yylex() -> ::std::os::raw::c_int;
    pub fn plpgsql_push_back_token(token: ::std::os::raw::c_int);
    pub fn plpgsql_token_is_unreserved_keyword(token: ::std::os::raw::c_int) -> bool;
    pub fn plpgsql_append_source_text(
        buf: StringInfo,
        startlocation: ::std::os::raw::c_int,
        endlocation: ::std::os::raw::c_int,
    );
    pub fn plpgsql_peek() -> ::std::os::raw::c_int;
    pub fn plpgsql_peek2(
        tok1_p: *mut ::std::os::raw::c_int,
        tok2_p: *mut ::std::os::raw::c_int,
        tok1_loc: *mut ::std::os::raw::c_int,
        tok2_loc: *mut ::std::os::raw::c_int,
    );
    pub fn plpgsql_scanner_errposition(location: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn plpgsql_yyerror(message: *const ::std::os::raw::c_char) -> !;
    pub fn plpgsql_location_to_lineno(location: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn plpgsql_latest_lineno() -> ::std::os::raw::c_int;
    pub fn plpgsql_scanner_init(str_: *const ::std::os::raw::c_char);
    pub fn plpgsql_scanner_finish();
    pub fn plpgsql_yyparse() -> ::std::os::raw::c_int;
    pub fn PostmasterMain(argc: ::std::os::raw::c_int, argv: *mut *mut ::std::os::raw::c_char)
        -> !;
    pub fn ClosePostmasterPorts(am_syslogger: bool);
    pub fn InitProcessGlobals();
    pub fn MaxLivePostmasterChildren() -> ::std::os::raw::c_int;
    pub fn PostmasterMarkPIDForWorkerNotify(arg1: ::std::os::raw::c_int) -> bool;
    pub fn ReorderBufferAllocate() -> *mut ReorderBuffer;
    pub fn ReorderBufferFree(rb: *mut ReorderBuffer);
    pub fn ReorderBufferGetTupleBuf(
        rb: *mut ReorderBuffer,
        tuple_len: Size,
    ) -> *mut ReorderBufferTupleBuf;
    pub fn ReorderBufferReturnTupleBuf(rb: *mut ReorderBuffer, tuple: *mut ReorderBufferTupleBuf);
    pub fn ReorderBufferGetChange(rb: *mut ReorderBuffer) -> *mut ReorderBufferChange;
    pub fn ReorderBufferReturnChange(
        rb: *mut ReorderBuffer,
        change: *mut ReorderBufferChange,
        upd_mem: bool,
    );
    pub fn ReorderBufferGetRelids(
        rb: *mut ReorderBuffer,
        nrelids: ::std::os::raw::c_int,
    ) -> *mut Oid;
    pub fn ReorderBufferReturnRelids(rb: *mut ReorderBuffer, relids: *mut Oid);
    pub fn ReorderBufferQueueChange(
        rb: *mut ReorderBuffer,
        xid: TransactionId,
        lsn: XLogRecPtr,
        change: *mut ReorderBufferChange,
        toast_insert: bool,
    );
    pub fn ReorderBufferQueueMessage(
        rb: *mut ReorderBuffer,
        xid: TransactionId,
        snap: Snapshot,
        lsn: XLogRecPtr,
        transactional: bool,
        prefix: *const ::std::os::raw::c_char,
        message_size: Size,
        message: *const ::std::os::raw::c_char,
    );
    pub fn ReorderBufferCommit(
        rb: *mut ReorderBuffer,
        xid: TransactionId,
        commit_lsn: XLogRecPtr,
        end_lsn: XLogRecPtr,
        commit_time: TimestampTz,
        origin_id: RepOriginId,
        origin_lsn: XLogRecPtr,
    );
    pub fn ReorderBufferFinishPrepared(
        rb: *mut ReorderBuffer,
        xid: TransactionId,
        commit_lsn: XLogRecPtr,
        end_lsn: XLogRecPtr,
        two_phase_at: XLogRecPtr,
        commit_time: TimestampTz,
        origin_id: RepOriginId,
        origin_lsn: XLogRecPtr,
        gid: *mut ::std::os::raw::c_char,
        is_commit: bool,
    );
    pub fn ReorderBufferAssignChild(
        rb: *mut ReorderBuffer,
        xid: TransactionId,
        subxid: TransactionId,
        lsn: XLogRecPtr,
    );
    pub fn ReorderBufferCommitChild(
        rb: *mut ReorderBuffer,
        xid: TransactionId,
        subxid: TransactionId,
        commit_lsn: XLogRecPtr,
        end_lsn: XLogRecPtr,
    );
    pub fn ReorderBufferAbort(
        rb: *mut ReorderBuffer,
        xid: TransactionId,
        lsn: XLogRecPtr,
        abort_time: TimestampTz,
    );
    pub fn ReorderBufferAbortOld(rb: *mut ReorderBuffer, oldestRunningXid: TransactionId);
    pub fn ReorderBufferForget(rb: *mut ReorderBuffer, xid: TransactionId, lsn: XLogRecPtr);
    pub fn ReorderBufferInvalidate(rb: *mut ReorderBuffer, xid: TransactionId, lsn: XLogRecPtr);
    pub fn ReorderBufferSetBaseSnapshot(
        rb: *mut ReorderBuffer,
        xid: TransactionId,
        lsn: XLogRecPtr,
        snap: Snapshot,
    );
    pub fn ReorderBufferAddSnapshot(
        rb: *mut ReorderBuffer,
        xid: TransactionId,
        lsn: XLogRecPtr,
        snap: Snapshot,
    );
    pub fn ReorderBufferAddNewCommandId(
        rb: *mut ReorderBuffer,
        xid: TransactionId,
        lsn: XLogRecPtr,
        cid: CommandId,
    );
    pub fn ReorderBufferAddNewTupleCids(
        rb: *mut ReorderBuffer,
        xid: TransactionId,
        lsn: XLogRecPtr,
        locator: RelFileLocator,
        tid: ItemPointerData,
        cmin: CommandId,
        cmax: CommandId,
        combocid: CommandId,
    );
    pub fn ReorderBufferAddInvalidations(
        rb: *mut ReorderBuffer,
        xid: TransactionId,
        lsn: XLogRecPtr,
        nmsgs: Size,
        msgs: *mut SharedInvalidationMessage,
    );
    pub fn ReorderBufferImmediateInvalidation(
        rb: *mut ReorderBuffer,
        ninvalidations: uint32,
        invalidations: *mut SharedInvalidationMessage,
    );
    pub fn ReorderBufferProcessXid(rb: *mut ReorderBuffer, xid: TransactionId, lsn: XLogRecPtr);
    pub fn ReorderBufferXidSetCatalogChanges(
        rb: *mut ReorderBuffer,
        xid: TransactionId,
        lsn: XLogRecPtr,
    );
    pub fn ReorderBufferXidHasCatalogChanges(rb: *mut ReorderBuffer, xid: TransactionId) -> bool;
    pub fn ReorderBufferXidHasBaseSnapshot(rb: *mut ReorderBuffer, xid: TransactionId) -> bool;
    pub fn ReorderBufferRememberPrepareInfo(
        rb: *mut ReorderBuffer,
        xid: TransactionId,
        prepare_lsn: XLogRecPtr,
        end_lsn: XLogRecPtr,
        prepare_time: TimestampTz,
        origin_id: RepOriginId,
        origin_lsn: XLogRecPtr,
    ) -> bool;
    pub fn ReorderBufferSkipPrepare(rb: *mut ReorderBuffer, xid: TransactionId);
    pub fn ReorderBufferPrepare(
        rb: *mut ReorderBuffer,
        xid: TransactionId,
        gid: *mut ::std::os::raw::c_char,
    );
    pub fn ReorderBufferGetOldestTXN(rb: *mut ReorderBuffer) -> *mut ReorderBufferTXN;
    pub fn ReorderBufferGetOldestXmin(rb: *mut ReorderBuffer) -> TransactionId;
    pub fn ReorderBufferGetCatalogChangesXacts(rb: *mut ReorderBuffer) -> *mut TransactionId;
    pub fn ReorderBufferSetRestartPoint(rb: *mut ReorderBuffer, ptr: XLogRecPtr);
    pub fn StartupReorderBuffer();
    pub fn _PG_output_plugin_init(cb: *mut OutputPluginCallbacks);
    pub fn OutputPluginPrepareWrite(ctx: *mut LogicalDecodingContext, last_write: bool);
    pub fn OutputPluginWrite(ctx: *mut LogicalDecodingContext, last_write: bool);
    pub fn OutputPluginUpdateProgress(ctx: *mut LogicalDecodingContext, skipped_xact: bool);
    pub fn logicalrep_write_begin(out: StringInfo, txn: *mut ReorderBufferTXN);
    pub fn logicalrep_read_begin(in_: StringInfo, begin_data: *mut LogicalRepBeginData);
    pub fn logicalrep_write_commit(
        out: StringInfo,
        txn: *mut ReorderBufferTXN,
        commit_lsn: XLogRecPtr,
    );
    pub fn logicalrep_read_commit(in_: StringInfo, commit_data: *mut LogicalRepCommitData);
    pub fn logicalrep_write_begin_prepare(out: StringInfo, txn: *mut ReorderBufferTXN);
    pub fn logicalrep_read_begin_prepare(
        in_: StringInfo,
        begin_data: *mut LogicalRepPreparedTxnData,
    );
    pub fn logicalrep_write_prepare(
        out: StringInfo,
        txn: *mut ReorderBufferTXN,
        prepare_lsn: XLogRecPtr,
    );
    pub fn logicalrep_read_prepare(in_: StringInfo, prepare_data: *mut LogicalRepPreparedTxnData);
    pub fn logicalrep_write_commit_prepared(
        out: StringInfo,
        txn: *mut ReorderBufferTXN,
        commit_lsn: XLogRecPtr,
    );
    pub fn logicalrep_read_commit_prepared(
        in_: StringInfo,
        prepare_data: *mut LogicalRepCommitPreparedTxnData,
    );
    pub fn logicalrep_write_rollback_prepared(
        out: StringInfo,
        txn: *mut ReorderBufferTXN,
        prepare_end_lsn: XLogRecPtr,
        prepare_time: TimestampTz,
    );
    pub fn logicalrep_read_rollback_prepared(
        in_: StringInfo,
        rollback_data: *mut LogicalRepRollbackPreparedTxnData,
    );
    pub fn logicalrep_write_stream_prepare(
        out: StringInfo,
        txn: *mut ReorderBufferTXN,
        prepare_lsn: XLogRecPtr,
    );
    pub fn logicalrep_read_stream_prepare(
        in_: StringInfo,
        prepare_data: *mut LogicalRepPreparedTxnData,
    );
    pub fn logicalrep_write_origin(
        out: StringInfo,
        origin: *const ::std::os::raw::c_char,
        origin_lsn: XLogRecPtr,
    );
    pub fn logicalrep_read_origin(
        in_: StringInfo,
        origin_lsn: *mut XLogRecPtr,
    ) -> *mut ::std::os::raw::c_char;
    pub fn logicalrep_write_insert(
        out: StringInfo,
        xid: TransactionId,
        rel: Relation,
        newslot: *mut TupleTableSlot,
        binary: bool,
        columns: *mut Bitmapset,
    );
    pub fn logicalrep_read_insert(
        in_: StringInfo,
        newtup: *mut LogicalRepTupleData,
    ) -> LogicalRepRelId;
    pub fn logicalrep_write_update(
        out: StringInfo,
        xid: TransactionId,
        rel: Relation,
        oldslot: *mut TupleTableSlot,
        newslot: *mut TupleTableSlot,
        binary: bool,
        columns: *mut Bitmapset,
    );
    pub fn logicalrep_read_update(
        in_: StringInfo,
        has_oldtuple: *mut bool,
        oldtup: *mut LogicalRepTupleData,
        newtup: *mut LogicalRepTupleData,
    ) -> LogicalRepRelId;
    pub fn logicalrep_write_delete(
        out: StringInfo,
        xid: TransactionId,
        rel: Relation,
        oldslot: *mut TupleTableSlot,
        binary: bool,
        columns: *mut Bitmapset,
    );
    pub fn logicalrep_read_delete(
        in_: StringInfo,
        oldtup: *mut LogicalRepTupleData,
    ) -> LogicalRepRelId;
    pub fn logicalrep_write_truncate(
        out: StringInfo,
        xid: TransactionId,
        nrelids: ::std::os::raw::c_int,
        relids: *mut Oid,
        cascade: bool,
        restart_seqs: bool,
    );
    pub fn logicalrep_read_truncate(
        in_: StringInfo,
        cascade: *mut bool,
        restart_seqs: *mut bool,
    ) -> *mut List;
    pub fn logicalrep_write_message(
        out: StringInfo,
        xid: TransactionId,
        lsn: XLogRecPtr,
        transactional: bool,
        prefix: *const ::std::os::raw::c_char,
        sz: Size,
        message: *const ::std::os::raw::c_char,
    );
    pub fn logicalrep_write_rel(
        out: StringInfo,
        xid: TransactionId,
        rel: Relation,
        columns: *mut Bitmapset,
    );
    pub fn logicalrep_read_rel(in_: StringInfo) -> *mut LogicalRepRelation;
    pub fn logicalrep_write_typ(out: StringInfo, xid: TransactionId, typoid: Oid);
    pub fn logicalrep_read_typ(in_: StringInfo, ltyp: *mut LogicalRepTyp);
    pub fn logicalrep_write_stream_start(out: StringInfo, xid: TransactionId, first_segment: bool);
    pub fn logicalrep_read_stream_start(in_: StringInfo, first_segment: *mut bool)
        -> TransactionId;
    pub fn logicalrep_write_stream_stop(out: StringInfo);
    pub fn logicalrep_write_stream_commit(
        out: StringInfo,
        txn: *mut ReorderBufferTXN,
        commit_lsn: XLogRecPtr,
    );
    pub fn logicalrep_read_stream_commit(
        in_: StringInfo,
        commit_data: *mut LogicalRepCommitData,
    ) -> TransactionId;
    pub fn logicalrep_write_stream_abort(
        out: StringInfo,
        xid: TransactionId,
        subxid: TransactionId,
        abort_lsn: XLogRecPtr,
        abort_time: TimestampTz,
        write_abort_info: bool,
    );
    pub fn logicalrep_read_stream_abort(
        in_: StringInfo,
        abort_data: *mut LogicalRepStreamAbortData,
        read_abort_info: bool,
    );
    pub fn logicalrep_message_type(action: LogicalRepMsgType) -> *const ::std::os::raw::c_char;
    pub fn InitWalSender();
    pub fn exec_replication_command(cmd_string: *const ::std::os::raw::c_char) -> bool;
    pub fn WalSndErrorCleanup();
    pub fn WalSndResourceCleanup(isCommit: bool);
    pub fn WalSndSignals();
    pub fn WalSndShmemSize() -> Size;
    pub fn WalSndShmemInit();
    pub fn WalSndWakeup(physical: bool, logical: bool);
    pub fn WalSndInitStopping();
    pub fn WalSndWaitStopping();
    pub fn HandleWalSndInitStopping();
    pub fn WalSndRqstFileReload();
    pub fn WalReceiverMain() -> !;
    pub fn ProcessWalRcvInterrupts();
    pub fn WalRcvForceReply();
    pub fn WalRcvShmemSize() -> Size;
    pub fn WalRcvShmemInit();
    pub fn ShutdownWalRcv();
    pub fn WalRcvStreaming() -> bool;
    pub fn WalRcvRunning() -> bool;
    pub fn RequestXLogStreaming(
        tli: TimeLineID,
        recptr: XLogRecPtr,
        conninfo: *const ::std::os::raw::c_char,
        slotname: *const ::std::os::raw::c_char,
        create_temp_slot: bool,
    );
    pub fn GetWalRcvFlushRecPtr(
        latestChunkStart: *mut XLogRecPtr,
        receiveTLI: *mut TimeLineID,
    ) -> XLogRecPtr;
    pub fn GetWalRcvWriteRecPtr() -> XLogRecPtr;
    pub fn GetReplicationApplyDelay() -> ::std::os::raw::c_int;
    pub fn GetReplicationTransferLatency() -> ::std::os::raw::c_int;
    pub fn ReplicationSlotsShmemSize() -> Size;
    pub fn ReplicationSlotsShmemInit();
    pub fn ReplicationSlotCreate(
        name: *const ::std::os::raw::c_char,
        db_specific: bool,
        persistency: ReplicationSlotPersistency,
        two_phase: bool,
    );
    pub fn ReplicationSlotPersist();
    pub fn ReplicationSlotDrop(name: *const ::std::os::raw::c_char, nowait: bool);
    pub fn ReplicationSlotAcquire(name: *const ::std::os::raw::c_char, nowait: bool);
    pub fn ReplicationSlotRelease();
    pub fn ReplicationSlotCleanup();
    pub fn ReplicationSlotSave();
    pub fn ReplicationSlotMarkDirty();
    pub fn ReplicationSlotInitialize();
    pub fn ReplicationSlotValidateName(
        name: *const ::std::os::raw::c_char,
        elevel: ::std::os::raw::c_int,
    ) -> bool;
    pub fn ReplicationSlotReserveWal();
    pub fn ReplicationSlotsComputeRequiredXmin(already_locked: bool);
    pub fn ReplicationSlotsComputeRequiredLSN();
    pub fn ReplicationSlotsComputeLogicalRestartLSN() -> XLogRecPtr;
    pub fn ReplicationSlotsCountDBSlots(
        dboid: Oid,
        nslots: *mut ::std::os::raw::c_int,
        nactive: *mut ::std::os::raw::c_int,
    ) -> bool;
    pub fn ReplicationSlotsDropDBSlots(dboid: Oid);
    pub fn InvalidateObsoleteReplicationSlots(
        cause: ReplicationSlotInvalidationCause,
        oldestSegno: XLogSegNo,
        dboid: Oid,
        snapshotConflictHorizon: TransactionId,
    ) -> bool;
    pub fn SearchNamedReplicationSlot(
        name: *const ::std::os::raw::c_char,
        need_lock: bool,
    ) -> *mut ReplicationSlot;
    pub fn ReplicationSlotIndex(slot: *mut ReplicationSlot) -> ::std::os::raw::c_int;
    pub fn ReplicationSlotName(index: ::std::os::raw::c_int, name: Name) -> bool;
    pub fn ReplicationSlotNameForTablesync(
        suboid: Oid,
        relid: Oid,
        syncslotname: *mut ::std::os::raw::c_char,
        szslot: Size,
    );
    pub fn ReplicationSlotDropAtPubNode(
        wrconn: *mut WalReceiverConn,
        slotname: *mut ::std::os::raw::c_char,
        missing_ok: bool,
    );
    pub fn StartupReplicationSlots();
    pub fn CheckPointReplicationSlots();
    pub fn CheckSlotRequirements();
    pub fn CheckSlotPermissions();
    pub fn CheckLogicalDecodingRequirements();
    pub fn CreateInitDecodingContext(
        plugin: *const ::std::os::raw::c_char,
        output_plugin_options: *mut List,
        need_full_snapshot: bool,
        restart_lsn: XLogRecPtr,
        xl_routine: *mut XLogReaderRoutine,
        prepare_write: LogicalOutputPluginWriterPrepareWrite,
        do_write: LogicalOutputPluginWriterWrite,
        update_progress: LogicalOutputPluginWriterUpdateProgress,
    ) -> *mut LogicalDecodingContext;
    pub fn CreateDecodingContext(
        start_lsn: XLogRecPtr,
        output_plugin_options: *mut List,
        fast_forward: bool,
        xl_routine: *mut XLogReaderRoutine,
        prepare_write: LogicalOutputPluginWriterPrepareWrite,
        do_write: LogicalOutputPluginWriterWrite,
        update_progress: LogicalOutputPluginWriterUpdateProgress,
    ) -> *mut LogicalDecodingContext;
    pub fn DecodingContextFindStartpoint(ctx: *mut LogicalDecodingContext);
    pub fn DecodingContextReady(ctx: *mut LogicalDecodingContext) -> bool;
    pub fn FreeDecodingContext(ctx: *mut LogicalDecodingContext);
    pub fn LogicalIncreaseXminForSlot(current_lsn: XLogRecPtr, xmin: TransactionId);
    pub fn LogicalIncreaseRestartDecodingForSlot(current_lsn: XLogRecPtr, restart_lsn: XLogRecPtr);
    pub fn LogicalConfirmReceivedLocation(lsn: XLogRecPtr);
    pub fn filter_prepare_cb_wrapper(
        ctx: *mut LogicalDecodingContext,
        xid: TransactionId,
        gid: *const ::std::os::raw::c_char,
    ) -> bool;
    pub fn filter_by_origin_cb_wrapper(
        ctx: *mut LogicalDecodingContext,
        origin_id: RepOriginId,
    ) -> bool;
    pub fn ResetLogicalStreamingState();
    pub fn UpdateDecodingStats(ctx: *mut LogicalDecodingContext);
    pub fn QueryRewrite(parsetree: *mut Query) -> *mut List;
    pub fn AcquireRewriteLocks(parsetree: *mut Query, forExecute: bool, forUpdatePushedDown: bool);
    pub fn build_column_default(rel: Relation, attrno: ::std::os::raw::c_int) -> *mut Node;
    pub fn get_view_query(view: Relation) -> *mut Query;
    pub fn view_query_is_auto_updatable(
        viewquery: *mut Query,
        check_cols: bool,
    ) -> *const ::std::os::raw::c_char;
    pub fn relation_is_updatable(
        reloid: Oid,
        outer_reloids: *mut List,
        include_triggers: bool,
        include_cols: *mut Bitmapset,
    ) -> ::std::os::raw::c_int;
    pub fn get_row_security_policies(
        root: *mut Query,
        rte: *mut RangeTblEntry,
        rt_index: ::std::os::raw::c_int,
        securityQuals: *mut *mut List,
        withCheckOptions: *mut *mut List,
        hasRowSecurity: *mut bool,
        hasSubLinks: *mut bool,
    );
    pub fn SnapMgrShmemSize() -> Size;
    pub fn SnapMgrInit();
    pub fn GetSnapshotCurrentTimestamp() -> TimestampTz;
    pub fn GetOldSnapshotThresholdTimestamp() -> TimestampTz;
    pub fn SnapshotTooOldMagicForTest();
    pub fn GetTransactionSnapshot() -> Snapshot;
    pub fn GetLatestSnapshot() -> Snapshot;
    pub fn SnapshotSetCommandId(curcid: CommandId);
    pub fn GetOldestSnapshot() -> Snapshot;
    pub fn GetCatalogSnapshot(relid: Oid) -> Snapshot;
    pub fn GetNonHistoricCatalogSnapshot(relid: Oid) -> Snapshot;
    pub fn InvalidateCatalogSnapshot();
    pub fn InvalidateCatalogSnapshotConditionally();
    pub fn PushActiveSnapshot(snapshot: Snapshot);
    pub fn PushActiveSnapshotWithLevel(snapshot: Snapshot, snap_level: ::std::os::raw::c_int);
    pub fn PushCopiedSnapshot(snapshot: Snapshot);
    pub fn UpdateActiveSnapshotCommandId();
    pub fn PopActiveSnapshot();
    pub fn GetActiveSnapshot() -> Snapshot;
    pub fn ActiveSnapshotSet() -> bool;
    pub fn RegisterSnapshot(snapshot: Snapshot) -> Snapshot;
    pub fn UnregisterSnapshot(snapshot: Snapshot);
    pub fn RegisterSnapshotOnOwner(snapshot: Snapshot, owner: ResourceOwner) -> Snapshot;
    pub fn UnregisterSnapshotFromOwner(snapshot: Snapshot, owner: ResourceOwner);
    pub fn AtSubCommit_Snapshot(level: ::std::os::raw::c_int);
    pub fn AtSubAbort_Snapshot(level: ::std::os::raw::c_int);
    pub fn AtEOXact_Snapshot(isCommit: bool, resetXmin: bool);
    pub fn ImportSnapshot(idstr: *const ::std::os::raw::c_char);
    pub fn XactHasExportedSnapshots() -> bool;
    pub fn DeleteAllExportedSnapshotFiles();
    pub fn WaitForOlderSnapshots(limitXmin: TransactionId, progress: bool);
    pub fn ThereAreNoPriorRegisteredSnapshots() -> bool;
    pub fn HaveRegisteredOrActiveSnapshot() -> bool;
    pub fn TransactionIdLimitedForOldSnapshots(
        recentXmin: TransactionId,
        relation: Relation,
        limit_xid: *mut TransactionId,
        limit_ts: *mut TimestampTz,
    ) -> bool;
    pub fn SetOldSnapshotThresholdTimestamp(ts: TimestampTz, xlimit: TransactionId);
    pub fn MaintainOldSnapshotTimeMapping(whenTaken: TimestampTz, xmin: TransactionId);
    pub fn ExportSnapshot(snapshot: Snapshot) -> *mut ::std::os::raw::c_char;
    pub fn GlobalVisTestFor(rel: Relation) -> *mut GlobalVisState;
    pub fn GlobalVisTestIsRemovableXid(state: *mut GlobalVisState, xid: TransactionId) -> bool;
    pub fn GlobalVisTestIsRemovableFullXid(
        state: *mut GlobalVisState,
        fxid: FullTransactionId,
    ) -> bool;
    pub fn GlobalVisTestNonRemovableFullHorizon(state: *mut GlobalVisState) -> FullTransactionId;
    pub fn GlobalVisTestNonRemovableHorizon(state: *mut GlobalVisState) -> TransactionId;
    pub fn GlobalVisCheckRemovableXid(rel: Relation, xid: TransactionId) -> bool;
    pub fn GlobalVisCheckRemovableFullXid(rel: Relation, fxid: FullTransactionId) -> bool;
    pub fn XidInMVCCSnapshot(xid: TransactionId, snapshot: Snapshot) -> bool;
    pub fn HistoricSnapshotGetTupleCids() -> *mut HTAB;
    pub fn SetupHistoricSnapshot(historic_snapshot: Snapshot, tuplecids: *mut HTAB);
    pub fn TeardownHistoricSnapshot(is_error: bool);
    pub fn HistoricSnapshotActive() -> bool;
    pub fn EstimateSnapshotSpace(snapshot: Snapshot) -> Size;
    pub fn SerializeSnapshot(snapshot: Snapshot, start_address: *mut ::std::os::raw::c_char);
    pub fn RestoreSnapshot(start_address: *mut ::std::os::raw::c_char) -> Snapshot;
    pub fn RestoreTransactionSnapshot(
        snapshot: Snapshot,
        source_pgproc: *mut ::std::os::raw::c_void,
    );
    pub fn PrefetchSharedBuffer(
        smgr_reln: *mut SMgrRelationData,
        forkNum: ForkNumber,
        blockNum: BlockNumber,
    ) -> PrefetchBufferResult;
    pub fn PrefetchBuffer(
        reln: Relation,
        forkNum: ForkNumber,
        blockNum: BlockNumber,
    ) -> PrefetchBufferResult;
    pub fn ReadRecentBuffer(
        rlocator: RelFileLocator,
        forkNum: ForkNumber,
        blockNum: BlockNumber,
        recent_buffer: Buffer,
    ) -> bool;
    pub fn ReadBuffer(reln: Relation, blockNum: BlockNumber) -> Buffer;
    pub fn ReadBufferExtended(
        reln: Relation,
        forkNum: ForkNumber,
        blockNum: BlockNumber,
        mode: ReadBufferMode,
        strategy: BufferAccessStrategy,
    ) -> Buffer;
    pub fn ReadBufferWithoutRelcache(
        rlocator: RelFileLocator,
        forkNum: ForkNumber,
        blockNum: BlockNumber,
        mode: ReadBufferMode,
        strategy: BufferAccessStrategy,
        permanent: bool,
    ) -> Buffer;
    pub fn ReleaseBuffer(buffer: Buffer);
    pub fn UnlockReleaseBuffer(buffer: Buffer);
    pub fn MarkBufferDirty(buffer: Buffer);
    pub fn IncrBufferRefCount(buffer: Buffer);
    pub fn CheckBufferIsPinnedOnce(buffer: Buffer);
    pub fn ReleaseAndReadBuffer(
        buffer: Buffer,
        relation: Relation,
        blockNum: BlockNumber,
    ) -> Buffer;
    pub fn ExtendBufferedRel(
        bmr: BufferManagerRelation,
        forkNum: ForkNumber,
        strategy: BufferAccessStrategy,
        flags: uint32,
    ) -> Buffer;
    pub fn ExtendBufferedRelBy(
        bmr: BufferManagerRelation,
        fork: ForkNumber,
        strategy: BufferAccessStrategy,
        flags: uint32,
        extend_by: uint32,
        buffers: *mut Buffer,
        extended_by: *mut uint32,
    ) -> BlockNumber;
    pub fn ExtendBufferedRelTo(
        bmr: BufferManagerRelation,
        fork: ForkNumber,
        strategy: BufferAccessStrategy,
        flags: uint32,
        extend_to: BlockNumber,
        mode: ReadBufferMode,
    ) -> Buffer;
    pub fn InitBufferPoolAccess();
    pub fn AtEOXact_Buffers(isCommit: bool);
    pub fn PrintBufferLeakWarning(buffer: Buffer);
    pub fn CheckPointBuffers(flags: ::std::os::raw::c_int);
    pub fn BufferGetBlockNumber(buffer: Buffer) -> BlockNumber;
    pub fn RelationGetNumberOfBlocksInFork(relation: Relation, forkNum: ForkNumber) -> BlockNumber;
    pub fn FlushOneBuffer(buffer: Buffer);
    pub fn FlushRelationBuffers(rel: Relation);
    pub fn FlushRelationsAllBuffers(
        smgrs: *mut *mut SMgrRelationData,
        nrels: ::std::os::raw::c_int,
    );
    pub fn CreateAndCopyRelationData(
        src_rlocator: RelFileLocator,
        dst_rlocator: RelFileLocator,
        permanent: bool,
    );
    pub fn FlushDatabaseBuffers(dbid: Oid);
    pub fn DropRelationBuffers(
        smgr_reln: *mut SMgrRelationData,
        forkNum: *mut ForkNumber,
        nforks: ::std::os::raw::c_int,
        firstDelBlock: *mut BlockNumber,
    );
    pub fn DropRelationsAllBuffers(
        smgr_reln: *mut *mut SMgrRelationData,
        nlocators: ::std::os::raw::c_int,
    );
    pub fn DropDatabaseBuffers(dbid: Oid);
    pub fn BufferIsPermanent(buffer: Buffer) -> bool;
    pub fn BufferGetLSNAtomic(buffer: Buffer) -> XLogRecPtr;
    pub fn BufferGetTag(
        buffer: Buffer,
        rlocator: *mut RelFileLocator,
        forknum: *mut ForkNumber,
        blknum: *mut BlockNumber,
    );
    pub fn MarkBufferDirtyHint(buffer: Buffer, buffer_std: bool);
    pub fn UnlockBuffers();
    pub fn LockBuffer(buffer: Buffer, mode: ::std::os::raw::c_int);
    pub fn ConditionalLockBuffer(buffer: Buffer) -> bool;
    pub fn LockBufferForCleanup(buffer: Buffer);
    pub fn ConditionalLockBufferForCleanup(buffer: Buffer) -> bool;
    pub fn IsBufferCleanupOK(buffer: Buffer) -> bool;
    pub fn HoldingBufferPinThatDelaysRecovery() -> bool;
    pub fn AbortBufferIO(buffer: Buffer);
    pub fn BgBufferSync(wb_context: *mut WritebackContext) -> bool;
    pub fn TestForOldSnapshot_impl(snapshot: Snapshot, relation: Relation);
    pub fn InitBufferPool();
    pub fn BufferShmemSize() -> Size;
    pub fn AtProcExit_LocalBuffers();
    pub fn GetAccessStrategy(btype: BufferAccessStrategyType) -> BufferAccessStrategy;
    pub fn GetAccessStrategyWithSize(
        btype: BufferAccessStrategyType,
        ring_size_kb: ::std::os::raw::c_int,
    ) -> BufferAccessStrategy;
    pub fn GetAccessStrategyBufferCount(strategy: BufferAccessStrategy) -> ::std::os::raw::c_int;
    pub fn FreeAccessStrategy(strategy: BufferAccessStrategy);
    pub fn BufFileCreateTemp(interXact: bool) -> *mut BufFile;
    pub fn BufFileClose(file: *mut BufFile);
    pub fn BufFileRead(file: *mut BufFile, ptr: *mut ::std::os::raw::c_void, size: usize) -> usize;
    pub fn BufFileReadExact(file: *mut BufFile, ptr: *mut ::std::os::raw::c_void, size: usize);
    pub fn BufFileReadMaybeEOF(
        file: *mut BufFile,
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        eofOK: bool,
    ) -> usize;
    pub fn BufFileWrite(file: *mut BufFile, ptr: *const ::std::os::raw::c_void, size: usize);
    pub fn BufFileSeek(
        file: *mut BufFile,
        fileno: ::std::os::raw::c_int,
        offset: off_t,
        whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn BufFileTell(file: *mut BufFile, fileno: *mut ::std::os::raw::c_int, offset: *mut off_t);
    pub fn BufFileSeekBlock(
        file: *mut BufFile,
        blknum: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
    pub fn BufFileSize(file: *mut BufFile) -> int64;
    pub fn BufFileAppend(target: *mut BufFile, source: *mut BufFile) -> ::std::os::raw::c_long;
    pub fn BufFileCreateFileSet(
        fileset: *mut FileSet,
        name: *const ::std::os::raw::c_char,
    ) -> *mut BufFile;
    pub fn BufFileExportFileSet(file: *mut BufFile);
    pub fn BufFileOpenFileSet(
        fileset: *mut FileSet,
        name: *const ::std::os::raw::c_char,
        mode: ::std::os::raw::c_int,
        missing_ok: bool,
    ) -> *mut BufFile;
    pub fn BufFileDeleteFileSet(
        fileset: *mut FileSet,
        name: *const ::std::os::raw::c_char,
        missing_ok: bool,
    );
    pub fn BufFileTruncateFileSet(file: *mut BufFile, fileno: ::std::os::raw::c_int, offset: off_t);
    pub fn proc_exit(code: ::std::os::raw::c_int) -> !;
    pub fn shmem_exit(code: ::std::os::raw::c_int);
    pub fn on_proc_exit(function: pg_on_exit_callback, arg: Datum);
    pub fn on_shmem_exit(function: pg_on_exit_callback, arg: Datum);
    pub fn before_shmem_exit(function: pg_on_exit_callback, arg: Datum);
    pub fn cancel_before_shmem_exit(function: pg_on_exit_callback, arg: Datum);
    pub fn on_exit_reset();
    pub fn check_on_shmem_exit_lists_are_empty();
    pub fn CalculateShmemSize(num_semaphores: *mut ::std::os::raw::c_int) -> Size;
    pub fn CreateSharedMemoryAndSemaphores();
    pub fn InitializeShmemGUCs();
    pub fn RelationInitLockInfo(relation: Relation);
    pub fn LockRelationOid(relid: Oid, lockmode: LOCKMODE);
    pub fn LockRelationId(relid: *mut LockRelId, lockmode: LOCKMODE);
    pub fn ConditionalLockRelationOid(relid: Oid, lockmode: LOCKMODE) -> bool;
    pub fn UnlockRelationId(relid: *mut LockRelId, lockmode: LOCKMODE);
    pub fn UnlockRelationOid(relid: Oid, lockmode: LOCKMODE);
    pub fn LockRelation(relation: Relation, lockmode: LOCKMODE);
    pub fn ConditionalLockRelation(relation: Relation, lockmode: LOCKMODE) -> bool;
    pub fn UnlockRelation(relation: Relation, lockmode: LOCKMODE);
    pub fn CheckRelationLockedByMe(
        relation: Relation,
        lockmode: LOCKMODE,
        orstronger: bool,
    ) -> bool;
    pub fn LockHasWaitersRelation(relation: Relation, lockmode: LOCKMODE) -> bool;
    pub fn LockRelationIdForSession(relid: *mut LockRelId, lockmode: LOCKMODE);
    pub fn UnlockRelationIdForSession(relid: *mut LockRelId, lockmode: LOCKMODE);
    pub fn LockRelationForExtension(relation: Relation, lockmode: LOCKMODE);
    pub fn UnlockRelationForExtension(relation: Relation, lockmode: LOCKMODE);
    pub fn ConditionalLockRelationForExtension(relation: Relation, lockmode: LOCKMODE) -> bool;
    pub fn RelationExtensionLockWaiterCount(relation: Relation) -> ::std::os::raw::c_int;
    pub fn LockDatabaseFrozenIds(lockmode: LOCKMODE);
    pub fn LockPage(relation: Relation, blkno: BlockNumber, lockmode: LOCKMODE);
    pub fn ConditionalLockPage(relation: Relation, blkno: BlockNumber, lockmode: LOCKMODE) -> bool;
    pub fn UnlockPage(relation: Relation, blkno: BlockNumber, lockmode: LOCKMODE);
    pub fn LockTuple(relation: Relation, tid: ItemPointer, lockmode: LOCKMODE);
    pub fn ConditionalLockTuple(relation: Relation, tid: ItemPointer, lockmode: LOCKMODE) -> bool;
    pub fn UnlockTuple(relation: Relation, tid: ItemPointer, lockmode: LOCKMODE);
    pub fn XactLockTableInsert(xid: TransactionId);
    pub fn XactLockTableDelete(xid: TransactionId);
    pub fn XactLockTableWait(xid: TransactionId, rel: Relation, ctid: ItemPointer, oper: XLTW_Oper);
    pub fn ConditionalXactLockTableWait(xid: TransactionId) -> bool;
    pub fn WaitForLockers(heaplocktag: LOCKTAG, lockmode: LOCKMODE, progress: bool);
    pub fn WaitForLockersMultiple(locktags: *mut List, lockmode: LOCKMODE, progress: bool);
    pub fn SpeculativeInsertionLockAcquire(xid: TransactionId) -> uint32;
    pub fn SpeculativeInsertionLockRelease(xid: TransactionId);
    pub fn SpeculativeInsertionWait(xid: TransactionId, token: uint32);
    pub fn LockDatabaseObject(classid: Oid, objid: Oid, objsubid: uint16, lockmode: LOCKMODE);
    pub fn UnlockDatabaseObject(classid: Oid, objid: Oid, objsubid: uint16, lockmode: LOCKMODE);
    pub fn LockSharedObject(classid: Oid, objid: Oid, objsubid: uint16, lockmode: LOCKMODE);
    pub fn UnlockSharedObject(classid: Oid, objid: Oid, objsubid: uint16, lockmode: LOCKMODE);
    pub fn LockSharedObjectForSession(
        classid: Oid,
        objid: Oid,
        objsubid: uint16,
        lockmode: LOCKMODE,
    );
    pub fn UnlockSharedObjectForSession(
        classid: Oid,
        objid: Oid,
        objsubid: uint16,
        lockmode: LOCKMODE,
    );
    pub fn LockApplyTransactionForSession(
        suboid: Oid,
        xid: TransactionId,
        objid: uint16,
        lockmode: LOCKMODE,
    );
    pub fn UnlockApplyTransactionForSession(
        suboid: Oid,
        xid: TransactionId,
        objid: uint16,
        lockmode: LOCKMODE,
    );
    pub fn DescribeLockTag(buf: StringInfo, tag: *const LOCKTAG);
    pub fn GetLockNameFromTagType(locktag_type: uint16) -> *const ::std::os::raw::c_char;
    pub fn ProcSignalShmemSize() -> Size;
    pub fn ProcSignalShmemInit();
    pub fn ProcSignalInit(pss_idx: ::std::os::raw::c_int);
    pub fn SendProcSignal(
        pid: pid_t,
        reason: ProcSignalReason,
        backendId: BackendId,
    ) -> ::std::os::raw::c_int;
    pub fn EmitProcSignalBarrier(type_: ProcSignalBarrierType) -> uint64;
    pub fn WaitForProcSignalBarrier(generation: uint64);
    pub fn ProcessProcSignalBarrier();
    pub fn procsignal_sigusr1_handler(postgres_signal_arg: ::std::os::raw::c_int);
    pub fn standby_redo(record: *mut XLogReaderState);
    pub fn standby_desc(buf: StringInfo, record: *mut XLogReaderState);
    pub fn standby_identify(info: uint8) -> *const ::std::os::raw::c_char;
    pub fn standby_desc_invalidations(
        buf: StringInfo,
        nmsgs: ::std::os::raw::c_int,
        msgs: *mut SharedInvalidationMessage,
        dbId: Oid,
        tsId: Oid,
        relcacheInitFileInval: bool,
    );
    pub fn InitRecoveryTransactionEnvironment();
    pub fn ShutdownRecoveryTransactionEnvironment();
    pub fn ResolveRecoveryConflictWithSnapshot(
        snapshotConflictHorizon: TransactionId,
        isCatalogRel: bool,
        locator: RelFileLocator,
    );
    pub fn ResolveRecoveryConflictWithSnapshotFullXid(
        snapshotConflictHorizon: FullTransactionId,
        isCatalogRel: bool,
        locator: RelFileLocator,
    );
    pub fn ResolveRecoveryConflictWithTablespace(tsid: Oid);
    pub fn ResolveRecoveryConflictWithDatabase(dbid: Oid);
    pub fn ResolveRecoveryConflictWithLock(locktag: LOCKTAG, logging_conflict: bool);
    pub fn ResolveRecoveryConflictWithBufferPin();
    pub fn CheckRecoveryConflictDeadlock();
    pub fn StandbyDeadLockHandler();
    pub fn StandbyTimeoutHandler();
    pub fn StandbyLockTimeoutHandler();
    pub fn LogRecoveryConflict(
        reason: ProcSignalReason,
        wait_start: TimestampTz,
        now: TimestampTz,
        wait_list: *mut VirtualTransactionId,
        still_waiting: bool,
    );
    pub fn StandbyAcquireAccessExclusiveLock(xid: TransactionId, dbOid: Oid, relOid: Oid);
    pub fn StandbyReleaseLockTree(
        xid: TransactionId,
        nsubxids: ::std::os::raw::c_int,
        subxids: *mut TransactionId,
    );
    pub fn StandbyReleaseAllLocks();
    pub fn StandbyReleaseOldLocks(oldxid: TransactionId);
    pub fn LogAccessExclusiveLock(dbOid: Oid, relOid: Oid);
    pub fn LogAccessExclusiveLockPrepare();
    pub fn LogStandbySnapshot() -> XLogRecPtr;
    pub fn LogStandbyInvalidations(
        nmsgs: ::std::os::raw::c_int,
        msgs: *mut SharedInvalidationMessage,
        relcacheInitFileInval: bool,
    );
    pub fn ProcArrayShmemSize() -> Size;
    pub fn CreateSharedProcArray();
    pub fn ProcArrayAdd(proc_: *mut PGPROC);
    pub fn ProcArrayRemove(proc_: *mut PGPROC, latestXid: TransactionId);
    pub fn ProcArrayEndTransaction(proc_: *mut PGPROC, latestXid: TransactionId);
    pub fn ProcArrayClearTransaction(proc_: *mut PGPROC);
    pub fn ProcArrayInitRecovery(initializedUptoXID: TransactionId);
    pub fn ProcArrayApplyRecoveryInfo(running: RunningTransactions);
    pub fn ProcArrayApplyXidAssignment(
        topxid: TransactionId,
        nsubxids: ::std::os::raw::c_int,
        subxids: *mut TransactionId,
    );
    pub fn RecordKnownAssignedTransactionIds(xid: TransactionId);
    pub fn ExpireTreeKnownAssignedTransactionIds(
        xid: TransactionId,
        nsubxids: ::std::os::raw::c_int,
        subxids: *mut TransactionId,
        max_xid: TransactionId,
    );
    pub fn ExpireAllKnownAssignedTransactionIds();
    pub fn ExpireOldKnownAssignedTransactionIds(xid: TransactionId);
    pub fn KnownAssignedTransactionIdsIdleMaintenance();
    pub fn GetMaxSnapshotXidCount() -> ::std::os::raw::c_int;
    pub fn GetMaxSnapshotSubxidCount() -> ::std::os::raw::c_int;
    pub fn GetSnapshotData(snapshot: Snapshot) -> Snapshot;
    pub fn ProcArrayInstallImportedXmin(
        xmin: TransactionId,
        sourcevxid: *mut VirtualTransactionId,
    ) -> bool;
    pub fn ProcArrayInstallRestoredXmin(xmin: TransactionId, proc_: *mut PGPROC) -> bool;
    pub fn GetRunningTransactionData() -> RunningTransactions;
    pub fn TransactionIdIsInProgress(xid: TransactionId) -> bool;
    pub fn TransactionIdIsActive(xid: TransactionId) -> bool;
    pub fn GetOldestNonRemovableTransactionId(rel: Relation) -> TransactionId;
    pub fn GetOldestTransactionIdConsideredRunning() -> TransactionId;
    pub fn GetOldestActiveTransactionId() -> TransactionId;
    pub fn GetOldestSafeDecodingTransactionId(catalogOnly: bool) -> TransactionId;
    pub fn GetReplicationHorizons(xmin: *mut TransactionId, catalog_xmin: *mut TransactionId);
    pub fn GetVirtualXIDsDelayingChkpt(
        nvxids: *mut ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> *mut VirtualTransactionId;
    pub fn HaveVirtualXIDsDelayingChkpt(
        vxids: *mut VirtualTransactionId,
        nvxids: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> bool;
    pub fn BackendPidGetProc(pid: ::std::os::raw::c_int) -> *mut PGPROC;
    pub fn BackendPidGetProcWithLock(pid: ::std::os::raw::c_int) -> *mut PGPROC;
    pub fn BackendXidGetPid(xid: TransactionId) -> ::std::os::raw::c_int;
    pub fn IsBackendPid(pid: ::std::os::raw::c_int) -> bool;
    pub fn GetCurrentVirtualXIDs(
        limitXmin: TransactionId,
        excludeXmin0: bool,
        allDbs: bool,
        excludeVacuum: ::std::os::raw::c_int,
        nvxids: *mut ::std::os::raw::c_int,
    ) -> *mut VirtualTransactionId;
    pub fn GetConflictingVirtualXIDs(
        limitXmin: TransactionId,
        dbOid: Oid,
    ) -> *mut VirtualTransactionId;
    pub fn CancelVirtualTransaction(vxid: VirtualTransactionId, sigmode: ProcSignalReason)
        -> pid_t;
    pub fn SignalVirtualTransaction(
        vxid: VirtualTransactionId,
        sigmode: ProcSignalReason,
        conflictPending: bool,
    ) -> pid_t;
    pub fn MinimumActiveBackends(min: ::std::os::raw::c_int) -> bool;
    pub fn CountDBBackends(databaseid: Oid) -> ::std::os::raw::c_int;
    pub fn CountDBConnections(databaseid: Oid) -> ::std::os::raw::c_int;
    pub fn CancelDBBackends(databaseid: Oid, sigmode: ProcSignalReason, conflictPending: bool);
    pub fn CountUserBackends(roleid: Oid) -> ::std::os::raw::c_int;
    pub fn CountOtherDBBackends(
        databaseId: Oid,
        nbackends: *mut ::std::os::raw::c_int,
        nprepared: *mut ::std::os::raw::c_int,
    ) -> bool;
    pub fn TerminateOtherDBBackends(databaseId: Oid);
    pub fn XidCacheRemoveRunningXids(
        xid: TransactionId,
        nxids: ::std::os::raw::c_int,
        xids: *const TransactionId,
        latestXid: TransactionId,
    );
    pub fn ProcArraySetReplicationSlotXmin(
        xmin: TransactionId,
        catalog_xmin: TransactionId,
        already_locked: bool,
    );
    pub fn ProcArrayGetReplicationSlotXmin(
        xmin: *mut TransactionId,
        catalog_xmin: *mut TransactionId,
    );
    pub fn pg_parse_query(query_string: *const ::std::os::raw::c_char) -> *mut List;
    pub fn pg_rewrite_query(query: *mut Query) -> *mut List;
    pub fn pg_analyze_and_rewrite_fixedparams(
        parsetree: *mut RawStmt,
        query_string: *const ::std::os::raw::c_char,
        paramTypes: *const Oid,
        numParams: ::std::os::raw::c_int,
        queryEnv: *mut QueryEnvironment,
    ) -> *mut List;
    pub fn pg_analyze_and_rewrite_varparams(
        parsetree: *mut RawStmt,
        query_string: *const ::std::os::raw::c_char,
        paramTypes: *mut *mut Oid,
        numParams: *mut ::std::os::raw::c_int,
        queryEnv: *mut QueryEnvironment,
    ) -> *mut List;
    pub fn pg_analyze_and_rewrite_withcb(
        parsetree: *mut RawStmt,
        query_string: *const ::std::os::raw::c_char,
        parserSetup: ParserSetupHook,
        parserSetupArg: *mut ::std::os::raw::c_void,
        queryEnv: *mut QueryEnvironment,
    ) -> *mut List;
    pub fn pg_plan_query(
        querytree: *mut Query,
        query_string: *const ::std::os::raw::c_char,
        cursorOptions: ::std::os::raw::c_int,
        boundParams: ParamListInfo,
    ) -> *mut PlannedStmt;
    pub fn pg_plan_queries(
        querytrees: *mut List,
        query_string: *const ::std::os::raw::c_char,
        cursorOptions: ::std::os::raw::c_int,
        boundParams: ParamListInfo,
    ) -> *mut List;
    pub fn die(postgres_signal_arg: ::std::os::raw::c_int);
    pub fn quickdie(postgres_signal_arg: ::std::os::raw::c_int) -> !;
    pub fn StatementCancelHandler(postgres_signal_arg: ::std::os::raw::c_int);
    pub fn FloatExceptionHandler(postgres_signal_arg: ::std::os::raw::c_int) -> !;
    pub fn RecoveryConflictInterrupt(reason: ProcSignalReason);
    pub fn ProcessClientReadInterrupt(blocked: bool);
    pub fn ProcessClientWriteInterrupt(blocked: bool);
    pub fn process_postgres_switches(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
        ctx: GucContext,
        dbname: *mut *const ::std::os::raw::c_char,
    );
    pub fn PostgresSingleUserMain(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
        username: *const ::std::os::raw::c_char,
    ) -> !;
    pub fn PostgresMain(
        dbname: *const ::std::os::raw::c_char,
        username: *const ::std::os::raw::c_char,
    ) -> !;
    pub fn get_stack_depth_rlimit() -> ::std::os::raw::c_long;
    pub fn ResetUsage();
    pub fn ShowUsage(title: *const ::std::os::raw::c_char);
    pub fn check_log_duration(
        msec_str: *mut ::std::os::raw::c_char,
        was_logged: bool,
    ) -> ::std::os::raw::c_int;
    pub fn set_debug_options(
        debug_flag: ::std::os::raw::c_int,
        context: GucContext,
        source: GucSource,
    );
    pub fn set_plan_disabling_options(
        arg: *const ::std::os::raw::c_char,
        context: GucContext,
        source: GucSource,
    ) -> bool;
    pub fn get_stats_option_name(
        arg: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
    pub fn ProcessUtility(
        pstmt: *mut PlannedStmt,
        queryString: *const ::std::os::raw::c_char,
        readOnlyTree: bool,
        context: ProcessUtilityContext,
        params: ParamListInfo,
        queryEnv: *mut QueryEnvironment,
        dest: *mut DestReceiver,
        qc: *mut QueryCompletion,
    );
    pub fn standard_ProcessUtility(
        pstmt: *mut PlannedStmt,
        queryString: *const ::std::os::raw::c_char,
        readOnlyTree: bool,
        context: ProcessUtilityContext,
        params: ParamListInfo,
        queryEnv: *mut QueryEnvironment,
        dest: *mut DestReceiver,
        qc: *mut QueryCompletion,
    );
    pub fn ProcessUtilityForAlterTable(stmt: *mut Node, context: *mut AlterTableUtilityContext);
    pub fn UtilityReturnsTuples(parsetree: *mut Node) -> bool;
    pub fn UtilityTupleDescriptor(parsetree: *mut Node) -> TupleDesc;
    pub fn UtilityContainsQuery(parsetree: *mut Node) -> *mut Query;
    pub fn CreateCommandTag(parsetree: *mut Node) -> CommandTag;
    pub fn GetCommandLogLevel(parsetree: *mut Node) -> LogStmtLevel;
    pub fn CommandIsReadOnly(pstmt: *mut PlannedStmt) -> bool;
    pub fn compareWordEntryPos(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
    pub fn get_tsearch_config_filename(
        basename: *const ::std::os::raw::c_char,
        extension: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn readstoplist(
        fname: *const ::std::os::raw::c_char,
        s: *mut StopList,
        wordop: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_char,
            ) -> *mut ::std::os::raw::c_char,
        >,
    );
    pub fn searchstoplist(s: *mut StopList, key: *mut ::std::os::raw::c_char) -> bool;
    pub fn init_tsvector_parser(
        input: *mut ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        escontext: *mut Node,
    ) -> TSVectorParseState;
    pub fn reset_tsvector_parser(state: TSVectorParseState, input: *mut ::std::os::raw::c_char);
    pub fn gettoken_tsvector(
        state: TSVectorParseState,
        strval: *mut *mut ::std::os::raw::c_char,
        lenval: *mut ::std::os::raw::c_int,
        pos_ptr: *mut *mut WordEntryPos,
        poslen: *mut ::std::os::raw::c_int,
        endptr: *mut *mut ::std::os::raw::c_char,
    ) -> bool;
    pub fn close_tsvector_parser(state: TSVectorParseState);
    pub fn parse_tsquery(
        buf: *mut ::std::os::raw::c_char,
        pushval: PushFunction,
        opaque: Datum,
        flags: ::std::os::raw::c_int,
        escontext: *mut Node,
    ) -> TSQuery;
    pub fn pushValue(
        state: TSQueryParserState,
        strval: *mut ::std::os::raw::c_char,
        lenval: ::std::os::raw::c_int,
        weight: int16,
        prefix: bool,
    );
    pub fn pushStop(state: TSQueryParserState);
    pub fn pushOperator(state: TSQueryParserState, oper: int8, distance: int16);
    pub fn parsetext(
        cfgId: Oid,
        prs: *mut ParsedText,
        buf: *mut ::std::os::raw::c_char,
        buflen: int32,
    );
    pub fn hlparsetext(
        cfgId: Oid,
        prs: *mut HeadlineParsedText,
        query: TSQuery,
        buf: *mut ::std::os::raw::c_char,
        buflen: int32,
    );
    pub fn generateHeadline(prs: *mut HeadlineParsedText) -> *mut text;
    pub fn TS_execute(
        curitem: *mut QueryItem,
        arg: *mut ::std::os::raw::c_void,
        flags: uint32,
        chkcond: TSExecuteCallback,
    ) -> bool;
    pub fn TS_execute_ternary(
        curitem: *mut QueryItem,
        arg: *mut ::std::os::raw::c_void,
        flags: uint32,
        chkcond: TSExecuteCallback,
    ) -> TSTernaryValue;
    pub fn TS_execute_locations(
        curitem: *mut QueryItem,
        arg: *mut ::std::os::raw::c_void,
        flags: uint32,
        chkcond: TSExecuteCallback,
    ) -> *mut List;
    pub fn tsquery_requires_match(curitem: *mut QueryItem) -> bool;
    pub fn make_tsvector(prs: *mut ParsedText) -> TSVector;
    pub fn tsCompareString(
        a: *mut ::std::os::raw::c_char,
        lena: ::std::os::raw::c_int,
        b: *mut ::std::os::raw::c_char,
        lenb: ::std::os::raw::c_int,
        prefix: bool,
    ) -> int32;
    pub fn clean_NOT(ptr: *mut QueryItem, len: *mut int32) -> *mut QueryItem;
    pub fn cleanup_tsquery_stopwords(in_: TSQuery, noisy: bool) -> TSQuery;
    pub fn QT2QTN(in_: *mut QueryItem, operand: *mut ::std::os::raw::c_char) -> *mut QTNode;
    pub fn QTN2QT(in_: *mut QTNode) -> TSQuery;
    pub fn QTNFree(in_: *mut QTNode);
    pub fn QTNSort(in_: *mut QTNode);
    pub fn QTNTernary(in_: *mut QTNode);
    pub fn QTNBinary(in_: *mut QTNode);
    pub fn QTNodeCompare(an: *mut QTNode, bn: *mut QTNode) -> ::std::os::raw::c_int;
    pub fn QTNCopy(in_: *mut QTNode) -> *mut QTNode;
    pub fn QTNClearFlags(in_: *mut QTNode, flags: uint32);
    pub fn QTNEq(a: *mut QTNode, b: *mut QTNode) -> bool;
    pub fn makeTSQuerySign(a: TSQuery) -> TSQuerySign;
    pub fn findsubquery(
        root: *mut QTNode,
        ex: *mut QTNode,
        subs: *mut QTNode,
        isfind: *mut bool,
    ) -> *mut QTNode;
    pub fn heap_tableam_handler(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteaout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namein(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2vectorin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2vectorout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xidin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xidout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boollt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolgt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn booleq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn chareq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texteq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xideq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cideq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn chargt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn chartoi4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i4tochar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameregexeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ddl_command_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ddl_command_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ddl_command_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pgsql_version(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ddl_command_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn eqsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn neqsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn scalarltsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn scalargtsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn eqjoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn neqjoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn scalarltjoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn scalargtjoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unknownin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unknownout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_above_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_below_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_overlap(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_above(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_left(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_right(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_below(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn on_pb(fcinfo: FunctionCallInfo) -> Datum;
    pub fn on_ppath(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_center(fcinfo: FunctionCallInfo) -> Datum;
    pub fn areasel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn areajoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2mod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4mod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int24mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int42mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oideq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_same(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_contain(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_left(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_overleft(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_overright(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_right(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_contained(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_contain_pt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_node_tree_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_node_tree_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_node_tree_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_node_tree_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4um(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4abs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4um(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2um(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8um(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8abs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_center(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_center(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dround(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtrunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dsqrt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dcbrt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dpow(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dexp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dlog1(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i2tod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i2tof(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtoi2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ftoi2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn line_distance(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameeqtext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namelttext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameletext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namegetext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namegttext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namenetext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btnametextcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texteqname(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textltname(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textlename(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textgename(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textgtname(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textnename(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bttextnamecmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameconcatoid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn table_am_handler_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn table_am_handler_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timeofday(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_nextoid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_combine(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inter_sl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inter_lb(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float48ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float84ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ftod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtof(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i2toi4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i4toi2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_jit_available(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i4tod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtoi4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i4tof(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ftoi4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn width_bucket_float8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn index_am_handler_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn index_am_handler_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashmacaddr8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hash_aclitem(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bthandler(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashhandler(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gisthandler(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ginhandler(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spghandler(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brinhandler(fcinfo: FunctionCallInfo) -> Datum;
    pub fn scalarlesel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn scalargesel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn amvalidate(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_same(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_contain(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_left(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_overleft(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_overright(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_right(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_contained(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_overlap(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint2cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint4cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat4cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat8cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btoidcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_bp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btcharcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btnamecmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bttextcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_distance(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_interpt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_ps(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_pb(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_sb(fcinfo: FunctionCallInfo) -> Datum;
    pub fn close_ps(fcinfo: FunctionCallInfo) -> Datum;
    pub fn close_pb(fcinfo: FunctionCallInfo) -> Datum;
    pub fn close_sb(fcinfo: FunctionCallInfo) -> Datum;
    pub fn on_ps(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_distance(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_ppath(fcinfo: FunctionCallInfo) -> Datum;
    pub fn on_sb(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inter_sb(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_to_array_null(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_append(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_prepend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_sp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_bs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btarraycmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_cat(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_to_text_null(fcinfo: FunctionCallInfo) -> Datum;
    pub fn scalarlejoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_to_array(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_to_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn scalargejoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashmacaddr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashtext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn rtrim1(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btoidvectorcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn name_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn name_bpchar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_pathp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashinet(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashint4extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hash_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_num_nulls(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_num_nonnulls(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashint2extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashint8extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashfloat4extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashfloat8extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashoidextended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashcharextended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashnameextended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashtextextended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashint2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashint4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashfloat4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashfloat8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashoid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashchar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashname(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashvarlena(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashoidvector(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8um(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int84eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int84ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int84lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int84gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int84le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int84ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int84(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int48(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i8tod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtoi8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_abbrev(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_abbrev(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_set_masklen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hash_array(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_set_masklen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_indexam_has_property(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_index_has_property(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_index_column_has_property(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i8tof(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ftoi8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namelt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namele(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namegt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namege(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namene(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varchar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_indexam_progress_phasename(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorlt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectoreq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorgt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_network(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_netmask(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_masklen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_broadcast(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_host(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_lp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_ls(fcinfo: FunctionCallInfo) -> Datum;
    pub fn current_user(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_family(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int82(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_create(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidlt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteaoctetlen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteaGetByte(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteaSetByte(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteaGetBit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteaSetBit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_sl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_cpoly(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_distance(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_show(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn session_user(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_dims(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_ndims(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteaoverlay(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteaoverlay_no_len(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int28(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_import(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_export(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4inc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_import_with_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashvarlenaextended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashoidvectorextended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hash_aclitem_extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashmacaddrextended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashinetextended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hash_numeric_extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashmacaddr8extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hash_array_extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_polyc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_client_encoding(fcinfo: FunctionCallInfo) -> Datum;
    pub fn current_query(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int82pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int82mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int82mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int82div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int28pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint8cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_mul_flt4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_div_flt4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn flt4_mul_cash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textpos(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textnlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int48eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int48ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int48lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int48gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int48le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int48ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namelike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namenlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn char_bpchar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn current_database(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_mul_cash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_mul_cash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_mul_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_div_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_mul_int2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_div_int2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lower(fcinfo: FunctionCallInfo) -> Datum;
    pub fn upper(fcinfo: FunctionCallInfo) -> Datum;
    pub fn initcap(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lpad(fcinfo: FunctionCallInfo) -> Datum;
    pub fn rpad(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ltrim(fcinfo: FunctionCallInfo) -> Datum;
    pub fn rtrim(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_substr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn translate(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ltrim1(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_substr_no_len(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btrim(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btrim1(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_mul_flt8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_div_flt8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cashlarger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cashsmaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn flt8_mul_cash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_sub(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_subeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_sup(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_supeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_words(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int28mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int28mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_char(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8mod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn char_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int28div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashint8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_open(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_close(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_loread(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lowrite(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_lseek(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_creat(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_tell(fcinfo: FunctionCallInfo) -> Datum;
    pub fn on_pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn on_sl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn close_pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_unlink(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashbpcharextended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_inter(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_area(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_width(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_height(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_distance(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_area(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_intersect(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_diagonal(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_n_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_n_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_n_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_n_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_n_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_length(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_vert(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_horiz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_distance(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_slope(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_construct(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_intersect(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_parallel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_perp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_vertical(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_horizontal(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_truncate(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textlike_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texticregexeq_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texticlike_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_izone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gist_point_compress(fcinfo: FunctionCallInfo) -> Datum;
    pub fn aclitemin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn aclitemout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn aclinsert(fcinfo: FunctionCallInfo) -> Datum;
    pub fn aclremove(fcinfo: FunctionCallInfo) -> Datum;
    pub fn aclcontains(fcinfo: FunctionCallInfo) -> Datum;
    pub fn getdatabaseencoding(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varcharin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varcharout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchareq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharlt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchargt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn aclitem_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_prepared_xact(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_step_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_step_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_regclass(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashbpchar(fcinfo: FunctionCallInfo) -> Datum;
    pub fn format_type(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_wal(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_wal_replay_pause_state(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_pli(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_mii(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_add_pt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_sub_pt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_mul_pt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_div_pt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_zone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_um(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_part(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_part(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_subset_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_justify_hours(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_path_exists_tz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_path_query_tz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_path_query_array_tz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xid_age(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_pl_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_mi_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_subscripts(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_subscripts_nodir(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_fill(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dlog10(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_age(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_scale(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8inc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8abs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texticregexeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texticregexne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameicregexeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameicregexne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteain(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charlt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unique_key_recheck(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4abs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameregexne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2abs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textlen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textcat(fcinfo: FunctionCallInfo) -> Datum;
    pub fn PG_char_to_encoding(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn parse_ident(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_column_size(fcinfo: FunctionCallInfo) -> Datum;
    pub fn overlaps_timetz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn datetime_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_part(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int84pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int84mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int84mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int84div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int48pl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int48mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int48mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int48div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn quote_ident(fcinfo: FunctionCallInfo) -> Datum;
    pub fn quote_literal(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_trunc_zone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_fill_with_lower_bounds(fcinfo: FunctionCallInfo) -> Datum;
    pub fn i8tooid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidtoi8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn quote_nullable(fcinfo: FunctionCallInfo) -> Datum;
    pub fn suppress_redundant_updates_trigger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tideq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_unnest(fcinfo: FunctionCallInfo) -> Datum;
    pub fn currtid_byrelname(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_justify_days(fcinfo: FunctionCallInfo) -> Datum;
    pub fn datetimetz_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn now(fcinfo: FunctionCallInfo) -> Datum;
    pub fn positionsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn positionjoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn contsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn contjoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn overlaps_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn overlaps_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharlen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectortypes(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_hostmask(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexeq_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn makeaclitem(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lock_status(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_finite(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textoctetlen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharoctetlen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_fac(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_part(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_constraintdef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_timetz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_finite(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_finite(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_backend_start(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_backend_client_addr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_backend_client_port(fcinfo: FunctionCallInfo) -> Datum;
    pub fn current_schema(fcinfo: FunctionCallInfo) -> Datum;
    pub fn current_schemas(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textoverlay(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textoverlay_no_len(fcinfo: FunctionCallInfo) -> Datum;
    pub fn line_parallel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn line_perp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn line_vertical(fcinfo: FunctionCallInfo) -> Datum;
    pub fn line_horizontal(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_center(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn points_box(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_add(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_sub(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_contain_pt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pt_contained_poly(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_isclosed(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_isopen(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_npoints(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_close(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_open(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_add(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_add_pt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_sub_pt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_mul_pt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_div_pt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn construct_point(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_add(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_sub(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_npoints(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_box(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_path(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_poly(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_poly(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_same(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_contain(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_left(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_overleft(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_overright(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_right(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_contained(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_overlap(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_below(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_above(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_area(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_diameter(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_radius(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_distance(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cr_circle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_circle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_poly(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_pc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_contain_pt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pt_contained_circle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_circle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_box(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_length(fcinfo: FunctionCallInfo) -> Datum;
    pub fn close_ls(fcinfo: FunctionCallInfo) -> Datum;
    pub fn close_lseg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn line_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn line_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn line_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn line_construct_pp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn line_interpt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn line_intersect(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bit_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bit_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_ruledef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nextval_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn currval_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn setval_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varbit_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varbit_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn biteq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitgt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitlt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn PG_encoding_to_char(fcinfo: FunctionCallInfo) -> Datum;
    pub fn drandom(fcinfo: FunctionCallInfo) -> Datum;
    pub fn setseed(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dasin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dacos(fcinfo: FunctionCallInfo) -> Datum;
    pub fn datan(fcinfo: FunctionCallInfo) -> Datum;
    pub fn datan2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dsin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dcos(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtan(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dcot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn degrees(fcinfo: FunctionCallInfo) -> Datum;
    pub fn radians(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dpi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_typeof(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ascii(fcinfo: FunctionCallInfo) -> Datum;
    pub fn chr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn repeat(fcinfo: FunctionCallInfo) -> Datum;
    pub fn similar_escape(fcinfo: FunctionCallInfo) -> Datum;
    pub fn mul_d_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texticlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texticnlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameiclike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nameicnlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn like_escape(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidgt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_viewdef_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_viewdef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_userbyid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_indexdef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_check_ins(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_check_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_cascade_del(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_cascade_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_restrict_del(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_restrict_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_setnull_del(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_setnull_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_setdefault_del(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_setdefault_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_noaction_del(fcinfo: FunctionCallInfo) -> Datum;
    pub fn RI_FKey_noaction_upd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_triggerdef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_serial_sequence(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bit_and(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bit_or(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitxor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitnot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitshiftleft(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitshiftright(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitcat(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitsubstr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitlength(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitoctetlength(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitfromint4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bittoint4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_keywords(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varbit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_hash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn aclexplode(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_mi_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btboolcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_hash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_hash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitposition(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitsubstr_no_len(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_abs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_sign(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_round(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_ceil(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_floor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn length_in_encoding(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_convert_from(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_to_cidr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_expr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_convert_to(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_add(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_sub(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_mul(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_div(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_mod(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_sqrt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_exp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_ln(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_log(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_power(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_float4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_float8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_pl_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_mi_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_pl_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_mi_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_inc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn setval3_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_to_char(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_to_char(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_uminus(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_to_char(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_to_char(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_to_char(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4_to_char(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_to_char(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_to_number(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_int2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_convert(fcinfo: FunctionCallInfo) -> Datum;
    pub fn iclikesel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn icnlikesel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn iclikejoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn icnlikejoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexeqsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn likesel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn icregexeqsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexnesel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nlikesel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn icregexnesel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexeqjoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn likejoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn icregexeqjoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexnejoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn nlikejoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn icregexnejoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_avg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_var_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_stddev_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_avg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_var_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_stddev_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_sum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_sum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_sum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_avg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_ascii_default(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_ascii_enc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_ascii_encname(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int28eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int28ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int28lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int28gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int28le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int28ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int82eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int82ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int82lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int82gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int82le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int82ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2and(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2or(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2xor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2not(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2shl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2shr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4and(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4or(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4xor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4not(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4shl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4shr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8and(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8or(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8xor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8not(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8shl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8shr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8up(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2up(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4up(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4up(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8up(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_uplus(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_table_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_numscans(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_tuples_returned(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_tuples_fetched(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_tuples_inserted(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_tuples_updated(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_tuples_deleted(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_blocks_fetched(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_blocks_hit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_backend_idset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_backend_pid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_backend_dbid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_backend_userid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_backend_activity(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_numbackends(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_xact_commit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_xact_rollback(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_blocks_fetched(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_blocks_hit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_encode(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_decode(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteaeq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bytealt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteale(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteagt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteage(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteane(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteacmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_scale(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_avg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidlarger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidsmaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_scale(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_scale(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_scale(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_tuples_hot_updated(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_div_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn similar_to_escape_2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn similar_to_escape_1(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bytealike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteanlike(fcinfo: FunctionCallInfo) -> Datum;
    pub fn like_escape_bytea(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteacat(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bytea_substr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bytea_substr_no_len(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteapos(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteatrim(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_part(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_activity(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_path_query_first_tz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_backend_pid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_path_match_tz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_pl_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_mi_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_conf_load_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_zone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_izone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_hash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_timetz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_to_char(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_age(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_zone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_izone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_pl_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_mi_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexsubstr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitfromint8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bittoint8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn show_config_by_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn set_config_by_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_table_is_visible(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_type_is_visible(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_function_is_visible(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_operator_is_visible(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_opclass_is_visible(fcinfo: FunctionCallInfo) -> Datum;
    pub fn show_all_settings(fcinfo: FunctionCallInfo) -> Datum;
    pub fn replace_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn split_part(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_hex32(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_hex64(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_lower(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_upper(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_conversion_is_visible(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_backend_activity_start(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_terminate_backend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_functiondef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_column_compression(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_force_next_flush(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_pattern_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_pattern_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_function_arguments(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_pattern_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_pattern_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_function_result(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bttext_pattern_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_database_size_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn width_bucket_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_cancel_backend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_backup_start(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_pattern_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_pattern_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_length(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_pattern_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_pattern_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gist_point_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btbpchar_pattern_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_sequence_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_sequence_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_sequence_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_sequence_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_sequence_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_sequence_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint48cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint84cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint24cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint42cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint28cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint82cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat48cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat84cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_client_addr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_client_port(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_server_addr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_server_port(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocedurein(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocedureout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperatorin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperatorout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regclassin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regclassout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regtypein(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regtypeout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_clear_snapshot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_function_identity_arguments(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashtid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashtidextended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn fmgr_internal_validator(fcinfo: FunctionCallInfo) -> Datum;
    pub fn fmgr_c_validator(fcinfo: FunctionCallInfo) -> Datum;
    pub fn fmgr_sql_validator(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_database_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_database_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_database_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_database_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_database_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_database_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_function_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_function_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_function_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_function_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_function_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_function_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_language_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_language_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_language_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_language_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_language_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_language_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_schema_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_reset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_backend_memory_contexts(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexreplace_noopt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexreplace(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_total_relation_size(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_size_pretty(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_options_to_table(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cstring_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cstring_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn any_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn any_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyarray_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyarray_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn void_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn void_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn trigger_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn trigger_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn language_handler_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn language_handler_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn internal_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn internal_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_slru(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_reset_slru(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dceil(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dfloor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dsign(fcinfo: FunctionCallInfo) -> Datum;
    pub fn md5_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyelement_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyelement_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn postgresql_fdw_validator(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_encoding_max_length_sql(fcinfo: FunctionCallInfo) -> Datum;
    pub fn md5_bytea(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_tablespace_size_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_tablespace_size_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_database_size_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_unnest(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_relation_size(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_lt_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_le_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_eq_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_gt_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_ge_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_ne_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_cmp_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_lt_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_le_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_eq_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_gt_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_ge_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_ne_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_cmp_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_lt_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_le_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_eq_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_gt_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_ge_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_ne_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_cmp_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_lt_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_le_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_eq_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_gt_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_ge_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_ne_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_cmp_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_tablespace_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_tablespace_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_tablespace_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_tablespace_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_tablespace_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_tablespace_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn shell_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn shell_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2vectorrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2vectorsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bytearecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteasend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unknownrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unknownsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn oidvectorsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namerecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn namesend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float4send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpcharsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varcharrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varcharsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn charsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xidrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xidsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regprocedurerecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regproceduresend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regopersend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperatorrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regoperatorsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regclassrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regclasssend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regtyperecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regtypesend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bit_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bit_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varbit_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varbit_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dsinh(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dcosh(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtanh(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dasinh(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dacosh(fcinfo: FunctionCallInfo) -> Datum;
    pub fn datanh(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lseg_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn path_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn line_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn line_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cidr_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cstring_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cstring_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyarray_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyarray_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_ruledef_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_viewdef_name_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_viewdef_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_indexdef_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_constraintdef_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_expr_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_prepared_statement(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_cursor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_var_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_stddev_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_var_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn booland_statefunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boolor_statefunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_lt_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_le_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_eq_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_gt_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_ge_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_ne_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_cmp_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_lt_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_le_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_eq_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_gt_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_ge_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_ne_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_cmp_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_tablespace_databases(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_bool(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bool_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn lastval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_postmaster_start_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_blocking_pids(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_below(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_overbelow(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_overabove(fcinfo: FunctionCallInfo) -> Datum;
    pub fn box_above(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_below(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_overbelow(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_overabove(fcinfo: FunctionCallInfo) -> Datum;
    pub fn poly_above(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gist_box_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_float8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gist_box_penalty(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gist_box_picksplit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gist_box_union(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gist_box_same(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gist_poly_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gist_poly_compress(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_overbelow(fcinfo: FunctionCallInfo) -> Datum;
    pub fn circle_overabove(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gist_circle_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gist_circle_compress(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_stddev_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn domain_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn domain_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_timezone_abbrevs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xmlexists(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_reload_conf(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_rotate_logfile_v2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_file_1arg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_file_off_len(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ls_dir_1arg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_sleep(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetnot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetand(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetor(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetpl(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetmi_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inetmi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn statement_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn clock_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_cmp_prefix(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_has_role_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_justify_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_triggerdef_ext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dasind(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dacosd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn datand(fcinfo: FunctionCallInfo) -> Datum;
    pub fn datan2d(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dsind(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dcosd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dtand(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dcotd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_backup_stop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_avg_serialize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_avg_deserialize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ginarrayextract(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ginarrayconsistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn arrayoverlap(fcinfo: FunctionCallInfo) -> Datum;
    pub fn arraycontains(fcinfo: FunctionCallInfo) -> Datum;
    pub fn arraycontained(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_tuples_returned(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_tuples_fetched(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_tuples_inserted(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_tuples_updated(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_tuples_deleted(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_matches_no_flags(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_matches(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_split_to_table_no_flags(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_split_to_table(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_split_to_array_no_flags(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_split_to_array(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_bgwriter_timed_checkpoints(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_bgwriter_requested_checkpoints(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_bgwriter_buf_written_checkpoints(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_bgwriter_buf_written_clean(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_bgwriter_maxwritten_clean(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ginqueryarrayextract(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_buf_written_backend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anynonarray_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anynonarray_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_last_vacuum_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_last_autovacuum_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_last_analyze_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_last_autoanalyze_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_avg_combine(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_avg_serialize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_avg_deserialize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_backend_wait_event_type(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidgt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidlt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bttidcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidlarger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tidsmaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8inc_any(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8inc_float8_float8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_sxx(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_syy(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_sxy(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_avgx(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_avgy(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_r2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_slope(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_intercept(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_covar_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_covar_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_corr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_blk_read_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_blk_write_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_switch_wal(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_current_wal_lsn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_walfile_name_offset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_walfile_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_current_wal_insert_lsn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_backend_wait_event(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_my_temp_schema(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_is_other_temp_schema(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_timezone_names(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_backend_xact_start(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_buf_alloc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_live_tuples(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_dead_tuples(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_lock_shared_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_try_advisory_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_try_advisory_lock_shared_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_unlock_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_unlock_shared_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_lock_shared_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_try_advisory_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_try_advisory_lock_shared_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_unlock_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_unlock_shared_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_unlock_all(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xml_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xml_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xmlcomment(fcinfo: FunctionCallInfo) -> Datum;
    pub fn texttoxml(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xmlvalidate(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xml_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xml_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xmlconcat2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varbittypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn intervaltypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn intervaltypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptztypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptztypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetztypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetztypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchartypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchartypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varchartypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varchartypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numerictypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numerictypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bittypmodin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bittypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varbittypmodout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xmltotext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn table_to_xml(fcinfo: FunctionCallInfo) -> Datum;
    pub fn query_to_xml(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cursor_to_xml(fcinfo: FunctionCallInfo) -> Datum;
    pub fn table_to_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
    pub fn query_to_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cursor_to_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
    pub fn table_to_xml_and_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
    pub fn query_to_xml_and_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xpath(fcinfo: FunctionCallInfo) -> Datum;
    pub fn schema_to_xml(fcinfo: FunctionCallInfo) -> Datum;
    pub fn schema_to_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
    pub fn schema_to_xml_and_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
    pub fn database_to_xml(fcinfo: FunctionCallInfo) -> Datum;
    pub fn database_to_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
    pub fn database_to_xml_and_xmlschema(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_snapshot_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_snapshot_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_snapshot_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_snapshot_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_current_xact_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_current_snapshot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_snapshot_xmin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_snapshot_xmax(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_snapshot_xip(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_visible_in_snapshot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_hash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn booltext(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_function_calls(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_function_total_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_function_self_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btrecordcmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_table_size(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_indexes_size(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_relation_filenode(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_foreign_data_wrapper_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_foreign_data_wrapper_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_foreign_data_wrapper_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_foreign_data_wrapper_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_foreign_data_wrapper_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_foreign_data_wrapper_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_server_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_name_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_name_name_attnum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_name_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_name_id_attnum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_id_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_id_name_attnum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_id_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_id_id_attnum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_name_attnum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_column_privilege_id_attnum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_any_column_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_any_column_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_any_column_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_any_column_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_any_column_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_any_column_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitoverlay(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitoverlay_no_len(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitgetbit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bitsetbit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_relation_filepath(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_listening_channels(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_notify(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_xact_numscans(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_xact_tuples_returned(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_xact_tuples_fetched(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_xact_tuples_inserted(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_xact_tuples_updated(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_xact_tuples_deleted(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_xact_tuples_hot_updated(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_xact_blocks_fetched(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_xact_blocks_hit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_xact_function_calls(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_xact_function_total_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_xact_function_self_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xpath_exists(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xml_is_well_formed(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xml_is_well_formed_document(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xml_is_well_formed_content(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_vacuum_count(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_autovacuum_count(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_analyze_count(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_autoanalyze_count(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_concat(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_concat_ws(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_left(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_right(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_reverse(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_buf_fsync_backend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gist_point_distance(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_conflict_tablespace(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_conflict_lock(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_conflict_snapshot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_conflict_bufferpin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_conflict_startup_deadlock(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_conflict_all(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_wal_replay_pause(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_wal_replay_resume(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_is_wal_replay_paused(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_stat_reset_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_bgwriter_stat_reset_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ginarrayextract_2args(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_extract_tsvector_2args(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_sequence_parameters(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_available_extensions(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_available_extension_versions(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_extension_update_paths(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_extension_config_dump(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_extract_tsquery_5args(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_tsquery_consistent_6args(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_xact_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_xact_lock_shared_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_try_advisory_xact_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_try_advisory_xact_lock_shared_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_xact_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_advisory_xact_lock_shared_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_try_advisory_xact_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_try_advisory_xact_lock_shared_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varchar_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_create_restore_point(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_wal_senders(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_row_number(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_rank(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_dense_rank(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_percent_rank(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_cume_dist(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_ntile(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_lag(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_lag_with_offset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_lag_with_offset_and_default(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_lead(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_lead_with_offset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_lead_with_offset_and_default(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_first_value(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_last_value(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_nth_value(fcinfo: FunctionCallInfo) -> Datum;
    pub fn fdw_handler_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn fdw_handler_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn void_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn void_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint2sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint4sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btint8sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat4sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btfloat8sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btoidsortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btnamesortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn date_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_type_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_not(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_and(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_or(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_temp_files(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_temp_bytes(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_deadlocks(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_to_json(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_to_json_pretty(fcinfo: FunctionCallInfo) -> Datum;
    pub fn row_to_json(fcinfo: FunctionCallInfo) -> Datum;
    pub fn row_to_json_pretty(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn varbit_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_viewdef_wrap(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_checkpoint_write_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_checkpoint_sync_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_collation_for(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_trigger_depth(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_wal_lsn_diff(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_size_pretty_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_remove(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_replace(fcinfo: FunctionCallInfo) -> Datum;
    pub fn rangesel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_lseek64(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_tell64(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_truncate64(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_json(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_mod_since_analyze(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_sum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_cardinality(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_image_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_image_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_image_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_image_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_image_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn record_image_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btrecordimagecmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_archiver(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_build_array(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_build_array_noargs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_build_object(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_build_object_noargs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object_two_arg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_to_record(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_to_recordset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_array_length(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_each(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_populate_record(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_typeof(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_object_field_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_array_element(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_array_element_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_extract_path(fcinfo: FunctionCallInfo) -> Datum;
    pub fn width_bucket_array(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_array_elements(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_mi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_hash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bttextsortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_step_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_strip_nulls(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_strip_nulls(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_object(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_object_two_arg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_object_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_object_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_build_array(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_build_array_noargs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_build_object(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_build_object_noargs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_ppoly(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_position(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_position_start(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_positions(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gist_circle_distance(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_scale(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gist_point_fetch(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gist_poly_distance(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_cpoint(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dist_polyp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_file_off_len_missing(fcinfo: FunctionCallInfo) -> Datum;
    pub fn show_config_by_name_missing_ok(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_binary_file_off_len_missing(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_notification_queue_usage(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ls_dir(fcinfo: FunctionCallInfo) -> Datum;
    pub fn row_security_active(fcinfo: FunctionCallInfo) -> Datum;
    pub fn row_security_active_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_concat(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_delete(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_delete_idx(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_delete_path(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_set(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_pretty(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_file(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xidneq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsm_handler_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsm_handler_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsm_bernoulli_handler(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsm_system_handler(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_wal_receiver(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_progress_info(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_filter(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_setweight_by_filter(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_delete_str(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_unnest(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_delete_arr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_avg_combine(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_combine(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_to_array(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_to_tsvector(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bpchar_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn show_all_file_settings(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_current_wal_flush_lsn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bytea_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bttext_pattern_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btbpchar_pattern_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_size_bytes(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_serialize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_deserialize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_avg_combine(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_poly_combine(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_poly_serialize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_poly_deserialize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_combine(fcinfo: FunctionCallInfo) -> Datum;
    pub fn float8_regr_combine(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_delete_array(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_mul_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_div_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_current_xact_id_if_assigned(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_partkeydef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ls_logdir(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ls_waldir(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ndistinct_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ndistinct_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ndistinct_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ndistinct_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_xact_status(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_safe_snapshot_blocking_pids(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_isolation_test_session_is_blocked(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_identify_object_as_address(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_opcinfo(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_add_value(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_union(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_avg_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_poly_sum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_poly_avg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_poly_var_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_poly_var_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_poly_stddev_pop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_poly_stddev_samp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_match_no_flags(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_match(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_mul_cash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_config(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_hba_file_rules(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_statistics_obj_is_visible(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_dependencies_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_dependencies_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_dependencies_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_dependencies_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_partition_constraintdef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_hash_extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timetz_hash_extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_hash_extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn uuid_hash_extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_hash_extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashenumextended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_statisticsobjdef(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_hash_extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hash_range_extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_hash_extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn sha224_bytea(fcinfo: FunctionCallInfo) -> Datum;
    pub fn sha256_bytea(fcinfo: FunctionCallInfo) -> Datum;
    pub fn sha384_bytea(fcinfo: FunctionCallInfo) -> Datum;
    pub fn sha512_bytea(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_partition_tree(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_partition_root(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_partition_ancestors(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_checksum_failures(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stats_ext_mcvlist_items(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_checksum_last_failure(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gen_random_uuid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsvector_options(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gist_point_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_promote(fcinfo: FunctionCallInfo) -> Datum;
    pub fn prefixsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn prefixjoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_control_system(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_control_checkpoint(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_control_recovery(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_control_init(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_import_system_collations(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr8_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr8_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_collation_actual_version(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_int2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_float4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_filenode_relation(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_from_bytea(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_get(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_get_fragment(fcinfo: FunctionCallInfo) -> Datum;
    pub fn be_lo_put(fcinfo: FunctionCallInfo) -> Datum;
    pub fn make_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn make_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn make_timestamptz_at_timezone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn make_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_array_elements_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_range_quad_config(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_range_quad_choose(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_range_quad_picksplit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_range_quad_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_range_quad_leaf_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_populate_recordset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regoperator(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_object_field(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regprocedure(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_compare_jsonb(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_extract_jsonb(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_extract_jsonb_query(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_consistent_jsonb(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_extract_jsonb_path(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_extract_jsonb_query_path(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_consistent_jsonb_path(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_triconsistent_jsonb(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_triconsistent_jsonb_path(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_to_record(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_to_recordset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regoper(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regtype(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regproc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regclass(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bool_accum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bool_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bool_alltrue(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bool_anytrue(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyenum_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyenum_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hashenum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_first(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_last(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_range_bounds(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_range_all(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn enum_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn string_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn string_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_describe_object(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_format(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_format_nv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bytea_string_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bytea_string_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8dec(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8dec_any(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_overlap(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_gist_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_gist_union(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_gist_compress(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_bool(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_gist_penalty(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_gist_picksplit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_gist_same(fcinfo: FunctionCallInfo) -> Datum;
    pub fn networksel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn networkjoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_event_trigger_dropped_objects(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2_avg_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_avg_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int2int4_sum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_gist_fetch(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_logical_emit_message_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_logical_emit_message_bytea(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_insert(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_xact_commit_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_set_next_pg_type_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_last_committed_xact(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_set_next_array_pg_type_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_set_next_heap_pg_class_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_set_next_index_pg_class_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_set_next_toast_pg_class_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_set_next_pg_enum_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_set_next_pg_authid_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_create_empty_extension(fcinfo: FunctionCallInfo) -> Datum;
    pub fn event_trigger_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn event_trigger_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvectorin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvectorout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsqueryin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsqueryout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_strip(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_setweight(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_concat(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_match_vq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_match_qv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvectorsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvectorrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsquerysend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsqueryrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsvectorin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsvectorout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsvector_compress(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsvector_decompress(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsvector_picksplit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsvector_union(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsvector_same(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsvector_penalty(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsvector_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_extract_tsvector(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_extract_tsquery(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_tsquery_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsquery_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsquery_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsquery_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsquery_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsquery_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsquery_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsquery_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsquery_and(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsquery_or(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsquery_not(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsquery_numnode(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsquerytree(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsquery_rewrite(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsquery_rewrite_query(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsmatchsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsmatchjoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_typanalyze(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_stat1(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_stat2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsq_mcontains(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsq_mcontained(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsquery_compress(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_starts_with(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsquery_picksplit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsquery_union(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsquery_same(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsquery_penalty(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsquery_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_rank_wttf(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_rank_wtt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_rank_ttf(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_rank_tt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_rankcd_wttf(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_rankcd_wtt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_rankcd_ttf(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_rankcd_tt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_length(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_token_type_byid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_token_type_byname(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_parse_byid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_parse_byname(fcinfo: FunctionCallInfo) -> Datum;
    pub fn prsd_start(fcinfo: FunctionCallInfo) -> Datum;
    pub fn prsd_nexttoken(fcinfo: FunctionCallInfo) -> Datum;
    pub fn prsd_end(fcinfo: FunctionCallInfo) -> Datum;
    pub fn prsd_headline(fcinfo: FunctionCallInfo) -> Datum;
    pub fn prsd_lextype(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_lexize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_cmp_tslexeme(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dsimple_init(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dsimple_lexize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dsynonym_init(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dsynonym_lexize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dispell_init(fcinfo: FunctionCallInfo) -> Datum;
    pub fn dispell_lexize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regconfigin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regconfigout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regconfigrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regconfigsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn thesaurus_init(fcinfo: FunctionCallInfo) -> Datum;
    pub fn thesaurus_lexize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_headline_byid_opt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_headline_byid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_tsvector_byid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_tsquery_byid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn plainto_tsquery_byid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_tsvector(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_tsquery(fcinfo: FunctionCallInfo) -> Datum;
    pub fn plainto_tsquery(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_update_trigger_byid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsvector_update_trigger_bycolumn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_headline_opt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_headline(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ts_parser_is_visible(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ts_dict_is_visible(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ts_config_is_visible(fcinfo: FunctionCallInfo) -> Datum;
    pub fn get_current_ts_config(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_match_tt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_match_tq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ts_template_is_visible(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regdictionaryin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regdictionaryout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regdictionaryrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regdictionarysend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_reset_shared(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_reset_single_table_counters(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_reset_single_function_counters(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_tablespace_location(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_create_physical_replication_slot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_drop_replication_slot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_replication_slots(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_logical_slot_get_changes(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_logical_slot_get_binary_changes(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_logical_slot_peek_changes(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_logical_slot_peek_binary_changes(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_create_logical_replication_slot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_jsonb(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_snapshot_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_clean_pending_list(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsvector_consistent_oldsig(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_extract_tsquery_oldsig(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_tsquery_consistent_oldsig(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gtsquery_consistent_oldsig(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_spg_config(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_spg_choose(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_spg_picksplit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_spg_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_spg_leaf_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_current_logfile(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_current_logfile_1arg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_function_arg_default(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_export_snapshot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_is_in_recovery(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4_cash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8_cash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_collation_is_visible(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_typanalyze(fcinfo: FunctionCallInfo) -> Datum;
    pub fn arraycontsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn arraycontjoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_multixact_members(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_last_wal_receive_lsn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_last_wal_replay_lsn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_div_cash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn cash_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_cash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_file_all(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_binary_file_off_len(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_binary_file_all(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_opfamily_is_visible(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_last_xact_replay_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyrange_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anyrange_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_identify_object(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_constructor2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_constructor3(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_relation_is_updatable(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_column_is_updatable(fcinfo: FunctionCallInfo) -> Datum;
    pub fn make_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn make_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_lower(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_upper(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_empty(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_lower_inc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_upper_inc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_lower_inf(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_upper_inf(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_overlaps(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_contains_elem(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_contains(fcinfo: FunctionCallInfo) -> Datum;
    pub fn elem_contained_by_range(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_contained_by(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_adjacent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_before(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_after(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_overleft(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_overright(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_union(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_intersect(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_minus(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_gist_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_gist_union(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_replication_slot_advance(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_gist_penalty(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_gist_picksplit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_gist_same(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hash_range(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4range_canonical(fcinfo: FunctionCallInfo) -> Datum;
    pub fn daterange_canonical(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_typanalyze(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn interval_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ginarraytriconsistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gin_tsquery_triconsistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4range_subdiff(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8range_subdiff(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numrange_subdiff(fcinfo: FunctionCallInfo) -> Datum;
    pub fn daterange_subdiff(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8range_canonical(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsrange_subdiff(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tstzrange_subdiff(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_object_keys(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_each_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn mxid_age(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_extract_path_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn acldefault_sql(fcinfo: FunctionCallInfo) -> Datum;
    pub fn time_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object_field(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object_field_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_array_element(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_array_element_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_extract_path(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_summarize_new_values(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_extract_path_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_object_address(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_array_elements(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_array_length(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object_keys(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_each(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_each_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_populate_record(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_populate_recordset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_typeof(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_array_elements_text(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ordered_set_transition(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ordered_set_transition_multi(fcinfo: FunctionCallInfo) -> Datum;
    pub fn percentile_disc_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn percentile_cont_float8_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn percentile_cont_interval_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn percentile_disc_multi_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn percentile_cont_float8_multi_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn percentile_cont_interval_multi_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn mode_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hypothetical_rank_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hypothetical_percent_rank_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hypothetical_cume_dist_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hypothetical_dense_rank_final(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_int4_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_int8_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_unnest_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn gist_box_distance(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_summarize_range(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonpath_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonpath_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonpath_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonpath_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_path_exists(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_path_query(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_path_query_array(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_path_query_first(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_path_match(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_path_exists_opr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_path_match_opr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_desummarize_range(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_quad_config(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_quad_choose(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_quad_picksplit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_quad_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_quad_leaf_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_kd_config(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_kd_choose(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_kd_picksplit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_kd_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_text_config(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_text_choose(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_text_picksplit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_text_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_text_leaf_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_sequence_last_value(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_hash(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_contains(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_exists(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_exists_any(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_exists_all(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_contained(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_agg_array_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_agg_array_finalfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_merge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_merge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn boxes_bound_box(fcinfo: FunctionCallInfo) -> Datum;
    pub fn inet_same_family(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_set_record_init_privs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regnamespacein(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regnamespaceout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regnamespace(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regnamespacerecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regnamespacesend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn point_box(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regroleout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regrole(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regrolerecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regrolesend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regrolein(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_rotate_logfile(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_file(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_set_missing_value(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_inclusion_opcinfo(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_inclusion_add_value(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_inclusion_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_inclusion_union(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr8_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr8_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr8_trunc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr8_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr8_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr8_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr8_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr8_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr8_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr8_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr8_not(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr8_and(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr8_or(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddrtomacaddr8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr8tomacaddr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn macaddr8_set7bit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn in_range_int8_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn in_range_int4_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn in_range_int4_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn in_range_int4_int2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn in_range_int2_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn in_range_int2_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn in_range_int2_int2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn in_range_date_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn in_range_timestamp_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn in_range_timestamptz_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn in_range_interval_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn in_range_time_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn in_range_timetz_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn in_range_float8_float8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn in_range_float4_float8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn in_range_numeric_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regcollationin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regcollationout(fcinfo: FunctionCallInfo) -> Datum;
    pub fn to_regcollation(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regcollationrecv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regcollationsend(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_headline_jsonb_byid_opt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_headline_jsonb_byid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_headline_jsonb_opt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_headline_jsonb(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_headline_json_byid_opt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_headline_json_byid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_headline_json_opt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn ts_headline_json(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_string_to_tsvector(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_string_to_tsvector(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_string_to_tsvector_byid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_string_to_tsvector_byid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_to_tsvector(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_to_tsvector_byid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_to_tsvector(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_to_tsvector_byid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_copy_physical_replication_slot_a(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_copy_physical_replication_slot_b(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_copy_logical_replication_slot_a(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_copy_logical_replication_slot_b(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_copy_logical_replication_slot_c(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anycompatiblemultirange_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anycompatiblemultirange_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_merge_from_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anymultirange_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anymultirange_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_lower(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_upper(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_empty(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_lower_inc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_upper_inc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_lower_inf(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_upper_inf(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_typanalyze(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirangesel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_overlaps_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_overlaps_range(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_overlaps_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_contains_elem(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_contains_range(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_contains_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn elem_contained_by_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_contained_by_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_contained_by_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_adjacent_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_adjacent_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_adjacent_range(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_before_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_before_range(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_before_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_after_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_after_range(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_after_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_overleft_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_overleft_range(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_overleft_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_overright_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_overright_range(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_overright_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_union(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_minus(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_intersect(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hash_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hash_multirange_extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_constructor0(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_constructor1(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_constructor2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unicode_normalize_func(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unicode_is_normalized(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_intersect_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_set_next_multirange_pg_type_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_set_next_multirange_array_pg_type_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_intersect_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn range_contains_multirange(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_contained_by_range(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_log_backend_memory_contexts(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_set_next_heap_relfilenode(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_set_next_index_relfilenode(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_set_next_toast_relfilenode(fcinfo: FunctionCallInfo) -> Datum;
    pub fn binary_upgrade_set_next_pg_tablespace_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_event_trigger_table_rewrite_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_event_trigger_table_rewrite_reason(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_event_trigger_ddl_commands(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_bloom_opcinfo(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_bloom_add_value(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_bloom_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_bloom_union(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_bloom_options(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_bloom_summary_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_bloom_summary_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_bloom_summary_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_bloom_summary_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_opcinfo(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_add_value(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_union(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_options(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_distance_int2(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_distance_int4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_distance_int8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_distance_float4(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_distance_float8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_distance_numeric(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_distance_tid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_distance_uuid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_distance_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_distance_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_distance_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_distance_timetz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_distance_pg_lsn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_distance_macaddr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_distance_macaddr8(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_distance_inet(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_distance_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_summary_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_summary_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_summary_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn brin_minmax_multi_summary_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn phraseto_tsquery(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsquery_phrase(fcinfo: FunctionCallInfo) -> Datum;
    pub fn tsquery_phrase_distance(fcinfo: FunctionCallInfo) -> Datum;
    pub fn phraseto_tsquery_byid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn websearch_to_tsquery_byid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn websearch_to_tsquery(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_bbox_quad_config(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_poly_quad_compress(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_box_quad_config(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_box_quad_choose(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_box_quad_picksplit(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_box_quad_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn spg_box_quad_leaf_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_mcv_list_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_mcv_list_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_mcv_list_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_mcv_list_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_pli(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_lsn_mii(fcinfo: FunctionCallInfo) -> Datum;
    pub fn satisfies_hash_partition(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ls_tmpdir_noargs(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ls_tmpdir_1arg(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ls_archive_statusdir(fcinfo: FunctionCallInfo) -> Datum;
    pub fn network_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xid8lt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xid8gt(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xid8le(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xid8ge(fcinfo: FunctionCallInfo) -> Datum;
    pub fn matchingsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn matchingjoinsel(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_min_scale(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_trim_scale(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4gcd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8gcd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int4lcm(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8lcm(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_gcd(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_lcm(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btvarstrequalimage(fcinfo: FunctionCallInfo) -> Datum;
    pub fn btequalimage(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_shmem_allocations(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_ins_since_vacuum(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_set_lax(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xid8in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xid8toxid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xid8out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xid8recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xid8send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xid8eq(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xid8ne(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anycompatible_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anycompatible_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anycompatiblearray_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anycompatiblearray_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anycompatiblearray_recv(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anycompatiblearray_send(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anycompatiblenonarray_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anycompatiblenonarray_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anycompatiblerange_in(fcinfo: FunctionCallInfo) -> Datum;
    pub fn anycompatiblerange_out(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xid8cmp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xid8_larger(fcinfo: FunctionCallInfo) -> Datum;
    pub fn xid8_smaller(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_replication_origin_create(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_replication_origin_drop(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_replication_origin_oid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_replication_origin_session_setup(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_replication_origin_session_reset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_replication_origin_session_is_setup(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_replication_origin_session_progress(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_replication_origin_xact_setup(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_replication_origin_xact_reset(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_replication_origin_advance(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_replication_origin_progress(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_show_replication_origin_status(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_subscript_handler(fcinfo: FunctionCallInfo) -> Datum;
    pub fn numeric_pg_lsn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_backend_subxact(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_subscription(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_publication_tables(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_replica_identity_index(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_relation_is_publishable(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_gist_consistent(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_gist_compress(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_catalog_foreign_keys(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_to_table(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_to_table_null(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bit_bit_count(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bytea_bit_count(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_xact_commit_timestamp_origin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_replication_slot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_reset_replication_slot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn trim_array(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_statisticsobjdef_expressions(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_statisticsobjdef_columns(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamp_bin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_bin(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_subscript_handler(fcinfo: FunctionCallInfo) -> Datum;
    pub fn raw_array_subscript_handler(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_session_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_active_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_idle_in_transaction_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_sessions(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_sessions_abandoned(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_sessions_fatal(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_sessions_killed(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hash_record(fcinfo: FunctionCallInfo) -> Datum;
    pub fn hash_record_extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn bytealtrim(fcinfo: FunctionCallInfo) -> Datum;
    pub fn byteartrim(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_function_sqlbody(fcinfo: FunctionCallInfo) -> Datum;
    pub fn unistr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn extract_date(fcinfo: FunctionCallInfo) -> Datum;
    pub fn extract_time(fcinfo: FunctionCallInfo) -> Datum;
    pub fn extract_timetz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn extract_timestamp(fcinfo: FunctionCallInfo) -> Datum;
    pub fn extract_timestamptz(fcinfo: FunctionCallInfo) -> Datum;
    pub fn extract_interval(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_parameter_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_parameter_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn has_parameter_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_file_all_missing(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_read_binary_file_all_missing(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_input_is_valid(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_input_error_info(fcinfo: FunctionCallInfo) -> Datum;
    pub fn drandom_normal(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_split_walfile_name(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_io(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_shuffle(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_sample(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_tuples_newpage_updated(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_xact_tuples_newpage_updated(fcinfo: FunctionCallInfo) -> Datum;
    pub fn derf(fcinfo: FunctionCallInfo) -> Datum;
    pub fn derfc(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_pl_interval_at_zone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_get_wal_resource_managers(fcinfo: FunctionCallInfo) -> Datum;
    pub fn multirange_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_have_stats(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_subscription_stats(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_reset_subscription_stats(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_row_number_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_rank_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_dense_rank_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn int8inc_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_settings_get_flags(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stop_making_pinned_objects(fcinfo: FunctionCallInfo) -> Datum;
    pub fn text_starts_with_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_recovery_prefetch(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_database_collation_actual_version(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ident_file_mappings(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexreplace_extended(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexreplace_extended_no_flags(fcinfo: FunctionCallInfo) -> Datum;
    pub fn textregexreplace_extended_no_n(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_count_no_start(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_count_no_flags(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_count(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_instr_no_start(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_instr_no_n(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_instr_no_endoption(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_instr_no_flags(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_instr_no_subexpr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_instr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_like_no_flags(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_like(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_substr_no_start(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_substr_no_n(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_substr_no_flags(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_substr_no_subexpr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn regexp_substr(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ls_logicalsnapdir(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ls_logicalmapdir(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_ls_replslotdir(fcinfo: FunctionCallInfo) -> Datum;
    pub fn timestamptz_mi_interval_at_zone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn generate_series_timestamptz_at_zone(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_agg_strict_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object_agg_strict_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object_agg_unique_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn json_object_agg_unique_strict_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_agg_strict_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_object_agg_strict_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_object_agg_unique_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn jsonb_object_agg_unique_strict_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn any_value_transfn(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_agg_combine(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_agg_serialize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_agg_deserialize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_agg_array_combine(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_agg_array_serialize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn array_agg_array_deserialize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn string_agg_combine(fcinfo: FunctionCallInfo) -> Datum;
    pub fn string_agg_serialize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn string_agg_deserialize(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_log_standby_snapshot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_percent_rank_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_cume_dist_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn window_ntile_support(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_db_conflict_logicalslot(fcinfo: FunctionCallInfo) -> Datum;
    pub fn pg_stat_get_lastscan(fcinfo: FunctionCallInfo) -> Datum;
    pub fn system_user(fcinfo: FunctionCallInfo) -> Datum;
    pub fn parse_bool(value: *const ::std::os::raw::c_char, result: *mut bool) -> bool;
    pub fn parse_bool_with_len(
        value: *const ::std::os::raw::c_char,
        len: usize,
        result: *mut bool,
    ) -> bool;
    pub fn domain_check(
        value: Datum,
        isnull: bool,
        domainType: Oid,
        extra: *mut *mut ::std::os::raw::c_void,
        mcxt: MemoryContext,
    );
    pub fn errdatatype(datatypeOid: Oid) -> ::std::os::raw::c_int;
    pub fn errdomainconstraint(
        datatypeOid: Oid,
        conname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn hex_encode(
        src: *const ::std::os::raw::c_char,
        len: usize,
        dst: *mut ::std::os::raw::c_char,
    ) -> uint64;
    pub fn hex_decode(
        src: *const ::std::os::raw::c_char,
        len: usize,
        dst: *mut ::std::os::raw::c_char,
    ) -> uint64;
    pub fn hex_decode_safe(
        src: *const ::std::os::raw::c_char,
        len: usize,
        dst: *mut ::std::os::raw::c_char,
        escontext: *mut Node,
    ) -> uint64;
    pub fn buildint2vector(int2s: *const int16, n: ::std::os::raw::c_int) -> *mut int2vector;
    pub fn namestrcpy(name: Name, str_: *const ::std::os::raw::c_char);
    pub fn namestrcmp(name: Name, str_: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn pg_strtoint16(s: *const ::std::os::raw::c_char) -> int16;
    pub fn pg_strtoint16_safe(s: *const ::std::os::raw::c_char, escontext: *mut Node) -> int16;
    pub fn pg_strtoint32(s: *const ::std::os::raw::c_char) -> int32;
    pub fn pg_strtoint32_safe(s: *const ::std::os::raw::c_char, escontext: *mut Node) -> int32;
    pub fn pg_strtoint64(s: *const ::std::os::raw::c_char) -> int64;
    pub fn pg_strtoint64_safe(s: *const ::std::os::raw::c_char, escontext: *mut Node) -> int64;
    pub fn uint32in_subr(
        s: *const ::std::os::raw::c_char,
        endloc: *mut *mut ::std::os::raw::c_char,
        typname: *const ::std::os::raw::c_char,
        escontext: *mut Node,
    ) -> uint32;
    pub fn uint64in_subr(
        s: *const ::std::os::raw::c_char,
        endloc: *mut *mut ::std::os::raw::c_char,
        typname: *const ::std::os::raw::c_char,
        escontext: *mut Node,
    ) -> uint64;
    pub fn pg_itoa(i: int16, a: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn pg_ultoa_n(value: uint32, a: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn pg_ulltoa_n(value: uint64, a: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn pg_ltoa(value: int32, a: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn pg_lltoa(value: int64, a: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
    pub fn pg_ultostr_zeropad(
        str_: *mut ::std::os::raw::c_char,
        value: uint32,
        minwidth: int32,
    ) -> *mut ::std::os::raw::c_char;
    pub fn pg_ultostr(
        str_: *mut ::std::os::raw::c_char,
        value: uint32,
    ) -> *mut ::std::os::raw::c_char;
    pub fn buildoidvector(oids: *const Oid, n: ::std::os::raw::c_int) -> *mut oidvector;
    pub fn oidparse(node: *mut Node) -> Oid;
    pub fn oid_cmp(
        p1: *const ::std::os::raw::c_void,
        p2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
    pub fn regexp_fixed_prefix(
        text_re: *mut text,
        case_insensitive: bool,
        collation: Oid,
        exact: *mut bool,
    ) -> *mut ::std::os::raw::c_char;
    pub fn quote_identifier(ident: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
    pub fn quote_qualified_identifier(
        qualifier: *const ::std::os::raw::c_char,
        ident: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
    pub fn generate_operator_clause(
        buf: fmStringInfo,
        leftop: *const ::std::os::raw::c_char,
        leftoptype: Oid,
        opoid: Oid,
        rightop: *const ::std::os::raw::c_char,
        rightoptype: Oid,
    );
    pub fn bpchartruelen(
        s: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn cstring_to_text(s: *const ::std::os::raw::c_char) -> *mut text;
    pub fn cstring_to_text_with_len(
        s: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut text;
    pub fn text_to_cstring(t: *const text) -> *mut ::std::os::raw::c_char;
    pub fn text_to_cstring_buffer(
        src: *const text,
        dst: *mut ::std::os::raw::c_char,
        dst_len: usize,
    );
    pub fn xidComparator(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
    pub fn xidLogicalComparator(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
    pub fn pg_inet_cidr_ntop(
        af: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_void,
        bits: ::std::os::raw::c_int,
        dst: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> *mut ::std::os::raw::c_char;
    pub fn pg_inet_net_pton(
        af: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> ::std::os::raw::c_int;
    pub fn convert_network_to_scalar(value: Datum, typid: Oid, failure: *mut bool) -> f64;
    pub fn network_scan_first(in_: Datum) -> Datum;
    pub fn network_scan_last(in_: Datum) -> Datum;
    pub fn clean_ipv6_addr(addr_family: ::std::os::raw::c_int, addr: *mut ::std::os::raw::c_char);
    pub fn numeric_float8_no_overflow(fcinfo: FunctionCallInfo) -> Datum;
    pub fn format_type_extended(
        type_oid: Oid,
        typemod: int32,
        flags: bits16,
    ) -> *mut ::std::os::raw::c_char;
    pub fn format_type_be(type_oid: Oid) -> *mut ::std::os::raw::c_char;
    pub fn format_type_be_qualified(type_oid: Oid) -> *mut ::std::os::raw::c_char;
    pub fn format_type_with_typemod(type_oid: Oid, typemod: int32) -> *mut ::std::os::raw::c_char;
    pub fn type_maximum_size(type_oid: Oid, typemod: int32) -> int32;
    pub fn quote_literal_cstr(rawstr: *const ::std::os::raw::c_char)
        -> *mut ::std::os::raw::c_char;
    pub fn anytime_typmod_check(istz: bool, typmod: int32) -> int32;
    pub fn date2timestamp_no_overflow(dateVal: DateADT) -> f64;
    pub fn date2timestamp_opt_overflow(
        dateVal: DateADT,
        overflow: *mut ::std::os::raw::c_int,
    ) -> Timestamp;
    pub fn date2timestamptz_opt_overflow(
        dateVal: DateADT,
        overflow: *mut ::std::os::raw::c_int,
    ) -> TimestampTz;
    pub fn date_cmp_timestamp_internal(dateVal: DateADT, dt2: Timestamp) -> int32;
    pub fn date_cmp_timestamptz_internal(dateVal: DateADT, dt2: TimestampTz) -> int32;
    pub fn EncodeSpecialDate(dt: DateADT, str_: *mut ::std::os::raw::c_char);
    pub fn GetSQLCurrentDate() -> DateADT;
    pub fn GetSQLCurrentTime(typmod: int32) -> *mut TimeTzADT;
    pub fn GetSQLLocalTime(typmod: int32) -> TimeADT;
    pub fn time2tm(time: TimeADT, tm: *mut pg_tm, fsec: *mut fsec_t) -> ::std::os::raw::c_int;
    pub fn timetz2tm(
        time: *mut TimeTzADT,
        tm: *mut pg_tm,
        fsec: *mut fsec_t,
        tzp: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn tm2time(tm: *mut pg_tm, fsec: fsec_t, result: *mut TimeADT) -> ::std::os::raw::c_int;
    pub fn tm2timetz(
        tm: *mut pg_tm,
        fsec: fsec_t,
        tz: ::std::os::raw::c_int,
        result: *mut TimeTzADT,
    ) -> ::std::os::raw::c_int;
    pub fn time_overflows(
        hour: ::std::os::raw::c_int,
        min: ::std::os::raw::c_int,
        sec: ::std::os::raw::c_int,
        fsec: fsec_t,
    ) -> bool;
    pub fn float_time_overflows(
        hour: ::std::os::raw::c_int,
        min: ::std::os::raw::c_int,
        sec: f64,
    ) -> bool;
    pub fn AdjustTimeForTypmod(time: *mut TimeADT, typmod: int32);
    pub fn GetCurrentDateTime(tm: *mut pg_tm);
    pub fn GetCurrentTimeUsec(tm: *mut pg_tm, fsec: *mut fsec_t, tzp: *mut ::std::os::raw::c_int);
    pub fn j2date(
        jd: ::std::os::raw::c_int,
        year: *mut ::std::os::raw::c_int,
        month: *mut ::std::os::raw::c_int,
        day: *mut ::std::os::raw::c_int,
    );
    pub fn date2j(
        year: ::std::os::raw::c_int,
        month: ::std::os::raw::c_int,
        day: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn ParseDateTime(
        timestr: *const ::std::os::raw::c_char,
        workbuf: *mut ::std::os::raw::c_char,
        buflen: usize,
        field: *mut *mut ::std::os::raw::c_char,
        ftype: *mut ::std::os::raw::c_int,
        maxfields: ::std::os::raw::c_int,
        numfields: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn DecodeDateTime(
        field: *mut *mut ::std::os::raw::c_char,
        ftype: *mut ::std::os::raw::c_int,
        nf: ::std::os::raw::c_int,
        dtype: *mut ::std::os::raw::c_int,
        tm: *mut pg_tm,
        fsec: *mut fsec_t,
        tzp: *mut ::std::os::raw::c_int,
        extra: *mut DateTimeErrorExtra,
    ) -> ::std::os::raw::c_int;
    pub fn DecodeTimezone(
        str_: *const ::std::os::raw::c_char,
        tzp: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn DecodeTimeOnly(
        field: *mut *mut ::std::os::raw::c_char,
        ftype: *mut ::std::os::raw::c_int,
        nf: ::std::os::raw::c_int,
        dtype: *mut ::std::os::raw::c_int,
        tm: *mut pg_tm,
        fsec: *mut fsec_t,
        tzp: *mut ::std::os::raw::c_int,
        extra: *mut DateTimeErrorExtra,
    ) -> ::std::os::raw::c_int;
    pub fn DecodeInterval(
        field: *mut *mut ::std::os::raw::c_char,
        ftype: *mut ::std::os::raw::c_int,
        nf: ::std::os::raw::c_int,
        range: ::std::os::raw::c_int,
        dtype: *mut ::std::os::raw::c_int,
        itm_in: *mut pg_itm_in,
    ) -> ::std::os::raw::c_int;
    pub fn DecodeISO8601Interval(
        str_: *mut ::std::os::raw::c_char,
        dtype: *mut ::std::os::raw::c_int,
        itm_in: *mut pg_itm_in,
    ) -> ::std::os::raw::c_int;
    pub fn DateTimeParseError(
        dterr: ::std::os::raw::c_int,
        extra: *mut DateTimeErrorExtra,
        str_: *const ::std::os::raw::c_char,
        datatype: *const ::std::os::raw::c_char,
        escontext: *mut Node,
    );
    pub fn DetermineTimeZoneOffset(tm: *mut pg_tm, tzp: *mut pg_tz) -> ::std::os::raw::c_int;
    pub fn DetermineTimeZoneAbbrevOffset(
        tm: *mut pg_tm,
        abbr: *const ::std::os::raw::c_char,
        tzp: *mut pg_tz,
    ) -> ::std::os::raw::c_int;
    pub fn DetermineTimeZoneAbbrevOffsetTS(
        ts: TimestampTz,
        abbr: *const ::std::os::raw::c_char,
        tzp: *mut pg_tz,
        isdst: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn EncodeDateOnly(
        tm: *mut pg_tm,
        style: ::std::os::raw::c_int,
        str_: *mut ::std::os::raw::c_char,
    );
    pub fn EncodeTimeOnly(
        tm: *mut pg_tm,
        fsec: fsec_t,
        print_tz: bool,
        tz: ::std::os::raw::c_int,
        style: ::std::os::raw::c_int,
        str_: *mut ::std::os::raw::c_char,
    );
    pub fn EncodeDateTime(
        tm: *mut pg_tm,
        fsec: fsec_t,
        print_tz: bool,
        tz: ::std::os::raw::c_int,
        tzn: *const ::std::os::raw::c_char,
        style: ::std::os::raw::c_int,
        str_: *mut ::std::os::raw::c_char,
    );
    pub fn EncodeInterval(
        itm: *mut pg_itm,
        style: ::std::os::raw::c_int,
        str_: *mut ::std::os::raw::c_char,
    );
    pub fn EncodeSpecialTimestamp(dt: Timestamp, str_: *mut ::std::os::raw::c_char);
    pub fn ValidateDate(
        fmask: ::std::os::raw::c_int,
        isjulian: bool,
        is2digits: bool,
        bc: bool,
        tm: *mut pg_tm,
    ) -> ::std::os::raw::c_int;
    pub fn DecodeTimezoneAbbrev(
        field: ::std::os::raw::c_int,
        lowtoken: *const ::std::os::raw::c_char,
        ftype: *mut ::std::os::raw::c_int,
        offset: *mut ::std::os::raw::c_int,
        tz: *mut *mut pg_tz,
        extra: *mut DateTimeErrorExtra,
    ) -> ::std::os::raw::c_int;
    pub fn DecodeSpecial(
        field: ::std::os::raw::c_int,
        lowtoken: *const ::std::os::raw::c_char,
        val: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn DecodeUnits(
        field: ::std::os::raw::c_int,
        lowtoken: *const ::std::os::raw::c_char,
        val: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn DecodeTimezoneName(
        tzname: *const ::std::os::raw::c_char,
        offset: *mut ::std::os::raw::c_int,
        tz: *mut *mut pg_tz,
    ) -> ::std::os::raw::c_int;
    pub fn DecodeTimezoneNameToTz(tzname: *const ::std::os::raw::c_char) -> *mut pg_tz;
    pub fn j2day(date: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn TemporalSimplify(max_precis: int32, node: *mut Node) -> *mut Node;
    pub fn CheckDateTokenTables() -> bool;
    pub fn ConvertTimeZoneAbbrevs(
        abbrevs: *mut tzEntry,
        n: ::std::os::raw::c_int,
    ) -> *mut TimeZoneAbbrevTable;
    pub fn InstallTimeZoneAbbrevs(tbl: *mut TimeZoneAbbrevTable);
    pub fn AdjustTimestampForTypmod(
        time: *mut Timestamp,
        typmod: int32,
        escontext: *mut Node,
    ) -> bool;
    pub fn float_overflow_error() -> !;
    pub fn float_underflow_error() -> !;
    pub fn float_zero_divide_error() -> !;
    pub fn is_infinite(val: float8) -> ::std::os::raw::c_int;
    pub fn float8in_internal(
        num: *mut ::std::os::raw::c_char,
        endptr_p: *mut *mut ::std::os::raw::c_char,
        type_name: *const ::std::os::raw::c_char,
        orig_string: *const ::std::os::raw::c_char,
        escontext: *mut Node,
    ) -> float8;
    pub fn float4in_internal(
        num: *mut ::std::os::raw::c_char,
        endptr_p: *mut *mut ::std::os::raw::c_char,
        type_name: *const ::std::os::raw::c_char,
        orig_string: *const ::std::os::raw::c_char,
        escontext: *mut Node,
    ) -> float4;
    pub fn float8out_internal(num: float8) -> *mut ::std::os::raw::c_char;
    pub fn float4_cmp_internal(a: float4, b: float4) -> ::std::os::raw::c_int;
    pub fn float8_cmp_internal(a: float8, b: float8) -> ::std::os::raw::c_int;
    pub fn pg_hypot(x: float8, y: float8) -> float8;
    pub fn escape_json(buf: StringInfo, str_: *const ::std::os::raw::c_char);
    pub fn JsonEncodeDateTime(
        buf: *mut ::std::os::raw::c_char,
        value: Datum,
        typid: Oid,
        tzp: *const ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
    pub fn to_json_is_immutable(typoid: Oid) -> bool;
    pub fn json_build_object_worker(
        nargs: ::std::os::raw::c_int,
        args: *mut Datum,
        nulls: *mut bool,
        types: *mut Oid,
        absent_on_null: bool,
        unique_keys: bool,
    ) -> Datum;
    pub fn json_build_array_worker(
        nargs: ::std::os::raw::c_int,
        args: *mut Datum,
        nulls: *mut bool,
        types: *mut Oid,
        absent_on_null: bool,
    ) -> Datum;
    pub fn json_validate(json: *mut text, check_unique_keys: bool, throw_error: bool) -> bool;
    pub fn numeric_is_nan(num: Numeric) -> bool;
    pub fn numeric_is_inf(num: Numeric) -> bool;
    pub fn numeric_maximum_size(typmod: int32) -> int32;
    pub fn numeric_out_sci(
        num: Numeric,
        scale: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
    pub fn numeric_normalize(num: Numeric) -> *mut ::std::os::raw::c_char;
    pub fn int64_to_numeric(val: int64) -> Numeric;
    pub fn int64_div_fast_to_numeric(val1: int64, log10val2: ::std::os::raw::c_int) -> Numeric;
    pub fn numeric_add_opt_error(num1: Numeric, num2: Numeric, have_error: *mut bool) -> Numeric;
    pub fn numeric_sub_opt_error(num1: Numeric, num2: Numeric, have_error: *mut bool) -> Numeric;
    pub fn numeric_mul_opt_error(num1: Numeric, num2: Numeric, have_error: *mut bool) -> Numeric;
    pub fn numeric_div_opt_error(num1: Numeric, num2: Numeric, have_error: *mut bool) -> Numeric;
    pub fn numeric_mod_opt_error(num1: Numeric, num2: Numeric, have_error: *mut bool) -> Numeric;
    pub fn numeric_int4_opt_error(num: Numeric, have_error: *mut bool) -> int32;
    pub fn getJsonbOffset(jc: *const JsonbContainer, index: ::std::os::raw::c_int) -> uint32;
    pub fn getJsonbLength(jc: *const JsonbContainer, index: ::std::os::raw::c_int) -> uint32;
    pub fn compareJsonbContainers(
        a: *mut JsonbContainer,
        b: *mut JsonbContainer,
    ) -> ::std::os::raw::c_int;
    pub fn findJsonbValueFromContainer(
        container: *mut JsonbContainer,
        flags: uint32,
        key: *mut JsonbValue,
    ) -> *mut JsonbValue;
    pub fn getKeyJsonValueFromContainer(
        container: *mut JsonbContainer,
        keyVal: *const ::std::os::raw::c_char,
        keyLen: ::std::os::raw::c_int,
        res: *mut JsonbValue,
    ) -> *mut JsonbValue;
    pub fn getIthJsonbValueFromContainer(
        container: *mut JsonbContainer,
        i: uint32,
    ) -> *mut JsonbValue;
    pub fn pushJsonbValue(
        pstate: *mut *mut JsonbParseState,
        seq: JsonbIteratorToken,
        jbval: *mut JsonbValue,
    ) -> *mut JsonbValue;
    pub fn JsonbIteratorInit(container: *mut JsonbContainer) -> *mut JsonbIterator;
    pub fn JsonbIteratorNext(
        it: *mut *mut JsonbIterator,
        val: *mut JsonbValue,
        skipNested: bool,
    ) -> JsonbIteratorToken;
    pub fn JsonbToJsonbValue(jsonb: *mut Jsonb, val: *mut JsonbValue);
    pub fn JsonbValueToJsonb(val: *mut JsonbValue) -> *mut Jsonb;
    pub fn JsonbDeepContains(
        val: *mut *mut JsonbIterator,
        mContained: *mut *mut JsonbIterator,
    ) -> bool;
    pub fn JsonbHashScalarValue(scalarVal: *const JsonbValue, hash: *mut uint32);
    pub fn JsonbHashScalarValueExtended(
        scalarVal: *const JsonbValue,
        hash: *mut uint64,
        seed: uint64,
    );
    pub fn JsonbToCString(
        out: StringInfo,
        in_: *mut JsonbContainer,
        estimated_len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
    pub fn JsonbToCStringIndent(
        out: StringInfo,
        in_: *mut JsonbContainer,
        estimated_len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
    pub fn JsonbExtractScalar(jbc: *mut JsonbContainer, res: *mut JsonbValue) -> bool;
    pub fn JsonbTypeName(val: *mut JsonbValue) -> *const ::std::os::raw::c_char;
    pub fn jsonb_set_element(
        jb: *mut Jsonb,
        path: *mut Datum,
        path_len: ::std::os::raw::c_int,
        newval: *mut JsonbValue,
    ) -> Datum;
    pub fn jsonb_get_element(
        jb: *mut Jsonb,
        path: *mut Datum,
        npath: ::std::os::raw::c_int,
        isnull: *mut bool,
        as_text: bool,
    ) -> Datum;
    pub fn to_jsonb_is_immutable(typoid: Oid) -> bool;
    pub fn jsonb_build_object_worker(
        nargs: ::std::os::raw::c_int,
        args: *mut Datum,
        nulls: *mut bool,
        types: *mut Oid,
        absent_on_null: bool,
        unique_keys: bool,
    ) -> Datum;
    pub fn jsonb_build_array_worker(
        nargs: ::std::os::raw::c_int,
        args: *mut Datum,
        nulls: *mut bool,
        types: *mut Oid,
        absent_on_null: bool,
    ) -> Datum;
    pub fn op_in_opfamily(opno: Oid, opfamily: Oid) -> bool;
    pub fn get_op_opfamily_strategy(opno: Oid, opfamily: Oid) -> ::std::os::raw::c_int;
    pub fn get_op_opfamily_sortfamily(opno: Oid, opfamily: Oid) -> Oid;
    pub fn get_op_opfamily_properties(
        opno: Oid,
        opfamily: Oid,
        ordering_op: bool,
        strategy: *mut ::std::os::raw::c_int,
        lefttype: *mut Oid,
        righttype: *mut Oid,
    );
    pub fn get_opfamily_member(
        opfamily: Oid,
        lefttype: Oid,
        righttype: Oid,
        strategy: int16,
    ) -> Oid;
    pub fn get_ordering_op_properties(
        opno: Oid,
        opfamily: *mut Oid,
        opcintype: *mut Oid,
        strategy: *mut int16,
    ) -> bool;
    pub fn get_equality_op_for_ordering_op(opno: Oid, reverse: *mut bool) -> Oid;
    pub fn get_ordering_op_for_equality_op(opno: Oid, use_lhs_type: bool) -> Oid;
    pub fn get_mergejoin_opfamilies(opno: Oid) -> *mut List;
    pub fn get_compatible_hash_operators(opno: Oid, lhs_opno: *mut Oid, rhs_opno: *mut Oid)
        -> bool;
    pub fn get_op_hash_functions(
        opno: Oid,
        lhs_procno: *mut RegProcedure,
        rhs_procno: *mut RegProcedure,
    ) -> bool;
    pub fn get_op_btree_interpretation(opno: Oid) -> *mut List;
    pub fn equality_ops_are_compatible(opno1: Oid, opno2: Oid) -> bool;
    pub fn comparison_ops_are_compatible(opno1: Oid, opno2: Oid) -> bool;
    pub fn get_opfamily_proc(opfamily: Oid, lefttype: Oid, righttype: Oid, procnum: int16) -> Oid;
    pub fn get_attname(
        relid: Oid,
        attnum: AttrNumber,
        missing_ok: bool,
    ) -> *mut ::std::os::raw::c_char;
    pub fn get_attnum(relid: Oid, attname: *const ::std::os::raw::c_char) -> AttrNumber;
    pub fn get_attstattarget(relid: Oid, attnum: AttrNumber) -> ::std::os::raw::c_int;
    pub fn get_attgenerated(relid: Oid, attnum: AttrNumber) -> ::std::os::raw::c_char;
    pub fn get_atttype(relid: Oid, attnum: AttrNumber) -> Oid;
    pub fn get_atttypetypmodcoll(
        relid: Oid,
        attnum: AttrNumber,
        typid: *mut Oid,
        typmod: *mut int32,
        collid: *mut Oid,
    );
    pub fn get_attoptions(relid: Oid, attnum: int16) -> Datum;
    pub fn get_cast_oid(sourcetypeid: Oid, targettypeid: Oid, missing_ok: bool) -> Oid;
    pub fn get_collation_name(colloid: Oid) -> *mut ::std::os::raw::c_char;
    pub fn get_collation_isdeterministic(colloid: Oid) -> bool;
    pub fn get_constraint_name(conoid: Oid) -> *mut ::std::os::raw::c_char;
    pub fn get_constraint_index(conoid: Oid) -> Oid;
    pub fn get_language_name(langoid: Oid, missing_ok: bool) -> *mut ::std::os::raw::c_char;
    pub fn get_opclass_family(opclass: Oid) -> Oid;
    pub fn get_opclass_input_type(opclass: Oid) -> Oid;
    pub fn get_opclass_opfamily_and_input_type(
        opclass: Oid,
        opfamily: *mut Oid,
        opcintype: *mut Oid,
    ) -> bool;
    pub fn get_opcode(opno: Oid) -> RegProcedure;
    pub fn get_opname(opno: Oid) -> *mut ::std::os::raw::c_char;
    pub fn get_op_rettype(opno: Oid) -> Oid;
    pub fn op_input_types(opno: Oid, lefttype: *mut Oid, righttype: *mut Oid);
    pub fn op_mergejoinable(opno: Oid, inputtype: Oid) -> bool;
    pub fn op_hashjoinable(opno: Oid, inputtype: Oid) -> bool;
    pub fn op_strict(opno: Oid) -> bool;
    pub fn op_volatile(opno: Oid) -> ::std::os::raw::c_char;
    pub fn get_commutator(opno: Oid) -> Oid;
    pub fn get_negator(opno: Oid) -> Oid;
    pub fn get_oprrest(opno: Oid) -> RegProcedure;
    pub fn get_oprjoin(opno: Oid) -> RegProcedure;
    pub fn get_func_name(funcid: Oid) -> *mut ::std::os::raw::c_char;
    pub fn get_func_namespace(funcid: Oid) -> Oid;
    pub fn get_func_rettype(funcid: Oid) -> Oid;
    pub fn get_func_nargs(funcid: Oid) -> ::std::os::raw::c_int;
    pub fn get_func_signature(
        funcid: Oid,
        argtypes: *mut *mut Oid,
        nargs: *mut ::std::os::raw::c_int,
    ) -> Oid;
    pub fn get_func_variadictype(funcid: Oid) -> Oid;
    pub fn get_func_retset(funcid: Oid) -> bool;
    pub fn func_strict(funcid: Oid) -> bool;
    pub fn func_volatile(funcid: Oid) -> ::std::os::raw::c_char;
    pub fn func_parallel(funcid: Oid) -> ::std::os::raw::c_char;
    pub fn get_func_prokind(funcid: Oid) -> ::std::os::raw::c_char;
    pub fn get_func_leakproof(funcid: Oid) -> bool;
    pub fn get_func_support(funcid: Oid) -> RegProcedure;
    pub fn get_relname_relid(relname: *const ::std::os::raw::c_char, relnamespace: Oid) -> Oid;
    pub fn get_rel_name(relid: Oid) -> *mut ::std::os::raw::c_char;
    pub fn get_rel_namespace(relid: Oid) -> Oid;
    pub fn get_rel_type_id(relid: Oid) -> Oid;
    pub fn get_rel_relkind(relid: Oid) -> ::std::os::raw::c_char;
    pub fn get_rel_relispartition(relid: Oid) -> bool;
    pub fn get_rel_tablespace(relid: Oid) -> Oid;
    pub fn get_rel_persistence(relid: Oid) -> ::std::os::raw::c_char;
    pub fn get_transform_fromsql(typid: Oid, langid: Oid, trftypes: *mut List) -> Oid;
    pub fn get_transform_tosql(typid: Oid, langid: Oid, trftypes: *mut List) -> Oid;
    pub fn get_typisdefined(typid: Oid) -> bool;
    pub fn get_typlen(typid: Oid) -> int16;
    pub fn get_typbyval(typid: Oid) -> bool;
    pub fn get_typlenbyval(typid: Oid, typlen: *mut int16, typbyval: *mut bool);
    pub fn get_typlenbyvalalign(
        typid: Oid,
        typlen: *mut int16,
        typbyval: *mut bool,
        typalign: *mut ::std::os::raw::c_char,
    );
    pub fn getTypeIOParam(typeTuple: HeapTuple) -> Oid;
    pub fn get_type_io_data(
        typid: Oid,
        which_func: IOFuncSelector,
        typlen: *mut int16,
        typbyval: *mut bool,
        typalign: *mut ::std::os::raw::c_char,
        typdelim: *mut ::std::os::raw::c_char,
        typioparam: *mut Oid,
        func: *mut Oid,
    );
    pub fn get_typstorage(typid: Oid) -> ::std::os::raw::c_char;
    pub fn get_typdefault(typid: Oid) -> *mut Node;
    pub fn get_typtype(typid: Oid) -> ::std::os::raw::c_char;
    pub fn type_is_rowtype(typid: Oid) -> bool;
    pub fn type_is_enum(typid: Oid) -> bool;
    pub fn type_is_range(typid: Oid) -> bool;
    pub fn type_is_multirange(typid: Oid) -> bool;
    pub fn get_type_category_preferred(
        typid: Oid,
        typcategory: *mut ::std::os::raw::c_char,
        typispreferred: *mut bool,
    );
    pub fn get_typ_typrelid(typid: Oid) -> Oid;
    pub fn get_element_type(typid: Oid) -> Oid;
    pub fn get_array_type(typid: Oid) -> Oid;
    pub fn get_promoted_array_type(typid: Oid) -> Oid;
    pub fn get_base_element_type(typid: Oid) -> Oid;
    pub fn getTypeInputInfo(type_: Oid, typInput: *mut Oid, typIOParam: *mut Oid);
    pub fn getTypeOutputInfo(type_: Oid, typOutput: *mut Oid, typIsVarlena: *mut bool);
    pub fn getTypeBinaryInputInfo(type_: Oid, typReceive: *mut Oid, typIOParam: *mut Oid);
    pub fn getTypeBinaryOutputInfo(type_: Oid, typSend: *mut Oid, typIsVarlena: *mut bool);
    pub fn get_typmodin(typid: Oid) -> Oid;
    pub fn get_typcollation(typid: Oid) -> Oid;
    pub fn type_is_collatable(typid: Oid) -> bool;
    pub fn get_typsubscript(typid: Oid, typelemp: *mut Oid) -> RegProcedure;
    pub fn getSubscriptingRoutines(typid: Oid, typelemp: *mut Oid) -> *const SubscriptRoutines;
    pub fn getBaseType(typid: Oid) -> Oid;
    pub fn getBaseTypeAndTypmod(typid: Oid, typmod: *mut int32) -> Oid;
    pub fn get_typavgwidth(typid: Oid, typmod: int32) -> int32;
    pub fn get_attavgwidth(relid: Oid, attnum: AttrNumber) -> int32;
    pub fn get_attstatsslot(
        sslot: *mut AttStatsSlot,
        statstuple: HeapTuple,
        reqkind: ::std::os::raw::c_int,
        reqop: Oid,
        flags: ::std::os::raw::c_int,
    ) -> bool;
    pub fn free_attstatsslot(sslot: *mut AttStatsSlot);
    pub fn get_namespace_name(nspid: Oid) -> *mut ::std::os::raw::c_char;
    pub fn get_namespace_name_or_temp(nspid: Oid) -> *mut ::std::os::raw::c_char;
    pub fn get_range_subtype(rangeOid: Oid) -> Oid;
    pub fn get_range_collation(rangeOid: Oid) -> Oid;
    pub fn get_range_multirange(rangeOid: Oid) -> Oid;
    pub fn get_multirange_range(multirangeOid: Oid) -> Oid;
    pub fn get_index_column_opclass(index_oid: Oid, attno: ::std::os::raw::c_int) -> Oid;
    pub fn get_index_isreplident(index_oid: Oid) -> bool;
    pub fn get_index_isvalid(index_oid: Oid) -> bool;
    pub fn get_index_isclustered(index_oid: Oid) -> bool;
    pub fn get_publication_oid(pubname: *const ::std::os::raw::c_char, missing_ok: bool) -> Oid;
    pub fn get_publication_name(pubid: Oid, missing_ok: bool) -> *mut ::std::os::raw::c_char;
    pub fn get_subscription_oid(subname: *const ::std::os::raw::c_char, missing_ok: bool) -> Oid;
    pub fn get_subscription_name(subid: Oid, missing_ok: bool) -> *mut ::std::os::raw::c_char;
    pub fn pg_prng_seed(state: *mut pg_prng_state, seed: uint64);
    pub fn pg_prng_fseed(state: *mut pg_prng_state, fseed: f64);
    pub fn pg_prng_seed_check(state: *mut pg_prng_state) -> bool;
    pub fn pg_prng_uint64(state: *mut pg_prng_state) -> uint64;
    pub fn pg_prng_uint64_range(state: *mut pg_prng_state, rmin: uint64, rmax: uint64) -> uint64;
    pub fn pg_prng_int64(state: *mut pg_prng_state) -> int64;
    pub fn pg_prng_int64p(state: *mut pg_prng_state) -> int64;
    pub fn pg_prng_uint32(state: *mut pg_prng_state) -> uint32;
    pub fn pg_prng_int32(state: *mut pg_prng_state) -> int32;
    pub fn pg_prng_int32p(state: *mut pg_prng_state) -> int32;
    pub fn pg_prng_double(state: *mut pg_prng_state) -> f64;
    pub fn pg_prng_double_normal(state: *mut pg_prng_state) -> f64;
    pub fn pg_prng_bool(state: *mut pg_prng_state) -> bool;
    pub fn sampler_random_init_state(seed: uint32, randstate: *mut pg_prng_state);
    pub fn sampler_random_fract(randstate: *mut pg_prng_state) -> f64;
    pub fn BlockSampler_Init(
        bs: BlockSampler,
        nblocks: BlockNumber,
        samplesize: ::std::os::raw::c_int,
        randseed: uint32,
    ) -> BlockNumber;
    pub fn BlockSampler_HasMore(bs: BlockSampler) -> bool;
    pub fn BlockSampler_Next(bs: BlockSampler) -> BlockNumber;
    pub fn reservoir_init_selection_state(rs: ReservoirState, n: ::std::os::raw::c_int);
    pub fn reservoir_get_next_S(rs: ReservoirState, t: f64, n: ::std::os::raw::c_int) -> f64;
    pub fn examine_variable(
        root: *mut PlannerInfo,
        node: *mut Node,
        varRelid: ::std::os::raw::c_int,
        vardata: *mut VariableStatData,
    );
    pub fn statistic_proc_security_check(vardata: *mut VariableStatData, func_oid: Oid) -> bool;
    pub fn get_restriction_variable(
        root: *mut PlannerInfo,
        args: *mut List,
        varRelid: ::std::os::raw::c_int,
        vardata: *mut VariableStatData,
        other: *mut *mut Node,
        varonleft: *mut bool,
    ) -> bool;
    pub fn get_join_variables(
        root: *mut PlannerInfo,
        args: *mut List,
        sjinfo: *mut SpecialJoinInfo,
        vardata1: *mut VariableStatData,
        vardata2: *mut VariableStatData,
        join_is_reversed: *mut bool,
    );
    pub fn get_variable_numdistinct(vardata: *mut VariableStatData, isdefault: *mut bool) -> f64;
    pub fn mcv_selectivity(
        vardata: *mut VariableStatData,
        opproc: *mut FmgrInfo,
        collation: Oid,
        constval: Datum,
        varonleft: bool,
        sumcommonp: *mut f64,
    ) -> f64;
    pub fn histogram_selectivity(
        vardata: *mut VariableStatData,
        opproc: *mut FmgrInfo,
        collation: Oid,
        constval: Datum,
        varonleft: bool,
        min_hist_size: ::std::os::raw::c_int,
        n_skip: ::std::os::raw::c_int,
        hist_size: *mut ::std::os::raw::c_int,
    ) -> f64;
    pub fn generic_restriction_selectivity(
        root: *mut PlannerInfo,
        oproid: Oid,
        collation: Oid,
        args: *mut List,
        varRelid: ::std::os::raw::c_int,
        default_selectivity: f64,
    ) -> f64;
    pub fn ineq_histogram_selectivity(
        root: *mut PlannerInfo,
        vardata: *mut VariableStatData,
        opoid: Oid,
        opproc: *mut FmgrInfo,
        isgt: bool,
        iseq: bool,
        collation: Oid,
        constval: Datum,
        consttype: Oid,
    ) -> f64;
    pub fn var_eq_const(
        vardata: *mut VariableStatData,
        oproid: Oid,
        collation: Oid,
        constval: Datum,
        constisnull: bool,
        varonleft: bool,
        negate: bool,
    ) -> f64;
    pub fn var_eq_non_const(
        vardata: *mut VariableStatData,
        oproid: Oid,
        collation: Oid,
        other: *mut Node,
        varonleft: bool,
        negate: bool,
    ) -> f64;
    pub fn boolvarsel(
        root: *mut PlannerInfo,
        arg: *mut Node,
        varRelid: ::std::os::raw::c_int,
    ) -> Selectivity;
    pub fn booltestsel(
        root: *mut PlannerInfo,
        booltesttype: BoolTestType,
        arg: *mut Node,
        varRelid: ::std::os::raw::c_int,
        jointype: JoinType,
        sjinfo: *mut SpecialJoinInfo,
    ) -> Selectivity;
    pub fn nulltestsel(
        root: *mut PlannerInfo,
        nulltesttype: NullTestType,
        arg: *mut Node,
        varRelid: ::std::os::raw::c_int,
        jointype: JoinType,
        sjinfo: *mut SpecialJoinInfo,
    ) -> Selectivity;
    pub fn scalararraysel(
        root: *mut PlannerInfo,
        clause: *mut ScalarArrayOpExpr,
        is_join_clause: bool,
        varRelid: ::std::os::raw::c_int,
        jointype: JoinType,
        sjinfo: *mut SpecialJoinInfo,
    ) -> Selectivity;
    pub fn estimate_array_length(arrayexpr: *mut Node) -> ::std::os::raw::c_int;
    pub fn rowcomparesel(
        root: *mut PlannerInfo,
        clause: *mut RowCompareExpr,
        varRelid: ::std::os::raw::c_int,
        jointype: JoinType,
        sjinfo: *mut SpecialJoinInfo,
    ) -> Selectivity;
    pub fn mergejoinscansel(
        root: *mut PlannerInfo,
        clause: *mut Node,
        opfamily: Oid,
        strategy: ::std::os::raw::c_int,
        nulls_first: bool,
        leftstart: *mut Selectivity,
        leftend: *mut Selectivity,
        rightstart: *mut Selectivity,
        rightend: *mut Selectivity,
    );
    pub fn estimate_num_groups(
        root: *mut PlannerInfo,
        groupExprs: *mut List,
        input_rows: f64,
        pgset: *mut *mut List,
        estinfo: *mut EstimationInfo,
    ) -> f64;
    pub fn estimate_hash_bucket_stats(
        root: *mut PlannerInfo,
        hashkey: *mut Node,
        nbuckets: f64,
        mcv_freq: *mut Selectivity,
        bucketsize_frac: *mut Selectivity,
    );
    pub fn estimate_hashagg_tablesize(
        root: *mut PlannerInfo,
        path: *mut Path,
        agg_costs: *const AggClauseCosts,
        dNumGroups: f64,
    ) -> f64;
    pub fn get_quals_from_indexclauses(indexclauses: *mut List) -> *mut List;
    pub fn index_other_operands_eval_cost(root: *mut PlannerInfo, indexquals: *mut List) -> Cost;
    pub fn add_predicate_to_index_quals(
        index: *mut IndexOptInfo,
        indexQuals: *mut List,
    ) -> *mut List;
    pub fn genericcostestimate(
        root: *mut PlannerInfo,
        path: *mut IndexPath,
        loop_count: f64,
        costs: *mut GenericCosts,
    );
    pub fn scalararraysel_containment(
        root: *mut PlannerInfo,
        leftop: *mut Node,
        rightop: *mut Node,
        elemtype: Oid,
        isEquality: bool,
        useOr: bool,
        varRelid: ::std::os::raw::c_int,
    ) -> Selectivity;
    pub fn CreateCacheMemoryContext();
    pub fn InitCatCache(
        id: ::std::os::raw::c_int,
        reloid: Oid,
        indexoid: Oid,
        nkeys: ::std::os::raw::c_int,
        key: *const ::std::os::raw::c_int,
        nbuckets: ::std::os::raw::c_int,
    ) -> *mut CatCache;
    pub fn InitCatCachePhase2(cache: *mut CatCache, touch_index: bool);
    pub fn SearchCatCache(
        cache: *mut CatCache,
        v1: Datum,
        v2: Datum,
        v3: Datum,
        v4: Datum,
    ) -> HeapTuple;
    pub fn SearchCatCache1(cache: *mut CatCache, v1: Datum) -> HeapTuple;
    pub fn SearchCatCache2(cache: *mut CatCache, v1: Datum, v2: Datum) -> HeapTuple;
    pub fn SearchCatCache3(cache: *mut CatCache, v1: Datum, v2: Datum, v3: Datum) -> HeapTuple;
    pub fn SearchCatCache4(
        cache: *mut CatCache,
        v1: Datum,
        v2: Datum,
        v3: Datum,
        v4: Datum,
    ) -> HeapTuple;
    pub fn ReleaseCatCache(tuple: HeapTuple);
    pub fn GetCatCacheHashValue(
        cache: *mut CatCache,
        v1: Datum,
        v2: Datum,
        v3: Datum,
        v4: Datum,
    ) -> uint32;
    pub fn SearchCatCacheList(
        cache: *mut CatCache,
        nkeys: ::std::os::raw::c_int,
        v1: Datum,
        v2: Datum,
        v3: Datum,
    ) -> *mut CatCList;
    pub fn ReleaseCatCacheList(list: *mut CatCList);
    pub fn ResetCatalogCaches();
    pub fn CatalogCacheFlushCatalog(catId: Oid);
    pub fn CatCacheInvalidate(cache: *mut CatCache, hashValue: uint32);
    pub fn PrepareToInvalidateCacheTuple(
        relation: Relation,
        tuple: HeapTuple,
        newtuple: HeapTuple,
        function: ::std::option::Option<
            unsafe extern "C" fn(arg1: ::std::os::raw::c_int, arg2: uint32, arg3: Oid),
        >,
    );
    pub fn PrintCatCacheLeakWarning(tuple: HeapTuple);
    pub fn PrintCatCacheListLeakWarning(list: *mut CatCList);
    pub fn InitCatalogCache();
    pub fn InitCatalogCachePhase2();
    pub fn SearchSysCache(
        cacheId: ::std::os::raw::c_int,
        key1: Datum,
        key2: Datum,
        key3: Datum,
        key4: Datum,
    ) -> HeapTuple;
    pub fn SearchSysCache1(cacheId: ::std::os::raw::c_int, key1: Datum) -> HeapTuple;
    pub fn SearchSysCache2(cacheId: ::std::os::raw::c_int, key1: Datum, key2: Datum) -> HeapTuple;
    pub fn SearchSysCache3(
        cacheId: ::std::os::raw::c_int,
        key1: Datum,
        key2: Datum,
        key3: Datum,
    ) -> HeapTuple;
    pub fn SearchSysCache4(
        cacheId: ::std::os::raw::c_int,
        key1: Datum,
        key2: Datum,
        key3: Datum,
        key4: Datum,
    ) -> HeapTuple;
    pub fn ReleaseSysCache(tuple: HeapTuple);
    pub fn SearchSysCacheCopy(
        cacheId: ::std::os::raw::c_int,
        key1: Datum,
        key2: Datum,
        key3: Datum,
        key4: Datum,
    ) -> HeapTuple;
    pub fn SearchSysCacheExists(
        cacheId: ::std::os::raw::c_int,
        key1: Datum,
        key2: Datum,
        key3: Datum,
        key4: Datum,
    ) -> bool;
    pub fn GetSysCacheOid(
        cacheId: ::std::os::raw::c_int,
        oidcol: AttrNumber,
        key1: Datum,
        key2: Datum,
        key3: Datum,
        key4: Datum,
    ) -> Oid;
    pub fn SearchSysCacheAttName(relid: Oid, attname: *const ::std::os::raw::c_char) -> HeapTuple;
    pub fn SearchSysCacheCopyAttName(
        relid: Oid,
        attname: *const ::std::os::raw::c_char,
    ) -> HeapTuple;
    pub fn SearchSysCacheExistsAttName(relid: Oid, attname: *const ::std::os::raw::c_char) -> bool;
    pub fn SearchSysCacheAttNum(relid: Oid, attnum: int16) -> HeapTuple;
    pub fn SearchSysCacheCopyAttNum(relid: Oid, attnum: int16) -> HeapTuple;
    pub fn SysCacheGetAttr(
        cacheId: ::std::os::raw::c_int,
        tup: HeapTuple,
        attributeNumber: AttrNumber,
        isNull: *mut bool,
    ) -> Datum;
    pub fn SysCacheGetAttrNotNull(
        cacheId: ::std::os::raw::c_int,
        tup: HeapTuple,
        attributeNumber: AttrNumber,
    ) -> Datum;
    pub fn GetSysCacheHashValue(
        cacheId: ::std::os::raw::c_int,
        key1: Datum,
        key2: Datum,
        key3: Datum,
        key4: Datum,
    ) -> uint32;
    pub fn SearchSysCacheList(
        cacheId: ::std::os::raw::c_int,
        nkeys: ::std::os::raw::c_int,
        key1: Datum,
        key2: Datum,
        key3: Datum,
    ) -> *mut catclist;
    pub fn SysCacheInvalidate(cacheId: ::std::os::raw::c_int, hashValue: uint32);
    pub fn RelationInvalidatesSnapshotsOnly(relid: Oid) -> bool;
    pub fn RelationHasSysCache(relid: Oid) -> bool;
    pub fn RelationSupportsSysCache(relid: Oid) -> bool;
    pub fn range_contains_elem_internal(
        typcache: *mut TypeCacheEntry,
        r: *const RangeType,
        val: Datum,
    ) -> bool;
    pub fn range_eq_internal(
        typcache: *mut TypeCacheEntry,
        r1: *const RangeType,
        r2: *const RangeType,
    ) -> bool;
    pub fn range_ne_internal(
        typcache: *mut TypeCacheEntry,
        r1: *const RangeType,
        r2: *const RangeType,
    ) -> bool;
    pub fn range_contains_internal(
        typcache: *mut TypeCacheEntry,
        r1: *const RangeType,
        r2: *const RangeType,
    ) -> bool;
    pub fn range_contained_by_internal(
        typcache: *mut TypeCacheEntry,
        r1: *const RangeType,
        r2: *const RangeType,
    ) -> bool;
    pub fn range_before_internal(
        typcache: *mut TypeCacheEntry,
        r1: *const RangeType,
        r2: *const RangeType,
    ) -> bool;
    pub fn range_after_internal(
        typcache: *mut TypeCacheEntry,
        r1: *const RangeType,
        r2: *const RangeType,
    ) -> bool;
    pub fn range_adjacent_internal(
        typcache: *mut TypeCacheEntry,
        r1: *const RangeType,
        r2: *const RangeType,
    ) -> bool;
    pub fn range_overlaps_internal(
        typcache: *mut TypeCacheEntry,
        r1: *const RangeType,
        r2: *const RangeType,
    ) -> bool;
    pub fn range_overleft_internal(
        typcache: *mut TypeCacheEntry,
        r1: *const RangeType,
        r2: *const RangeType,
    ) -> bool;
    pub fn range_overright_internal(
        typcache: *mut TypeCacheEntry,
        r1: *const RangeType,
        r2: *const RangeType,
    ) -> bool;
    pub fn range_union_internal(
        typcache: *mut TypeCacheEntry,
        r1: *mut RangeType,
        r2: *mut RangeType,
        strict: bool,
    ) -> *mut RangeType;
    pub fn range_minus_internal(
        typcache: *mut TypeCacheEntry,
        r1: *mut RangeType,
        r2: *mut RangeType,
    ) -> *mut RangeType;
    pub fn range_intersect_internal(
        typcache: *mut TypeCacheEntry,
        r1: *const RangeType,
        r2: *const RangeType,
    ) -> *mut RangeType;
    pub fn range_get_typcache(fcinfo: FunctionCallInfo, rngtypid: Oid) -> *mut TypeCacheEntry;
    pub fn range_serialize(
        typcache: *mut TypeCacheEntry,
        lower: *mut RangeBound,
        upper: *mut RangeBound,
        empty: bool,
        escontext: *mut Node,
    ) -> *mut RangeType;
    pub fn range_deserialize(
        typcache: *mut TypeCacheEntry,
        range: *const RangeType,
        lower: *mut RangeBound,
        upper: *mut RangeBound,
        empty: *mut bool,
    );
    pub fn range_get_flags(range: *const RangeType) -> ::std::os::raw::c_char;
    pub fn range_set_contain_empty(range: *mut RangeType);
    pub fn make_range(
        typcache: *mut TypeCacheEntry,
        lower: *mut RangeBound,
        upper: *mut RangeBound,
        empty: bool,
        escontext: *mut Node,
    ) -> *mut RangeType;
    pub fn range_cmp_bounds(
        typcache: *mut TypeCacheEntry,
        b1: *const RangeBound,
        b2: *const RangeBound,
    ) -> ::std::os::raw::c_int;
    pub fn range_cmp_bound_values(
        typcache: *mut TypeCacheEntry,
        b1: *const RangeBound,
        b2: *const RangeBound,
    ) -> ::std::os::raw::c_int;
    pub fn range_compare(
        key1: *const ::std::os::raw::c_void,
        key2: *const ::std::os::raw::c_void,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
    pub fn bounds_adjacent(
        typcache: *mut TypeCacheEntry,
        boundA: RangeBound,
        boundB: RangeBound,
    ) -> bool;
    pub fn make_empty_range(typcache: *mut TypeCacheEntry) -> *mut RangeType;
    pub fn range_split_internal(
        typcache: *mut TypeCacheEntry,
        r1: *const RangeType,
        r2: *const RangeType,
        output1: *mut *mut RangeType,
        output2: *mut *mut RangeType,
    ) -> bool;
}
extern "C" {
    pub static mut error_context_stack: *mut ErrorContextCallback;
    pub static mut PG_exception_stack: *mut sigjmp_buf;
    pub static mut emit_log_hook: emit_log_hook_type;
    pub static mut Log_error_verbosity: ::std::os::raw::c_int;
    pub static mut Log_line_prefix: *mut ::std::os::raw::c_char;
    pub static mut Log_destination: ::std::os::raw::c_int;
    pub static mut Log_destination_string: *mut ::std::os::raw::c_char;
    pub static mut syslog_sequence_numbers: bool;
    pub static mut syslog_split_messages: bool;
    pub static mut CurrentMemoryContext: MemoryContext;
    pub static mut no_such_variable: ::std::os::raw::c_int;
    pub static mut ShmemVariableCache: VariableCache;
    pub static TTSOpsVirtual: TupleTableSlotOps;
    pub static TTSOpsHeapTuple: TupleTableSlotOps;
    pub static TTSOpsMinimalTuple: TupleTableSlotOps;
    pub static TTSOpsBufferHeapTuple: TupleTableSlotOps;
    pub static mut pgBufferUsage: BufferUsage;
    pub static mut pgWalUsage: WalUsage;
    pub static mut Dynamic_library_path: *mut ::std::os::raw::c_char;
    pub static mut needs_fmgr_hook: needs_fmgr_hook_type;
    pub static mut fmgr_hook: fmgr_hook_type;
    pub static forkNames: [*const ::std::os::raw::c_char; 0usize];
    pub static mut dynamic_shared_memory_type: ::std::os::raw::c_int;
    pub static mut min_dynamic_shared_memory: ::std::os::raw::c_int;
    pub static mut dummy_spinlock: slock_t;
    pub static mut max_files_per_process: ::std::os::raw::c_int;
    pub static mut data_sync_retry: bool;
    pub static mut recovery_init_sync_method: ::std::os::raw::c_int;
    pub static mut io_direct_flags: ::std::os::raw::c_int;
    pub static mut max_safe_fds: ::std::os::raw::c_int;
    pub static mut criticalRelcachesBuilt: bool;
    pub static mut criticalSharedRelcachesBuilt: bool;
    pub static pg_leftmost_one_pos: [uint8; 256usize];
    pub static pg_rightmost_one_pos: [uint8; 256usize];
    pub static pg_number_of_ones: [uint8; 256usize];
    pub static mut pg_popcount32:
        ::std::option::Option<unsafe extern "C" fn(word: uint32) -> ::std::os::raw::c_int>;
    pub static mut pg_popcount64:
        ::std::option::Option<unsafe extern "C" fn(word: uint64) -> ::std::os::raw::c_int>;
    pub static mut None_Receiver: *mut DestReceiver;
    pub static mut TopMemoryContext: MemoryContext;
    pub static mut ErrorContext: MemoryContext;
    pub static mut PostmasterContext: MemoryContext;
    pub static mut CacheMemoryContext: MemoryContext;
    pub static mut MessageContext: MemoryContext;
    pub static mut TopTransactionContext: MemoryContext;
    pub static mut CurTransactionContext: MemoryContext;
    pub static mut PortalContext: MemoryContext;
    pub static mut ExecutorStart_hook: ExecutorStart_hook_type;
    pub static mut ExecutorRun_hook: ExecutorRun_hook_type;
    pub static mut ExecutorFinish_hook: ExecutorFinish_hook_type;
    pub static mut ExecutorEnd_hook: ExecutorEnd_hook_type;
    pub static mut ExecutorCheckPerms_hook: ExecutorCheckPerms_hook_type;
    pub static mut session_timezone: *mut pg_tz;
    pub static mut log_timezone: *mut pg_tz;
    #[doc = "\t  System interrupt and critical section handling\n\n There are two types of interrupts that a running backend needs to accept\n without messing up its state: QueryCancel (SIGINT) and ProcDie (SIGTERM).\n In both cases, we need to be able to clean up the current transaction\n gracefully, so we can't respond to the interrupt instantaneously ---\n there's no guarantee that internal data structures would be self-consistent\n if the code is interrupted at an arbitrary instant.  Instead, the signal\n handlers set flags that are checked periodically during execution.\n\n The CHECK_FOR_INTERRUPTS() macro is called at strategically located spots\n where it is normally safe to accept a cancel or die interrupt.  In some\n cases, we invoke CHECK_FOR_INTERRUPTS() inside low-level subroutines that\n might sometimes be called in contexts that do *not* want to allow a cancel\n or die interrupt.  The HOLD_INTERRUPTS() and RESUME_INTERRUPTS() macros\n allow code to ensure that no cancel or die interrupt will be accepted,\n even if CHECK_FOR_INTERRUPTS() gets called in a subroutine.  The interrupt\n will be held off until CHECK_FOR_INTERRUPTS() is done outside any\n HOLD_INTERRUPTS() ... RESUME_INTERRUPTS() section.\n\n There is also a mechanism to prevent query cancel interrupts, while still\n allowing die interrupts: HOLD_CANCEL_INTERRUPTS() and\n RESUME_CANCEL_INTERRUPTS().\n\n Note that ProcessInterrupts() has also acquired a number of tasks that\n do not necessarily cause a query-cancel-or-die response.  Hence, it's\n possible that it will just clear InterruptPending and return.\n\n INTERRUPTS_PENDING_CONDITION() can be checked to see whether an\n interrupt needs to be serviced, without trying to do so immediately.\n Some callers are also interested in INTERRUPTS_CAN_BE_PROCESSED(),\n which tells whether ProcessInterrupts is sure to clear the interrupt.\n\n Special mechanisms are used to let an interrupt be accepted when we are\n waiting for a lock or when we are waiting for command input (but, of\n course, only if the interrupt holdoff counter is zero).  See the\n related code for details.\n\n A lost connection is handled similarly, although the loss of connection\n does not raise a signal, but is detected when we fail to write to the\n socket. If there was a signal for a broken connection, we could make use of\n it by setting ClientConnectionLost in the signal handler.\n\n A related, but conceptually distinct, mechanism is the \"critical section\"\n mechanism.  A critical section not only holds off cancel/die interrupts,\n but causes any ereport(ERROR) or ereport(FATAL) to become ereport(PANIC)\n --- that is, a system-wide reset is forced.  Needless to say, only really\n *critical* code should be marked as a critical section!\tCurrently, this\n mechanism is only used for XLOG-related code.\n"]
    pub static mut InterruptPending: sig_atomic_t;
    pub static mut QueryCancelPending: sig_atomic_t;
    pub static mut ProcDiePending: sig_atomic_t;
    pub static mut IdleInTransactionSessionTimeoutPending: sig_atomic_t;
    pub static mut IdleSessionTimeoutPending: sig_atomic_t;
    pub static mut ProcSignalBarrierPending: sig_atomic_t;
    pub static mut LogMemoryContextPending: sig_atomic_t;
    pub static mut IdleStatsUpdateTimeoutPending: sig_atomic_t;
    pub static mut CheckClientConnectionPending: sig_atomic_t;
    pub static mut ClientConnectionLost: sig_atomic_t;
    pub static mut InterruptHoldoffCount: uint32;
    pub static mut QueryCancelHoldoffCount: uint32;
    pub static mut CritSectionCount: uint32;
    #[doc = "\t  globals.h --\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t *"]
    pub static mut PostmasterPid: pid_t;
    pub static mut IsPostmasterEnvironment: bool;
    pub static mut IsUnderPostmaster: bool;
    pub static mut IsBackgroundWorker: bool;
    pub static mut IsBinaryUpgrade: bool;
    pub static mut ExitOnAnyError: bool;
    pub static mut DataDir: *mut ::std::os::raw::c_char;
    pub static mut data_directory_mode: ::std::os::raw::c_int;
    pub static mut NBuffers: ::std::os::raw::c_int;
    pub static mut MaxBackends: ::std::os::raw::c_int;
    pub static mut MaxConnections: ::std::os::raw::c_int;
    pub static mut max_worker_processes: ::std::os::raw::c_int;
    pub static mut max_parallel_workers: ::std::os::raw::c_int;
    pub static mut MyProcPid: ::std::os::raw::c_int;
    pub static mut MyStartTime: pg_time_t;
    pub static mut MyStartTimestamp: TimestampTz;
    pub static mut MyProcPort: *mut Port;
    pub static mut MyLatch: *mut Latch;
    pub static mut MyCancelKey: int32;
    pub static mut MyPMChildSlot: ::std::os::raw::c_int;
    pub static mut OutputFileName: [::std::os::raw::c_char; 0usize];
    pub static mut my_exec_path: [::std::os::raw::c_char; 0usize];
    pub static mut pkglib_path: [::std::os::raw::c_char; 0usize];
    pub static mut MyDatabaseId: Oid;
    pub static mut MyDatabaseTableSpace: Oid;
    pub static mut DateStyle: ::std::os::raw::c_int;
    pub static mut DateOrder: ::std::os::raw::c_int;
    pub static mut IntervalStyle: ::std::os::raw::c_int;
    pub static mut enableFsync: bool;
    pub static mut allowSystemTableMods: bool;
    pub static mut work_mem: ::std::os::raw::c_int;
    pub static mut hash_mem_multiplier: f64;
    pub static mut maintenance_work_mem: ::std::os::raw::c_int;
    pub static mut max_parallel_maintenance_workers: ::std::os::raw::c_int;
    pub static mut VacuumBufferUsageLimit: ::std::os::raw::c_int;
    pub static mut VacuumCostPageHit: ::std::os::raw::c_int;
    pub static mut VacuumCostPageMiss: ::std::os::raw::c_int;
    pub static mut VacuumCostPageDirty: ::std::os::raw::c_int;
    pub static mut VacuumCostLimit: ::std::os::raw::c_int;
    pub static mut VacuumCostDelay: f64;
    pub static mut VacuumPageHit: int64;
    pub static mut VacuumPageMiss: int64;
    pub static mut VacuumPageDirty: int64;
    pub static mut VacuumCostBalance: ::std::os::raw::c_int;
    pub static mut VacuumCostActive: bool;
    pub static mut trace_recovery_messages: ::std::os::raw::c_int;
    pub static mut DatabasePath: *mut ::std::os::raw::c_char;
    pub static mut MyBackendType: BackendType;
    pub static mut Mode: ProcessingMode;
    pub static mut MyAuxProcType: AuxProcType;
    pub static mut IgnoreSystemIndexes: bool;
    pub static mut process_shared_preload_libraries_in_progress: bool;
    pub static mut process_shared_preload_libraries_done: bool;
    pub static mut process_shmem_requests_in_progress: bool;
    pub static mut session_preload_libraries_string: *mut ::std::os::raw::c_char;
    pub static mut shared_preload_libraries_string: *mut ::std::os::raw::c_char;
    pub static mut local_preload_libraries_string: *mut ::std::os::raw::c_char;
    pub static mut shmem_request_hook: shmem_request_hook_type;
    pub static mut Db_user_namespace: bool;
    pub static mut MyBackendId: BackendId;
    pub static mut ParallelLeaderBackendId: BackendId;
    pub static mut pgstat_track_activities: bool;
    pub static mut pgstat_track_activity_query_size: ::std::os::raw::c_int;
    pub static mut MyBEEntry: *mut PgBackendStatus;
    pub static mut my_wait_event_info: *mut uint32;
    pub static mut pgstat_track_counts: bool;
    pub static mut pgstat_track_functions: ::std::os::raw::c_int;
    pub static mut pgstat_fetch_consistency: ::std::os::raw::c_int;
    pub static mut PendingBgWriterStats: PgStat_BgWriterStats;
    pub static mut PendingCheckpointerStats: PgStat_CheckpointerStats;
    pub static mut pgStatBlockReadTime: PgStat_Counter;
    pub static mut pgStatBlockWriteTime: PgStat_Counter;
    pub static mut pgStatActiveTime: PgStat_Counter;
    pub static mut pgStatTransactionIdleTime: PgStat_Counter;
    pub static mut pgStatSessionEndCause: SessionEndType;
    pub static mut PendingWalStats: PgStat_PendingWalStats;
    pub static mut sync_method: ::std::os::raw::c_int;
    pub static mut ProcLastRecPtr: XLogRecPtr;
    pub static mut XactLastRecEnd: XLogRecPtr;
    pub static mut XactLastCommitEnd: XLogRecPtr;
    pub static mut wal_segment_size: ::std::os::raw::c_int;
    pub static mut min_wal_size_mb: ::std::os::raw::c_int;
    pub static mut max_wal_size_mb: ::std::os::raw::c_int;
    pub static mut wal_keep_size_mb: ::std::os::raw::c_int;
    pub static mut max_slot_wal_keep_size_mb: ::std::os::raw::c_int;
    pub static mut XLOGbuffers: ::std::os::raw::c_int;
    pub static mut XLogArchiveTimeout: ::std::os::raw::c_int;
    pub static mut wal_retrieve_retry_interval: ::std::os::raw::c_int;
    pub static mut XLogArchiveCommand: *mut ::std::os::raw::c_char;
    pub static mut EnableHotStandby: bool;
    pub static mut fullPageWrites: bool;
    pub static mut wal_log_hints: bool;
    pub static mut wal_compression: ::std::os::raw::c_int;
    pub static mut wal_init_zero: bool;
    pub static mut wal_recycle: bool;
    pub static mut wal_consistency_checking: *mut bool;
    pub static mut wal_consistency_checking_string: *mut ::std::os::raw::c_char;
    pub static mut log_checkpoints: bool;
    pub static mut track_wal_io_timing: bool;
    pub static mut wal_decode_buffer_size: ::std::os::raw::c_int;
    pub static mut CheckPointSegments: ::std::os::raw::c_int;
    pub static mut XLogArchiveMode: ::std::os::raw::c_int;
    pub static mut wal_level: ::std::os::raw::c_int;
    pub static mut CheckpointStats: CheckpointStatsData;
    pub static mut pg_comp_crc32c: ::std::option::Option<
        unsafe extern "C" fn(
            crc: pg_crc32c,
            data: *const ::std::os::raw::c_void,
            len: usize,
        ) -> pg_crc32c,
    >;
    pub static mut RmgrTable: [RmgrData; 0usize];
    pub static mut ArchiveRecoveryRequested: bool;
    pub static mut InArchiveRecovery: bool;
    pub static mut StandbyMode: bool;
    pub static mut recoveryRestoreCommand: *mut ::std::os::raw::c_char;
    pub static InvalidObjectAddress: ObjectAddress;
    pub static mut GinFuzzySearchLimit: ::std::os::raw::c_int;
    pub static mut gin_pending_list_limit: ::std::os::raw::c_int;
    pub static mut SharedInvalidMessageCounter: uint64;
    pub static mut catchupInterruptPending: sig_atomic_t;
    pub static mut DefaultXactIsoLevel: ::std::os::raw::c_int;
    pub static mut XactIsoLevel: ::std::os::raw::c_int;
    pub static mut DefaultXactReadOnly: bool;
    pub static mut XactReadOnly: bool;
    pub static mut xact_is_sampled: bool;
    pub static mut DefaultXactDeferrable: bool;
    pub static mut XactDeferrable: bool;
    pub static mut synchronous_commit: ::std::os::raw::c_int;
    pub static mut CheckXidAlive: TransactionId;
    pub static mut bsysscan: bool;
    pub static mut MyXactFlags: ::std::os::raw::c_int;
    pub static mut default_table_access_method: *mut ::std::os::raw::c_char;
    pub static mut synchronize_seqscans: bool;
    pub static mut MainLWLockArray: *mut LWLockPadded;
    pub static mut NamedLWLockTrancheArray: *mut NamedLWLockTranche;
    pub static mut NamedLWLockTrancheRequests: ::std::os::raw::c_int;
    pub static mut PgStartTime: TimestampTz;
    pub static mut PgReloadTime: TimestampTz;
    pub static mut max_locks_per_xact: ::std::os::raw::c_int;
    pub static LockTagTypeNames: [*const ::std::os::raw::c_char; 0usize];
    pub static mut recoveryTargetInclusive: bool;
    pub static mut recoveryTargetAction: ::std::os::raw::c_int;
    pub static mut recovery_min_apply_delay: ::std::os::raw::c_int;
    pub static mut PrimaryConnInfo: *mut ::std::os::raw::c_char;
    pub static mut PrimarySlotName: *mut ::std::os::raw::c_char;
    pub static mut recoveryEndCommand: *mut ::std::os::raw::c_char;
    pub static mut archiveCleanupCommand: *mut ::std::os::raw::c_char;
    pub static mut recoveryTargetXid: TransactionId;
    pub static mut recovery_target_time_string: *mut ::std::os::raw::c_char;
    pub static mut recoveryTargetTime: TimestampTz;
    pub static mut recoveryTargetName: *const ::std::os::raw::c_char;
    pub static mut recoveryTargetLSN: XLogRecPtr;
    pub static mut recoveryTarget: RecoveryTargetType;
    pub static mut wal_receiver_create_temp_slot: bool;
    pub static mut recoveryTargetTimeLineGoal: RecoveryTargetTimeLineGoal;
    pub static mut recoveryTargetTLIRequested: TimeLineID;
    pub static mut recoveryTargetTLI: TimeLineID;
    pub static mut reachedConsistency: bool;
    pub static mut namespace_search_path: *mut ::std::os::raw::c_char;
    pub static mut object_access_hook: object_access_hook_type;
    pub static mut object_access_hook_str: object_access_hook_type_str;
    pub static mut Array_nulls: bool;
    pub static mut ExplainOneQuery_hook: ExplainOneQuery_hook_type;
    pub static mut explain_get_index_name_hook: explain_get_index_name_hook_type;
    pub static mut allow_in_place_tablespaces: bool;
    pub static mut SessionReplicationRole: ::std::os::raw::c_int;
    pub static mut Debug_print_plan: bool;
    pub static mut Debug_print_parse: bool;
    pub static mut Debug_print_rewritten: bool;
    pub static mut Debug_pretty_print: bool;
    pub static mut log_parser_stats: bool;
    pub static mut log_planner_stats: bool;
    pub static mut log_executor_stats: bool;
    pub static mut log_statement_stats: bool;
    pub static mut log_btree_build_stats: bool;
    pub static mut check_function_bodies: bool;
    pub static mut session_auth_is_superuser: bool;
    pub static mut log_duration: bool;
    pub static mut log_parameter_max_length: ::std::os::raw::c_int;
    pub static mut log_parameter_max_length_on_error: ::std::os::raw::c_int;
    pub static mut log_min_error_statement: ::std::os::raw::c_int;
    pub static mut log_min_messages: ::std::os::raw::c_int;
    pub static mut client_min_messages: ::std::os::raw::c_int;
    pub static mut log_min_duration_sample: ::std::os::raw::c_int;
    pub static mut log_min_duration_statement: ::std::os::raw::c_int;
    pub static mut log_temp_files: ::std::os::raw::c_int;
    pub static mut log_statement_sample_rate: f64;
    pub static mut log_xact_sample_rate: f64;
    pub static mut backtrace_functions: *mut ::std::os::raw::c_char;
    pub static mut temp_file_limit: ::std::os::raw::c_int;
    pub static mut num_temp_buffers: ::std::os::raw::c_int;
    pub static mut cluster_name: *mut ::std::os::raw::c_char;
    pub static mut ConfigFileName: *mut ::std::os::raw::c_char;
    pub static mut HbaFileName: *mut ::std::os::raw::c_char;
    pub static mut IdentFileName: *mut ::std::os::raw::c_char;
    pub static mut external_pid_file: *mut ::std::os::raw::c_char;
    pub static mut application_name: *mut ::std::os::raw::c_char;
    pub static mut tcp_keepalives_idle: ::std::os::raw::c_int;
    pub static mut tcp_keepalives_interval: ::std::os::raw::c_int;
    pub static mut tcp_keepalives_count: ::std::os::raw::c_int;
    pub static mut tcp_user_timeout: ::std::os::raw::c_int;
    pub static mut trace_sort: bool;
    pub static mut GUC_check_errmsg_string: *mut ::std::os::raw::c_char;
    pub static mut GUC_check_errdetail_string: *mut ::std::os::raw::c_char;
    pub static mut GUC_check_errhint_string: *mut ::std::os::raw::c_char;
    pub static mut Password_encryption: ::std::os::raw::c_int;
    pub static mut createrole_self_grant: *mut ::std::os::raw::c_char;
    pub static mut check_password_hook: check_password_hook_type;
    pub static mut MyBgworkerEntry: *mut BackgroundWorker;
    pub static mut MyProc: *mut PGPROC;
    pub static mut ProcGlobal: *mut PROC_HDR;
    pub static mut PreparedXactProcs: *mut PGPROC;
    pub static mut DeadlockTimeout: ::std::os::raw::c_int;
    pub static mut StatementTimeout: ::std::os::raw::c_int;
    pub static mut LockTimeout: ::std::os::raw::c_int;
    pub static mut IdleInTransactionSessionTimeout: ::std::os::raw::c_int;
    pub static mut IdleSessionTimeout: ::std::os::raw::c_int;
    pub static mut log_lock_waits: bool;
    pub static shm_mq_minimum_size: Size;
    pub static mut ParallelMessagePending: sig_atomic_t;
    pub static mut ParallelWorkerNumber: ::std::os::raw::c_int;
    pub static mut InitializingParallelWorker: bool;
    pub static mut default_statistics_target: ::std::os::raw::c_int;
    pub static mut vacuum_freeze_min_age: ::std::os::raw::c_int;
    pub static mut vacuum_freeze_table_age: ::std::os::raw::c_int;
    pub static mut vacuum_multixact_freeze_min_age: ::std::os::raw::c_int;
    pub static mut vacuum_multixact_freeze_table_age: ::std::os::raw::c_int;
    pub static mut vacuum_failsafe_age: ::std::os::raw::c_int;
    pub static mut vacuum_multixact_failsafe_age: ::std::os::raw::c_int;
    pub static mut VacuumSharedCostBalance: *mut pg_atomic_uint32;
    pub static mut VacuumActiveNWorkers: *mut pg_atomic_uint32;
    pub static mut VacuumCostBalanceLocal: ::std::os::raw::c_int;
    pub static mut VacuumFailsafeActive: bool;
    pub static mut vacuum_cost_delay: f64;
    pub static mut vacuum_cost_limit: ::std::os::raw::c_int;
    pub static mut backslash_quote: ::std::os::raw::c_int;
    pub static mut escape_string_warning: bool;
    pub static mut standard_conforming_strings: bool;
    pub static mut CurrentResourceOwner: ResourceOwner;
    pub static mut CurTransactionResourceOwner: ResourceOwner;
    pub static mut TopTransactionResourceOwner: ResourceOwner;
    pub static mut AuxProcessResourceOwner: ResourceOwner;
    pub static mut plan_cache_mode: ::std::os::raw::c_int;
    pub static mut SPI_processed: uint64;
    pub static mut SPI_tuptable: *mut SPITupleTable;
    pub static mut SPI_result: ::std::os::raw::c_int;
    pub static pg_enc2name_tbl: [pg_enc2name; 0usize];
    pub static pg_enc2gettext_tbl: [pg_enc2gettext; 0usize];
    pub static pg_wchar_table: [pg_wchar_tbl; 0usize];
    pub static mut disable_cost: Cost;
    pub static mut max_parallel_workers_per_gather: ::std::os::raw::c_int;
    pub static mut enable_seqscan: bool;
    pub static mut enable_indexscan: bool;
    pub static mut enable_indexonlyscan: bool;
    pub static mut enable_bitmapscan: bool;
    pub static mut enable_tidscan: bool;
    pub static mut enable_sort: bool;
    pub static mut enable_incremental_sort: bool;
    pub static mut enable_hashagg: bool;
    pub static mut enable_nestloop: bool;
    pub static mut enable_material: bool;
    pub static mut enable_memoize: bool;
    pub static mut enable_mergejoin: bool;
    pub static mut enable_hashjoin: bool;
    pub static mut enable_gathermerge: bool;
    pub static mut enable_partitionwise_join: bool;
    pub static mut enable_partitionwise_aggregate: bool;
    pub static mut enable_parallel_append: bool;
    pub static mut enable_parallel_hash: bool;
    pub static mut enable_partition_pruning: bool;
    pub static mut enable_presorted_aggregate: bool;
    pub static mut enable_async_append: bool;
    pub static mut constraint_exclusion: ::std::os::raw::c_int;
    pub static mut seq_page_cost: f64;
    pub static mut random_page_cost: f64;
    pub static mut cpu_tuple_cost: f64;
    pub static mut cpu_index_tuple_cost: f64;
    pub static mut cpu_operator_cost: f64;
    pub static mut parallel_tuple_cost: f64;
    pub static mut parallel_setup_cost: f64;
    pub static mut recursive_worktable_factor: f64;
    pub static mut effective_cache_size: ::std::os::raw::c_int;
    pub static mut debug_parallel_query: ::std::os::raw::c_int;
    pub static mut parallel_leader_participation: bool;
    pub static mut enable_geqo: bool;
    pub static mut geqo_threshold: ::std::os::raw::c_int;
    pub static mut min_parallel_table_scan_size: ::std::os::raw::c_int;
    pub static mut min_parallel_index_scan_size: ::std::os::raw::c_int;
    pub static mut set_rel_pathlist_hook: set_rel_pathlist_hook_type;
    pub static mut set_join_pathlist_hook: set_join_pathlist_hook_type;
    pub static mut join_search_hook: join_search_hook_type;
    pub static mut get_relation_info_hook: get_relation_info_hook_type;
    pub static mut cursor_tuple_fraction: f64;
    pub static mut from_collapse_limit: ::std::os::raw::c_int;
    pub static mut join_collapse_limit: ::std::os::raw::c_int;
    pub static mut planner_hook: planner_hook_type;
    pub static mut create_upper_paths_hook: create_upper_paths_hook_type;
    pub static mut compute_query_id: ::std::os::raw::c_int;
    pub static mut query_id_enabled: bool;
    pub static mut post_parse_analyze_hook: post_parse_analyze_hook_type;
    pub static mut plpgsql_IdentifierLookup: IdentifierLookup;
    pub static mut plpgsql_variable_conflict: ::std::os::raw::c_int;
    pub static mut plpgsql_print_strict_params: bool;
    pub static mut plpgsql_check_asserts: bool;
    pub static mut plpgsql_extra_warnings: ::std::os::raw::c_int;
    pub static mut plpgsql_extra_errors: ::std::os::raw::c_int;
    pub static mut plpgsql_check_syntax: bool;
    pub static mut plpgsql_DumpExecTree: bool;
    pub static mut plpgsql_parse_result: *mut PLpgSQL_stmt_block;
    pub static mut plpgsql_nDatums: ::std::os::raw::c_int;
    pub static mut plpgsql_Datums: *mut *mut PLpgSQL_datum;
    pub static mut plpgsql_error_funcname: *mut ::std::os::raw::c_char;
    pub static mut plpgsql_curr_compile: *mut PLpgSQL_function;
    pub static mut plpgsql_compile_tmp_cxt: MemoryContext;
    pub static mut plpgsql_plugin_ptr: *mut *mut PLpgSQL_plugin;
    pub static mut EnableSSL: bool;
    pub static mut SuperuserReservedConnections: ::std::os::raw::c_int;
    pub static mut ReservedConnections: ::std::os::raw::c_int;
    pub static mut PostPortNumber: ::std::os::raw::c_int;
    pub static mut Unix_socket_permissions: ::std::os::raw::c_int;
    pub static mut Unix_socket_group: *mut ::std::os::raw::c_char;
    pub static mut Unix_socket_directories: *mut ::std::os::raw::c_char;
    pub static mut ListenAddresses: *mut ::std::os::raw::c_char;
    pub static mut ClientAuthInProgress: bool;
    pub static mut PreAuthDelay: ::std::os::raw::c_int;
    pub static mut AuthenticationTimeout: ::std::os::raw::c_int;
    pub static mut Log_connections: bool;
    pub static mut log_hostname: bool;
    pub static mut enable_bonjour: bool;
    pub static mut bonjour_name: *mut ::std::os::raw::c_char;
    pub static mut restart_after_crash: bool;
    pub static mut remove_temp_files_after_crash: bool;
    pub static mut send_abort_for_crash: bool;
    pub static mut send_abort_for_kill: bool;
    pub static mut postmaster_alive_fds: [::std::os::raw::c_int; 2usize];
    pub static mut progname: *const ::std::os::raw::c_char;
    pub static mut logical_decoding_work_mem: ::std::os::raw::c_int;
    pub static mut debug_logical_replication_streaming: ::std::os::raw::c_int;
    pub static mut am_walsender: bool;
    pub static mut am_cascading_walsender: bool;
    pub static mut am_db_walsender: bool;
    pub static mut wake_wal_senders: bool;
    pub static mut max_wal_senders: ::std::os::raw::c_int;
    pub static mut wal_sender_timeout: ::std::os::raw::c_int;
    pub static mut log_replication_commands: bool;
    pub static mut wal_receiver_status_interval: ::std::os::raw::c_int;
    pub static mut wal_receiver_timeout: ::std::os::raw::c_int;
    pub static mut hot_standby_feedback: bool;
    pub static mut WalRcv: *mut WalRcvData;
    pub static mut WalReceiverFunctions: *mut WalReceiverFunctionsType;
    pub static mut ReplicationSlotCtl: *mut ReplicationSlotCtlData;
    pub static mut MyReplicationSlot: *mut ReplicationSlot;
    pub static mut max_replication_slots: ::std::os::raw::c_int;
    pub static mut row_security_policy_hook_permissive: row_security_policy_hook_type;
    pub static mut row_security_policy_hook_restrictive: row_security_policy_hook_type;
    pub static mut old_snapshot_threshold: ::std::os::raw::c_int;
    pub static mut FirstSnapshotSet: bool;
    pub static mut TransactionXmin: TransactionId;
    pub static mut RecentXmin: TransactionId;
    pub static mut SnapshotSelfData: SnapshotData;
    pub static mut SnapshotAnyData: SnapshotData;
    pub static mut CatalogSnapshotData: SnapshotData;
    pub static mut zero_damaged_pages: bool;
    pub static mut bgwriter_lru_maxpages: ::std::os::raw::c_int;
    pub static mut bgwriter_lru_multiplier: f64;
    pub static mut track_io_timing: bool;
    pub static mut effective_io_concurrency: ::std::os::raw::c_int;
    pub static mut maintenance_io_concurrency: ::std::os::raw::c_int;
    pub static mut checkpoint_flush_after: ::std::os::raw::c_int;
    pub static mut backend_flush_after: ::std::os::raw::c_int;
    pub static mut bgwriter_flush_after: ::std::os::raw::c_int;
    pub static mut BufferBlocks: *mut ::std::os::raw::c_char;
    pub static mut NLocBuffer: ::std::os::raw::c_int;
    pub static mut LocalBufferBlockPointers: *mut Block;
    pub static mut LocalRefCount: *mut int32;
    pub static mut proc_exit_inprogress: bool;
    pub static mut shmem_exit_inprogress: bool;
    pub static mut shmem_startup_hook: shmem_startup_hook_type;
    pub static mut max_standby_archive_delay: ::std::os::raw::c_int;
    pub static mut max_standby_streaming_delay: ::std::os::raw::c_int;
    pub static mut log_recovery_conflict_waits: bool;
    pub static mut whereToSendOutput: CommandDest;
    pub static mut debug_query_string: *const ::std::os::raw::c_char;
    pub static mut max_stack_depth: ::std::os::raw::c_int;
    pub static mut PostAuthDelay: ::std::os::raw::c_int;
    pub static mut client_connection_check_interval: ::std::os::raw::c_int;
    pub static mut log_statement: ::std::os::raw::c_int;
    pub static mut ProcessUtility_hook: ProcessUtility_hook_type;
    pub static tsearch_op_priority: [::std::os::raw::c_int; 4usize];
    pub static mut quote_all_identifiers: bool;
    pub static months: [*const ::std::os::raw::c_char; 0usize];
    pub static days: [*const ::std::os::raw::c_char; 0usize];
    pub static mut day_tab: [[::std::os::raw::c_int; 13usize]; 2usize];
    pub static mut extra_float_digits: ::std::os::raw::c_int;
    pub static mut get_attavgwidth_hook: get_attavgwidth_hook_type;
    pub static mut pg_global_prng_state: pg_prng_state;
    pub static mut get_relation_stats_hook: get_relation_stats_hook_type;
    pub static mut get_index_stats_hook: get_index_stats_hook_type;
}
impl pg_sys::seal::Sealed for A_ArrayExpr {}
impl pg_sys::PgNode for A_ArrayExpr {}
impl ::core::fmt::Display for A_ArrayExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for A_Const {}
impl pg_sys::PgNode for A_Const {}
impl ::core::fmt::Display for A_Const {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for A_Expr {}
impl pg_sys::PgNode for A_Expr {}
impl ::core::fmt::Display for A_Expr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for A_Indices {}
impl pg_sys::PgNode for A_Indices {}
impl ::core::fmt::Display for A_Indices {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for A_Indirection {}
impl pg_sys::PgNode for A_Indirection {}
impl ::core::fmt::Display for A_Indirection {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for A_Star {}
impl pg_sys::PgNode for A_Star {}
impl ::core::fmt::Display for A_Star {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AccessPriv {}
impl pg_sys::PgNode for AccessPriv {}
impl ::core::fmt::Display for AccessPriv {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Agg {}
impl pg_sys::PgNode for Agg {}
impl ::core::fmt::Display for Agg {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AggInfo {}
impl pg_sys::PgNode for AggInfo {}
impl ::core::fmt::Display for AggInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AggPath {}
impl pg_sys::PgNode for AggPath {}
impl ::core::fmt::Display for AggPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AggState {}
impl pg_sys::PgNode for AggState {}
impl ::core::fmt::Display for AggState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AggTransInfo {}
impl pg_sys::PgNode for AggTransInfo {}
impl ::core::fmt::Display for AggTransInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Aggref {}
impl pg_sys::PgNode for Aggref {}
impl ::core::fmt::Display for Aggref {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Alias {}
impl pg_sys::PgNode for Alias {}
impl ::core::fmt::Display for Alias {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterCollationStmt {}
impl pg_sys::PgNode for AlterCollationStmt {}
impl ::core::fmt::Display for AlterCollationStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterDatabaseRefreshCollStmt {}
impl pg_sys::PgNode for AlterDatabaseRefreshCollStmt {}
impl ::core::fmt::Display for AlterDatabaseRefreshCollStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterDatabaseSetStmt {}
impl pg_sys::PgNode for AlterDatabaseSetStmt {}
impl ::core::fmt::Display for AlterDatabaseSetStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterDatabaseStmt {}
impl pg_sys::PgNode for AlterDatabaseStmt {}
impl ::core::fmt::Display for AlterDatabaseStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterDefaultPrivilegesStmt {}
impl pg_sys::PgNode for AlterDefaultPrivilegesStmt {}
impl ::core::fmt::Display for AlterDefaultPrivilegesStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterDomainStmt {}
impl pg_sys::PgNode for AlterDomainStmt {}
impl ::core::fmt::Display for AlterDomainStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterEnumStmt {}
impl pg_sys::PgNode for AlterEnumStmt {}
impl ::core::fmt::Display for AlterEnumStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterEventTrigStmt {}
impl pg_sys::PgNode for AlterEventTrigStmt {}
impl ::core::fmt::Display for AlterEventTrigStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterExtensionContentsStmt {}
impl pg_sys::PgNode for AlterExtensionContentsStmt {}
impl ::core::fmt::Display for AlterExtensionContentsStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterExtensionStmt {}
impl pg_sys::PgNode for AlterExtensionStmt {}
impl ::core::fmt::Display for AlterExtensionStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterFdwStmt {}
impl pg_sys::PgNode for AlterFdwStmt {}
impl ::core::fmt::Display for AlterFdwStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterForeignServerStmt {}
impl pg_sys::PgNode for AlterForeignServerStmt {}
impl ::core::fmt::Display for AlterForeignServerStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterFunctionStmt {}
impl pg_sys::PgNode for AlterFunctionStmt {}
impl ::core::fmt::Display for AlterFunctionStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterObjectDependsStmt {}
impl pg_sys::PgNode for AlterObjectDependsStmt {}
impl ::core::fmt::Display for AlterObjectDependsStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterObjectSchemaStmt {}
impl pg_sys::PgNode for AlterObjectSchemaStmt {}
impl ::core::fmt::Display for AlterObjectSchemaStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterOpFamilyStmt {}
impl pg_sys::PgNode for AlterOpFamilyStmt {}
impl ::core::fmt::Display for AlterOpFamilyStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterOperatorStmt {}
impl pg_sys::PgNode for AlterOperatorStmt {}
impl ::core::fmt::Display for AlterOperatorStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterOwnerStmt {}
impl pg_sys::PgNode for AlterOwnerStmt {}
impl ::core::fmt::Display for AlterOwnerStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterPolicyStmt {}
impl pg_sys::PgNode for AlterPolicyStmt {}
impl ::core::fmt::Display for AlterPolicyStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterPublicationStmt {}
impl pg_sys::PgNode for AlterPublicationStmt {}
impl ::core::fmt::Display for AlterPublicationStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterRoleSetStmt {}
impl pg_sys::PgNode for AlterRoleSetStmt {}
impl ::core::fmt::Display for AlterRoleSetStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterRoleStmt {}
impl pg_sys::PgNode for AlterRoleStmt {}
impl ::core::fmt::Display for AlterRoleStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterSeqStmt {}
impl pg_sys::PgNode for AlterSeqStmt {}
impl ::core::fmt::Display for AlterSeqStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterStatsStmt {}
impl pg_sys::PgNode for AlterStatsStmt {}
impl ::core::fmt::Display for AlterStatsStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterSubscriptionStmt {}
impl pg_sys::PgNode for AlterSubscriptionStmt {}
impl ::core::fmt::Display for AlterSubscriptionStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterSystemStmt {}
impl pg_sys::PgNode for AlterSystemStmt {}
impl ::core::fmt::Display for AlterSystemStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterTSConfigurationStmt {}
impl pg_sys::PgNode for AlterTSConfigurationStmt {}
impl ::core::fmt::Display for AlterTSConfigurationStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterTSDictionaryStmt {}
impl pg_sys::PgNode for AlterTSDictionaryStmt {}
impl ::core::fmt::Display for AlterTSDictionaryStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterTableCmd {}
impl pg_sys::PgNode for AlterTableCmd {}
impl ::core::fmt::Display for AlterTableCmd {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterTableMoveAllStmt {}
impl pg_sys::PgNode for AlterTableMoveAllStmt {}
impl ::core::fmt::Display for AlterTableMoveAllStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterTableSpaceOptionsStmt {}
impl pg_sys::PgNode for AlterTableSpaceOptionsStmt {}
impl ::core::fmt::Display for AlterTableSpaceOptionsStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterTableStmt {}
impl pg_sys::PgNode for AlterTableStmt {}
impl ::core::fmt::Display for AlterTableStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterTypeStmt {}
impl pg_sys::PgNode for AlterTypeStmt {}
impl ::core::fmt::Display for AlterTypeStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlterUserMappingStmt {}
impl pg_sys::PgNode for AlterUserMappingStmt {}
impl ::core::fmt::Display for AlterUserMappingStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AlternativeSubPlan {}
impl pg_sys::PgNode for AlternativeSubPlan {}
impl ::core::fmt::Display for AlternativeSubPlan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Append {}
impl pg_sys::PgNode for Append {}
impl ::core::fmt::Display for Append {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AppendPath {}
impl pg_sys::PgNode for AppendPath {}
impl ::core::fmt::Display for AppendPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AppendRelInfo {}
impl pg_sys::PgNode for AppendRelInfo {}
impl ::core::fmt::Display for AppendRelInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for AppendState {}
impl pg_sys::PgNode for AppendState {}
impl ::core::fmt::Display for AppendState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ArrayCoerceExpr {}
impl pg_sys::PgNode for ArrayCoerceExpr {}
impl ::core::fmt::Display for ArrayCoerceExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ArrayExpr {}
impl pg_sys::PgNode for ArrayExpr {}
impl ::core::fmt::Display for ArrayExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for BaseBackupCmd {}
impl pg_sys::PgNode for BaseBackupCmd {}
impl ::core::fmt::Display for BaseBackupCmd {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for BitString {}
impl pg_sys::PgNode for BitString {}
impl ::core::fmt::Display for BitString {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for BitmapAnd {}
impl pg_sys::PgNode for BitmapAnd {}
impl ::core::fmt::Display for BitmapAnd {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for BitmapAndPath {}
impl pg_sys::PgNode for BitmapAndPath {}
impl ::core::fmt::Display for BitmapAndPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for BitmapAndState {}
impl pg_sys::PgNode for BitmapAndState {}
impl ::core::fmt::Display for BitmapAndState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for BitmapHeapPath {}
impl pg_sys::PgNode for BitmapHeapPath {}
impl ::core::fmt::Display for BitmapHeapPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for BitmapHeapScan {}
impl pg_sys::PgNode for BitmapHeapScan {}
impl ::core::fmt::Display for BitmapHeapScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for BitmapHeapScanState {}
impl pg_sys::PgNode for BitmapHeapScanState {}
impl ::core::fmt::Display for BitmapHeapScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for BitmapIndexScan {}
impl pg_sys::PgNode for BitmapIndexScan {}
impl ::core::fmt::Display for BitmapIndexScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for BitmapIndexScanState {}
impl pg_sys::PgNode for BitmapIndexScanState {}
impl ::core::fmt::Display for BitmapIndexScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for BitmapOr {}
impl pg_sys::PgNode for BitmapOr {}
impl ::core::fmt::Display for BitmapOr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for BitmapOrPath {}
impl pg_sys::PgNode for BitmapOrPath {}
impl ::core::fmt::Display for BitmapOrPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for BitmapOrState {}
impl pg_sys::PgNode for BitmapOrState {}
impl ::core::fmt::Display for BitmapOrState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Bitmapset {}
impl pg_sys::PgNode for Bitmapset {}
impl ::core::fmt::Display for Bitmapset {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for BoolExpr {}
impl pg_sys::PgNode for BoolExpr {}
impl ::core::fmt::Display for BoolExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Boolean {}
impl pg_sys::PgNode for Boolean {}
impl ::core::fmt::Display for Boolean {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for BooleanTest {}
impl pg_sys::PgNode for BooleanTest {}
impl ::core::fmt::Display for BooleanTest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for BufferHeapTupleTableSlot {}
impl pg_sys::PgNode for BufferHeapTupleTableSlot {}
impl ::core::fmt::Display for BufferHeapTupleTableSlot {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CTECycleClause {}
impl pg_sys::PgNode for CTECycleClause {}
impl ::core::fmt::Display for CTECycleClause {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CTESearchClause {}
impl pg_sys::PgNode for CTESearchClause {}
impl ::core::fmt::Display for CTESearchClause {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CallContext {}
impl pg_sys::PgNode for CallContext {}
impl ::core::fmt::Display for CallContext {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CallStmt {}
impl pg_sys::PgNode for CallStmt {}
impl ::core::fmt::Display for CallStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CaseExpr {}
impl pg_sys::PgNode for CaseExpr {}
impl ::core::fmt::Display for CaseExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CaseTestExpr {}
impl pg_sys::PgNode for CaseTestExpr {}
impl ::core::fmt::Display for CaseTestExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CaseWhen {}
impl pg_sys::PgNode for CaseWhen {}
impl ::core::fmt::Display for CaseWhen {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CheckPointStmt {}
impl pg_sys::PgNode for CheckPointStmt {}
impl ::core::fmt::Display for CheckPointStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ClosePortalStmt {}
impl pg_sys::PgNode for ClosePortalStmt {}
impl ::core::fmt::Display for ClosePortalStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ClusterStmt {}
impl pg_sys::PgNode for ClusterStmt {}
impl ::core::fmt::Display for ClusterStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CoalesceExpr {}
impl pg_sys::PgNode for CoalesceExpr {}
impl ::core::fmt::Display for CoalesceExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CoerceToDomain {}
impl pg_sys::PgNode for CoerceToDomain {}
impl ::core::fmt::Display for CoerceToDomain {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CoerceToDomainValue {}
impl pg_sys::PgNode for CoerceToDomainValue {}
impl ::core::fmt::Display for CoerceToDomainValue {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CoerceViaIO {}
impl pg_sys::PgNode for CoerceViaIO {}
impl ::core::fmt::Display for CoerceViaIO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CollateClause {}
impl pg_sys::PgNode for CollateClause {}
impl ::core::fmt::Display for CollateClause {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CollateExpr {}
impl pg_sys::PgNode for CollateExpr {}
impl ::core::fmt::Display for CollateExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ColumnDef {}
impl pg_sys::PgNode for ColumnDef {}
impl ::core::fmt::Display for ColumnDef {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ColumnRef {}
impl pg_sys::PgNode for ColumnRef {}
impl ::core::fmt::Display for ColumnRef {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CommentStmt {}
impl pg_sys::PgNode for CommentStmt {}
impl ::core::fmt::Display for CommentStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CommonTableExpr {}
impl pg_sys::PgNode for CommonTableExpr {}
impl ::core::fmt::Display for CommonTableExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CompositeTypeStmt {}
impl pg_sys::PgNode for CompositeTypeStmt {}
impl ::core::fmt::Display for CompositeTypeStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Const {}
impl pg_sys::PgNode for Const {}
impl ::core::fmt::Display for Const {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Constraint {}
impl pg_sys::PgNode for Constraint {}
impl ::core::fmt::Display for Constraint {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ConstraintsSetStmt {}
impl pg_sys::PgNode for ConstraintsSetStmt {}
impl ::core::fmt::Display for ConstraintsSetStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ConvertRowtypeExpr {}
impl pg_sys::PgNode for ConvertRowtypeExpr {}
impl ::core::fmt::Display for ConvertRowtypeExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CopyStmt {}
impl pg_sys::PgNode for CopyStmt {}
impl ::core::fmt::Display for CopyStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateAmStmt {}
impl pg_sys::PgNode for CreateAmStmt {}
impl ::core::fmt::Display for CreateAmStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateCastStmt {}
impl pg_sys::PgNode for CreateCastStmt {}
impl ::core::fmt::Display for CreateCastStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateConversionStmt {}
impl pg_sys::PgNode for CreateConversionStmt {}
impl ::core::fmt::Display for CreateConversionStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateDomainStmt {}
impl pg_sys::PgNode for CreateDomainStmt {}
impl ::core::fmt::Display for CreateDomainStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateEnumStmt {}
impl pg_sys::PgNode for CreateEnumStmt {}
impl ::core::fmt::Display for CreateEnumStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateEventTrigStmt {}
impl pg_sys::PgNode for CreateEventTrigStmt {}
impl ::core::fmt::Display for CreateEventTrigStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateExtensionStmt {}
impl pg_sys::PgNode for CreateExtensionStmt {}
impl ::core::fmt::Display for CreateExtensionStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateFdwStmt {}
impl pg_sys::PgNode for CreateFdwStmt {}
impl ::core::fmt::Display for CreateFdwStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateForeignServerStmt {}
impl pg_sys::PgNode for CreateForeignServerStmt {}
impl ::core::fmt::Display for CreateForeignServerStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateForeignTableStmt {}
impl pg_sys::PgNode for CreateForeignTableStmt {}
impl ::core::fmt::Display for CreateForeignTableStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateFunctionStmt {}
impl pg_sys::PgNode for CreateFunctionStmt {}
impl ::core::fmt::Display for CreateFunctionStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateOpClassItem {}
impl pg_sys::PgNode for CreateOpClassItem {}
impl ::core::fmt::Display for CreateOpClassItem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateOpClassStmt {}
impl pg_sys::PgNode for CreateOpClassStmt {}
impl ::core::fmt::Display for CreateOpClassStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateOpFamilyStmt {}
impl pg_sys::PgNode for CreateOpFamilyStmt {}
impl ::core::fmt::Display for CreateOpFamilyStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreatePLangStmt {}
impl pg_sys::PgNode for CreatePLangStmt {}
impl ::core::fmt::Display for CreatePLangStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreatePolicyStmt {}
impl pg_sys::PgNode for CreatePolicyStmt {}
impl ::core::fmt::Display for CreatePolicyStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreatePublicationStmt {}
impl pg_sys::PgNode for CreatePublicationStmt {}
impl ::core::fmt::Display for CreatePublicationStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateRangeStmt {}
impl pg_sys::PgNode for CreateRangeStmt {}
impl ::core::fmt::Display for CreateRangeStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateReplicationSlotCmd {}
impl pg_sys::PgNode for CreateReplicationSlotCmd {}
impl ::core::fmt::Display for CreateReplicationSlotCmd {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateRoleStmt {}
impl pg_sys::PgNode for CreateRoleStmt {}
impl ::core::fmt::Display for CreateRoleStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateSchemaStmt {}
impl pg_sys::PgNode for CreateSchemaStmt {}
impl ::core::fmt::Display for CreateSchemaStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateSeqStmt {}
impl pg_sys::PgNode for CreateSeqStmt {}
impl ::core::fmt::Display for CreateSeqStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateStatsStmt {}
impl pg_sys::PgNode for CreateStatsStmt {}
impl ::core::fmt::Display for CreateStatsStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateStmt {}
impl pg_sys::PgNode for CreateStmt {}
impl ::core::fmt::Display for CreateStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateSubscriptionStmt {}
impl pg_sys::PgNode for CreateSubscriptionStmt {}
impl ::core::fmt::Display for CreateSubscriptionStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateTableAsStmt {}
impl pg_sys::PgNode for CreateTableAsStmt {}
impl ::core::fmt::Display for CreateTableAsStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateTableSpaceStmt {}
impl pg_sys::PgNode for CreateTableSpaceStmt {}
impl ::core::fmt::Display for CreateTableSpaceStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateTransformStmt {}
impl pg_sys::PgNode for CreateTransformStmt {}
impl ::core::fmt::Display for CreateTransformStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateTrigStmt {}
impl pg_sys::PgNode for CreateTrigStmt {}
impl ::core::fmt::Display for CreateTrigStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreateUserMappingStmt {}
impl pg_sys::PgNode for CreateUserMappingStmt {}
impl ::core::fmt::Display for CreateUserMappingStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CreatedbStmt {}
impl pg_sys::PgNode for CreatedbStmt {}
impl ::core::fmt::Display for CreatedbStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CteScan {}
impl pg_sys::PgNode for CteScan {}
impl ::core::fmt::Display for CteScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CteScanState {}
impl pg_sys::PgNode for CteScanState {}
impl ::core::fmt::Display for CteScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CurrentOfExpr {}
impl pg_sys::PgNode for CurrentOfExpr {}
impl ::core::fmt::Display for CurrentOfExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CustomPath {}
impl pg_sys::PgNode for CustomPath {}
impl ::core::fmt::Display for CustomPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CustomScan {}
impl pg_sys::PgNode for CustomScan {}
impl ::core::fmt::Display for CustomScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for CustomScanState {}
impl pg_sys::PgNode for CustomScanState {}
impl ::core::fmt::Display for CustomScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for DeallocateStmt {}
impl pg_sys::PgNode for DeallocateStmt {}
impl ::core::fmt::Display for DeallocateStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for DeclareCursorStmt {}
impl pg_sys::PgNode for DeclareCursorStmt {}
impl ::core::fmt::Display for DeclareCursorStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for DefElem {}
impl pg_sys::PgNode for DefElem {}
impl ::core::fmt::Display for DefElem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for DefineStmt {}
impl pg_sys::PgNode for DefineStmt {}
impl ::core::fmt::Display for DefineStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for DeleteStmt {}
impl pg_sys::PgNode for DeleteStmt {}
impl ::core::fmt::Display for DeleteStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for DiscardStmt {}
impl pg_sys::PgNode for DiscardStmt {}
impl ::core::fmt::Display for DiscardStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for DoStmt {}
impl pg_sys::PgNode for DoStmt {}
impl ::core::fmt::Display for DoStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for DomainConstraintState {}
impl pg_sys::PgNode for DomainConstraintState {}
impl ::core::fmt::Display for DomainConstraintState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for DropOwnedStmt {}
impl pg_sys::PgNode for DropOwnedStmt {}
impl ::core::fmt::Display for DropOwnedStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for DropReplicationSlotCmd {}
impl pg_sys::PgNode for DropReplicationSlotCmd {}
impl ::core::fmt::Display for DropReplicationSlotCmd {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for DropRoleStmt {}
impl pg_sys::PgNode for DropRoleStmt {}
impl ::core::fmt::Display for DropRoleStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for DropStmt {}
impl pg_sys::PgNode for DropStmt {}
impl ::core::fmt::Display for DropStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for DropSubscriptionStmt {}
impl pg_sys::PgNode for DropSubscriptionStmt {}
impl ::core::fmt::Display for DropSubscriptionStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for DropTableSpaceStmt {}
impl pg_sys::PgNode for DropTableSpaceStmt {}
impl ::core::fmt::Display for DropTableSpaceStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for DropUserMappingStmt {}
impl pg_sys::PgNode for DropUserMappingStmt {}
impl ::core::fmt::Display for DropUserMappingStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for DropdbStmt {}
impl pg_sys::PgNode for DropdbStmt {}
impl ::core::fmt::Display for DropdbStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for EState {}
impl pg_sys::PgNode for EState {}
impl ::core::fmt::Display for EState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for EquivalenceClass {}
impl pg_sys::PgNode for EquivalenceClass {}
impl ::core::fmt::Display for EquivalenceClass {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for EquivalenceMember {}
impl pg_sys::PgNode for EquivalenceMember {}
impl ::core::fmt::Display for EquivalenceMember {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for EventTriggerData {}
impl pg_sys::PgNode for EventTriggerData {}
impl ::core::fmt::Display for EventTriggerData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ExecuteStmt {}
impl pg_sys::PgNode for ExecuteStmt {}
impl ::core::fmt::Display for ExecuteStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ExplainStmt {}
impl pg_sys::PgNode for ExplainStmt {}
impl ::core::fmt::Display for ExplainStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Expr {}
impl pg_sys::PgNode for Expr {}
impl ::core::fmt::Display for Expr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ExprContext {}
impl pg_sys::PgNode for ExprContext {}
impl ::core::fmt::Display for ExprContext {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ExprState {}
impl pg_sys::PgNode for ExprState {}
impl ::core::fmt::Display for ExprState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ExtensibleNode {}
impl pg_sys::PgNode for ExtensibleNode {}
impl ::core::fmt::Display for ExtensibleNode {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for FdwRoutine {}
impl pg_sys::PgNode for FdwRoutine {}
impl ::core::fmt::Display for FdwRoutine {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for FetchStmt {}
impl pg_sys::PgNode for FetchStmt {}
impl ::core::fmt::Display for FetchStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for FieldSelect {}
impl pg_sys::PgNode for FieldSelect {}
impl ::core::fmt::Display for FieldSelect {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for FieldStore {}
impl pg_sys::PgNode for FieldStore {}
impl ::core::fmt::Display for FieldStore {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Float {}
impl pg_sys::PgNode for Float {}
impl ::core::fmt::Display for Float {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ForeignKeyCacheInfo {}
impl pg_sys::PgNode for ForeignKeyCacheInfo {}
impl ::core::fmt::Display for ForeignKeyCacheInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ForeignKeyOptInfo {}
impl pg_sys::PgNode for ForeignKeyOptInfo {}
impl ::core::fmt::Display for ForeignKeyOptInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ForeignPath {}
impl pg_sys::PgNode for ForeignPath {}
impl ::core::fmt::Display for ForeignPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ForeignScan {}
impl pg_sys::PgNode for ForeignScan {}
impl ::core::fmt::Display for ForeignScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ForeignScanState {}
impl pg_sys::PgNode for ForeignScanState {}
impl ::core::fmt::Display for ForeignScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for FromExpr {}
impl pg_sys::PgNode for FromExpr {}
impl ::core::fmt::Display for FromExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for FuncCall {}
impl pg_sys::PgNode for FuncCall {}
impl ::core::fmt::Display for FuncCall {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for FuncExpr {}
impl pg_sys::PgNode for FuncExpr {}
impl ::core::fmt::Display for FuncExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for FunctionParameter {}
impl pg_sys::PgNode for FunctionParameter {}
impl ::core::fmt::Display for FunctionParameter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for FunctionScan {}
impl pg_sys::PgNode for FunctionScan {}
impl ::core::fmt::Display for FunctionScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for FunctionScanState {}
impl pg_sys::PgNode for FunctionScanState {}
impl ::core::fmt::Display for FunctionScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Gather {}
impl pg_sys::PgNode for Gather {}
impl ::core::fmt::Display for Gather {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for GatherMerge {}
impl pg_sys::PgNode for GatherMerge {}
impl ::core::fmt::Display for GatherMerge {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for GatherMergePath {}
impl pg_sys::PgNode for GatherMergePath {}
impl ::core::fmt::Display for GatherMergePath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for GatherMergeState {}
impl pg_sys::PgNode for GatherMergeState {}
impl ::core::fmt::Display for GatherMergeState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for GatherPath {}
impl pg_sys::PgNode for GatherPath {}
impl ::core::fmt::Display for GatherPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for GatherState {}
impl pg_sys::PgNode for GatherState {}
impl ::core::fmt::Display for GatherState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for GrantRoleStmt {}
impl pg_sys::PgNode for GrantRoleStmt {}
impl ::core::fmt::Display for GrantRoleStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for GrantStmt {}
impl pg_sys::PgNode for GrantStmt {}
impl ::core::fmt::Display for GrantStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Group {}
impl pg_sys::PgNode for Group {}
impl ::core::fmt::Display for Group {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for GroupPath {}
impl pg_sys::PgNode for GroupPath {}
impl ::core::fmt::Display for GroupPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for GroupResultPath {}
impl pg_sys::PgNode for GroupResultPath {}
impl ::core::fmt::Display for GroupResultPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for GroupState {}
impl pg_sys::PgNode for GroupState {}
impl ::core::fmt::Display for GroupState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for GroupingFunc {}
impl pg_sys::PgNode for GroupingFunc {}
impl ::core::fmt::Display for GroupingFunc {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for GroupingSet {}
impl pg_sys::PgNode for GroupingSet {}
impl ::core::fmt::Display for GroupingSet {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for GroupingSetData {}
impl pg_sys::PgNode for GroupingSetData {}
impl ::core::fmt::Display for GroupingSetData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for GroupingSetsPath {}
impl pg_sys::PgNode for GroupingSetsPath {}
impl ::core::fmt::Display for GroupingSetsPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Hash {}
impl pg_sys::PgNode for Hash {}
impl ::core::fmt::Display for Hash {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for HashJoin {}
impl pg_sys::PgNode for HashJoin {}
impl ::core::fmt::Display for HashJoin {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for HashJoinState {}
impl pg_sys::PgNode for HashJoinState {}
impl ::core::fmt::Display for HashJoinState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for HashPath {}
impl pg_sys::PgNode for HashPath {}
impl ::core::fmt::Display for HashPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for HashState {}
impl pg_sys::PgNode for HashState {}
impl ::core::fmt::Display for HashState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for HeapTupleTableSlot {}
impl pg_sys::PgNode for HeapTupleTableSlot {}
impl ::core::fmt::Display for HeapTupleTableSlot {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for IdentifySystemCmd {}
impl pg_sys::PgNode for IdentifySystemCmd {}
impl ::core::fmt::Display for IdentifySystemCmd {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ImportForeignSchemaStmt {}
impl pg_sys::PgNode for ImportForeignSchemaStmt {}
impl ::core::fmt::Display for ImportForeignSchemaStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for IncrementalSort {}
impl pg_sys::PgNode for IncrementalSort {}
impl ::core::fmt::Display for IncrementalSort {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for IncrementalSortPath {}
impl pg_sys::PgNode for IncrementalSortPath {}
impl ::core::fmt::Display for IncrementalSortPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for IncrementalSortState {}
impl pg_sys::PgNode for IncrementalSortState {}
impl ::core::fmt::Display for IncrementalSortState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for IndexAmRoutine {}
impl pg_sys::PgNode for IndexAmRoutine {}
impl ::core::fmt::Display for IndexAmRoutine {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for IndexClause {}
impl pg_sys::PgNode for IndexClause {}
impl ::core::fmt::Display for IndexClause {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for IndexElem {}
impl pg_sys::PgNode for IndexElem {}
impl ::core::fmt::Display for IndexElem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for IndexInfo {}
impl pg_sys::PgNode for IndexInfo {}
impl ::core::fmt::Display for IndexInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for IndexOnlyScan {}
impl pg_sys::PgNode for IndexOnlyScan {}
impl ::core::fmt::Display for IndexOnlyScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for IndexOnlyScanState {}
impl pg_sys::PgNode for IndexOnlyScanState {}
impl ::core::fmt::Display for IndexOnlyScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for IndexOptInfo {}
impl pg_sys::PgNode for IndexOptInfo {}
impl ::core::fmt::Display for IndexOptInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for IndexPath {}
impl pg_sys::PgNode for IndexPath {}
impl ::core::fmt::Display for IndexPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for IndexScan {}
impl pg_sys::PgNode for IndexScan {}
impl ::core::fmt::Display for IndexScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for IndexScanState {}
impl pg_sys::PgNode for IndexScanState {}
impl ::core::fmt::Display for IndexScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for IndexStmt {}
impl pg_sys::PgNode for IndexStmt {}
impl ::core::fmt::Display for IndexStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for InferClause {}
impl pg_sys::PgNode for InferClause {}
impl ::core::fmt::Display for InferClause {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for InferenceElem {}
impl pg_sys::PgNode for InferenceElem {}
impl ::core::fmt::Display for InferenceElem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for InlineCodeBlock {}
impl pg_sys::PgNode for InlineCodeBlock {}
impl ::core::fmt::Display for InlineCodeBlock {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for InsertStmt {}
impl pg_sys::PgNode for InsertStmt {}
impl ::core::fmt::Display for InsertStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Integer {}
impl pg_sys::PgNode for Integer {}
impl ::core::fmt::Display for Integer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for IntoClause {}
impl pg_sys::PgNode for IntoClause {}
impl ::core::fmt::Display for IntoClause {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Join {}
impl pg_sys::PgNode for Join {}
impl ::core::fmt::Display for Join {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JoinDomain {}
impl pg_sys::PgNode for JoinDomain {}
impl ::core::fmt::Display for JoinDomain {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JoinExpr {}
impl pg_sys::PgNode for JoinExpr {}
impl ::core::fmt::Display for JoinExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JoinPath {}
impl pg_sys::PgNode for JoinPath {}
impl ::core::fmt::Display for JoinPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JoinState {}
impl pg_sys::PgNode for JoinState {}
impl ::core::fmt::Display for JoinState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonAggConstructor {}
impl pg_sys::PgNode for JsonAggConstructor {}
impl ::core::fmt::Display for JsonAggConstructor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonArrayAgg {}
impl pg_sys::PgNode for JsonArrayAgg {}
impl ::core::fmt::Display for JsonArrayAgg {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonArrayConstructor {}
impl pg_sys::PgNode for JsonArrayConstructor {}
impl ::core::fmt::Display for JsonArrayConstructor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonArrayQueryConstructor {}
impl pg_sys::PgNode for JsonArrayQueryConstructor {}
impl ::core::fmt::Display for JsonArrayQueryConstructor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonConstructorExpr {}
impl pg_sys::PgNode for JsonConstructorExpr {}
impl ::core::fmt::Display for JsonConstructorExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonFormat {}
impl pg_sys::PgNode for JsonFormat {}
impl ::core::fmt::Display for JsonFormat {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonIsPredicate {}
impl pg_sys::PgNode for JsonIsPredicate {}
impl ::core::fmt::Display for JsonIsPredicate {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonKeyValue {}
impl pg_sys::PgNode for JsonKeyValue {}
impl ::core::fmt::Display for JsonKeyValue {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonObjectAgg {}
impl pg_sys::PgNode for JsonObjectAgg {}
impl ::core::fmt::Display for JsonObjectAgg {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonObjectConstructor {}
impl pg_sys::PgNode for JsonObjectConstructor {}
impl ::core::fmt::Display for JsonObjectConstructor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonOutput {}
impl pg_sys::PgNode for JsonOutput {}
impl ::core::fmt::Display for JsonOutput {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonReturning {}
impl pg_sys::PgNode for JsonReturning {}
impl ::core::fmt::Display for JsonReturning {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JsonValueExpr {}
impl pg_sys::PgNode for JsonValueExpr {}
impl ::core::fmt::Display for JsonValueExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for JunkFilter {}
impl pg_sys::PgNode for JunkFilter {}
impl ::core::fmt::Display for JunkFilter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Limit {}
impl pg_sys::PgNode for Limit {}
impl ::core::fmt::Display for Limit {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for LimitPath {}
impl pg_sys::PgNode for LimitPath {}
impl ::core::fmt::Display for LimitPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for LimitState {}
impl pg_sys::PgNode for LimitState {}
impl ::core::fmt::Display for LimitState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for List {}
impl pg_sys::PgNode for List {}
impl ::core::fmt::Display for List {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ListenStmt {}
impl pg_sys::PgNode for ListenStmt {}
impl ::core::fmt::Display for ListenStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for LoadStmt {}
impl pg_sys::PgNode for LoadStmt {}
impl ::core::fmt::Display for LoadStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for LockRows {}
impl pg_sys::PgNode for LockRows {}
impl ::core::fmt::Display for LockRows {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for LockRowsPath {}
impl pg_sys::PgNode for LockRowsPath {}
impl ::core::fmt::Display for LockRowsPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for LockRowsState {}
impl pg_sys::PgNode for LockRowsState {}
impl ::core::fmt::Display for LockRowsState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for LockStmt {}
impl pg_sys::PgNode for LockStmt {}
impl ::core::fmt::Display for LockStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for LockingClause {}
impl pg_sys::PgNode for LockingClause {}
impl ::core::fmt::Display for LockingClause {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Material {}
impl pg_sys::PgNode for Material {}
impl ::core::fmt::Display for Material {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MaterialPath {}
impl pg_sys::PgNode for MaterialPath {}
impl ::core::fmt::Display for MaterialPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MaterialState {}
impl pg_sys::PgNode for MaterialState {}
impl ::core::fmt::Display for MaterialState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Memoize {}
impl pg_sys::PgNode for Memoize {}
impl ::core::fmt::Display for Memoize {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MemoizePath {}
impl pg_sys::PgNode for MemoizePath {}
impl ::core::fmt::Display for MemoizePath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MemoizeState {}
impl pg_sys::PgNode for MemoizeState {}
impl ::core::fmt::Display for MemoizeState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MemoryContextData {}
impl pg_sys::PgNode for MemoryContextData {}
impl ::core::fmt::Display for MemoryContextData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MergeAction {}
impl pg_sys::PgNode for MergeAction {}
impl ::core::fmt::Display for MergeAction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MergeActionState {}
impl pg_sys::PgNode for MergeActionState {}
impl ::core::fmt::Display for MergeActionState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MergeAppend {}
impl pg_sys::PgNode for MergeAppend {}
impl ::core::fmt::Display for MergeAppend {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MergeAppendPath {}
impl pg_sys::PgNode for MergeAppendPath {}
impl ::core::fmt::Display for MergeAppendPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MergeAppendState {}
impl pg_sys::PgNode for MergeAppendState {}
impl ::core::fmt::Display for MergeAppendState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MergeJoin {}
impl pg_sys::PgNode for MergeJoin {}
impl ::core::fmt::Display for MergeJoin {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MergeJoinState {}
impl pg_sys::PgNode for MergeJoinState {}
impl ::core::fmt::Display for MergeJoinState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MergePath {}
impl pg_sys::PgNode for MergePath {}
impl ::core::fmt::Display for MergePath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MergeStmt {}
impl pg_sys::PgNode for MergeStmt {}
impl ::core::fmt::Display for MergeStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MergeWhenClause {}
impl pg_sys::PgNode for MergeWhenClause {}
impl ::core::fmt::Display for MergeWhenClause {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MinMaxAggInfo {}
impl pg_sys::PgNode for MinMaxAggInfo {}
impl ::core::fmt::Display for MinMaxAggInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MinMaxAggPath {}
impl pg_sys::PgNode for MinMaxAggPath {}
impl ::core::fmt::Display for MinMaxAggPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MinMaxExpr {}
impl pg_sys::PgNode for MinMaxExpr {}
impl ::core::fmt::Display for MinMaxExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MinimalTupleTableSlot {}
impl pg_sys::PgNode for MinimalTupleTableSlot {}
impl ::core::fmt::Display for MinimalTupleTableSlot {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ModifyTable {}
impl pg_sys::PgNode for ModifyTable {}
impl ::core::fmt::Display for ModifyTable {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ModifyTablePath {}
impl pg_sys::PgNode for ModifyTablePath {}
impl ::core::fmt::Display for ModifyTablePath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ModifyTableState {}
impl pg_sys::PgNode for ModifyTableState {}
impl ::core::fmt::Display for ModifyTableState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for MultiAssignRef {}
impl pg_sys::PgNode for MultiAssignRef {}
impl ::core::fmt::Display for MultiAssignRef {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for NamedArgExpr {}
impl pg_sys::PgNode for NamedArgExpr {}
impl ::core::fmt::Display for NamedArgExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for NamedTuplestoreScan {}
impl pg_sys::PgNode for NamedTuplestoreScan {}
impl ::core::fmt::Display for NamedTuplestoreScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for NamedTuplestoreScanState {}
impl pg_sys::PgNode for NamedTuplestoreScanState {}
impl ::core::fmt::Display for NamedTuplestoreScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for NestLoop {}
impl pg_sys::PgNode for NestLoop {}
impl ::core::fmt::Display for NestLoop {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for NestLoopParam {}
impl pg_sys::PgNode for NestLoopParam {}
impl ::core::fmt::Display for NestLoopParam {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for NestLoopState {}
impl pg_sys::PgNode for NestLoopState {}
impl ::core::fmt::Display for NestLoopState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for NestPath {}
impl pg_sys::PgNode for NestPath {}
impl ::core::fmt::Display for NestPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for NextValueExpr {}
impl pg_sys::PgNode for NextValueExpr {}
impl ::core::fmt::Display for NextValueExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Node {}
impl pg_sys::PgNode for Node {}
impl ::core::fmt::Display for Node {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for NotifyStmt {}
impl pg_sys::PgNode for NotifyStmt {}
impl ::core::fmt::Display for NotifyStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for NullTest {}
impl pg_sys::PgNode for NullTest {}
impl ::core::fmt::Display for NullTest {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ObjectWithArgs {}
impl pg_sys::PgNode for ObjectWithArgs {}
impl ::core::fmt::Display for ObjectWithArgs {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for OnConflictClause {}
impl pg_sys::PgNode for OnConflictClause {}
impl ::core::fmt::Display for OnConflictClause {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for OnConflictExpr {}
impl pg_sys::PgNode for OnConflictExpr {}
impl ::core::fmt::Display for OnConflictExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for OnConflictSetState {}
impl pg_sys::PgNode for OnConflictSetState {}
impl ::core::fmt::Display for OnConflictSetState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for OpExpr {}
impl pg_sys::PgNode for OpExpr {}
impl ::core::fmt::Display for OpExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for OuterJoinClauseInfo {}
impl pg_sys::PgNode for OuterJoinClauseInfo {}
impl ::core::fmt::Display for OuterJoinClauseInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PLAssignStmt {}
impl pg_sys::PgNode for PLAssignStmt {}
impl ::core::fmt::Display for PLAssignStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Param {}
impl pg_sys::PgNode for Param {}
impl ::core::fmt::Display for Param {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ParamPathInfo {}
impl pg_sys::PgNode for ParamPathInfo {}
impl ::core::fmt::Display for ParamPathInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ParamRef {}
impl pg_sys::PgNode for ParamRef {}
impl ::core::fmt::Display for ParamRef {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PartitionBoundSpec {}
impl pg_sys::PgNode for PartitionBoundSpec {}
impl ::core::fmt::Display for PartitionBoundSpec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PartitionCmd {}
impl pg_sys::PgNode for PartitionCmd {}
impl ::core::fmt::Display for PartitionCmd {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PartitionElem {}
impl pg_sys::PgNode for PartitionElem {}
impl ::core::fmt::Display for PartitionElem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PartitionPruneInfo {}
impl pg_sys::PgNode for PartitionPruneInfo {}
impl ::core::fmt::Display for PartitionPruneInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PartitionPruneStep {}
impl pg_sys::PgNode for PartitionPruneStep {}
impl ::core::fmt::Display for PartitionPruneStep {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PartitionPruneStepCombine {}
impl pg_sys::PgNode for PartitionPruneStepCombine {}
impl ::core::fmt::Display for PartitionPruneStepCombine {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PartitionPruneStepOp {}
impl pg_sys::PgNode for PartitionPruneStepOp {}
impl ::core::fmt::Display for PartitionPruneStepOp {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PartitionRangeDatum {}
impl pg_sys::PgNode for PartitionRangeDatum {}
impl ::core::fmt::Display for PartitionRangeDatum {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PartitionSpec {}
impl pg_sys::PgNode for PartitionSpec {}
impl ::core::fmt::Display for PartitionSpec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PartitionedRelPruneInfo {}
impl pg_sys::PgNode for PartitionedRelPruneInfo {}
impl ::core::fmt::Display for PartitionedRelPruneInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Path {}
impl pg_sys::PgNode for Path {}
impl ::core::fmt::Display for Path {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PathKey {}
impl pg_sys::PgNode for PathKey {}
impl ::core::fmt::Display for PathKey {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PathTarget {}
impl pg_sys::PgNode for PathTarget {}
impl ::core::fmt::Display for PathTarget {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PlaceHolderInfo {}
impl pg_sys::PgNode for PlaceHolderInfo {}
impl ::core::fmt::Display for PlaceHolderInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PlaceHolderVar {}
impl pg_sys::PgNode for PlaceHolderVar {}
impl ::core::fmt::Display for PlaceHolderVar {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Plan {}
impl pg_sys::PgNode for Plan {}
impl ::core::fmt::Display for Plan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PlanInvalItem {}
impl pg_sys::PgNode for PlanInvalItem {}
impl ::core::fmt::Display for PlanInvalItem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PlanRowMark {}
impl pg_sys::PgNode for PlanRowMark {}
impl ::core::fmt::Display for PlanRowMark {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PlanState {}
impl pg_sys::PgNode for PlanState {}
impl ::core::fmt::Display for PlanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PlannedStmt {}
impl pg_sys::PgNode for PlannedStmt {}
impl ::core::fmt::Display for PlannedStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PlannerGlobal {}
impl pg_sys::PgNode for PlannerGlobal {}
impl ::core::fmt::Display for PlannerGlobal {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PlannerInfo {}
impl pg_sys::PgNode for PlannerInfo {}
impl ::core::fmt::Display for PlannerInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PlannerParamItem {}
impl pg_sys::PgNode for PlannerParamItem {}
impl ::core::fmt::Display for PlannerParamItem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PrepareStmt {}
impl pg_sys::PgNode for PrepareStmt {}
impl ::core::fmt::Display for PrepareStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ProjectSet {}
impl pg_sys::PgNode for ProjectSet {}
impl ::core::fmt::Display for ProjectSet {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ProjectSetPath {}
impl pg_sys::PgNode for ProjectSetPath {}
impl ::core::fmt::Display for ProjectSetPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ProjectSetState {}
impl pg_sys::PgNode for ProjectSetState {}
impl ::core::fmt::Display for ProjectSetState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ProjectionInfo {}
impl pg_sys::PgNode for ProjectionInfo {}
impl ::core::fmt::Display for ProjectionInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ProjectionPath {}
impl pg_sys::PgNode for ProjectionPath {}
impl ::core::fmt::Display for ProjectionPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PublicationObjSpec {}
impl pg_sys::PgNode for PublicationObjSpec {}
impl ::core::fmt::Display for PublicationObjSpec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for PublicationTable {}
impl pg_sys::PgNode for PublicationTable {}
impl ::core::fmt::Display for PublicationTable {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Query {}
impl pg_sys::PgNode for Query {}
impl ::core::fmt::Display for Query {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RTEPermissionInfo {}
impl pg_sys::PgNode for RTEPermissionInfo {}
impl ::core::fmt::Display for RTEPermissionInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RangeFunction {}
impl pg_sys::PgNode for RangeFunction {}
impl ::core::fmt::Display for RangeFunction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RangeSubselect {}
impl pg_sys::PgNode for RangeSubselect {}
impl ::core::fmt::Display for RangeSubselect {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RangeTableFunc {}
impl pg_sys::PgNode for RangeTableFunc {}
impl ::core::fmt::Display for RangeTableFunc {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RangeTableFuncCol {}
impl pg_sys::PgNode for RangeTableFuncCol {}
impl ::core::fmt::Display for RangeTableFuncCol {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RangeTableSample {}
impl pg_sys::PgNode for RangeTableSample {}
impl ::core::fmt::Display for RangeTableSample {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RangeTblEntry {}
impl pg_sys::PgNode for RangeTblEntry {}
impl ::core::fmt::Display for RangeTblEntry {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RangeTblFunction {}
impl pg_sys::PgNode for RangeTblFunction {}
impl ::core::fmt::Display for RangeTblFunction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RangeTblRef {}
impl pg_sys::PgNode for RangeTblRef {}
impl ::core::fmt::Display for RangeTblRef {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RangeVar {}
impl pg_sys::PgNode for RangeVar {}
impl ::core::fmt::Display for RangeVar {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RawStmt {}
impl pg_sys::PgNode for RawStmt {}
impl ::core::fmt::Display for RawStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ReadReplicationSlotCmd {}
impl pg_sys::PgNode for ReadReplicationSlotCmd {}
impl ::core::fmt::Display for ReadReplicationSlotCmd {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ReassignOwnedStmt {}
impl pg_sys::PgNode for ReassignOwnedStmt {}
impl ::core::fmt::Display for ReassignOwnedStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RecursiveUnion {}
impl pg_sys::PgNode for RecursiveUnion {}
impl ::core::fmt::Display for RecursiveUnion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RecursiveUnionPath {}
impl pg_sys::PgNode for RecursiveUnionPath {}
impl ::core::fmt::Display for RecursiveUnionPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RecursiveUnionState {}
impl pg_sys::PgNode for RecursiveUnionState {}
impl ::core::fmt::Display for RecursiveUnionState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RefreshMatViewStmt {}
impl pg_sys::PgNode for RefreshMatViewStmt {}
impl ::core::fmt::Display for RefreshMatViewStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ReindexStmt {}
impl pg_sys::PgNode for ReindexStmt {}
impl ::core::fmt::Display for ReindexStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RelOptInfo {}
impl pg_sys::PgNode for RelOptInfo {}
impl ::core::fmt::Display for RelOptInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RelabelType {}
impl pg_sys::PgNode for RelabelType {}
impl ::core::fmt::Display for RelabelType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RenameStmt {}
impl pg_sys::PgNode for RenameStmt {}
impl ::core::fmt::Display for RenameStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ReplicaIdentityStmt {}
impl pg_sys::PgNode for ReplicaIdentityStmt {}
impl ::core::fmt::Display for ReplicaIdentityStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ResTarget {}
impl pg_sys::PgNode for ResTarget {}
impl ::core::fmt::Display for ResTarget {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RestrictInfo {}
impl pg_sys::PgNode for RestrictInfo {}
impl ::core::fmt::Display for RestrictInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Result {}
impl pg_sys::PgNode for Result {}
impl ::core::fmt::Display for Result {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ResultRelInfo {}
impl pg_sys::PgNode for ResultRelInfo {}
impl ::core::fmt::Display for ResultRelInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ResultState {}
impl pg_sys::PgNode for ResultState {}
impl ::core::fmt::Display for ResultState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ReturnSetInfo {}
impl pg_sys::PgNode for ReturnSetInfo {}
impl ::core::fmt::Display for ReturnSetInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ReturnStmt {}
impl pg_sys::PgNode for ReturnStmt {}
impl ::core::fmt::Display for ReturnStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RoleSpec {}
impl pg_sys::PgNode for RoleSpec {}
impl ::core::fmt::Display for RoleSpec {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RollupData {}
impl pg_sys::PgNode for RollupData {}
impl ::core::fmt::Display for RollupData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RowCompareExpr {}
impl pg_sys::PgNode for RowCompareExpr {}
impl ::core::fmt::Display for RowCompareExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RowExpr {}
impl pg_sys::PgNode for RowExpr {}
impl ::core::fmt::Display for RowExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RowIdentityVarInfo {}
impl pg_sys::PgNode for RowIdentityVarInfo {}
impl ::core::fmt::Display for RowIdentityVarInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RowMarkClause {}
impl pg_sys::PgNode for RowMarkClause {}
impl ::core::fmt::Display for RowMarkClause {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for RuleStmt {}
impl pg_sys::PgNode for RuleStmt {}
impl ::core::fmt::Display for RuleStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SQLValueFunction {}
impl pg_sys::PgNode for SQLValueFunction {}
impl ::core::fmt::Display for SQLValueFunction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SampleScan {}
impl pg_sys::PgNode for SampleScan {}
impl ::core::fmt::Display for SampleScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SampleScanState {}
impl pg_sys::PgNode for SampleScanState {}
impl ::core::fmt::Display for SampleScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ScalarArrayOpExpr {}
impl pg_sys::PgNode for ScalarArrayOpExpr {}
impl ::core::fmt::Display for ScalarArrayOpExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Scan {}
impl pg_sys::PgNode for Scan {}
impl ::core::fmt::Display for Scan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ScanState {}
impl pg_sys::PgNode for ScanState {}
impl ::core::fmt::Display for ScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SecLabelStmt {}
impl pg_sys::PgNode for SecLabelStmt {}
impl ::core::fmt::Display for SecLabelStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SelectStmt {}
impl pg_sys::PgNode for SelectStmt {}
impl ::core::fmt::Display for SelectStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SeqScan {}
impl pg_sys::PgNode for SeqScan {}
impl ::core::fmt::Display for SeqScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SeqScanState {}
impl pg_sys::PgNode for SeqScanState {}
impl ::core::fmt::Display for SeqScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SetExprState {}
impl pg_sys::PgNode for SetExprState {}
impl ::core::fmt::Display for SetExprState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SetOp {}
impl pg_sys::PgNode for SetOp {}
impl ::core::fmt::Display for SetOp {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SetOpPath {}
impl pg_sys::PgNode for SetOpPath {}
impl ::core::fmt::Display for SetOpPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SetOpState {}
impl pg_sys::PgNode for SetOpState {}
impl ::core::fmt::Display for SetOpState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SetOperationStmt {}
impl pg_sys::PgNode for SetOperationStmt {}
impl ::core::fmt::Display for SetOperationStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SetToDefault {}
impl pg_sys::PgNode for SetToDefault {}
impl ::core::fmt::Display for SetToDefault {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Sort {}
impl pg_sys::PgNode for Sort {}
impl ::core::fmt::Display for Sort {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SortBy {}
impl pg_sys::PgNode for SortBy {}
impl ::core::fmt::Display for SortBy {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SortGroupClause {}
impl pg_sys::PgNode for SortGroupClause {}
impl ::core::fmt::Display for SortGroupClause {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SortPath {}
impl pg_sys::PgNode for SortPath {}
impl ::core::fmt::Display for SortPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SortState {}
impl pg_sys::PgNode for SortState {}
impl ::core::fmt::Display for SortState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SpecialJoinInfo {}
impl pg_sys::PgNode for SpecialJoinInfo {}
impl ::core::fmt::Display for SpecialJoinInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for StartReplicationCmd {}
impl pg_sys::PgNode for StartReplicationCmd {}
impl ::core::fmt::Display for StartReplicationCmd {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for StatisticExtInfo {}
impl pg_sys::PgNode for StatisticExtInfo {}
impl ::core::fmt::Display for StatisticExtInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for StatsElem {}
impl pg_sys::PgNode for StatsElem {}
impl ::core::fmt::Display for StatsElem {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for String {}
impl pg_sys::PgNode for String {}
impl ::core::fmt::Display for String {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SubLink {}
impl pg_sys::PgNode for SubLink {}
impl ::core::fmt::Display for SubLink {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SubPlan {}
impl pg_sys::PgNode for SubPlan {}
impl ::core::fmt::Display for SubPlan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SubPlanState {}
impl pg_sys::PgNode for SubPlanState {}
impl ::core::fmt::Display for SubPlanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SubqueryScan {}
impl pg_sys::PgNode for SubqueryScan {}
impl ::core::fmt::Display for SubqueryScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SubqueryScanPath {}
impl pg_sys::PgNode for SubqueryScanPath {}
impl ::core::fmt::Display for SubqueryScanPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SubqueryScanState {}
impl pg_sys::PgNode for SubqueryScanState {}
impl ::core::fmt::Display for SubqueryScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SubscriptingRef {}
impl pg_sys::PgNode for SubscriptingRef {}
impl ::core::fmt::Display for SubscriptingRef {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SupportRequestCost {}
impl pg_sys::PgNode for SupportRequestCost {}
impl ::core::fmt::Display for SupportRequestCost {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SupportRequestIndexCondition {}
impl pg_sys::PgNode for SupportRequestIndexCondition {}
impl ::core::fmt::Display for SupportRequestIndexCondition {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SupportRequestOptimizeWindowClause {}
impl pg_sys::PgNode for SupportRequestOptimizeWindowClause {}
impl ::core::fmt::Display for SupportRequestOptimizeWindowClause {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SupportRequestRows {}
impl pg_sys::PgNode for SupportRequestRows {}
impl ::core::fmt::Display for SupportRequestRows {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SupportRequestSelectivity {}
impl pg_sys::PgNode for SupportRequestSelectivity {}
impl ::core::fmt::Display for SupportRequestSelectivity {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SupportRequestSimplify {}
impl pg_sys::PgNode for SupportRequestSimplify {}
impl ::core::fmt::Display for SupportRequestSimplify {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for SupportRequestWFuncMonotonic {}
impl pg_sys::PgNode for SupportRequestWFuncMonotonic {}
impl ::core::fmt::Display for SupportRequestWFuncMonotonic {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TableAmRoutine {}
impl pg_sys::PgNode for TableAmRoutine {}
impl ::core::fmt::Display for TableAmRoutine {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TableFunc {}
impl pg_sys::PgNode for TableFunc {}
impl ::core::fmt::Display for TableFunc {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TableFuncScan {}
impl pg_sys::PgNode for TableFuncScan {}
impl ::core::fmt::Display for TableFuncScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TableFuncScanState {}
impl pg_sys::PgNode for TableFuncScanState {}
impl ::core::fmt::Display for TableFuncScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TableLikeClause {}
impl pg_sys::PgNode for TableLikeClause {}
impl ::core::fmt::Display for TableLikeClause {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TableSampleClause {}
impl pg_sys::PgNode for TableSampleClause {}
impl ::core::fmt::Display for TableSampleClause {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TargetEntry {}
impl pg_sys::PgNode for TargetEntry {}
impl ::core::fmt::Display for TargetEntry {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TidPath {}
impl pg_sys::PgNode for TidPath {}
impl ::core::fmt::Display for TidPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TidRangePath {}
impl pg_sys::PgNode for TidRangePath {}
impl ::core::fmt::Display for TidRangePath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TidRangeScan {}
impl pg_sys::PgNode for TidRangeScan {}
impl ::core::fmt::Display for TidRangeScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TidRangeScanState {}
impl pg_sys::PgNode for TidRangeScanState {}
impl ::core::fmt::Display for TidRangeScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TidScan {}
impl pg_sys::PgNode for TidScan {}
impl ::core::fmt::Display for TidScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TidScanState {}
impl pg_sys::PgNode for TidScanState {}
impl ::core::fmt::Display for TidScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TimeLineHistoryCmd {}
impl pg_sys::PgNode for TimeLineHistoryCmd {}
impl ::core::fmt::Display for TimeLineHistoryCmd {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TransactionStmt {}
impl pg_sys::PgNode for TransactionStmt {}
impl ::core::fmt::Display for TransactionStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TriggerData {}
impl pg_sys::PgNode for TriggerData {}
impl ::core::fmt::Display for TriggerData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TriggerTransition {}
impl pg_sys::PgNode for TriggerTransition {}
impl ::core::fmt::Display for TriggerTransition {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TruncateStmt {}
impl pg_sys::PgNode for TruncateStmt {}
impl ::core::fmt::Display for TruncateStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TupleTableSlot {}
impl pg_sys::PgNode for TupleTableSlot {}
impl ::core::fmt::Display for TupleTableSlot {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TypeCast {}
impl pg_sys::PgNode for TypeCast {}
impl ::core::fmt::Display for TypeCast {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for TypeName {}
impl pg_sys::PgNode for TypeName {}
impl ::core::fmt::Display for TypeName {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Unique {}
impl pg_sys::PgNode for Unique {}
impl ::core::fmt::Display for Unique {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for UniquePath {}
impl pg_sys::PgNode for UniquePath {}
impl ::core::fmt::Display for UniquePath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for UniqueState {}
impl pg_sys::PgNode for UniqueState {}
impl ::core::fmt::Display for UniqueState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for UnlistenStmt {}
impl pg_sys::PgNode for UnlistenStmt {}
impl ::core::fmt::Display for UnlistenStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for UpdateStmt {}
impl pg_sys::PgNode for UpdateStmt {}
impl ::core::fmt::Display for UpdateStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for UpperUniquePath {}
impl pg_sys::PgNode for UpperUniquePath {}
impl ::core::fmt::Display for UpperUniquePath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for VacuumRelation {}
impl pg_sys::PgNode for VacuumRelation {}
impl ::core::fmt::Display for VacuumRelation {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for VacuumStmt {}
impl pg_sys::PgNode for VacuumStmt {}
impl ::core::fmt::Display for VacuumStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ValuesScan {}
impl pg_sys::PgNode for ValuesScan {}
impl ::core::fmt::Display for ValuesScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ValuesScanState {}
impl pg_sys::PgNode for ValuesScanState {}
impl ::core::fmt::Display for ValuesScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for Var {}
impl pg_sys::PgNode for Var {}
impl ::core::fmt::Display for Var {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for VariableSetStmt {}
impl pg_sys::PgNode for VariableSetStmt {}
impl ::core::fmt::Display for VariableSetStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for VariableShowStmt {}
impl pg_sys::PgNode for VariableShowStmt {}
impl ::core::fmt::Display for VariableShowStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for ViewStmt {}
impl pg_sys::PgNode for ViewStmt {}
impl ::core::fmt::Display for ViewStmt {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for VirtualTupleTableSlot {}
impl pg_sys::PgNode for VirtualTupleTableSlot {}
impl ::core::fmt::Display for VirtualTupleTableSlot {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for WindowAgg {}
impl pg_sys::PgNode for WindowAgg {}
impl ::core::fmt::Display for WindowAgg {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for WindowAggPath {}
impl pg_sys::PgNode for WindowAggPath {}
impl ::core::fmt::Display for WindowAggPath {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for WindowAggState {}
impl pg_sys::PgNode for WindowAggState {}
impl ::core::fmt::Display for WindowAggState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for WindowClause {}
impl pg_sys::PgNode for WindowClause {}
impl ::core::fmt::Display for WindowClause {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for WindowDef {}
impl pg_sys::PgNode for WindowDef {}
impl ::core::fmt::Display for WindowDef {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for WindowFunc {}
impl pg_sys::PgNode for WindowFunc {}
impl ::core::fmt::Display for WindowFunc {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for WindowFuncExprState {}
impl pg_sys::PgNode for WindowFuncExprState {}
impl ::core::fmt::Display for WindowFuncExprState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for WithCheckOption {}
impl pg_sys::PgNode for WithCheckOption {}
impl ::core::fmt::Display for WithCheckOption {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for WithClause {}
impl pg_sys::PgNode for WithClause {}
impl ::core::fmt::Display for WithClause {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for WorkTableScan {}
impl pg_sys::PgNode for WorkTableScan {}
impl ::core::fmt::Display for WorkTableScan {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for WorkTableScanState {}
impl pg_sys::PgNode for WorkTableScanState {}
impl ::core::fmt::Display for WorkTableScanState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for XmlExpr {}
impl pg_sys::PgNode for XmlExpr {}
impl ::core::fmt::Display for XmlExpr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
impl pg_sys::seal::Sealed for XmlSerialize {}
impl pg_sys::PgNode for XmlSerialize {}
impl ::core::fmt::Display for XmlSerialize {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.display_node().fmt(f)
    }
}
