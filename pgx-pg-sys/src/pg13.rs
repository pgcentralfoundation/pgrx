use crate as pg_sys;
#[cfg(any(feature = "pg12", feature = "pg13", feature = "pg14"))]
use crate::NullableDatum;
use crate::{Datum, PgNode};
#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") { 7 - (index % 8) } else { index % 8 };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") { 7 - (index % 8) } else { index % 8 };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index =
                    if cfg!(target_endian = "big") { bit_width as usize - 1 - i } else { i };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") { bit_width as usize - 1 - i } else { i };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const PG_DIAG_SEVERITY: u8 = 83u8;
pub const PG_DIAG_SEVERITY_NONLOCALIZED: u8 = 86u8;
pub const PG_DIAG_SQLSTATE: u8 = 67u8;
pub const PG_DIAG_MESSAGE_PRIMARY: u8 = 77u8;
pub const PG_DIAG_MESSAGE_DETAIL: u8 = 68u8;
pub const PG_DIAG_MESSAGE_HINT: u8 = 72u8;
pub const PG_DIAG_STATEMENT_POSITION: u8 = 80u8;
pub const PG_DIAG_INTERNAL_POSITION: u8 = 112u8;
pub const PG_DIAG_INTERNAL_QUERY: u8 = 113u8;
pub const PG_DIAG_CONTEXT: u8 = 87u8;
pub const PG_DIAG_SCHEMA_NAME: u8 = 115u8;
pub const PG_DIAG_TABLE_NAME: u8 = 116u8;
pub const PG_DIAG_COLUMN_NAME: u8 = 99u8;
pub const PG_DIAG_DATATYPE_NAME: u8 = 100u8;
pub const PG_DIAG_CONSTRAINT_NAME: u8 = 110u8;
pub const PG_DIAG_SOURCE_FILE: u8 = 70u8;
pub const PG_DIAG_SOURCE_LINE: u8 = 76u8;
pub const PG_DIAG_SOURCE_FUNCTION: u8 = 82u8;
pub const ALIGNOF_DOUBLE: u32 = 8;
pub const ALIGNOF_INT: u32 = 4;
pub const ALIGNOF_LONG: u32 = 8;
pub const ALIGNOF_PG_INT128_TYPE: u32 = 16;
pub const ALIGNOF_SHORT: u32 = 2;
pub const BLCKSZ: u32 = 8192;
pub const CONFIGURE_ARGS : & [u8 ; 107usize] = b" '--prefix=/Users/e_ridge/.pgx/13.5/pgx-install' '--with-pgport=28813' '--enable-debug' '--enable-cassert'\0" ;
pub const DEF_PGPORT: u32 = 28813;
pub const DEF_PGPORT_STR: &[u8; 6usize] = b"28813\0";
pub const ENABLE_THREAD_SAFETY: u32 = 1;
pub const HAVE_ATOMICS: u32 = 1;
pub const HAVE_BACKTRACE_SYMBOLS: u32 = 1;
pub const HAVE_CLOCK_GETTIME: u32 = 1;
pub const HAVE_COMPUTED_GOTO: u32 = 1;
pub const HAVE_COPYFILE: u32 = 1;
pub const HAVE_COPYFILE_H: u32 = 1;
pub const HAVE_DECL_FDATASYNC: u32 = 0;
pub const HAVE_DECL_F_FULLFSYNC: u32 = 1;
pub const HAVE_DECL_POSIX_FADVISE: u32 = 0;
pub const HAVE_DECL_RTLD_GLOBAL: u32 = 1;
pub const HAVE_DECL_RTLD_NOW: u32 = 1;
pub const HAVE_DECL_STRLCAT: u32 = 1;
pub const HAVE_DECL_STRLCPY: u32 = 1;
pub const HAVE_DECL_STRNLEN: u32 = 1;
pub const HAVE_DECL_STRTOLL: u32 = 1;
pub const HAVE_DECL_STRTOULL: u32 = 1;
pub const HAVE_DLOPEN: u32 = 1;
pub const HAVE_EXECINFO_H: u32 = 1;
pub const HAVE_FDATASYNC: u32 = 1;
pub const HAVE_FLS: u32 = 1;
pub const HAVE_FSEEKO: u32 = 1;
pub const HAVE_FUNCNAME__FUNC: u32 = 1;
pub const HAVE_GCC__ATOMIC_INT32_CAS: u32 = 1;
pub const HAVE_GCC__ATOMIC_INT64_CAS: u32 = 1;
pub const HAVE_GCC__SYNC_CHAR_TAS: u32 = 1;
pub const HAVE_GCC__SYNC_INT32_CAS: u32 = 1;
pub const HAVE_GCC__SYNC_INT32_TAS: u32 = 1;
pub const HAVE_GCC__SYNC_INT64_CAS: u32 = 1;
pub const HAVE_GETADDRINFO: u32 = 1;
pub const HAVE_GETIFADDRS: u32 = 1;
pub const HAVE_GETOPT: u32 = 1;
pub const HAVE_GETOPT_H: u32 = 1;
pub const HAVE_GETOPT_LONG: u32 = 1;
pub const HAVE_GETPEEREID: u32 = 1;
pub const HAVE_GETPWUID_R: u32 = 1;
pub const HAVE_GETRLIMIT: u32 = 1;
pub const HAVE_GETRUSAGE: u32 = 1;
pub const HAVE_HISTORY_TRUNCATE_FILE: u32 = 1;
pub const HAVE_IFADDRS_H: u32 = 1;
pub const HAVE_INET_ATON: u32 = 1;
pub const HAVE_INTTYPES_H: u32 = 1;
pub const HAVE_INT_OPTERR: u32 = 1;
pub const HAVE_INT_OPTRESET: u32 = 1;
pub const HAVE_INT_TIMEZONE: u32 = 1;
pub const HAVE_IPV6: u32 = 1;
pub const HAVE_KQUEUE: u32 = 1;
pub const HAVE_LANGINFO_H: u32 = 1;
pub const HAVE_LIBM: u32 = 1;
pub const HAVE_LIBREADLINE: u32 = 1;
pub const HAVE_LIBZ: u32 = 1;
pub const HAVE_LINK: u32 = 1;
pub const HAVE_LOCALE_T: u32 = 1;
pub const HAVE_LONG_INT_64: u32 = 1;
pub const HAVE_MBSTOWCS_L: u32 = 1;
pub const HAVE_MEMORY_H: u32 = 1;
pub const HAVE_MEMSET_S: u32 = 1;
pub const HAVE_MKDTEMP: u32 = 1;
pub const HAVE_NETINET_TCP_H: u32 = 1;
pub const HAVE_NET_IF_H: u32 = 1;
pub const HAVE_POLL: u32 = 1;
pub const HAVE_POLL_H: u32 = 1;
pub const HAVE_PREAD: u32 = 1;
pub const HAVE_PTHREAD: u32 = 1;
pub const HAVE_PTHREAD_IS_THREADED_NP: u32 = 1;
pub const HAVE_PTHREAD_PRIO_INHERIT: u32 = 1;
pub const HAVE_PWRITE: u32 = 1;
pub const HAVE_RANDOM: u32 = 1;
pub const HAVE_READLINE_HISTORY_H: u32 = 1;
pub const HAVE_READLINE_READLINE_H: u32 = 1;
pub const HAVE_READLINK: u32 = 1;
pub const HAVE_RL_COMPLETION_APPEND_CHARACTER: u32 = 1;
pub const HAVE_RL_COMPLETION_MATCHES: u32 = 1;
pub const HAVE_RL_FILENAME_COMPLETION_FUNCTION: u32 = 1;
pub const HAVE_SETENV: u32 = 1;
pub const HAVE_SETSID: u32 = 1;
pub const HAVE_SHM_OPEN: u32 = 1;
pub const HAVE_SPINLOCKS: u32 = 1;
pub const HAVE_SRANDOM: u32 = 1;
pub const HAVE_STDBOOL_H: u32 = 1;
pub const HAVE_STDINT_H: u32 = 1;
pub const HAVE_STDLIB_H: u32 = 1;
pub const HAVE_STRERROR_R: u32 = 1;
pub const HAVE_STRINGS_H: u32 = 1;
pub const HAVE_STRING_H: u32 = 1;
pub const HAVE_STRLCAT: u32 = 1;
pub const HAVE_STRLCPY: u32 = 1;
pub const HAVE_STRNLEN: u32 = 1;
pub const HAVE_STRSIGNAL: u32 = 1;
pub const HAVE_STRTOF: u32 = 1;
pub const HAVE_STRTOLL: u32 = 1;
pub const HAVE_STRTOULL: u32 = 1;
pub const HAVE_STRUCT_ADDRINFO: u32 = 1;
pub const HAVE_STRUCT_OPTION: u32 = 1;
pub const HAVE_STRUCT_SOCKADDR_SA_LEN: u32 = 1;
pub const HAVE_STRUCT_SOCKADDR_STORAGE: u32 = 1;
pub const HAVE_STRUCT_SOCKADDR_STORAGE_SS_FAMILY: u32 = 1;
pub const HAVE_STRUCT_SOCKADDR_STORAGE_SS_LEN: u32 = 1;
pub const HAVE_STRUCT_SOCKADDR_UN: u32 = 1;
pub const HAVE_STRUCT_TM_TM_ZONE: u32 = 1;
pub const HAVE_SYMLINK: u32 = 1;
pub const HAVE_SYSLOG: u32 = 1;
pub const HAVE_SYS_EVENT_H: u32 = 1;
pub const HAVE_SYS_IPC_H: u32 = 1;
pub const HAVE_SYS_RESOURCE_H: u32 = 1;
pub const HAVE_SYS_SELECT_H: u32 = 1;
pub const HAVE_SYS_SEM_H: u32 = 1;
pub const HAVE_SYS_SHM_H: u32 = 1;
pub const HAVE_SYS_SOCKIO_H: u32 = 1;
pub const HAVE_SYS_STAT_H: u32 = 1;
pub const HAVE_SYS_TYPES_H: u32 = 1;
pub const HAVE_SYS_UCRED_H: u32 = 1;
pub const HAVE_SYS_UN_H: u32 = 1;
pub const HAVE_TERMIOS_H: u32 = 1;
pub const HAVE_TYPEOF: u32 = 1;
pub const HAVE_UNION_SEMUN: u32 = 1;
pub const HAVE_UNISTD_H: u32 = 1;
pub const HAVE_UNSETENV: u32 = 1;
pub const HAVE_USELOCALE: u32 = 1;
pub const HAVE_WCSTOMBS_L: u32 = 1;
pub const HAVE_WCTYPE_H: u32 = 1;
pub const HAVE__BOOL: u32 = 1;
pub const HAVE__BUILTIN_BSWAP16: u32 = 1;
pub const HAVE__BUILTIN_BSWAP32: u32 = 1;
pub const HAVE__BUILTIN_BSWAP64: u32 = 1;
pub const HAVE__BUILTIN_CLZ: u32 = 1;
pub const HAVE__BUILTIN_CONSTANT_P: u32 = 1;
pub const HAVE__BUILTIN_CTZ: u32 = 1;
pub const HAVE__BUILTIN_OP_OVERFLOW: u32 = 1;
pub const HAVE__BUILTIN_POPCOUNT: u32 = 1;
pub const HAVE__BUILTIN_TYPES_COMPATIBLE_P: u32 = 1;
pub const HAVE__BUILTIN_UNREACHABLE: u32 = 1;
pub const HAVE__STATIC_ASSERT: u32 = 1;
pub const INT64_MODIFIER: &[u8; 2usize] = b"l\0";
pub const LOCALE_T_IN_XLOCALE: u32 = 1;
pub const MAXIMUM_ALIGNOF: u32 = 8;
pub const MEMSET_LOOP_LIMIT: u32 = 1024;
pub const PACKAGE_BUGREPORT: &[u8; 32usize] = b"pgsql-bugs@lists.postgresql.org\0";
pub const PACKAGE_NAME: &[u8; 11usize] = b"PostgreSQL\0";
pub const PACKAGE_STRING: &[u8; 16usize] = b"PostgreSQL 13.5\0";
pub const PACKAGE_TARNAME: &[u8; 11usize] = b"postgresql\0";
pub const PACKAGE_URL: &[u8; 28usize] = b"https://www.postgresql.org/\0";
pub const PACKAGE_VERSION: &[u8; 5usize] = b"13.5\0";
pub const PG_KRB_SRVNAM: &[u8; 9usize] = b"postgres\0";
pub const PG_MAJORVERSION: &[u8; 3usize] = b"13\0";
pub const PG_MAJORVERSION_NUM: u32 = 13;
pub const PG_MINORVERSION_NUM: u32 = 5;
pub const PG_USE_STDBOOL: u32 = 1;
pub const PG_VERSION: &[u8; 5usize] = b"13.5\0";
pub const PG_VERSION_NUM: u32 = 130005;
pub const PG_VERSION_STR : & [u8 ; 111usize] = b"PostgreSQL 13.5 on arm-apple-darwin21.3.0, compiled by Apple clang version 13.0.0 (clang-1300.0.29.30), 64-bit\0" ;
pub const RELSEG_SIZE: u32 = 131072;
pub const SIZEOF_BOOL: u32 = 1;
pub const SIZEOF_LONG: u32 = 8;
pub const SIZEOF_OFF_T: u32 = 8;
pub const SIZEOF_SIZE_T: u32 = 8;
pub const SIZEOF_VOID_P: u32 = 8;
pub const STDC_HEADERS: u32 = 1;
pub const STRERROR_R_INT: u32 = 1;
pub const USE_ARMV8_CRC32C: u32 = 1;
pub const USE_ASSERT_CHECKING: u32 = 1;
pub const USE_DEV_URANDOM: u32 = 1;
pub const USE_SYSV_SEMAPHORES: u32 = 1;
pub const USE_SYSV_SHARED_MEMORY: u32 = 1;
pub const WCSTOMBS_L_IN_XLOCALE: u32 = 1;
pub const XLOG_BLCKSZ: u32 = 8192;
pub const DEFAULT_XLOG_SEG_SIZE: u32 = 16777216;
pub const NAMEDATALEN: u32 = 64;
pub const FUNC_MAX_ARGS: u32 = 100;
pub const INDEX_MAX_KEYS: u32 = 32;
pub const PARTITION_MAX_KEYS: u32 = 32;
pub const USE_FLOAT8_BYVAL: u32 = 1;
pub const NUM_SPINLOCK_SEMAPHORES: u32 = 128;
pub const NUM_ATOMICS_SEMAPHORES: u32 = 64;
pub const MAXPGPATH: u32 = 1024;
pub const PG_SOMAXCONN: u32 = 10000;
pub const BITS_PER_BYTE: u32 = 8;
pub const ALIGNOF_BUFFER: u32 = 32;
pub const HAVE_WORKING_LINK: u32 = 1;
pub const DEFAULT_BACKEND_FLUSH_AFTER: u32 = 0;
pub const DEFAULT_BGWRITER_FLUSH_AFTER: u32 = 0;
pub const DEFAULT_CHECKPOINT_FLUSH_AFTER: u32 = 0;
pub const WRITEBACK_MAX_PENDING_FLUSHES: u32 = 256;
pub const DEFAULT_PGSOCKET_DIR: &[u8; 5usize] = b"/tmp\0";
pub const DEFAULT_EVENT_SOURCE: &[u8; 11usize] = b"PostgreSQL\0";
pub const PG_CACHE_LINE_SIZE: u32 = 128;
pub const TRACE_SORT: u32 = 1;
pub const __darwin__: u32 = 1;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 120100;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const RENAME_SECLUDE: u32 = 1;
pub const RENAME_SWAP: u32 = 2;
pub const RENAME_EXCL: u32 = 4;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SMOD: u32 = 8192;
pub const __SALC: u32 = 16384;
pub const __SIGN: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const P_tmpdir: &[u8; 10usize] = b"/var/tmp/\0";
pub const L_tmpnam: u32 = 1024;
pub const TMP_MAX: u32 = 308915776;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const L_ctermid: u32 = 1024;
pub const _USE_FORTIFY_LEVEL: u32 = 2;
pub const __DARWIN_NSIG: u32 = 32;
pub const NSIG: u32 = 32;
pub const _ARM_SIGNAL_: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGINFO: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const __DARWIN_OPAQUE_ARM_THREAD_STATE64: u32 = 0;
pub const SIGEV_NONE: u32 = 0;
pub const SIGEV_SIGNAL: u32 = 1;
pub const SIGEV_THREAD: u32 = 3;
pub const ILL_NOOP: u32 = 0;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLTRP: u32 = 2;
pub const ILL_PRVOPC: u32 = 3;
pub const ILL_ILLOPN: u32 = 4;
pub const ILL_ILLADR: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const FPE_NOOP: u32 = 0;
pub const FPE_FLTDIV: u32 = 1;
pub const FPE_FLTOVF: u32 = 2;
pub const FPE_FLTUND: u32 = 3;
pub const FPE_FLTRES: u32 = 4;
pub const FPE_FLTINV: u32 = 5;
pub const FPE_FLTSUB: u32 = 6;
pub const FPE_INTDIV: u32 = 7;
pub const FPE_INTOVF: u32 = 8;
pub const SEGV_NOOP: u32 = 0;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const BUS_NOOP: u32 = 0;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const CLD_NOOP: u32 = 0;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const SA_ONSTACK: u32 = 1;
pub const SA_RESTART: u32 = 2;
pub const SA_RESETHAND: u32 = 4;
pub const SA_NOCLDSTOP: u32 = 8;
pub const SA_NODEFER: u32 = 16;
pub const SA_NOCLDWAIT: u32 = 32;
pub const SA_SIGINFO: u32 = 64;
pub const SA_USERTRAMP: u32 = 256;
pub const SA_64REGSET: u32 = 512;
pub const SA_USERSPACE_MASK: u32 = 127;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG_SETMASK: u32 = 3;
pub const SI_USER: u32 = 65537;
pub const SI_QUEUE: u32 = 65538;
pub const SI_TIMER: u32 = 65539;
pub const SI_ASYNCIO: u32 = 65540;
pub const SI_MESGQ: u32 = 65541;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 4;
pub const MINSIGSTKSZ: u32 = 32768;
pub const SIGSTKSZ: u32 = 131072;
pub const SV_ONSTACK: u32 = 1;
pub const SV_INTERRUPT: u32 = 2;
pub const SV_RESETHAND: u32 = 4;
pub const SV_NODEFER: u32 = 16;
pub const SV_NOCLDSTOP: u32 = 8;
pub const SV_SIGINFO: u32 = 64;
pub const __WORDSIZE: u32 = 64;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const PRIO_DARWIN_THREAD: u32 = 3;
pub const PRIO_DARWIN_PROCESS: u32 = 4;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const PRIO_DARWIN_BG: u32 = 4096;
pub const PRIO_DARWIN_NONUI: u32 = 4097;
pub const RUSAGE_SELF: u32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_INFO_V0: u32 = 0;
pub const RUSAGE_INFO_V1: u32 = 1;
pub const RUSAGE_INFO_V2: u32 = 2;
pub const RUSAGE_INFO_V3: u32 = 3;
pub const RUSAGE_INFO_V4: u32 = 4;
pub const RUSAGE_INFO_V5: u32 = 5;
pub const RUSAGE_INFO_CURRENT: u32 = 5;
pub const RU_PROC_RUNS_RESLIDE: u32 = 1;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_AS: u32 = 5;
pub const RLIMIT_RSS: u32 = 5;
pub const RLIMIT_MEMLOCK: u32 = 6;
pub const RLIMIT_NPROC: u32 = 7;
pub const RLIMIT_NOFILE: u32 = 8;
pub const RLIM_NLIMITS: u32 = 9;
pub const _RLIMIT_POSIX_FLAG: u32 = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: u32 = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: u32 = 2;
pub const RLIMIT_THREAD_CPULIMITS: u32 = 3;
pub const RLIMIT_FOOTPRINT_INTERVAL: u32 = 4;
pub const WAKEMON_ENABLE: u32 = 1;
pub const WAKEMON_DISABLE: u32 = 2;
pub const WAKEMON_GET_PARAMS: u32 = 4;
pub const WAKEMON_SET_DEFAULTS: u32 = 8;
pub const WAKEMON_MAKE_FATAL: u32 = 16;
pub const CPUMON_MAKE_FATAL: u32 = 4096;
pub const FOOTPRINT_INTERVAL_RESET: u32 = 1;
pub const IOPOL_TYPE_DISK: u32 = 0;
pub const IOPOL_TYPE_VFS_ATIME_UPDATES: u32 = 2;
pub const IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES: u32 = 3;
pub const IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME: u32 = 4;
pub const IOPOL_TYPE_VFS_TRIGGER_RESOLVE: u32 = 5;
pub const IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION: u32 = 6;
pub const IOPOL_TYPE_VFS_IGNORE_PERMISSIONS: u32 = 7;
pub const IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE: u32 = 8;
pub const IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES: u32 = 9;
pub const IOPOL_SCOPE_PROCESS: u32 = 0;
pub const IOPOL_SCOPE_THREAD: u32 = 1;
pub const IOPOL_SCOPE_DARWIN_BG: u32 = 2;
pub const IOPOL_DEFAULT: u32 = 0;
pub const IOPOL_IMPORTANT: u32 = 1;
pub const IOPOL_PASSIVE: u32 = 2;
pub const IOPOL_THROTTLE: u32 = 3;
pub const IOPOL_UTILITY: u32 = 4;
pub const IOPOL_STANDARD: u32 = 5;
pub const IOPOL_APPLICATION: u32 = 5;
pub const IOPOL_NORMAL: u32 = 1;
pub const IOPOL_ATIME_UPDATES_DEFAULT: u32 = 0;
pub const IOPOL_ATIME_UPDATES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT: u32 = 0;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_ON: u32 = 2;
pub const IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT: u32 = 0;
pub const IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME: u32 = 1;
pub const IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_TRIGGER_RESOLVE_OFF: u32 = 1;
pub const IOPOL_VFS_CONTENT_PROTECTION_DEFAULT: u32 = 0;
pub const IOPOL_VFS_CONTENT_PROTECTION_IGNORE: u32 = 1;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_OFF: u32 = 0;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_ON: u32 = 1;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_OFF: u32 = 0;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_ON: u32 = 1;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF: u32 = 0;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WCOREFLAG: u32 = 128;
pub const _WSTOPPED: u32 = 127;
pub const WEXITED: u32 = 4;
pub const WSTOPPED: u32 = 8;
pub const WCONTINUED: u32 = 16;
pub const WNOWAIT: u32 = 32;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: u32 = 0;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const __HAS_FIXED_CHK_PROTOTYPES: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const __DARWIN_FD_SETSIZE: u32 = 1024;
pub const __DARWIN_NBBY: u32 = 8;
pub const NBBY: u32 = 8;
pub const FD_SETSIZE: u32 = 1024;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EDEADLK: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EAGAIN: u32 = 35;
pub const EWOULDBLOCK: u32 = 35;
pub const EINPROGRESS: u32 = 36;
pub const EALREADY: u32 = 37;
pub const ENOTSOCK: u32 = 38;
pub const EDESTADDRREQ: u32 = 39;
pub const EMSGSIZE: u32 = 40;
pub const EPROTOTYPE: u32 = 41;
pub const ENOPROTOOPT: u32 = 42;
pub const EPROTONOSUPPORT: u32 = 43;
pub const ESOCKTNOSUPPORT: u32 = 44;
pub const ENOTSUP: u32 = 45;
pub const EPFNOSUPPORT: u32 = 46;
pub const EAFNOSUPPORT: u32 = 47;
pub const EADDRINUSE: u32 = 48;
pub const EADDRNOTAVAIL: u32 = 49;
pub const ENETDOWN: u32 = 50;
pub const ENETUNREACH: u32 = 51;
pub const ENETRESET: u32 = 52;
pub const ECONNABORTED: u32 = 53;
pub const ECONNRESET: u32 = 54;
pub const ENOBUFS: u32 = 55;
pub const EISCONN: u32 = 56;
pub const ENOTCONN: u32 = 57;
pub const ESHUTDOWN: u32 = 58;
pub const ETOOMANYREFS: u32 = 59;
pub const ETIMEDOUT: u32 = 60;
pub const ECONNREFUSED: u32 = 61;
pub const ELOOP: u32 = 62;
pub const ENAMETOOLONG: u32 = 63;
pub const EHOSTDOWN: u32 = 64;
pub const EHOSTUNREACH: u32 = 65;
pub const ENOTEMPTY: u32 = 66;
pub const EPROCLIM: u32 = 67;
pub const EUSERS: u32 = 68;
pub const EDQUOT: u32 = 69;
pub const ESTALE: u32 = 70;
pub const EREMOTE: u32 = 71;
pub const EBADRPC: u32 = 72;
pub const ERPCMISMATCH: u32 = 73;
pub const EPROGUNAVAIL: u32 = 74;
pub const EPROGMISMATCH: u32 = 75;
pub const EPROCUNAVAIL: u32 = 76;
pub const ENOLCK: u32 = 77;
pub const ENOSYS: u32 = 78;
pub const EFTYPE: u32 = 79;
pub const EAUTH: u32 = 80;
pub const ENEEDAUTH: u32 = 81;
pub const EPWROFF: u32 = 82;
pub const EDEVERR: u32 = 83;
pub const EOVERFLOW: u32 = 84;
pub const EBADEXEC: u32 = 85;
pub const EBADARCH: u32 = 86;
pub const ESHLIBVERS: u32 = 87;
pub const EBADMACHO: u32 = 88;
pub const ECANCELED: u32 = 89;
pub const EIDRM: u32 = 90;
pub const ENOMSG: u32 = 91;
pub const EILSEQ: u32 = 92;
pub const ENOATTR: u32 = 93;
pub const EBADMSG: u32 = 94;
pub const EMULTIHOP: u32 = 95;
pub const ENODATA: u32 = 96;
pub const ENOLINK: u32 = 97;
pub const ENOSR: u32 = 98;
pub const ENOSTR: u32 = 99;
pub const EPROTO: u32 = 100;
pub const ETIME: u32 = 101;
pub const EOPNOTSUPP: u32 = 102;
pub const ENOPOLICY: u32 = 103;
pub const ENOTRECOVERABLE: u32 = 104;
pub const EOWNERDEAD: u32 = 105;
pub const EQFULL: u32 = 106;
pub const ELAST: u32 = 106;
pub const LC_ALL: u32 = 0;
pub const LC_COLLATE: u32 = 1;
pub const LC_CTYPE: u32 = 2;
pub const LC_MONETARY: u32 = 3;
pub const LC_NUMERIC: u32 = 4;
pub const LC_TIME: u32 = 5;
pub const LC_MESSAGES: u32 = 6;
pub const _LC_LAST: u32 = 7;
pub const HAVE_PG_ATTRIBUTE_NORETURN: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const INT64_FORMAT: &[u8; 4usize] = b"%ld\0";
pub const UINT64_FORMAT: &[u8; 4usize] = b"%lu\0";
pub const HAVE_INT128: u32 = 1;
pub const PG_INT8_MIN: i32 = -128;
pub const PG_INT8_MAX: u32 = 127;
pub const PG_UINT8_MAX: u32 = 255;
pub const PG_INT16_MIN: i32 = -32768;
pub const PG_INT16_MAX: u32 = 32767;
pub const PG_UINT16_MAX: u32 = 65535;
pub const PG_INT32_MIN: i32 = -2147483648;
pub const PG_INT32_MAX: u32 = 2147483647;
pub const PG_UINT32_MAX: u32 = 4294967295;
pub const FLOAT8PASSBYVAL: u32 = 1;
pub const MAXDIM: u32 = 6;
pub const HAVE_UNIX_SOCKETS: u32 = 1;
pub const HIGHBIT: u32 = 128;
pub const ESCAPE_STRING_SYNTAX: u8 = 69u8;
pub const STATUS_OK: u32 = 0;
pub const STATUS_ERROR: i32 = -1;
pub const STATUS_EOF: i32 = -2;
pub const STATUS_WAITING: u32 = 2;
pub const PG_BINARY: u32 = 0;
pub const PG_BINARY_A: &[u8; 2usize] = b"a\0";
pub const PG_BINARY_R: &[u8; 2usize] = b"r\0";
pub const PG_BINARY_W: &[u8; 2usize] = b"w\0";
pub const _CACHED_RUNES: u32 = 256;
pub const _CRMASK: i32 = -256;
pub const _RUNE_MAGIC_A: &[u8; 9usize] = b"RuneMagA\0";
pub const _CTYPE_A: u32 = 256;
pub const _CTYPE_C: u32 = 512;
pub const _CTYPE_D: u32 = 1024;
pub const _CTYPE_G: u32 = 2048;
pub const _CTYPE_L: u32 = 4096;
pub const _CTYPE_P: u32 = 8192;
pub const _CTYPE_S: u32 = 16384;
pub const _CTYPE_U: u32 = 32768;
pub const _CTYPE_X: u32 = 65536;
pub const _CTYPE_B: u32 = 131072;
pub const _CTYPE_R: u32 = 262144;
pub const _CTYPE_I: u32 = 524288;
pub const _CTYPE_T: u32 = 1048576;
pub const _CTYPE_Q: u32 = 2097152;
pub const _CTYPE_SW0: u32 = 536870912;
pub const _CTYPE_SW1: u32 = 1073741824;
pub const _CTYPE_SW2: u32 = 2147483648;
pub const _CTYPE_SW3: u32 = 3221225472;
pub const _CTYPE_SWM: u32 = 3758096384;
pub const _CTYPE_SWS: u32 = 30;
pub const KEV_INET_SUBCLASS: u32 = 1;
pub const KEV_INET_NEW_ADDR: u32 = 1;
pub const KEV_INET_CHANGED_ADDR: u32 = 2;
pub const KEV_INET_ADDR_DELETED: u32 = 3;
pub const KEV_INET_SIFDSTADDR: u32 = 4;
pub const KEV_INET_SIFBRDADDR: u32 = 5;
pub const KEV_INET_SIFNETMASK: u32 = 6;
pub const KEV_INET_ARPCOLLISION: u32 = 7;
pub const KEV_INET_PORTINUSE: u32 = 8;
pub const KEV_INET_ARPRTRFAILURE: u32 = 9;
pub const KEV_INET_ARPRTRALIVE: u32 = 10;
pub const KEV_DL_SUBCLASS: u32 = 2;
pub const KEV_DL_SIFFLAGS: u32 = 1;
pub const KEV_DL_SIFMETRICS: u32 = 2;
pub const KEV_DL_SIFMTU: u32 = 3;
pub const KEV_DL_SIFPHYS: u32 = 4;
pub const KEV_DL_SIFMEDIA: u32 = 5;
pub const KEV_DL_SIFGENERIC: u32 = 6;
pub const KEV_DL_ADDMULTI: u32 = 7;
pub const KEV_DL_DELMULTI: u32 = 8;
pub const KEV_DL_IF_ATTACHED: u32 = 9;
pub const KEV_DL_IF_DETACHING: u32 = 10;
pub const KEV_DL_IF_DETACHED: u32 = 11;
pub const KEV_DL_LINK_OFF: u32 = 12;
pub const KEV_DL_LINK_ON: u32 = 13;
pub const KEV_DL_PROTO_ATTACHED: u32 = 14;
pub const KEV_DL_PROTO_DETACHED: u32 = 15;
pub const KEV_DL_LINK_ADDRESS_CHANGED: u32 = 16;
pub const KEV_DL_WAKEFLAGS_CHANGED: u32 = 17;
pub const KEV_DL_IF_IDLE_ROUTE_REFCNT: u32 = 18;
pub const KEV_DL_IFCAP_CHANGED: u32 = 19;
pub const KEV_DL_LINK_QUALITY_METRIC_CHANGED: u32 = 20;
pub const KEV_DL_NODE_PRESENCE: u32 = 21;
pub const KEV_DL_NODE_ABSENCE: u32 = 22;
pub const KEV_DL_PRIMARY_ELECTED: u32 = 23;
pub const KEV_DL_ISSUES: u32 = 24;
pub const KEV_DL_IFDELEGATE_CHANGED: u32 = 25;
pub const KEV_DL_AWDL_RESTRICTED: u32 = 26;
pub const KEV_DL_AWDL_UNRESTRICTED: u32 = 27;
pub const KEV_DL_RRC_STATE_CHANGED: u32 = 28;
pub const KEV_DL_QOS_MODE_CHANGED: u32 = 29;
pub const KEV_DL_LOW_POWER_MODE_CHANGED: u32 = 30;
pub const KEV_INET6_SUBCLASS: u32 = 6;
pub const KEV_INET6_NEW_USER_ADDR: u32 = 1;
pub const KEV_INET6_CHANGED_ADDR: u32 = 2;
pub const KEV_INET6_ADDR_DELETED: u32 = 3;
pub const KEV_INET6_NEW_LL_ADDR: u32 = 4;
pub const KEV_INET6_NEW_RTADV_ADDR: u32 = 5;
pub const KEV_INET6_DEFROUTER: u32 = 6;
pub const KEV_INET6_REQUEST_NAT64_PREFIX: u32 = 7;
pub const SOCK_STREAM: u32 = 1;
pub const SOCK_DGRAM: u32 = 2;
pub const SOCK_RAW: u32 = 3;
pub const SOCK_RDM: u32 = 4;
pub const SOCK_SEQPACKET: u32 = 5;
pub const SO_DEBUG: u32 = 1;
pub const SO_ACCEPTCONN: u32 = 2;
pub const SO_REUSEADDR: u32 = 4;
pub const SO_KEEPALIVE: u32 = 8;
pub const SO_DONTROUTE: u32 = 16;
pub const SO_BROADCAST: u32 = 32;
pub const SO_USELOOPBACK: u32 = 64;
pub const SO_LINGER: u32 = 128;
pub const SO_OOBINLINE: u32 = 256;
pub const SO_REUSEPORT: u32 = 512;
pub const SO_TIMESTAMP: u32 = 1024;
pub const SO_TIMESTAMP_MONOTONIC: u32 = 2048;
pub const SO_DONTTRUNC: u32 = 8192;
pub const SO_WANTMORE: u32 = 16384;
pub const SO_WANTOOBFLAG: u32 = 32768;
pub const SO_SNDBUF: u32 = 4097;
pub const SO_RCVBUF: u32 = 4098;
pub const SO_SNDLOWAT: u32 = 4099;
pub const SO_RCVLOWAT: u32 = 4100;
pub const SO_SNDTIMEO: u32 = 4101;
pub const SO_RCVTIMEO: u32 = 4102;
pub const SO_ERROR: u32 = 4103;
pub const SO_TYPE: u32 = 4104;
pub const SO_LABEL: u32 = 4112;
pub const SO_PEERLABEL: u32 = 4113;
pub const SO_NREAD: u32 = 4128;
pub const SO_NKE: u32 = 4129;
pub const SO_NOSIGPIPE: u32 = 4130;
pub const SO_NOADDRERR: u32 = 4131;
pub const SO_NWRITE: u32 = 4132;
pub const SO_REUSESHAREUID: u32 = 4133;
pub const SO_NOTIFYCONFLICT: u32 = 4134;
pub const SO_UPCALLCLOSEWAIT: u32 = 4135;
pub const SO_LINGER_SEC: u32 = 4224;
pub const SO_RANDOMPORT: u32 = 4226;
pub const SO_NP_EXTENSIONS: u32 = 4227;
pub const SO_NUMRCVPKT: u32 = 4370;
pub const SO_NET_SERVICE_TYPE: u32 = 4374;
pub const SO_NETSVC_MARKING_LEVEL: u32 = 4377;
pub const NET_SERVICE_TYPE_BE: u32 = 0;
pub const NET_SERVICE_TYPE_BK: u32 = 1;
pub const NET_SERVICE_TYPE_SIG: u32 = 2;
pub const NET_SERVICE_TYPE_VI: u32 = 3;
pub const NET_SERVICE_TYPE_VO: u32 = 4;
pub const NET_SERVICE_TYPE_RV: u32 = 5;
pub const NET_SERVICE_TYPE_AV: u32 = 6;
pub const NET_SERVICE_TYPE_OAM: u32 = 7;
pub const NET_SERVICE_TYPE_RD: u32 = 8;
pub const NETSVC_MRKNG_UNKNOWN: u32 = 0;
pub const NETSVC_MRKNG_LVL_L2: u32 = 1;
pub const NETSVC_MRKNG_LVL_L3L2_ALL: u32 = 2;
pub const NETSVC_MRKNG_LVL_L3L2_BK: u32 = 3;
pub const SAE_ASSOCID_ANY: u32 = 0;
pub const SAE_CONNID_ANY: u32 = 0;
pub const CONNECT_RESUME_ON_READ_WRITE: u32 = 1;
pub const CONNECT_DATA_IDEMPOTENT: u32 = 2;
pub const CONNECT_DATA_AUTHENTICATED: u32 = 4;
pub const SONPX_SETOPTSHUT: u32 = 1;
pub const SOL_SOCKET: u32 = 65535;
pub const AF_UNSPEC: u32 = 0;
pub const AF_UNIX: u32 = 1;
pub const AF_LOCAL: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_IMPLINK: u32 = 3;
pub const AF_PUP: u32 = 4;
pub const AF_CHAOS: u32 = 5;
pub const AF_NS: u32 = 6;
pub const AF_ISO: u32 = 7;
pub const AF_OSI: u32 = 7;
pub const AF_ECMA: u32 = 8;
pub const AF_DATAKIT: u32 = 9;
pub const AF_CCITT: u32 = 10;
pub const AF_SNA: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_DLI: u32 = 13;
pub const AF_LAT: u32 = 14;
pub const AF_HYLINK: u32 = 15;
pub const AF_APPLETALK: u32 = 16;
pub const AF_ROUTE: u32 = 17;
pub const AF_LINK: u32 = 18;
pub const pseudo_AF_XTP: u32 = 19;
pub const AF_COIP: u32 = 20;
pub const AF_CNT: u32 = 21;
pub const pseudo_AF_RTIP: u32 = 22;
pub const AF_IPX: u32 = 23;
pub const AF_SIP: u32 = 24;
pub const pseudo_AF_PIP: u32 = 25;
pub const AF_NDRV: u32 = 27;
pub const AF_ISDN: u32 = 28;
pub const AF_E164: u32 = 28;
pub const pseudo_AF_KEY: u32 = 29;
pub const AF_INET6: u32 = 30;
pub const AF_NATM: u32 = 31;
pub const AF_SYSTEM: u32 = 32;
pub const AF_NETBIOS: u32 = 33;
pub const AF_PPP: u32 = 34;
pub const pseudo_AF_HDRCMPLT: u32 = 35;
pub const AF_RESERVED_36: u32 = 36;
pub const AF_IEEE80211: u32 = 37;
pub const AF_UTUN: u32 = 38;
pub const AF_VSOCK: u32 = 40;
pub const AF_MAX: u32 = 41;
pub const SOCK_MAXADDRLEN: u32 = 255;
pub const _SS_MAXSIZE: u32 = 128;
pub const PF_UNSPEC: u32 = 0;
pub const PF_LOCAL: u32 = 1;
pub const PF_UNIX: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_IMPLINK: u32 = 3;
pub const PF_PUP: u32 = 4;
pub const PF_CHAOS: u32 = 5;
pub const PF_NS: u32 = 6;
pub const PF_ISO: u32 = 7;
pub const PF_OSI: u32 = 7;
pub const PF_ECMA: u32 = 8;
pub const PF_DATAKIT: u32 = 9;
pub const PF_CCITT: u32 = 10;
pub const PF_SNA: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_DLI: u32 = 13;
pub const PF_LAT: u32 = 14;
pub const PF_HYLINK: u32 = 15;
pub const PF_APPLETALK: u32 = 16;
pub const PF_ROUTE: u32 = 17;
pub const PF_LINK: u32 = 18;
pub const PF_XTP: u32 = 19;
pub const PF_COIP: u32 = 20;
pub const PF_CNT: u32 = 21;
pub const PF_SIP: u32 = 24;
pub const PF_IPX: u32 = 23;
pub const PF_RTIP: u32 = 22;
pub const PF_PIP: u32 = 25;
pub const PF_NDRV: u32 = 27;
pub const PF_ISDN: u32 = 28;
pub const PF_KEY: u32 = 29;
pub const PF_INET6: u32 = 30;
pub const PF_NATM: u32 = 31;
pub const PF_SYSTEM: u32 = 32;
pub const PF_NETBIOS: u32 = 33;
pub const PF_PPP: u32 = 34;
pub const PF_RESERVED_36: u32 = 36;
pub const PF_UTUN: u32 = 38;
pub const PF_VSOCK: u32 = 40;
pub const PF_MAX: u32 = 41;
pub const NET_MAXID: u32 = 41;
pub const NET_RT_DUMP: u32 = 1;
pub const NET_RT_FLAGS: u32 = 2;
pub const NET_RT_IFLIST: u32 = 3;
pub const NET_RT_STAT: u32 = 4;
pub const NET_RT_TRASH: u32 = 5;
pub const NET_RT_IFLIST2: u32 = 6;
pub const NET_RT_DUMP2: u32 = 7;
pub const NET_RT_FLAGS_PRIV: u32 = 10;
pub const NET_RT_MAXID: u32 = 11;
pub const SOMAXCONN: u32 = 128;
pub const MSG_OOB: u32 = 1;
pub const MSG_PEEK: u32 = 2;
pub const MSG_DONTROUTE: u32 = 4;
pub const MSG_EOR: u32 = 8;
pub const MSG_TRUNC: u32 = 16;
pub const MSG_CTRUNC: u32 = 32;
pub const MSG_WAITALL: u32 = 64;
pub const MSG_DONTWAIT: u32 = 128;
pub const MSG_EOF: u32 = 256;
pub const MSG_WAITSTREAM: u32 = 512;
pub const MSG_FLUSH: u32 = 1024;
pub const MSG_HOLD: u32 = 2048;
pub const MSG_SEND: u32 = 4096;
pub const MSG_HAVEMORE: u32 = 8192;
pub const MSG_RCVMORE: u32 = 16384;
pub const MSG_NEEDSA: u32 = 65536;
pub const MSG_NOSIGNAL: u32 = 524288;
pub const SCM_RIGHTS: u32 = 1;
pub const SCM_TIMESTAMP: u32 = 2;
pub const SCM_CREDS: u32 = 3;
pub const SCM_TIMESTAMP_MONOTONIC: u32 = 4;
pub const SHUT_RD: u32 = 0;
pub const SHUT_WR: u32 = 1;
pub const SHUT_RDWR: u32 = 2;
pub const IPPROTO_IP: u32 = 0;
pub const IPPROTO_HOPOPTS: u32 = 0;
pub const IPPROTO_ICMP: u32 = 1;
pub const IPPROTO_IGMP: u32 = 2;
pub const IPPROTO_GGP: u32 = 3;
pub const IPPROTO_IPV4: u32 = 4;
pub const IPPROTO_IPIP: u32 = 4;
pub const IPPROTO_TCP: u32 = 6;
pub const IPPROTO_ST: u32 = 7;
pub const IPPROTO_EGP: u32 = 8;
pub const IPPROTO_PIGP: u32 = 9;
pub const IPPROTO_RCCMON: u32 = 10;
pub const IPPROTO_NVPII: u32 = 11;
pub const IPPROTO_PUP: u32 = 12;
pub const IPPROTO_ARGUS: u32 = 13;
pub const IPPROTO_EMCON: u32 = 14;
pub const IPPROTO_XNET: u32 = 15;
pub const IPPROTO_CHAOS: u32 = 16;
pub const IPPROTO_UDP: u32 = 17;
pub const IPPROTO_MUX: u32 = 18;
pub const IPPROTO_MEAS: u32 = 19;
pub const IPPROTO_HMP: u32 = 20;
pub const IPPROTO_PRM: u32 = 21;
pub const IPPROTO_IDP: u32 = 22;
pub const IPPROTO_TRUNK1: u32 = 23;
pub const IPPROTO_TRUNK2: u32 = 24;
pub const IPPROTO_LEAF1: u32 = 25;
pub const IPPROTO_LEAF2: u32 = 26;
pub const IPPROTO_RDP: u32 = 27;
pub const IPPROTO_IRTP: u32 = 28;
pub const IPPROTO_TP: u32 = 29;
pub const IPPROTO_BLT: u32 = 30;
pub const IPPROTO_NSP: u32 = 31;
pub const IPPROTO_INP: u32 = 32;
pub const IPPROTO_SEP: u32 = 33;
pub const IPPROTO_3PC: u32 = 34;
pub const IPPROTO_IDPR: u32 = 35;
pub const IPPROTO_XTP: u32 = 36;
pub const IPPROTO_DDP: u32 = 37;
pub const IPPROTO_CMTP: u32 = 38;
pub const IPPROTO_TPXX: u32 = 39;
pub const IPPROTO_IL: u32 = 40;
pub const IPPROTO_IPV6: u32 = 41;
pub const IPPROTO_SDRP: u32 = 42;
pub const IPPROTO_ROUTING: u32 = 43;
pub const IPPROTO_FRAGMENT: u32 = 44;
pub const IPPROTO_IDRP: u32 = 45;
pub const IPPROTO_RSVP: u32 = 46;
pub const IPPROTO_GRE: u32 = 47;
pub const IPPROTO_MHRP: u32 = 48;
pub const IPPROTO_BHA: u32 = 49;
pub const IPPROTO_ESP: u32 = 50;
pub const IPPROTO_AH: u32 = 51;
pub const IPPROTO_INLSP: u32 = 52;
pub const IPPROTO_SWIPE: u32 = 53;
pub const IPPROTO_NHRP: u32 = 54;
pub const IPPROTO_ICMPV6: u32 = 58;
pub const IPPROTO_NONE: u32 = 59;
pub const IPPROTO_DSTOPTS: u32 = 60;
pub const IPPROTO_AHIP: u32 = 61;
pub const IPPROTO_CFTP: u32 = 62;
pub const IPPROTO_HELLO: u32 = 63;
pub const IPPROTO_SATEXPAK: u32 = 64;
pub const IPPROTO_KRYPTOLAN: u32 = 65;
pub const IPPROTO_RVD: u32 = 66;
pub const IPPROTO_IPPC: u32 = 67;
pub const IPPROTO_ADFS: u32 = 68;
pub const IPPROTO_SATMON: u32 = 69;
pub const IPPROTO_VISA: u32 = 70;
pub const IPPROTO_IPCV: u32 = 71;
pub const IPPROTO_CPNX: u32 = 72;
pub const IPPROTO_CPHB: u32 = 73;
pub const IPPROTO_WSN: u32 = 74;
pub const IPPROTO_PVP: u32 = 75;
pub const IPPROTO_BRSATMON: u32 = 76;
pub const IPPROTO_ND: u32 = 77;
pub const IPPROTO_WBMON: u32 = 78;
pub const IPPROTO_WBEXPAK: u32 = 79;
pub const IPPROTO_EON: u32 = 80;
pub const IPPROTO_VMTP: u32 = 81;
pub const IPPROTO_SVMTP: u32 = 82;
pub const IPPROTO_VINES: u32 = 83;
pub const IPPROTO_TTP: u32 = 84;
pub const IPPROTO_IGP: u32 = 85;
pub const IPPROTO_DGP: u32 = 86;
pub const IPPROTO_TCF: u32 = 87;
pub const IPPROTO_IGRP: u32 = 88;
pub const IPPROTO_OSPFIGP: u32 = 89;
pub const IPPROTO_SRPC: u32 = 90;
pub const IPPROTO_LARP: u32 = 91;
pub const IPPROTO_MTP: u32 = 92;
pub const IPPROTO_AX25: u32 = 93;
pub const IPPROTO_IPEIP: u32 = 94;
pub const IPPROTO_MICP: u32 = 95;
pub const IPPROTO_SCCSP: u32 = 96;
pub const IPPROTO_ETHERIP: u32 = 97;
pub const IPPROTO_ENCAP: u32 = 98;
pub const IPPROTO_APES: u32 = 99;
pub const IPPROTO_GMTP: u32 = 100;
pub const IPPROTO_PIM: u32 = 103;
pub const IPPROTO_IPCOMP: u32 = 108;
pub const IPPROTO_PGM: u32 = 113;
pub const IPPROTO_SCTP: u32 = 132;
pub const IPPROTO_DIVERT: u32 = 254;
pub const IPPROTO_RAW: u32 = 255;
pub const IPPROTO_MAX: u32 = 256;
pub const IPPROTO_DONE: u32 = 257;
pub const __DARWIN_IPPORT_RESERVED: u32 = 1024;
pub const IPPORT_USERRESERVED: u32 = 5000;
pub const IPPORT_HIFIRSTAUTO: u32 = 49152;
pub const IPPORT_HILASTAUTO: u32 = 65535;
pub const IPPORT_RESERVEDSTART: u32 = 600;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_CLASSD_NET: u32 = 4026531840;
pub const IN_CLASSD_NSHIFT: u32 = 28;
pub const IN_CLASSD_HOST: u32 = 268435455;
pub const INADDR_NONE: u32 = 4294967295;
pub const IN_LOOPBACKNET: u32 = 127;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const IP_OPTIONS: u32 = 1;
pub const IP_HDRINCL: u32 = 2;
pub const IP_TOS: u32 = 3;
pub const IP_TTL: u32 = 4;
pub const IP_RECVOPTS: u32 = 5;
pub const IP_RECVRETOPTS: u32 = 6;
pub const IP_RECVDSTADDR: u32 = 7;
pub const IP_RETOPTS: u32 = 8;
pub const IP_MULTICAST_IF: u32 = 9;
pub const IP_MULTICAST_TTL: u32 = 10;
pub const IP_MULTICAST_LOOP: u32 = 11;
pub const IP_ADD_MEMBERSHIP: u32 = 12;
pub const IP_DROP_MEMBERSHIP: u32 = 13;
pub const IP_MULTICAST_VIF: u32 = 14;
pub const IP_RSVP_ON: u32 = 15;
pub const IP_RSVP_OFF: u32 = 16;
pub const IP_RSVP_VIF_ON: u32 = 17;
pub const IP_RSVP_VIF_OFF: u32 = 18;
pub const IP_PORTRANGE: u32 = 19;
pub const IP_RECVIF: u32 = 20;
pub const IP_IPSEC_POLICY: u32 = 21;
pub const IP_FAITH: u32 = 22;
pub const IP_STRIPHDR: u32 = 23;
pub const IP_RECVTTL: u32 = 24;
pub const IP_BOUND_IF: u32 = 25;
pub const IP_PKTINFO: u32 = 26;
pub const IP_RECVPKTINFO: u32 = 26;
pub const IP_RECVTOS: u32 = 27;
pub const IP_DONTFRAG: u32 = 28;
pub const IP_FW_ADD: u32 = 40;
pub const IP_FW_DEL: u32 = 41;
pub const IP_FW_FLUSH: u32 = 42;
pub const IP_FW_ZERO: u32 = 43;
pub const IP_FW_GET: u32 = 44;
pub const IP_FW_RESETLOG: u32 = 45;
pub const IP_OLD_FW_ADD: u32 = 50;
pub const IP_OLD_FW_DEL: u32 = 51;
pub const IP_OLD_FW_FLUSH: u32 = 52;
pub const IP_OLD_FW_ZERO: u32 = 53;
pub const IP_OLD_FW_GET: u32 = 54;
pub const IP_NAT__XXX: u32 = 55;
pub const IP_OLD_FW_RESETLOG: u32 = 56;
pub const IP_DUMMYNET_CONFIGURE: u32 = 60;
pub const IP_DUMMYNET_DEL: u32 = 61;
pub const IP_DUMMYNET_FLUSH: u32 = 62;
pub const IP_DUMMYNET_GET: u32 = 64;
pub const IP_TRAFFIC_MGT_BACKGROUND: u32 = 65;
pub const IP_MULTICAST_IFINDEX: u32 = 66;
pub const IP_ADD_SOURCE_MEMBERSHIP: u32 = 70;
pub const IP_DROP_SOURCE_MEMBERSHIP: u32 = 71;
pub const IP_BLOCK_SOURCE: u32 = 72;
pub const IP_UNBLOCK_SOURCE: u32 = 73;
pub const IP_MSFILTER: u32 = 74;
pub const MCAST_JOIN_GROUP: u32 = 80;
pub const MCAST_LEAVE_GROUP: u32 = 81;
pub const MCAST_JOIN_SOURCE_GROUP: u32 = 82;
pub const MCAST_LEAVE_SOURCE_GROUP: u32 = 83;
pub const MCAST_BLOCK_SOURCE: u32 = 84;
pub const MCAST_UNBLOCK_SOURCE: u32 = 85;
pub const IP_DEFAULT_MULTICAST_TTL: u32 = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IP_MIN_MEMBERSHIPS: u32 = 31;
pub const IP_MAX_MEMBERSHIPS: u32 = 4095;
pub const IP_MAX_GROUP_SRC_FILTER: u32 = 512;
pub const IP_MAX_SOCK_SRC_FILTER: u32 = 128;
pub const IP_MAX_SOCK_MUTE_FILTER: u32 = 128;
pub const MCAST_UNDEFINED: u32 = 0;
pub const MCAST_INCLUDE: u32 = 1;
pub const MCAST_EXCLUDE: u32 = 2;
pub const IP_PORTRANGE_DEFAULT: u32 = 0;
pub const IP_PORTRANGE_HIGH: u32 = 1;
pub const IP_PORTRANGE_LOW: u32 = 2;
pub const IPPROTO_MAXID: u32 = 52;
pub const IPCTL_FORWARDING: u32 = 1;
pub const IPCTL_SENDREDIRECTS: u32 = 2;
pub const IPCTL_DEFTTL: u32 = 3;
pub const IPCTL_RTEXPIRE: u32 = 5;
pub const IPCTL_RTMINEXPIRE: u32 = 6;
pub const IPCTL_RTMAXCACHE: u32 = 7;
pub const IPCTL_SOURCEROUTE: u32 = 8;
pub const IPCTL_DIRECTEDBROADCAST: u32 = 9;
pub const IPCTL_INTRQMAXLEN: u32 = 10;
pub const IPCTL_INTRQDROPS: u32 = 11;
pub const IPCTL_STATS: u32 = 12;
pub const IPCTL_ACCEPTSOURCEROUTE: u32 = 13;
pub const IPCTL_FASTFORWARDING: u32 = 14;
pub const IPCTL_KEEPFAITH: u32 = 15;
pub const IPCTL_GIF_TTL: u32 = 16;
pub const IPCTL_MAXID: u32 = 17;
pub const __KAME_VERSION: &[u8; 18usize] = b"2009/apple-darwin\0";
pub const IPV6PORT_RESERVED: u32 = 1024;
pub const IPV6PORT_ANONMIN: u32 = 49152;
pub const IPV6PORT_ANONMAX: u32 = 65535;
pub const IPV6PORT_RESERVEDMIN: u32 = 600;
pub const IPV6PORT_RESERVEDMAX: u32 = 1023;
pub const INET6_ADDRSTRLEN: u32 = 46;
pub const __IPV6_ADDR_SCOPE_NODELOCAL: u32 = 1;
pub const __IPV6_ADDR_SCOPE_INTFACELOCAL: u32 = 1;
pub const __IPV6_ADDR_SCOPE_LINKLOCAL: u32 = 2;
pub const __IPV6_ADDR_SCOPE_SITELOCAL: u32 = 5;
pub const __IPV6_ADDR_SCOPE_ORGLOCAL: u32 = 8;
pub const __IPV6_ADDR_SCOPE_GLOBAL: u32 = 14;
pub const IPV6_ADDR_MC_FLAGS_TRANSIENT: u32 = 16;
pub const IPV6_ADDR_MC_FLAGS_PREFIX: u32 = 32;
pub const IPV6_ADDR_MC_FLAGS_UNICAST_BASED: u32 = 48;
pub const IPV6_SOCKOPT_RESERVED1: u32 = 3;
pub const IPV6_UNICAST_HOPS: u32 = 4;
pub const IPV6_MULTICAST_IF: u32 = 9;
pub const IPV6_MULTICAST_HOPS: u32 = 10;
pub const IPV6_MULTICAST_LOOP: u32 = 11;
pub const IPV6_JOIN_GROUP: u32 = 12;
pub const IPV6_LEAVE_GROUP: u32 = 13;
pub const IPV6_PORTRANGE: u32 = 14;
pub const ICMP6_FILTER: u32 = 18;
pub const IPV6_2292PKTINFO: u32 = 19;
pub const IPV6_2292HOPLIMIT: u32 = 20;
pub const IPV6_2292NEXTHOP: u32 = 21;
pub const IPV6_2292HOPOPTS: u32 = 22;
pub const IPV6_2292DSTOPTS: u32 = 23;
pub const IPV6_2292RTHDR: u32 = 24;
pub const IPV6_2292PKTOPTIONS: u32 = 25;
pub const IPV6_CHECKSUM: u32 = 26;
pub const IPV6_V6ONLY: u32 = 27;
pub const IPV6_BINDV6ONLY: u32 = 27;
pub const IPV6_IPSEC_POLICY: u32 = 28;
pub const IPV6_FAITH: u32 = 29;
pub const IPV6_FW_ADD: u32 = 30;
pub const IPV6_FW_DEL: u32 = 31;
pub const IPV6_FW_FLUSH: u32 = 32;
pub const IPV6_FW_ZERO: u32 = 33;
pub const IPV6_FW_GET: u32 = 34;
pub const IPV6_RECVTCLASS: u32 = 35;
pub const IPV6_TCLASS: u32 = 36;
pub const IPV6_BOUND_IF: u32 = 125;
pub const IPV6_RTHDR_LOOSE: u32 = 0;
pub const IPV6_RTHDR_STRICT: u32 = 1;
pub const IPV6_RTHDR_TYPE_0: u32 = 0;
pub const IPV6_DEFAULT_MULTICAST_HOPS: u32 = 1;
pub const IPV6_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IPV6_MIN_MEMBERSHIPS: u32 = 31;
pub const IPV6_MAX_MEMBERSHIPS: u32 = 4095;
pub const IPV6_MAX_GROUP_SRC_FILTER: u32 = 512;
pub const IPV6_MAX_SOCK_SRC_FILTER: u32 = 128;
pub const IPV6_PORTRANGE_DEFAULT: u32 = 0;
pub const IPV6_PORTRANGE_HIGH: u32 = 1;
pub const IPV6_PORTRANGE_LOW: u32 = 2;
pub const IPV6PROTO_MAXID: u32 = 104;
pub const IPV6CTL_FORWARDING: u32 = 1;
pub const IPV6CTL_SENDREDIRECTS: u32 = 2;
pub const IPV6CTL_DEFHLIM: u32 = 3;
pub const IPV6CTL_FORWSRCRT: u32 = 5;
pub const IPV6CTL_STATS: u32 = 6;
pub const IPV6CTL_MRTSTATS: u32 = 7;
pub const IPV6CTL_MRTPROTO: u32 = 8;
pub const IPV6CTL_MAXFRAGPACKETS: u32 = 9;
pub const IPV6CTL_SOURCECHECK: u32 = 10;
pub const IPV6CTL_SOURCECHECK_LOGINT: u32 = 11;
pub const IPV6CTL_ACCEPT_RTADV: u32 = 12;
pub const IPV6CTL_KEEPFAITH: u32 = 13;
pub const IPV6CTL_LOG_INTERVAL: u32 = 14;
pub const IPV6CTL_HDRNESTLIMIT: u32 = 15;
pub const IPV6CTL_DAD_COUNT: u32 = 16;
pub const IPV6CTL_AUTO_FLOWLABEL: u32 = 17;
pub const IPV6CTL_DEFMCASTHLIM: u32 = 18;
pub const IPV6CTL_GIF_HLIM: u32 = 19;
pub const IPV6CTL_KAME_VERSION: u32 = 20;
pub const IPV6CTL_USE_DEPRECATED: u32 = 21;
pub const IPV6CTL_RR_PRUNE: u32 = 22;
pub const IPV6CTL_V6ONLY: u32 = 24;
pub const IPV6CTL_RTEXPIRE: u32 = 25;
pub const IPV6CTL_RTMINEXPIRE: u32 = 26;
pub const IPV6CTL_RTMAXCACHE: u32 = 27;
pub const IPV6CTL_USETEMPADDR: u32 = 32;
pub const IPV6CTL_TEMPPLTIME: u32 = 33;
pub const IPV6CTL_TEMPVLTIME: u32 = 34;
pub const IPV6CTL_AUTO_LINKLOCAL: u32 = 35;
pub const IPV6CTL_RIP6STATS: u32 = 36;
pub const IPV6CTL_PREFER_TEMPADDR: u32 = 37;
pub const IPV6CTL_ADDRCTLPOLICY: u32 = 38;
pub const IPV6CTL_USE_DEFAULTZONE: u32 = 39;
pub const IPV6CTL_MAXFRAGS: u32 = 41;
pub const IPV6CTL_MCAST_PMTU: u32 = 44;
pub const IPV6CTL_NEIGHBORGCTHRESH: u32 = 46;
pub const IPV6CTL_MAXIFPREFIXES: u32 = 47;
pub const IPV6CTL_MAXIFDEFROUTERS: u32 = 48;
pub const IPV6CTL_MAXDYNROUTES: u32 = 49;
pub const ICMPV6CTL_ND6_ONLINKNSRFC4861: u32 = 50;
pub const IPV6CTL_ULA_USETEMPADDR: u32 = 51;
pub const IPV6CTL_MAXID: u32 = 51;
pub const _PATH_HEQUIV: &[u8; 17usize] = b"/etc/hosts.equiv\0";
pub const _PATH_HOSTS: &[u8; 11usize] = b"/etc/hosts\0";
pub const _PATH_NETWORKS: &[u8; 14usize] = b"/etc/networks\0";
pub const _PATH_PROTOCOLS: &[u8; 15usize] = b"/etc/protocols\0";
pub const _PATH_SERVICES: &[u8; 14usize] = b"/etc/services\0";
pub const NETDB_INTERNAL: i32 = -1;
pub const NETDB_SUCCESS: u32 = 0;
pub const HOST_NOT_FOUND: u32 = 1;
pub const TRY_AGAIN: u32 = 2;
pub const NO_RECOVERY: u32 = 3;
pub const NO_DATA: u32 = 4;
pub const NO_ADDRESS: u32 = 4;
pub const EAI_ADDRFAMILY: u32 = 1;
pub const EAI_AGAIN: u32 = 2;
pub const EAI_BADFLAGS: u32 = 3;
pub const EAI_FAIL: u32 = 4;
pub const EAI_FAMILY: u32 = 5;
pub const EAI_MEMORY: u32 = 6;
pub const EAI_NODATA: u32 = 7;
pub const EAI_NONAME: u32 = 8;
pub const EAI_SERVICE: u32 = 9;
pub const EAI_SOCKTYPE: u32 = 10;
pub const EAI_SYSTEM: u32 = 11;
pub const EAI_BADHINTS: u32 = 12;
pub const EAI_PROTOCOL: u32 = 13;
pub const EAI_OVERFLOW: u32 = 14;
pub const EAI_MAX: u32 = 15;
pub const AI_PASSIVE: u32 = 1;
pub const AI_CANONNAME: u32 = 2;
pub const AI_NUMERICHOST: u32 = 4;
pub const AI_NUMERICSERV: u32 = 4096;
pub const AI_ALL: u32 = 256;
pub const AI_V4MAPPED_CFG: u32 = 512;
pub const AI_ADDRCONFIG: u32 = 1024;
pub const AI_V4MAPPED: u32 = 2048;
pub const AI_DEFAULT: u32 = 1536;
pub const AI_UNUSABLE: u32 = 268435456;
pub const NI_MAXHOST: u32 = 1025;
pub const NI_MAXSERV: u32 = 32;
pub const NI_NOFQDN: u32 = 1;
pub const NI_NUMERICHOST: u32 = 2;
pub const NI_NAMEREQD: u32 = 4;
pub const NI_NUMERICSERV: u32 = 8;
pub const NI_NUMERICSCOPE: u32 = 256;
pub const NI_DGRAM: u32 = 16;
pub const NI_WITHSCOPEID: u32 = 32;
pub const SCOPE_DELIMITER: u8 = 37u8;
pub const _PATH_PWD: &[u8; 5usize] = b"/etc\0";
pub const _PATH_PASSWD: &[u8; 12usize] = b"/etc/passwd\0";
pub const _PASSWD: &[u8; 7usize] = b"passwd\0";
pub const _PATH_MASTERPASSWD: &[u8; 19usize] = b"/etc/master.passwd\0";
pub const _PATH_MASTERPASSWD_LOCK: &[u8; 10usize] = b"/etc/ptmp\0";
pub const _MASTERPASSWD: &[u8; 14usize] = b"master.passwd\0";
pub const _PATH_MP_DB: &[u8; 12usize] = b"/etc/pwd.db\0";
pub const _MP_DB: &[u8; 7usize] = b"pwd.db\0";
pub const _PATH_SMP_DB: &[u8; 13usize] = b"/etc/spwd.db\0";
pub const _SMP_DB: &[u8; 8usize] = b"spwd.db\0";
pub const _PATH_PWD_MKDB: &[u8; 19usize] = b"/usr/sbin/pwd_mkdb\0";
pub const _PW_KEYBYNAME: u8 = 49u8;
pub const _PW_KEYBYNUM: u8 = 50u8;
pub const _PW_KEYBYUID: u8 = 51u8;
pub const _PASSWORD_EFMT1: u8 = 95u8;
pub const _PASSWORD_LEN: u32 = 128;
pub const _PASSWORD_NOUID: u32 = 1;
pub const _PASSWORD_NOGID: u32 = 2;
pub const _PASSWORD_NOCHG: u32 = 4;
pub const _PASSWORD_NOEXP: u32 = 8;
pub const _PASSWORD_WARNDAYS: u32 = 14;
pub const _PASSWORD_CHGNOW: i32 = -1;
pub const PGINVALID_SOCKET: i32 = -1;
pub const PG_BACKEND_VERSIONSTR: &[u8; 28usize] = b"postgres (PostgreSQL) 13.5\n\0";
pub const EXE: &[u8; 1usize] = b"\0";
pub const DEVNULL: &[u8; 10usize] = b"/dev/null\0";
pub const USE_REPL_SNPRINTF: u32 = 1;
pub const PG_STRERROR_R_BUFLEN: u32 = 256;
pub const PG_IOLBF: u32 = 1;
pub const FP_SUPERNORMAL: u32 = 6;
pub const FP_FAST_FMA: u32 = 1;
pub const FP_FAST_FMAF: u32 = 1;
pub const FP_FAST_FMAL: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const DOMAIN: u32 = 1;
pub const SING: u32 = 2;
pub const OVERFLOW: u32 = 3;
pub const UNDERFLOW: u32 = 4;
pub const TLOSS: u32 = 5;
pub const PLOSS: u32 = 6;
pub const _JBLEN: u32 = 48;
pub const DEBUG5: u32 = 10;
pub const DEBUG4: u32 = 11;
pub const DEBUG3: u32 = 12;
pub const DEBUG2: u32 = 13;
pub const DEBUG1: u32 = 14;
pub const LOG: u32 = 15;
pub const LOG_SERVER_ONLY: u32 = 16;
pub const COMMERROR: u32 = 16;
pub const INFO: u32 = 17;
pub const NOTICE: u32 = 18;
pub const WARNING: u32 = 19;
pub const ERROR: u32 = 20;
pub const FATAL: u32 = 21;
pub const PANIC: u32 = 22;
pub const LOG_DESTINATION_STDERR: u32 = 1;
pub const LOG_DESTINATION_SYSLOG: u32 = 2;
pub const LOG_DESTINATION_EVENTLOG: u32 = 4;
pub const LOG_DESTINATION_CSVLOG: u32 = 8;
pub const MCXT_ALLOC_HUGE: u32 = 1;
pub const MCXT_ALLOC_NO_OOM: u32 = 2;
pub const MCXT_ALLOC_ZERO: u32 = 4;
pub const VARATT_SHORT_MAX: u32 = 127;
pub const FIELDNO_NULLABLE_DATUM_DATUM: u32 = 0;
pub const FIELDNO_NULLABLE_DATUM_ISNULL: u32 = 1;
pub const SIZEOF_DATUM: u32 = 8;
pub const InvalidAttrNumber: u32 = 0;
pub const MaxAttrNumber: u32 = 32767;
pub const AttributeRelationId: u32 = 1249;
pub const AttributeRelation_Rowtype_Id: u32 = 75;
pub const Anum_pg_attribute_attrelid: u32 = 1;
pub const Anum_pg_attribute_attname: u32 = 2;
pub const Anum_pg_attribute_atttypid: u32 = 3;
pub const Anum_pg_attribute_attstattarget: u32 = 4;
pub const Anum_pg_attribute_attlen: u32 = 5;
pub const Anum_pg_attribute_attnum: u32 = 6;
pub const Anum_pg_attribute_attndims: u32 = 7;
pub const Anum_pg_attribute_attcacheoff: u32 = 8;
pub const Anum_pg_attribute_atttypmod: u32 = 9;
pub const Anum_pg_attribute_attbyval: u32 = 10;
pub const Anum_pg_attribute_attstorage: u32 = 11;
pub const Anum_pg_attribute_attalign: u32 = 12;
pub const Anum_pg_attribute_attnotnull: u32 = 13;
pub const Anum_pg_attribute_atthasdef: u32 = 14;
pub const Anum_pg_attribute_atthasmissing: u32 = 15;
pub const Anum_pg_attribute_attidentity: u32 = 16;
pub const Anum_pg_attribute_attgenerated: u32 = 17;
pub const Anum_pg_attribute_attisdropped: u32 = 18;
pub const Anum_pg_attribute_attislocal: u32 = 19;
pub const Anum_pg_attribute_attinhcount: u32 = 20;
pub const Anum_pg_attribute_attcollation: u32 = 21;
pub const Anum_pg_attribute_attacl: u32 = 22;
pub const Anum_pg_attribute_attoptions: u32 = 23;
pub const Anum_pg_attribute_attfdwoptions: u32 = 24;
pub const Anum_pg_attribute_attmissingval: u32 = 25;
pub const Natts_pg_attribute: u32 = 25;
pub const ATTRIBUTE_IDENTITY_ALWAYS: u8 = 97u8;
pub const ATTRIBUTE_IDENTITY_BY_DEFAULT: u8 = 100u8;
pub const ATTRIBUTE_GENERATED_STORED: u8 = 115u8;
pub const AGGSPLITOP_COMBINE: u32 = 1;
pub const AGGSPLITOP_SKIPFINAL: u32 = 2;
pub const AGGSPLITOP_SERIALIZE: u32 = 4;
pub const AGGSPLITOP_DESERIALIZE: u32 = 8;
pub const LP_UNUSED: u32 = 0;
pub const LP_NORMAL: u32 = 1;
pub const LP_REDIRECT: u32 = 2;
pub const LP_DEAD: u32 = 3;
pub const SpecTokenOffsetNumber: u32 = 65534;
pub const MovedPartitionsOffsetNumber: u32 = 65533;
pub const FIELDNO_HEAPTUPLEDATA_DATA: u32 = 3;
pub const O_RDONLY: u32 = 0;
pub const O_WRONLY: u32 = 1;
pub const O_RDWR: u32 = 2;
pub const O_ACCMODE: u32 = 3;
pub const FREAD: u32 = 1;
pub const FWRITE: u32 = 2;
pub const O_NONBLOCK: u32 = 4;
pub const O_APPEND: u32 = 8;
pub const O_SYNC: u32 = 128;
pub const O_SHLOCK: u32 = 16;
pub const O_EXLOCK: u32 = 32;
pub const O_ASYNC: u32 = 64;
pub const O_FSYNC: u32 = 128;
pub const O_NOFOLLOW: u32 = 256;
pub const O_CREAT: u32 = 512;
pub const O_TRUNC: u32 = 1024;
pub const O_EXCL: u32 = 2048;
pub const O_EVTONLY: u32 = 32768;
pub const O_NOCTTY: u32 = 131072;
pub const O_DIRECTORY: u32 = 1048576;
pub const O_SYMLINK: u32 = 2097152;
pub const O_DSYNC: u32 = 4194304;
pub const O_CLOEXEC: u32 = 16777216;
pub const O_NOFOLLOW_ANY: u32 = 536870912;
pub const AT_FDCWD: i32 = -2;
pub const AT_EACCESS: u32 = 16;
pub const AT_SYMLINK_NOFOLLOW: u32 = 32;
pub const AT_SYMLINK_FOLLOW: u32 = 64;
pub const AT_REMOVEDIR: u32 = 128;
pub const AT_REALDEV: u32 = 512;
pub const AT_FDONLY: u32 = 1024;
pub const O_DP_GETRAWENCRYPTED: u32 = 1;
pub const O_DP_GETRAWUNENCRYPTED: u32 = 2;
pub const FAPPEND: u32 = 8;
pub const FASYNC: u32 = 64;
pub const FFSYNC: u32 = 128;
pub const FFDSYNC: u32 = 4194304;
pub const FNONBLOCK: u32 = 4;
pub const FNDELAY: u32 = 4;
pub const O_NDELAY: u32 = 4;
pub const CPF_OVERWRITE: u32 = 1;
pub const CPF_IGNORE_MODE: u32 = 2;
pub const CPF_MASK: u32 = 3;
pub const F_DUPFD: u32 = 0;
pub const F_GETFD: u32 = 1;
pub const F_SETFD: u32 = 2;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const F_GETOWN: u32 = 5;
pub const F_SETOWN: u32 = 6;
pub const F_GETLK: u32 = 7;
pub const F_SETLK: u32 = 8;
pub const F_SETLKW: u32 = 9;
pub const F_SETLKWTIMEOUT: u32 = 10;
pub const F_FLUSH_DATA: u32 = 40;
pub const F_CHKCLEAN: u32 = 41;
pub const F_PREALLOCATE: u32 = 42;
pub const F_SETSIZE: u32 = 43;
pub const F_RDADVISE: u32 = 44;
pub const F_RDAHEAD: u32 = 45;
pub const F_NOCACHE: u32 = 48;
pub const F_LOG2PHYS: u32 = 49;
pub const F_GETPATH: u32 = 50;
pub const F_FULLFSYNC: u32 = 51;
pub const F_PATHPKG_CHECK: u32 = 52;
pub const F_FREEZE_FS: u32 = 53;
pub const F_THAW_FS: u32 = 54;
pub const F_GLOBAL_NOCACHE: u32 = 55;
pub const F_ADDSIGS: u32 = 59;
pub const F_ADDFILESIGS: u32 = 61;
pub const F_NODIRECT: u32 = 62;
pub const F_GETPROTECTIONCLASS: u32 = 63;
pub const F_SETPROTECTIONCLASS: u32 = 64;
pub const F_LOG2PHYS_EXT: u32 = 65;
pub const F_GETLKPID: u32 = 66;
pub const F_SETBACKINGSTORE: u32 = 70;
pub const F_GETPATH_MTMINFO: u32 = 71;
pub const F_GETCODEDIR: u32 = 72;
pub const F_SETNOSIGPIPE: u32 = 73;
pub const F_GETNOSIGPIPE: u32 = 74;
pub const F_TRANSCODEKEY: u32 = 75;
pub const F_SINGLE_WRITER: u32 = 76;
pub const F_GETPROTECTIONLEVEL: u32 = 77;
pub const F_FINDSIGS: u32 = 78;
pub const F_ADDFILESIGS_FOR_DYLD_SIM: u32 = 83;
pub const F_BARRIERFSYNC: u32 = 85;
pub const F_ADDFILESIGS_RETURN: u32 = 97;
pub const F_CHECK_LV: u32 = 98;
pub const F_PUNCHHOLE: u32 = 99;
pub const F_TRIM_ACTIVE_FILE: u32 = 100;
pub const F_SPECULATIVE_READ: u32 = 101;
pub const F_GETPATH_NOFIRMLINK: u32 = 102;
pub const F_ADDFILESIGS_INFO: u32 = 103;
pub const F_ADDFILESUPPL: u32 = 104;
pub const F_GETSIGSINFO: u32 = 105;
pub const FCNTL_FS_SPECIFIC_BASE: u32 = 65536;
pub const F_DUPFD_CLOEXEC: u32 = 67;
pub const FD_CLOEXEC: u32 = 1;
pub const F_RDLCK: u32 = 1;
pub const F_UNLCK: u32 = 2;
pub const F_WRLCK: u32 = 3;
pub const SEEK_HOLE: u32 = 3;
pub const SEEK_DATA: u32 = 4;
pub const S_IFMT: u32 = 61440;
pub const S_IFIFO: u32 = 4096;
pub const S_IFCHR: u32 = 8192;
pub const S_IFDIR: u32 = 16384;
pub const S_IFBLK: u32 = 24576;
pub const S_IFREG: u32 = 32768;
pub const S_IFLNK: u32 = 40960;
pub const S_IFSOCK: u32 = 49152;
pub const S_IFWHT: u32 = 57344;
pub const S_IRWXU: u32 = 448;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXG: u32 = 56;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXO: u32 = 7;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_ISTXT: u32 = 512;
pub const S_IREAD: u32 = 256;
pub const S_IWRITE: u32 = 128;
pub const S_IEXEC: u32 = 64;
pub const F_ALLOCATECONTIG: u32 = 2;
pub const F_ALLOCATEALL: u32 = 4;
pub const F_PEOFPOSMODE: u32 = 3;
pub const F_VOLPOSMODE: u32 = 4;
pub const USER_FSIGNATURES_CDHASH_LEN: u32 = 20;
pub const GETSIGSINFO_PLATFORM_BINARY: u32 = 1;
pub const LOCK_SH: u32 = 1;
pub const LOCK_EX: u32 = 2;
pub const LOCK_NB: u32 = 4;
pub const LOCK_UN: u32 = 8;
pub const O_POPUP: u32 = 2147483648;
pub const O_ALERT: u32 = 536870912;
pub const InvalidXLogRecPtr: u32 = 0;
pub const PG_O_DIRECT: u32 = 0;
pub const OPEN_SYNC_FLAG: u32 = 128;
pub const OPEN_DATASYNC_FLAG: u32 = 4194304;
pub const FirstGenbkiObjectId: u32 = 10000;
pub const FirstBootstrapObjectId: u32 = 12000;
pub const FirstNormalObjectId: u32 = 16384;
pub const TypeRelationId: u32 = 1247;
pub const TypeRelation_Rowtype_Id: u32 = 71;
pub const Anum_pg_type_oid: u32 = 1;
pub const Anum_pg_type_typname: u32 = 2;
pub const Anum_pg_type_typnamespace: u32 = 3;
pub const Anum_pg_type_typowner: u32 = 4;
pub const Anum_pg_type_typlen: u32 = 5;
pub const Anum_pg_type_typbyval: u32 = 6;
pub const Anum_pg_type_typtype: u32 = 7;
pub const Anum_pg_type_typcategory: u32 = 8;
pub const Anum_pg_type_typispreferred: u32 = 9;
pub const Anum_pg_type_typisdefined: u32 = 10;
pub const Anum_pg_type_typdelim: u32 = 11;
pub const Anum_pg_type_typrelid: u32 = 12;
pub const Anum_pg_type_typelem: u32 = 13;
pub const Anum_pg_type_typarray: u32 = 14;
pub const Anum_pg_type_typinput: u32 = 15;
pub const Anum_pg_type_typoutput: u32 = 16;
pub const Anum_pg_type_typreceive: u32 = 17;
pub const Anum_pg_type_typsend: u32 = 18;
pub const Anum_pg_type_typmodin: u32 = 19;
pub const Anum_pg_type_typmodout: u32 = 20;
pub const Anum_pg_type_typanalyze: u32 = 21;
pub const Anum_pg_type_typalign: u32 = 22;
pub const Anum_pg_type_typstorage: u32 = 23;
pub const Anum_pg_type_typnotnull: u32 = 24;
pub const Anum_pg_type_typbasetype: u32 = 25;
pub const Anum_pg_type_typtypmod: u32 = 26;
pub const Anum_pg_type_typndims: u32 = 27;
pub const Anum_pg_type_typcollation: u32 = 28;
pub const Anum_pg_type_typdefaultbin: u32 = 29;
pub const Anum_pg_type_typdefault: u32 = 30;
pub const Anum_pg_type_typacl: u32 = 31;
pub const Natts_pg_type: u32 = 31;
pub const TYPTYPE_BASE: u8 = 98u8;
pub const TYPTYPE_COMPOSITE: u8 = 99u8;
pub const TYPTYPE_DOMAIN: u8 = 100u8;
pub const TYPTYPE_ENUM: u8 = 101u8;
pub const TYPTYPE_PSEUDO: u8 = 112u8;
pub const TYPTYPE_RANGE: u8 = 114u8;
pub const TYPCATEGORY_INVALID: u8 = 0u8;
pub const TYPCATEGORY_ARRAY: u8 = 65u8;
pub const TYPCATEGORY_BOOLEAN: u8 = 66u8;
pub const TYPCATEGORY_COMPOSITE: u8 = 67u8;
pub const TYPCATEGORY_DATETIME: u8 = 68u8;
pub const TYPCATEGORY_ENUM: u8 = 69u8;
pub const TYPCATEGORY_GEOMETRIC: u8 = 71u8;
pub const TYPCATEGORY_NETWORK: u8 = 73u8;
pub const TYPCATEGORY_NUMERIC: u8 = 78u8;
pub const TYPCATEGORY_PSEUDOTYPE: u8 = 80u8;
pub const TYPCATEGORY_RANGE: u8 = 82u8;
pub const TYPCATEGORY_STRING: u8 = 83u8;
pub const TYPCATEGORY_TIMESPAN: u8 = 84u8;
pub const TYPCATEGORY_USER: u8 = 85u8;
pub const TYPCATEGORY_BITSTRING: u8 = 86u8;
pub const TYPCATEGORY_UNKNOWN: u8 = 88u8;
pub const TYPALIGN_CHAR: u8 = 99u8;
pub const TYPALIGN_SHORT: u8 = 115u8;
pub const TYPALIGN_INT: u8 = 105u8;
pub const TYPALIGN_DOUBLE: u8 = 100u8;
pub const TYPSTORAGE_PLAIN: u8 = 112u8;
pub const TYPSTORAGE_EXTERNAL: u8 = 101u8;
pub const TYPSTORAGE_EXTENDED: u8 = 120u8;
pub const TYPSTORAGE_MAIN: u8 = 109u8;
pub const BOOLOID: u32 = 16;
pub const BYTEAOID: u32 = 17;
pub const CHAROID: u32 = 18;
pub const NAMEOID: u32 = 19;
pub const INT8OID: u32 = 20;
pub const INT2OID: u32 = 21;
pub const INT2VECTOROID: u32 = 22;
pub const INT4OID: u32 = 23;
pub const REGPROCOID: u32 = 24;
pub const TEXTOID: u32 = 25;
pub const OIDOID: u32 = 26;
pub const TIDOID: u32 = 27;
pub const XIDOID: u32 = 28;
pub const CIDOID: u32 = 29;
pub const OIDVECTOROID: u32 = 30;
pub const JSONOID: u32 = 114;
pub const XMLOID: u32 = 142;
pub const PGNODETREEOID: u32 = 194;
pub const PGNDISTINCTOID: u32 = 3361;
pub const PGDEPENDENCIESOID: u32 = 3402;
pub const PGMCVLISTOID: u32 = 5017;
pub const PGDDLCOMMANDOID: u32 = 32;
pub const XID8OID: u32 = 5069;
pub const POINTOID: u32 = 600;
pub const LSEGOID: u32 = 601;
pub const PATHOID: u32 = 602;
pub const BOXOID: u32 = 603;
pub const POLYGONOID: u32 = 604;
pub const LINEOID: u32 = 628;
pub const FLOAT4OID: u32 = 700;
pub const FLOAT8OID: u32 = 701;
pub const UNKNOWNOID: u32 = 705;
pub const CIRCLEOID: u32 = 718;
pub const CASHOID: u32 = 790;
pub const MACADDROID: u32 = 829;
pub const INETOID: u32 = 869;
pub const CIDROID: u32 = 650;
pub const MACADDR8OID: u32 = 774;
pub const ACLITEMOID: u32 = 1033;
pub const BPCHAROID: u32 = 1042;
pub const VARCHAROID: u32 = 1043;
pub const DATEOID: u32 = 1082;
pub const TIMEOID: u32 = 1083;
pub const TIMESTAMPOID: u32 = 1114;
pub const TIMESTAMPTZOID: u32 = 1184;
pub const INTERVALOID: u32 = 1186;
pub const TIMETZOID: u32 = 1266;
pub const BITOID: u32 = 1560;
pub const VARBITOID: u32 = 1562;
pub const NUMERICOID: u32 = 1700;
pub const REFCURSOROID: u32 = 1790;
pub const REGPROCEDUREOID: u32 = 2202;
pub const REGOPEROID: u32 = 2203;
pub const REGOPERATOROID: u32 = 2204;
pub const REGCLASSOID: u32 = 2205;
pub const REGCOLLATIONOID: u32 = 4191;
pub const REGTYPEOID: u32 = 2206;
pub const REGROLEOID: u32 = 4096;
pub const REGNAMESPACEOID: u32 = 4089;
pub const UUIDOID: u32 = 2950;
pub const LSNOID: u32 = 3220;
pub const TSVECTOROID: u32 = 3614;
pub const GTSVECTOROID: u32 = 3642;
pub const TSQUERYOID: u32 = 3615;
pub const REGCONFIGOID: u32 = 3734;
pub const REGDICTIONARYOID: u32 = 3769;
pub const JSONBOID: u32 = 3802;
pub const JSONPATHOID: u32 = 4072;
pub const TXID_SNAPSHOTOID: u32 = 2970;
pub const PG_SNAPSHOTOID: u32 = 5038;
pub const INT4RANGEOID: u32 = 3904;
pub const NUMRANGEOID: u32 = 3906;
pub const TSRANGEOID: u32 = 3908;
pub const TSTZRANGEOID: u32 = 3910;
pub const DATERANGEOID: u32 = 3912;
pub const INT8RANGEOID: u32 = 3926;
pub const RECORDOID: u32 = 2249;
pub const RECORDARRAYOID: u32 = 2287;
pub const CSTRINGOID: u32 = 2275;
pub const ANYOID: u32 = 2276;
pub const ANYARRAYOID: u32 = 2277;
pub const VOIDOID: u32 = 2278;
pub const TRIGGEROID: u32 = 2279;
pub const EVTTRIGGEROID: u32 = 3838;
pub const LANGUAGE_HANDLEROID: u32 = 2280;
pub const INTERNALOID: u32 = 2281;
pub const ANYELEMENTOID: u32 = 2283;
pub const ANYNONARRAYOID: u32 = 2776;
pub const ANYENUMOID: u32 = 3500;
pub const FDW_HANDLEROID: u32 = 3115;
pub const INDEX_AM_HANDLEROID: u32 = 325;
pub const TSM_HANDLEROID: u32 = 3310;
pub const TABLE_AM_HANDLEROID: u32 = 269;
pub const ANYRANGEOID: u32 = 3831;
pub const ANYCOMPATIBLEOID: u32 = 5077;
pub const ANYCOMPATIBLEARRAYOID: u32 = 5078;
pub const ANYCOMPATIBLENONARRAYOID: u32 = 5079;
pub const ANYCOMPATIBLERANGEOID: u32 = 5080;
pub const BOOLARRAYOID: u32 = 1000;
pub const BYTEAARRAYOID: u32 = 1001;
pub const CHARARRAYOID: u32 = 1002;
pub const NAMEARRAYOID: u32 = 1003;
pub const INT8ARRAYOID: u32 = 1016;
pub const INT2ARRAYOID: u32 = 1005;
pub const INT2VECTORARRAYOID: u32 = 1006;
pub const INT4ARRAYOID: u32 = 1007;
pub const REGPROCARRAYOID: u32 = 1008;
pub const TEXTARRAYOID: u32 = 1009;
pub const OIDARRAYOID: u32 = 1028;
pub const TIDARRAYOID: u32 = 1010;
pub const XIDARRAYOID: u32 = 1011;
pub const CIDARRAYOID: u32 = 1012;
pub const OIDVECTORARRAYOID: u32 = 1013;
pub const JSONARRAYOID: u32 = 199;
pub const XMLARRAYOID: u32 = 143;
pub const XID8ARRAYOID: u32 = 271;
pub const POINTARRAYOID: u32 = 1017;
pub const LSEGARRAYOID: u32 = 1018;
pub const PATHARRAYOID: u32 = 1019;
pub const BOXARRAYOID: u32 = 1020;
pub const POLYGONARRAYOID: u32 = 1027;
pub const LINEARRAYOID: u32 = 629;
pub const FLOAT4ARRAYOID: u32 = 1021;
pub const FLOAT8ARRAYOID: u32 = 1022;
pub const CIRCLEARRAYOID: u32 = 719;
pub const MONEYARRAYOID: u32 = 791;
pub const MACADDRARRAYOID: u32 = 1040;
pub const INETARRAYOID: u32 = 1041;
pub const CIDRARRAYOID: u32 = 651;
pub const MACADDR8ARRAYOID: u32 = 775;
pub const ACLITEMARRAYOID: u32 = 1034;
pub const BPCHARARRAYOID: u32 = 1014;
pub const VARCHARARRAYOID: u32 = 1015;
pub const DATEARRAYOID: u32 = 1182;
pub const TIMEARRAYOID: u32 = 1183;
pub const TIMESTAMPARRAYOID: u32 = 1115;
pub const TIMESTAMPTZARRAYOID: u32 = 1185;
pub const INTERVALARRAYOID: u32 = 1187;
pub const TIMETZARRAYOID: u32 = 1270;
pub const BITARRAYOID: u32 = 1561;
pub const VARBITARRAYOID: u32 = 1563;
pub const NUMERICARRAYOID: u32 = 1231;
pub const REFCURSORARRAYOID: u32 = 2201;
pub const REGPROCEDUREARRAYOID: u32 = 2207;
pub const REGOPERARRAYOID: u32 = 2208;
pub const REGOPERATORARRAYOID: u32 = 2209;
pub const REGCLASSARRAYOID: u32 = 2210;
pub const REGCOLLATIONARRAYOID: u32 = 4192;
pub const REGTYPEARRAYOID: u32 = 2211;
pub const REGROLEARRAYOID: u32 = 4097;
pub const REGNAMESPACEARRAYOID: u32 = 4090;
pub const UUIDARRAYOID: u32 = 2951;
pub const PG_LSNARRAYOID: u32 = 3221;
pub const TSVECTORARRAYOID: u32 = 3643;
pub const GTSVECTORARRAYOID: u32 = 3644;
pub const TSQUERYARRAYOID: u32 = 3645;
pub const REGCONFIGARRAYOID: u32 = 3735;
pub const REGDICTIONARYARRAYOID: u32 = 3770;
pub const JSONBARRAYOID: u32 = 3807;
pub const JSONPATHARRAYOID: u32 = 4073;
pub const TXID_SNAPSHOTARRAYOID: u32 = 2949;
pub const PG_SNAPSHOTARRAYOID: u32 = 5039;
pub const INT4RANGEARRAYOID: u32 = 3905;
pub const NUMRANGEARRAYOID: u32 = 3907;
pub const TSRANGEARRAYOID: u32 = 3909;
pub const TSTZRANGEARRAYOID: u32 = 3911;
pub const DATERANGEARRAYOID: u32 = 3913;
pub const INT8RANGEARRAYOID: u32 = 3927;
pub const CSTRINGARRAYOID: u32 = 1263;
pub const PD_HAS_FREE_LINES: u32 = 1;
pub const PD_PAGE_FULL: u32 = 2;
pub const PD_ALL_VISIBLE: u32 = 4;
pub const PD_VALID_FLAG_BITS: u32 = 7;
pub const PG_PAGE_LAYOUT_VERSION: u32 = 4;
pub const PG_DATA_CHECKSUM_VERSION: u32 = 1;
pub const PAI_OVERWRITE: u32 = 1;
pub const PAI_IS_HEAP: u32 = 2;
pub const PIV_LOG_WARNING: u32 = 1;
pub const PIV_REPORT_STAT: u32 = 2;
pub const MaxTupleAttributeNumber: u32 = 1664;
pub const MaxHeapAttributeNumber: u32 = 1600;
pub const FIELDNO_HEAPTUPLEHEADERDATA_INFOMASK2: u32 = 2;
pub const FIELDNO_HEAPTUPLEHEADERDATA_INFOMASK: u32 = 3;
pub const FIELDNO_HEAPTUPLEHEADERDATA_HOFF: u32 = 4;
pub const FIELDNO_HEAPTUPLEHEADERDATA_BITS: u32 = 5;
pub const HEAP_HASNULL: u32 = 1;
pub const HEAP_HASVARWIDTH: u32 = 2;
pub const HEAP_HASEXTERNAL: u32 = 4;
pub const HEAP_HASOID_OLD: u32 = 8;
pub const HEAP_XMAX_KEYSHR_LOCK: u32 = 16;
pub const HEAP_COMBOCID: u32 = 32;
pub const HEAP_XMAX_EXCL_LOCK: u32 = 64;
pub const HEAP_XMAX_LOCK_ONLY: u32 = 128;
pub const HEAP_XMAX_SHR_LOCK: u32 = 80;
pub const HEAP_LOCK_MASK: u32 = 80;
pub const HEAP_XMIN_COMMITTED: u32 = 256;
pub const HEAP_XMIN_INVALID: u32 = 512;
pub const HEAP_XMIN_FROZEN: u32 = 768;
pub const HEAP_XMAX_COMMITTED: u32 = 1024;
pub const HEAP_XMAX_INVALID: u32 = 2048;
pub const HEAP_XMAX_IS_MULTI: u32 = 4096;
pub const HEAP_UPDATED: u32 = 8192;
pub const HEAP_MOVED_OFF: u32 = 16384;
pub const HEAP_MOVED_IN: u32 = 32768;
pub const HEAP_MOVED: u32 = 49152;
pub const HEAP_XACT_MASK: u32 = 65520;
pub const HEAP_XMAX_BITS: u32 = 7376;
pub const HEAP_NATTS_MASK: u32 = 2047;
pub const HEAP_KEYS_UPDATED: u32 = 8192;
pub const HEAP_HOT_UPDATED: u32 = 16384;
pub const HEAP_ONLY_TUPLE: u32 = 32768;
pub const HEAP2_XACT_MASK: u32 = 57344;
pub const HEAP_TUPLE_HAS_MATCH: u32 = 32768;
pub const MaxAttrSize: u32 = 10485760;
pub const SelfItemPointerAttributeNumber: i32 = -1;
pub const MinTransactionIdAttributeNumber: i32 = -2;
pub const MinCommandIdAttributeNumber: i32 = -3;
pub const MaxTransactionIdAttributeNumber: i32 = -4;
pub const MaxCommandIdAttributeNumber: i32 = -5;
pub const TableOidAttributeNumber: i32 = -6;
pub const FirstLowInvalidHeapAttributeNumber: i32 = -7;
pub const InvalidBuffer: u32 = 0;
pub const TTS_FLAG_EMPTY: u32 = 2;
pub const TTS_FLAG_SHOULDFREE: u32 = 4;
pub const TTS_FLAG_SLOW: u32 = 8;
pub const TTS_FLAG_FIXED: u32 = 16;
pub const FIELDNO_TUPLETABLESLOT_FLAGS: u32 = 1;
pub const FIELDNO_TUPLETABLESLOT_NVALID: u32 = 2;
pub const FIELDNO_TUPLETABLESLOT_TUPLEDESCRIPTOR: u32 = 4;
pub const FIELDNO_TUPLETABLESLOT_VALUES: u32 = 5;
pub const FIELDNO_TUPLETABLESLOT_ISNULL: u32 = 6;
pub const FIELDNO_HEAPTUPLETABLESLOT_TUPLE: u32 = 1;
pub const FIELDNO_HEAPTUPLETABLESLOT_OFF: u32 = 2;
pub const FIELDNO_MINIMALTUPLETABLESLOT_TUPLE: u32 = 1;
pub const FIELDNO_MINIMALTUPLETABLESLOT_OFF: u32 = 4;
pub const BITS_PER_BITMAPWORD: u32 = 64;
pub const CLOCKS_PER_SEC: u32 = 1000000;
pub const TIME_UTC: u32 = 1;
pub const FIELDNO_FUNCTIONCALLINFODATA_ISNULL: u32 = 4;
pub const FIELDNO_FUNCTIONCALLINFODATA_ARGS: u32 = 6;
pub const PG_MAGIC_FUNCTION_NAME_STRING: &[u8; 14usize] = b"Pg_magic_func\0";
pub const AGG_CONTEXT_AGGREGATE: u32 = 1;
pub const AGG_CONTEXT_WINDOW: u32 = 2;
pub const PARAM_FLAG_CONST: u32 = 1;
pub const BTLessStrategyNumber: u32 = 1;
pub const BTLessEqualStrategyNumber: u32 = 2;
pub const BTEqualStrategyNumber: u32 = 3;
pub const BTGreaterEqualStrategyNumber: u32 = 4;
pub const BTGreaterStrategyNumber: u32 = 5;
pub const BTMaxStrategyNumber: u32 = 5;
pub const HTEqualStrategyNumber: u32 = 1;
pub const HTMaxStrategyNumber: u32 = 1;
pub const RTLeftStrategyNumber: u32 = 1;
pub const RTOverLeftStrategyNumber: u32 = 2;
pub const RTOverlapStrategyNumber: u32 = 3;
pub const RTOverRightStrategyNumber: u32 = 4;
pub const RTRightStrategyNumber: u32 = 5;
pub const RTSameStrategyNumber: u32 = 6;
pub const RTContainsStrategyNumber: u32 = 7;
pub const RTContainedByStrategyNumber: u32 = 8;
pub const RTOverBelowStrategyNumber: u32 = 9;
pub const RTBelowStrategyNumber: u32 = 10;
pub const RTAboveStrategyNumber: u32 = 11;
pub const RTOverAboveStrategyNumber: u32 = 12;
pub const RTOldContainsStrategyNumber: u32 = 13;
pub const RTOldContainedByStrategyNumber: u32 = 14;
pub const RTKNNSearchStrategyNumber: u32 = 15;
pub const RTContainsElemStrategyNumber: u32 = 16;
pub const RTAdjacentStrategyNumber: u32 = 17;
pub const RTEqualStrategyNumber: u32 = 18;
pub const RTNotEqualStrategyNumber: u32 = 19;
pub const RTLessStrategyNumber: u32 = 20;
pub const RTLessEqualStrategyNumber: u32 = 21;
pub const RTGreaterStrategyNumber: u32 = 22;
pub const RTGreaterEqualStrategyNumber: u32 = 23;
pub const RTSubStrategyNumber: u32 = 24;
pub const RTSubEqualStrategyNumber: u32 = 25;
pub const RTSuperStrategyNumber: u32 = 26;
pub const RTSuperEqualStrategyNumber: u32 = 27;
pub const RTPrefixStrategyNumber: u32 = 28;
pub const RTMaxStrategyNumber: u32 = 28;
pub const INNER_VAR: u32 = 65000;
pub const OUTER_VAR: u32 = 65001;
pub const INDEX_VAR: u32 = 65002;
pub const PRS2_OLD_VARNO: u32 = 1;
pub const PRS2_NEW_VARNO: u32 = 2;
pub const __DARWIN_CLK_TCK: u32 = 100;
pub const CHAR_BIT: u32 = 8;
pub const MB_LEN_MAX: u32 = 6;
pub const CLK_TCK: u32 = 100;
pub const SCHAR_MAX: u32 = 127;
pub const SCHAR_MIN: i32 = -128;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MAX: u32 = 127;
pub const CHAR_MIN: i32 = -128;
pub const USHRT_MAX: u32 = 65535;
pub const SHRT_MAX: u32 = 32767;
pub const SHRT_MIN: i32 = -32768;
pub const UINT_MAX: u32 = 4294967295;
pub const INT_MAX: u32 = 2147483647;
pub const INT_MIN: i32 = -2147483648;
pub const ULONG_MAX: i32 = -1;
pub const LONG_MAX: u64 = 9223372036854775807;
pub const LONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const LONG_BIT: u32 = 64;
pub const SSIZE_MAX: u64 = 9223372036854775807;
pub const WORD_BIT: u32 = 32;
pub const SIZE_T_MAX: i32 = -1;
pub const UQUAD_MAX: i32 = -1;
pub const QUAD_MAX: u64 = 9223372036854775807;
pub const QUAD_MIN: i64 = -9223372036854775808;
pub const ARG_MAX: u32 = 1048576;
pub const CHILD_MAX: u32 = 266;
pub const GID_MAX: u32 = 2147483647;
pub const LINK_MAX: u32 = 32767;
pub const MAX_CANON: u32 = 1024;
pub const MAX_INPUT: u32 = 1024;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 16;
pub const UID_MAX: u32 = 2147483647;
pub const OPEN_MAX: u32 = 10240;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const CHARCLASS_NAME_MAX: u32 = 14;
pub const COLL_WEIGHTS_MAX: u32 = 2;
pub const EQUIV_CLASS_MAX: u32 = 2;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 255;
pub const NZERO: u32 = 20;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_EQUIV_CLASS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_KEYS_MAX: u32 = 512;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const OFF_MIN: i64 = -9223372036854775808;
pub const OFF_MAX: u64 = 9223372036854775807;
pub const PASS_MAX: u32 = 128;
pub const NL_ARGMAX: u32 = 9;
pub const NL_LANGMAX: u32 = 14;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_NMAX: u32 = 1;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 2048;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const IOV_MAX: u32 = 1024;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const DSM_IMPL_POSIX: u32 = 1;
pub const DSM_IMPL_SYSV: u32 = 2;
pub const DSM_IMPL_WINDOWS: u32 = 3;
pub const DSM_IMPL_MMAP: u32 = 4;
pub const DEFAULT_DYNAMIC_SHARED_MEMORY_TYPE: u32 = 1;
pub const PG_DYNSHMEM_DIR: &[u8; 12usize] = b"pg_dynshmem\0";
pub const PG_DYNSHMEM_MMAP_FILE_PREFIX: &[u8; 6usize] = b"mmap.\0";
pub const DSM_CREATE_NULL_IF_MAXSEGMENTS: u32 = 1;
pub const DSM_HANDLE_INVALID: u32 = 0;
pub const SIZEOF_DSA_POINTER: u32 = 8;
pub const DSA_POINTER_FORMAT: &[u8; 7usize] = b"%016lx\0";
pub const DSA_ALLOC_HUGE: u32 = 1;
pub const DSA_ALLOC_NO_OOM: u32 = 2;
pub const DSA_ALLOC_ZERO: u32 = 4;
pub const DEFAULT_SPINS_PER_DELAY: u32 = 100;
pub const HASH_PARTITION: u32 = 1;
pub const HASH_SEGMENT: u32 = 2;
pub const HASH_DIRSIZE: u32 = 4;
pub const HASH_FFACTOR: u32 = 8;
pub const HASH_ELEM: u32 = 16;
pub const HASH_BLOBS: u32 = 32;
pub const HASH_FUNCTION: u32 = 64;
pub const HASH_COMPARE: u32 = 128;
pub const HASH_KEYCOPY: u32 = 256;
pub const HASH_ALLOC: u32 = 512;
pub const HASH_CONTEXT: u32 = 1024;
pub const HASH_SHARED_MEM: u32 = 2048;
pub const HASH_ATTACH: u32 = 4096;
pub const HASH_FIXED_SIZE: u32 = 8192;
pub const NO_MAX_DSIZE: i32 = -1;
pub const __DARWIN_MAXNAMLEN: u32 = 255;
pub const __DARWIN_MAXPATHLEN: u32 = 1024;
pub const MAXNAMLEN: u32 = 255;
pub const DT_UNKNOWN: u32 = 0;
pub const DT_FIFO: u32 = 1;
pub const DT_CHR: u32 = 2;
pub const DT_DIR: u32 = 4;
pub const DT_BLK: u32 = 6;
pub const DT_REG: u32 = 8;
pub const DT_LNK: u32 = 10;
pub const DT_SOCK: u32 = 12;
pub const DT_WHT: u32 = 14;
pub const DIRBLKSIZ: u32 = 1024;
pub const DTF_HIDEW: u32 = 1;
pub const DTF_NODUP: u32 = 2;
pub const DTF_REWIND: u32 = 4;
pub const __DTF_READALL: u32 = 8;
pub const __DTF_SKIPREAD: u32 = 16;
pub const __DTF_ATEND: u32 = 32;
pub const PG_TEMP_FILES_DIR: &[u8; 10usize] = b"pgsql_tmp\0";
pub const PG_TEMP_FILE_PREFIX: &[u8; 10usize] = b"pgsql_tmp\0";
pub const SHARED_TUPLESTORE_SINGLE_PASS: u32 = 1;
pub const MAX_TIMESTAMP_PRECISION: u32 = 6;
pub const MAX_INTERVAL_PRECISION: u32 = 6;
pub const TS_PREC_INV: f64 = 1000000.0;
pub const DAYS_PER_YEAR: f64 = 365.25;
pub const MONTHS_PER_YEAR: u32 = 12;
pub const DAYS_PER_MONTH: u32 = 30;
pub const HOURS_PER_DAY: u32 = 24;
pub const SECS_PER_YEAR: u32 = 31557600;
pub const SECS_PER_DAY: u32 = 86400;
pub const SECS_PER_HOUR: u32 = 3600;
pub const SECS_PER_MINUTE: u32 = 60;
pub const MINS_PER_HOUR: u32 = 60;
pub const MAX_TZDISP_HOUR: u32 = 15;
pub const TZDISP_LIMIT: u32 = 57600;
pub const JULIAN_MINYEAR: i32 = -4713;
pub const JULIAN_MINMONTH: u32 = 11;
pub const JULIAN_MINDAY: u32 = 24;
pub const JULIAN_MAXYEAR: u32 = 5874898;
pub const JULIAN_MAXMONTH: u32 = 6;
pub const JULIAN_MAXDAY: u32 = 3;
pub const UNIX_EPOCH_JDATE: u32 = 2440588;
pub const POSTGRES_EPOCH_JDATE: u32 = 2451545;
pub const DATETIME_MIN_JULIAN: u32 = 0;
pub const DATE_END_JULIAN: u32 = 2147483494;
pub const TIMESTAMP_END_JULIAN: u32 = 109203528;
pub const RELCACHE_INIT_FILENAME: &[u8; 17usize] = b"pg_internal.init\0";
pub const INDEX_SIZE_MASK: u32 = 8191;
pub const INDEX_AM_RESERVED_BIT: u32 = 8192;
pub const INDEX_VAR_MASK: u32 = 16384;
pub const INDEX_NULL_MASK: u32 = 32768;
pub const NUM_TUPLESORTMETHODS: u32 = 4;
pub const EEO_FLAG_IS_QUAL: u32 = 1;
pub const FIELDNO_EXPRSTATE_RESNULL: u32 = 2;
pub const FIELDNO_EXPRSTATE_RESVALUE: u32 = 3;
pub const FIELDNO_EXPRSTATE_RESULTSLOT: u32 = 4;
pub const FIELDNO_EXPRSTATE_PARENT: u32 = 11;
pub const FIELDNO_EXPRCONTEXT_SCANTUPLE: u32 = 1;
pub const FIELDNO_EXPRCONTEXT_INNERTUPLE: u32 = 2;
pub const FIELDNO_EXPRCONTEXT_OUTERTUPLE: u32 = 3;
pub const FIELDNO_EXPRCONTEXT_AGGVALUES: u32 = 8;
pub const FIELDNO_EXPRCONTEXT_AGGNULLS: u32 = 9;
pub const FIELDNO_EXPRCONTEXT_CASEDATUM: u32 = 10;
pub const FIELDNO_EXPRCONTEXT_CASENULL: u32 = 11;
pub const FIELDNO_EXPRCONTEXT_DOMAINDATUM: u32 = 12;
pub const FIELDNO_EXPRCONTEXT_DOMAINNULL: u32 = 13;
pub const FIELDNO_AGGSTATE_CURAGGCONTEXT: u32 = 14;
pub const FIELDNO_AGGSTATE_CURPERTRANS: u32 = 16;
pub const FIELDNO_AGGSTATE_CURRENT_SET: u32 = 20;
pub const FIELDNO_AGGSTATE_ALL_PERGROUPS: u32 = 53;
pub const COMPLETION_TAG_BUFSIZE: u32 = 64;
pub const ACL_INSERT: u32 = 1;
pub const ACL_SELECT: u32 = 2;
pub const ACL_UPDATE: u32 = 4;
pub const ACL_DELETE: u32 = 8;
pub const ACL_TRUNCATE: u32 = 16;
pub const ACL_REFERENCES: u32 = 32;
pub const ACL_TRIGGER: u32 = 64;
pub const ACL_EXECUTE: u32 = 128;
pub const ACL_USAGE: u32 = 256;
pub const ACL_CREATE: u32 = 512;
pub const ACL_CREATE_TEMP: u32 = 1024;
pub const ACL_CONNECT: u32 = 2048;
pub const N_ACL_RIGHTS: u32 = 12;
pub const ACL_NO_RIGHTS: u32 = 0;
pub const ACL_SELECT_FOR_UPDATE: u32 = 4;
pub const FRAMEOPTION_NONDEFAULT: u32 = 1;
pub const FRAMEOPTION_RANGE: u32 = 2;
pub const FRAMEOPTION_ROWS: u32 = 4;
pub const FRAMEOPTION_GROUPS: u32 = 8;
pub const FRAMEOPTION_BETWEEN: u32 = 16;
pub const FRAMEOPTION_START_UNBOUNDED_PRECEDING: u32 = 32;
pub const FRAMEOPTION_END_UNBOUNDED_PRECEDING: u32 = 64;
pub const FRAMEOPTION_START_UNBOUNDED_FOLLOWING: u32 = 128;
pub const FRAMEOPTION_END_UNBOUNDED_FOLLOWING: u32 = 256;
pub const FRAMEOPTION_START_CURRENT_ROW: u32 = 512;
pub const FRAMEOPTION_END_CURRENT_ROW: u32 = 1024;
pub const FRAMEOPTION_START_OFFSET_PRECEDING: u32 = 2048;
pub const FRAMEOPTION_END_OFFSET_PRECEDING: u32 = 4096;
pub const FRAMEOPTION_START_OFFSET_FOLLOWING: u32 = 8192;
pub const FRAMEOPTION_END_OFFSET_FOLLOWING: u32 = 16384;
pub const FRAMEOPTION_EXCLUDE_CURRENT_ROW: u32 = 32768;
pub const FRAMEOPTION_EXCLUDE_GROUP: u32 = 65536;
pub const FRAMEOPTION_EXCLUDE_TIES: u32 = 131072;
pub const FRAMEOPTION_START_OFFSET: u32 = 10240;
pub const FRAMEOPTION_END_OFFSET: u32 = 20480;
pub const FRAMEOPTION_EXCLUSION: u32 = 229376;
pub const FRAMEOPTION_DEFAULTS: u32 = 1058;
pub const PARTITION_STRATEGY_HASH: u8 = 104u8;
pub const PARTITION_STRATEGY_LIST: u8 = 108u8;
pub const PARTITION_STRATEGY_RANGE: u8 = 114u8;
pub const FKCONSTR_ACTION_NOACTION: u8 = 97u8;
pub const FKCONSTR_ACTION_RESTRICT: u8 = 114u8;
pub const FKCONSTR_ACTION_CASCADE: u8 = 99u8;
pub const FKCONSTR_ACTION_SETNULL: u8 = 110u8;
pub const FKCONSTR_ACTION_SETDEFAULT: u8 = 100u8;
pub const FKCONSTR_MATCH_FULL: u8 = 102u8;
pub const FKCONSTR_MATCH_PARTIAL: u8 = 112u8;
pub const FKCONSTR_MATCH_SIMPLE: u8 = 115u8;
pub const OPCLASS_ITEM_OPERATOR: u32 = 1;
pub const OPCLASS_ITEM_FUNCTION: u32 = 2;
pub const OPCLASS_ITEM_STORAGETYPE: u32 = 3;
pub const CURSOR_OPT_BINARY: u32 = 1;
pub const CURSOR_OPT_SCROLL: u32 = 2;
pub const CURSOR_OPT_NO_SCROLL: u32 = 4;
pub const CURSOR_OPT_INSENSITIVE: u32 = 8;
pub const CURSOR_OPT_HOLD: u32 = 16;
pub const CURSOR_OPT_FAST_PLAN: u32 = 32;
pub const CURSOR_OPT_GENERIC_PLAN: u32 = 64;
pub const CURSOR_OPT_CUSTOM_PLAN: u32 = 128;
pub const CURSOR_OPT_PARALLEL_OK: u32 = 256;
pub const FETCH_ALL: u64 = 9223372036854775807;
pub const REINDEXOPT_VERBOSE: u32 = 1;
pub const REINDEXOPT_REPORT_PROGRESS: u32 = 2;
pub const MaxAllocHugeSize: u32 = 0;
pub const ALLOCSET_DEFAULT_MINSIZE: u32 = 0;
pub const ALLOCSET_DEFAULT_INITSIZE: u32 = 8192;
pub const ALLOCSET_DEFAULT_MAXSIZE: u32 = 8388608;
pub const ALLOCSET_SMALL_MINSIZE: u32 = 0;
pub const ALLOCSET_SMALL_INITSIZE: u32 = 1024;
pub const ALLOCSET_SMALL_MAXSIZE: u32 = 8192;
pub const ALLOCSET_SEPARATE_THRESHOLD: u32 = 8192;
pub const SLAB_DEFAULT_BLOCK_SIZE: u32 = 8192;
pub const SLAB_LARGE_BLOCK_SIZE: u32 = 8388608;
pub const EXEC_FLAG_EXPLAIN_ONLY: u32 = 1;
pub const EXEC_FLAG_REWIND: u32 = 2;
pub const EXEC_FLAG_BACKWARD: u32 = 4;
pub const EXEC_FLAG_MARK: u32 = 8;
pub const EXEC_FLAG_SKIP_TRIGGERS: u32 = 16;
pub const EXEC_FLAG_WITH_NO_DATA: u32 = 32;
pub const TZ_STRLEN_MAX: u32 = 255;
pub const InvalidPid: i32 = -1;
pub const USE_POSTGRES_DATES: u32 = 0;
pub const USE_ISO_DATES: u32 = 1;
pub const USE_SQL_DATES: u32 = 2;
pub const USE_GERMAN_DATES: u32 = 3;
pub const USE_XSD_DATES: u32 = 4;
pub const DATEORDER_YMD: u32 = 0;
pub const DATEORDER_DMY: u32 = 1;
pub const DATEORDER_MDY: u32 = 2;
pub const INTSTYLE_POSTGRES: u32 = 0;
pub const INTSTYLE_POSTGRES_VERBOSE: u32 = 1;
pub const INTSTYLE_SQL_STANDARD: u32 = 2;
pub const INTSTYLE_ISO_8601: u32 = 3;
pub const MAXTZLEN: u32 = 10;
pub const SECURITY_LOCAL_USERID_CHANGE: u32 = 1;
pub const SECURITY_RESTRICTED_OPERATION: u32 = 2;
pub const SECURITY_NOFORCE_RLS: u32 = 4;
pub const SOL_LOCAL: u32 = 0;
pub const LOCAL_PEERCRED: u32 = 1;
pub const LOCAL_PEERPID: u32 = 2;
pub const LOCAL_PEEREPID: u32 = 3;
pub const LOCAL_PEERUUID: u32 = 4;
pub const LOCAL_PEEREUUID: u32 = 5;
pub const LOCAL_PEERTOKEN: u32 = 6;
pub const SM_DATABASE: u32 = 64;
pub const SM_USER: u32 = 32;
pub const SM_DATABASE_USER: u32 = 97;
pub const SM_OPTIONS: u32 = 64;
pub const SM_UNUSED: u32 = 64;
pub const SM_TTY: u32 = 64;
pub const MAX_STARTUP_PACKET_LENGTH: u32 = 10000;
pub const AUTH_REQ_OK: u32 = 0;
pub const AUTH_REQ_KRB4: u32 = 1;
pub const AUTH_REQ_KRB5: u32 = 2;
pub const AUTH_REQ_PASSWORD: u32 = 3;
pub const AUTH_REQ_CRYPT: u32 = 4;
pub const AUTH_REQ_MD5: u32 = 5;
pub const AUTH_REQ_SCM_CREDS: u32 = 6;
pub const AUTH_REQ_GSS: u32 = 7;
pub const AUTH_REQ_GSS_CONT: u32 = 8;
pub const AUTH_REQ_SSPI: u32 = 9;
pub const AUTH_REQ_SASL: u32 = 10;
pub const AUTH_REQ_SASL_CONT: u32 = 11;
pub const AUTH_REQ_SASL_FIN: u32 = 12;
pub const MIN_XFN_CHARS: u32 = 16;
pub const MAX_XFN_CHARS: u32 = 40;
pub const VALID_XFN_CHARS: &[u8; 40usize] = b"0123456789ABCDEF.history.backup.partial\0";
pub const CATALOG_VERSION_NO: u32 = 202007201;
pub const OIDCHARS: u32 = 10;
pub const FORKNAMECHARS: u32 = 4;
pub const InvalidBackendId: i32 = -1;
pub const XLR_INFO_MASK: u32 = 15;
pub const XLR_RMGR_INFO_MASK: u32 = 240;
pub const XLR_SPECIAL_REL_UPDATE: u32 = 1;
pub const XLR_CHECK_CONSISTENCY: u32 = 2;
pub const BKPIMAGE_HAS_HOLE: u32 = 1;
pub const BKPIMAGE_IS_COMPRESSED: u32 = 2;
pub const BKPIMAGE_APPLY: u32 = 4;
pub const BKPBLOCK_FORK_MASK: u32 = 15;
pub const BKPBLOCK_FLAG_MASK: u32 = 240;
pub const BKPBLOCK_HAS_IMAGE: u32 = 16;
pub const BKPBLOCK_HAS_DATA: u32 = 32;
pub const BKPBLOCK_WILL_INIT: u32 = 64;
pub const BKPBLOCK_SAME_REL: u32 = 128;
pub const XLR_MAX_BLOCK_ID: u32 = 32;
pub const XLR_BLOCK_ID_DATA_SHORT: u32 = 255;
pub const XLR_BLOCK_ID_DATA_LONG: u32 = 254;
pub const XLR_BLOCK_ID_ORIGIN: u32 = 253;
pub const TRANSACTION_STATUS_IN_PROGRESS: u32 = 0;
pub const TRANSACTION_STATUS_COMMITTED: u32 = 1;
pub const TRANSACTION_STATUS_ABORTED: u32 = 2;
pub const TRANSACTION_STATUS_SUB_COMMITTED: u32 = 3;
pub const CLOG_ZEROPAGE: u32 = 0;
pub const CLOG_TRUNCATE: u32 = 16;
pub const WL_LATCH_SET: u32 = 1;
pub const WL_SOCKET_READABLE: u32 = 2;
pub const WL_SOCKET_WRITEABLE: u32 = 4;
pub const WL_TIMEOUT: u32 = 8;
pub const WL_POSTMASTER_DEATH: u32 = 16;
pub const WL_EXIT_ON_PM_DEATH: u32 = 32;
pub const WL_SOCKET_CONNECTED: u32 = 4;
pub const WL_SOCKET_MASK: u32 = 6;
pub const NoLock: u32 = 0;
pub const AccessShareLock: u32 = 1;
pub const RowShareLock: u32 = 2;
pub const RowExclusiveLock: u32 = 3;
pub const ShareUpdateExclusiveLock: u32 = 4;
pub const ShareLock: u32 = 5;
pub const ShareRowExclusiveLock: u32 = 6;
pub const ExclusiveLock: u32 = 7;
pub const AccessExclusiveLock: u32 = 8;
pub const MaxLockMode: u32 = 8;
pub const LWLOCK_PADDED_SIZE: u32 = 128;
pub const NUM_INDIVIDUAL_LWLOCKS: u32 = 48;
pub const NUM_BUFFER_PARTITIONS: u32 = 128;
pub const LOG2_NUM_LOCK_PARTITIONS: u32 = 4;
pub const NUM_LOCK_PARTITIONS: u32 = 16;
pub const LOG2_NUM_PREDICATELOCK_PARTITIONS: u32 = 4;
pub const NUM_PREDICATELOCK_PARTITIONS: u32 = 16;
pub const BUFFER_MAPPING_LWLOCK_OFFSET: u32 = 48;
pub const LOCK_MANAGER_LWLOCK_OFFSET: u32 = 176;
pub const PREDICATELOCK_MANAGER_LWLOCK_OFFSET: u32 = 192;
pub const NUM_FIXED_LWLOCKS: u32 = 208;
pub const SHMEM_INDEX_KEYSIZE: u32 = 48;
pub const SHMEM_INDEX_SIZE: u32 = 64;
pub const InvalidLocalTransactionId: u32 = 0;
pub const MAX_LOCKMODES: u32 = 10;
pub const DEFAULT_LOCKMETHOD: u32 = 1;
pub const USER_LOCKMETHOD: u32 = 2;
pub const PGPROC_MAX_CACHED_SUBXIDS: u32 = 64;
pub const PROC_IS_AUTOVACUUM: u32 = 1;
pub const PROC_IN_VACUUM: u32 = 2;
pub const PROC_IN_ANALYZE: u32 = 4;
pub const PROC_VACUUM_FOR_WRAPAROUND: u32 = 8;
pub const PROC_IN_LOGICAL_DECODING: u32 = 16;
pub const PROC_RESERVED: u32 = 32;
pub const PROC_VACUUM_STATE_MASK: u32 = 14;
pub const FP_LOCK_SLOTS_PER_BACKEND: u32 = 16;
pub const INVALID_PGPROCNO: u32 = 2147483647;
pub const NUM_AUXILIARY_PROCS: u32 = 4;
pub const PGSTAT_STAT_PERMANENT_DIRECTORY: &[u8; 8usize] = b"pg_stat\0";
pub const PGSTAT_STAT_PERMANENT_FILENAME: &[u8; 20usize] = b"pg_stat/global.stat\0";
pub const PGSTAT_STAT_PERMANENT_TMPFILE: &[u8; 19usize] = b"pg_stat/global.tmp\0";
pub const PG_STAT_TMP_DIR: &[u8; 12usize] = b"pg_stat_tmp\0";
pub const PGSTAT_MAX_MSG_SIZE: u32 = 1000;
pub const PGSTAT_FILE_FORMAT_ID: u32 = 27638941;
pub const PG_WAIT_LWLOCK: u32 = 16777216;
pub const PG_WAIT_LOCK: u32 = 50331648;
pub const PG_WAIT_BUFFER_PIN: u32 = 67108864;
pub const PG_WAIT_ACTIVITY: u32 = 83886080;
pub const PG_WAIT_CLIENT: u32 = 100663296;
pub const PG_WAIT_EXTENSION: u32 = 117440512;
pub const PG_WAIT_IPC: u32 = 134217728;
pub const PG_WAIT_TIMEOUT: u32 = 150994944;
pub const PG_WAIT_IO: u32 = 167772160;
pub const PGSTAT_NUM_PROGRESS_PARAM: u32 = 20;
pub const SK_ISNULL: u32 = 1;
pub const SK_UNARY: u32 = 2;
pub const SK_ROW_HEADER: u32 = 4;
pub const SK_ROW_MEMBER: u32 = 8;
pub const SK_ROW_END: u32 = 16;
pub const SK_SEARCHARRAY: u32 = 32;
pub const SK_SEARCHNULL: u32 = 64;
pub const SK_SEARCHNOTNULL: u32 = 128;
pub const SK_ORDER_BY: u32 = 256;
pub const GIN_COMPARE_PROC: u32 = 1;
pub const GIN_EXTRACTVALUE_PROC: u32 = 2;
pub const GIN_EXTRACTQUERY_PROC: u32 = 3;
pub const GIN_CONSISTENT_PROC: u32 = 4;
pub const GIN_COMPARE_PARTIAL_PROC: u32 = 5;
pub const GIN_TRICONSISTENT_PROC: u32 = 6;
pub const GIN_OPTIONS_PROC: u32 = 7;
pub const GINNProcs: u32 = 7;
pub const GIN_SEARCH_MODE_DEFAULT: u32 = 0;
pub const GIN_SEARCH_MODE_INCLUDE_EMPTY: u32 = 1;
pub const GIN_SEARCH_MODE_ALL: u32 = 2;
pub const GIN_SEARCH_MODE_EVERYTHING: u32 = 3;
pub const GIN_FALSE: u32 = 0;
pub const GIN_TRUE: u32 = 1;
pub const GIN_MAYBE: u32 = 2;
pub const XLR_NORMAL_MAX_BLOCK_ID: u32 = 4;
pub const XLR_NORMAL_RDATAS: u32 = 20;
pub const REGBUF_FORCE_IMAGE: u32 = 1;
pub const REGBUF_NO_IMAGE: u32 = 2;
pub const REGBUF_WILL_INIT: u32 = 6;
pub const REGBUF_STANDARD: u32 = 8;
pub const REGBUF_KEEP_DATA: u32 = 16;
pub const SYNC_METHOD_FSYNC: u32 = 0;
pub const SYNC_METHOD_FDATASYNC: u32 = 1;
pub const SYNC_METHOD_OPEN: u32 = 2;
pub const SYNC_METHOD_FSYNC_WRITETHROUGH: u32 = 3;
pub const SYNC_METHOD_OPEN_DSYNC: u32 = 4;
pub const CHECKPOINT_IS_SHUTDOWN: u32 = 1;
pub const CHECKPOINT_END_OF_RECOVERY: u32 = 2;
pub const CHECKPOINT_IMMEDIATE: u32 = 4;
pub const CHECKPOINT_FORCE: u32 = 8;
pub const CHECKPOINT_FLUSH_ALL: u32 = 16;
pub const CHECKPOINT_WAIT: u32 = 32;
pub const CHECKPOINT_REQUESTED: u32 = 64;
pub const CHECKPOINT_CAUSE_XLOG: u32 = 128;
pub const CHECKPOINT_CAUSE_TIME: u32 = 256;
pub const XLOG_INCLUDE_ORIGIN: u32 = 1;
pub const XLOG_MARK_UNIMPORTANT: u32 = 2;
pub const RECOVERY_SIGNAL_FILE: &[u8; 16usize] = b"recovery.signal\0";
pub const STANDBY_SIGNAL_FILE: &[u8; 15usize] = b"standby.signal\0";
pub const BACKUP_LABEL_FILE: &[u8; 13usize] = b"backup_label\0";
pub const BACKUP_LABEL_OLD: &[u8; 17usize] = b"backup_label.old\0";
pub const TABLESPACE_MAP: &[u8; 15usize] = b"tablespace_map\0";
pub const TABLESPACE_MAP_OLD: &[u8; 19usize] = b"tablespace_map.old\0";
pub const PROMOTE_SIGNAL_FILE: &[u8; 8usize] = b"promote\0";
pub const FALLBACK_PROMOTE_SIGNAL_FILE: &[u8; 17usize] = b"fallback_promote\0";
pub const GIST_CONSISTENT_PROC: u32 = 1;
pub const GIST_UNION_PROC: u32 = 2;
pub const GIST_COMPRESS_PROC: u32 = 3;
pub const GIST_DECOMPRESS_PROC: u32 = 4;
pub const GIST_PENALTY_PROC: u32 = 5;
pub const GIST_PICKSPLIT_PROC: u32 = 6;
pub const GIST_EQUAL_PROC: u32 = 7;
pub const GIST_DISTANCE_PROC: u32 = 8;
pub const GIST_FETCH_PROC: u32 = 9;
pub const GIST_OPTIONS_PROC: u32 = 10;
pub const GISTNProcs: u32 = 10;
pub const F_LEAF: u32 = 1;
pub const F_DELETED: u32 = 2;
pub const F_TUPLES_DELETED: u32 = 4;
pub const F_FOLLOW_RIGHT: u32 = 8;
pub const F_HAS_GARBAGE: u32 = 16;
pub const GIST_PAGE_ID: u32 = 65409;
pub const EOH_HEADER_MAGIC: i32 = -1;
pub const EA_MAGIC: u32 = 689375833;
pub const MAX_KILOBYTES: u32 = 2147483647;
pub const PG_AUTOCONF_FILENAME: &[u8; 21usize] = b"postgresql.auto.conf\0";
pub const GUC_QUALIFIER_SEPARATOR: u8 = 46u8;
pub const GUC_LIST_INPUT: u32 = 1;
pub const GUC_LIST_QUOTE: u32 = 2;
pub const GUC_NO_SHOW_ALL: u32 = 4;
pub const GUC_NO_RESET_ALL: u32 = 8;
pub const GUC_REPORT: u32 = 16;
pub const GUC_NOT_IN_SAMPLE: u32 = 32;
pub const GUC_DISALLOW_IN_FILE: u32 = 64;
pub const GUC_CUSTOM_PLACEHOLDER: u32 = 128;
pub const GUC_SUPERUSER_ONLY: u32 = 256;
pub const GUC_IS_NAME: u32 = 512;
pub const GUC_NOT_WHILE_SEC_REST: u32 = 1024;
pub const GUC_DISALLOW_IN_AUTO_FILE: u32 = 2048;
pub const GUC_UNIT_KB: u32 = 4096;
pub const GUC_UNIT_BLOCKS: u32 = 8192;
pub const GUC_UNIT_XBLOCKS: u32 = 12288;
pub const GUC_UNIT_MB: u32 = 16384;
pub const GUC_UNIT_BYTE: u32 = 32768;
pub const GUC_UNIT_MEMORY: u32 = 61440;
pub const GUC_UNIT_MS: u32 = 65536;
pub const GUC_UNIT_S: u32 = 131072;
pub const GUC_UNIT_MIN: u32 = 196608;
pub const GUC_UNIT_TIME: u32 = 983040;
pub const GUC_EXPLAIN: u32 = 1048576;
pub const GUC_UNIT: u32 = 1044480;
pub const RelationRelationId: u32 = 1259;
pub const RelationRelation_Rowtype_Id: u32 = 83;
pub const Anum_pg_class_oid: u32 = 1;
pub const Anum_pg_class_relname: u32 = 2;
pub const Anum_pg_class_relnamespace: u32 = 3;
pub const Anum_pg_class_reltype: u32 = 4;
pub const Anum_pg_class_reloftype: u32 = 5;
pub const Anum_pg_class_relowner: u32 = 6;
pub const Anum_pg_class_relam: u32 = 7;
pub const Anum_pg_class_relfilenode: u32 = 8;
pub const Anum_pg_class_reltablespace: u32 = 9;
pub const Anum_pg_class_relpages: u32 = 10;
pub const Anum_pg_class_reltuples: u32 = 11;
pub const Anum_pg_class_relallvisible: u32 = 12;
pub const Anum_pg_class_reltoastrelid: u32 = 13;
pub const Anum_pg_class_relhasindex: u32 = 14;
pub const Anum_pg_class_relisshared: u32 = 15;
pub const Anum_pg_class_relpersistence: u32 = 16;
pub const Anum_pg_class_relkind: u32 = 17;
pub const Anum_pg_class_relnatts: u32 = 18;
pub const Anum_pg_class_relchecks: u32 = 19;
pub const Anum_pg_class_relhasrules: u32 = 20;
pub const Anum_pg_class_relhastriggers: u32 = 21;
pub const Anum_pg_class_relhassubclass: u32 = 22;
pub const Anum_pg_class_relrowsecurity: u32 = 23;
pub const Anum_pg_class_relforcerowsecurity: u32 = 24;
pub const Anum_pg_class_relispopulated: u32 = 25;
pub const Anum_pg_class_relreplident: u32 = 26;
pub const Anum_pg_class_relispartition: u32 = 27;
pub const Anum_pg_class_relrewrite: u32 = 28;
pub const Anum_pg_class_relfrozenxid: u32 = 29;
pub const Anum_pg_class_relminmxid: u32 = 30;
pub const Anum_pg_class_relacl: u32 = 31;
pub const Anum_pg_class_reloptions: u32 = 32;
pub const Anum_pg_class_relpartbound: u32 = 33;
pub const Natts_pg_class: u32 = 33;
pub const RELKIND_RELATION: u8 = 114u8;
pub const RELKIND_INDEX: u8 = 105u8;
pub const RELKIND_SEQUENCE: u8 = 83u8;
pub const RELKIND_TOASTVALUE: u8 = 116u8;
pub const RELKIND_VIEW: u8 = 118u8;
pub const RELKIND_MATVIEW: u8 = 109u8;
pub const RELKIND_COMPOSITE_TYPE: u8 = 99u8;
pub const RELKIND_FOREIGN_TABLE: u8 = 102u8;
pub const RELKIND_PARTITIONED_TABLE: u8 = 112u8;
pub const RELKIND_PARTITIONED_INDEX: u8 = 73u8;
pub const RELPERSISTENCE_PERMANENT: u8 = 112u8;
pub const RELPERSISTENCE_UNLOGGED: u8 = 117u8;
pub const RELPERSISTENCE_TEMP: u8 = 116u8;
pub const REPLICA_IDENTITY_DEFAULT: u8 = 100u8;
pub const REPLICA_IDENTITY_NOTHING: u8 = 110u8;
pub const REPLICA_IDENTITY_FULL: u8 = 102u8;
pub const REPLICA_IDENTITY_INDEX: u8 = 105u8;
pub const IndexRelationId: u32 = 2610;
pub const Anum_pg_index_indexrelid: u32 = 1;
pub const Anum_pg_index_indrelid: u32 = 2;
pub const Anum_pg_index_indnatts: u32 = 3;
pub const Anum_pg_index_indnkeyatts: u32 = 4;
pub const Anum_pg_index_indisunique: u32 = 5;
pub const Anum_pg_index_indisprimary: u32 = 6;
pub const Anum_pg_index_indisexclusion: u32 = 7;
pub const Anum_pg_index_indimmediate: u32 = 8;
pub const Anum_pg_index_indisclustered: u32 = 9;
pub const Anum_pg_index_indisvalid: u32 = 10;
pub const Anum_pg_index_indcheckxmin: u32 = 11;
pub const Anum_pg_index_indisready: u32 = 12;
pub const Anum_pg_index_indislive: u32 = 13;
pub const Anum_pg_index_indisreplident: u32 = 14;
pub const Anum_pg_index_indkey: u32 = 15;
pub const Anum_pg_index_indcollation: u32 = 16;
pub const Anum_pg_index_indclass: u32 = 17;
pub const Anum_pg_index_indoption: u32 = 18;
pub const Anum_pg_index_indexprs: u32 = 19;
pub const Anum_pg_index_indpred: u32 = 20;
pub const Natts_pg_index: u32 = 20;
pub const INDOPTION_DESC: u32 = 1;
pub const INDOPTION_NULLS_FIRST: u32 = 2;
pub const PublicationRelationId: u32 = 6104;
pub const Anum_pg_publication_oid: u32 = 1;
pub const Anum_pg_publication_pubname: u32 = 2;
pub const Anum_pg_publication_pubowner: u32 = 3;
pub const Anum_pg_publication_puballtables: u32 = 4;
pub const Anum_pg_publication_pubinsert: u32 = 5;
pub const Anum_pg_publication_pubupdate: u32 = 6;
pub const Anum_pg_publication_pubdelete: u32 = 7;
pub const Anum_pg_publication_pubtruncate: u32 = 8;
pub const Anum_pg_publication_pubviaroot: u32 = 9;
pub const Natts_pg_publication: u32 = 9;
pub const HEAP_MIN_FILLFACTOR: u32 = 10;
pub const HEAP_DEFAULT_FILLFACTOR: u32 = 100;
pub const DEFAULT_TABLE_ACCESS_METHOD: &[u8; 5usize] = b"heap\0";
pub const TABLE_INSERT_SKIP_FSM: u32 = 2;
pub const TABLE_INSERT_FROZEN: u32 = 4;
pub const TABLE_INSERT_NO_LOGICAL: u32 = 8;
pub const TUPLE_LOCK_FLAG_LOCK_UPDATE_IN_PROGRESS: u32 = 1;
pub const TUPLE_LOCK_FLAG_FIND_LAST_VERSION: u32 = 2;
pub const HEAP_INSERT_SKIP_FSM: u32 = 2;
pub const HEAP_INSERT_FROZEN: u32 = 4;
pub const HEAP_INSERT_NO_LOGICAL: u32 = 8;
pub const HEAP_INSERT_SPECULATIVE: u32 = 16;
pub const SHAREDINVALCATALOG_ID: i32 = -1;
pub const SHAREDINVALRELCACHE_ID: i32 = -2;
pub const SHAREDINVALSMGR_ID: i32 = -3;
pub const SHAREDINVALRELMAP_ID: i32 = -4;
pub const SHAREDINVALSNAPSHOT_ID: i32 = -5;
pub const INTERVAL_FULL_RANGE: u32 = 32767;
pub const INTERVAL_RANGE_MASK: u32 = 32767;
pub const INTERVAL_FULL_PRECISION: u32 = 65535;
pub const INTERVAL_PRECISION_MASK: u32 = 65535;
pub const DAGO: &[u8; 4usize] = b"ago\0";
pub const DCURRENT: &[u8; 8usize] = b"current\0";
pub const EPOCH: &[u8; 6usize] = b"epoch\0";
pub const INVALID: &[u8; 8usize] = b"invalid\0";
pub const EARLY: &[u8; 10usize] = b"-infinity\0";
pub const LATE: &[u8; 9usize] = b"infinity\0";
pub const NOW: &[u8; 4usize] = b"now\0";
pub const TODAY: &[u8; 6usize] = b"today\0";
pub const TOMORROW: &[u8; 9usize] = b"tomorrow\0";
pub const YESTERDAY: &[u8; 10usize] = b"yesterday\0";
pub const ZULU: &[u8; 5usize] = b"zulu\0";
pub const DMICROSEC: &[u8; 8usize] = b"usecond\0";
pub const DMILLISEC: &[u8; 8usize] = b"msecond\0";
pub const DSECOND: &[u8; 7usize] = b"second\0";
pub const DMINUTE: &[u8; 7usize] = b"minute\0";
pub const DHOUR: &[u8; 5usize] = b"hour\0";
pub const DDAY: &[u8; 4usize] = b"day\0";
pub const DWEEK: &[u8; 5usize] = b"week\0";
pub const DMONTH: &[u8; 6usize] = b"month\0";
pub const DQUARTER: &[u8; 8usize] = b"quarter\0";
pub const DYEAR: &[u8; 5usize] = b"year\0";
pub const DDECADE: &[u8; 7usize] = b"decade\0";
pub const DCENTURY: &[u8; 8usize] = b"century\0";
pub const DMILLENNIUM: &[u8; 11usize] = b"millennium\0";
pub const DA_D: &[u8; 3usize] = b"ad\0";
pub const DB_C: &[u8; 3usize] = b"bc\0";
pub const DTIMEZONE: &[u8; 9usize] = b"timezone\0";
pub const AM: u32 = 0;
pub const PM: u32 = 1;
pub const HR24: u32 = 2;
pub const AD: u32 = 0;
pub const BC: u32 = 1;
pub const RESERV: u32 = 0;
pub const MONTH: u32 = 1;
pub const YEAR: u32 = 2;
pub const DAY: u32 = 3;
pub const JULIAN: u32 = 4;
pub const TZ: u32 = 5;
pub const DTZ: u32 = 6;
pub const DYNTZ: u32 = 7;
pub const IGNORE_DTF: u32 = 8;
pub const AMPM: u32 = 9;
pub const HOUR: u32 = 10;
pub const MINUTE: u32 = 11;
pub const SECOND: u32 = 12;
pub const MILLISECOND: u32 = 13;
pub const MICROSECOND: u32 = 14;
pub const DOY: u32 = 15;
pub const DOW: u32 = 16;
pub const UNITS: u32 = 17;
pub const ADBC: u32 = 18;
pub const AGO: u32 = 19;
pub const ABS_BEFORE: u32 = 20;
pub const ABS_AFTER: u32 = 21;
pub const ISODATE: u32 = 22;
pub const ISOTIME: u32 = 23;
pub const WEEK: u32 = 24;
pub const DECADE: u32 = 25;
pub const CENTURY: u32 = 26;
pub const MILLENNIUM: u32 = 27;
pub const DTZMOD: u32 = 28;
pub const UNKNOWN_FIELD: u32 = 31;
pub const DTK_NUMBER: u32 = 0;
pub const DTK_STRING: u32 = 1;
pub const DTK_DATE: u32 = 2;
pub const DTK_TIME: u32 = 3;
pub const DTK_TZ: u32 = 4;
pub const DTK_AGO: u32 = 5;
pub const DTK_SPECIAL: u32 = 6;
pub const DTK_EARLY: u32 = 9;
pub const DTK_LATE: u32 = 10;
pub const DTK_EPOCH: u32 = 11;
pub const DTK_NOW: u32 = 12;
pub const DTK_YESTERDAY: u32 = 13;
pub const DTK_TODAY: u32 = 14;
pub const DTK_TOMORROW: u32 = 15;
pub const DTK_ZULU: u32 = 16;
pub const DTK_DELTA: u32 = 17;
pub const DTK_SECOND: u32 = 18;
pub const DTK_MINUTE: u32 = 19;
pub const DTK_HOUR: u32 = 20;
pub const DTK_DAY: u32 = 21;
pub const DTK_WEEK: u32 = 22;
pub const DTK_MONTH: u32 = 23;
pub const DTK_QUARTER: u32 = 24;
pub const DTK_YEAR: u32 = 25;
pub const DTK_DECADE: u32 = 26;
pub const DTK_CENTURY: u32 = 27;
pub const DTK_MILLENNIUM: u32 = 28;
pub const DTK_MILLISEC: u32 = 29;
pub const DTK_MICROSEC: u32 = 30;
pub const DTK_JULIAN: u32 = 31;
pub const DTK_DOW: u32 = 32;
pub const DTK_DOY: u32 = 33;
pub const DTK_TZ_HOUR: u32 = 34;
pub const DTK_TZ_MINUTE: u32 = 35;
pub const DTK_ISOYEAR: u32 = 36;
pub const DTK_ISODOW: u32 = 37;
pub const MAXDATELEN: u32 = 128;
pub const MAXDATEFIELDS: u32 = 25;
pub const TOKMAXLEN: u32 = 10;
pub const DTERR_BAD_FORMAT: i32 = -1;
pub const DTERR_FIELD_OVERFLOW: i32 = -2;
pub const DTERR_MD_FIELD_OVERFLOW: i32 = -3;
pub const DTERR_INTERVAL_OVERFLOW: i32 = -4;
pub const DTERR_TZDISP_OVERFLOW: i32 = -5;
pub const GIDSIZE: u32 = 200;
pub const XACT_READ_UNCOMMITTED: u32 = 0;
pub const XACT_READ_COMMITTED: u32 = 1;
pub const XACT_REPEATABLE_READ: u32 = 2;
pub const XACT_SERIALIZABLE: u32 = 3;
pub const XACT_FLAGS_ACCESSEDTEMPNAMESPACE: u32 = 1;
pub const XACT_FLAGS_ACQUIREDACCESSEXCLUSIVELOCK: u32 = 2;
pub const XLOG_XACT_COMMIT: u32 = 0;
pub const XLOG_XACT_PREPARE: u32 = 16;
pub const XLOG_XACT_ABORT: u32 = 32;
pub const XLOG_XACT_COMMIT_PREPARED: u32 = 48;
pub const XLOG_XACT_ABORT_PREPARED: u32 = 64;
pub const XLOG_XACT_ASSIGNMENT: u32 = 80;
pub const XLOG_XACT_OPMASK: u32 = 112;
pub const XLOG_XACT_HAS_INFO: u32 = 128;
pub const XACT_XINFO_HAS_DBINFO: u32 = 1;
pub const XACT_XINFO_HAS_SUBXACTS: u32 = 2;
pub const XACT_XINFO_HAS_RELFILENODES: u32 = 4;
pub const XACT_XINFO_HAS_INVALS: u32 = 8;
pub const XACT_XINFO_HAS_TWOPHASE: u32 = 16;
pub const XACT_XINFO_HAS_ORIGIN: u32 = 32;
pub const XACT_XINFO_HAS_AE_LOCKS: u32 = 64;
pub const XACT_XINFO_HAS_GID: u32 = 128;
pub const XACT_COMPLETION_APPLY_FEEDBACK: u32 = 536870912;
pub const XACT_COMPLETION_UPDATE_RELCACHE_FILE: u32 = 1073741824;
pub const XACT_COMPLETION_FORCE_SYNC_COMMIT: u32 = 2147483648;
pub const PERFORM_DELETION_INTERNAL: u32 = 1;
pub const PERFORM_DELETION_CONCURRENTLY: u32 = 2;
pub const PERFORM_DELETION_QUIETLY: u32 = 4;
pub const PERFORM_DELETION_SKIP_ORIGINAL: u32 = 8;
pub const PERFORM_DELETION_SKIP_EXTENSIONS: u32 = 16;
pub const PERFORM_DELETION_CONCURRENT_LOCK: u32 = 32;
pub const DEFAULT_INDEX_TYPE: &[u8; 6usize] = b"btree\0";
pub const INDEX_CREATE_IS_PRIMARY: u32 = 1;
pub const INDEX_CREATE_ADD_CONSTRAINT: u32 = 2;
pub const INDEX_CREATE_SKIP_BUILD: u32 = 4;
pub const INDEX_CREATE_CONCURRENT: u32 = 8;
pub const INDEX_CREATE_IF_NOT_EXISTS: u32 = 16;
pub const INDEX_CREATE_PARTITIONED: u32 = 32;
pub const INDEX_CREATE_INVALID: u32 = 64;
pub const INDEX_CONSTR_CREATE_MARK_AS_PRIMARY: u32 = 1;
pub const INDEX_CONSTR_CREATE_DEFERRABLE: u32 = 2;
pub const INDEX_CONSTR_CREATE_INIT_DEFERRED: u32 = 4;
pub const INDEX_CONSTR_CREATE_UPDATE_INDEX: u32 = 8;
pub const INDEX_CONSTR_CREATE_REMOVE_OLD_DEPS: u32 = 16;
pub const REINDEX_REL_PROCESS_TOAST: u32 = 1;
pub const REINDEX_REL_SUPPRESS_INDEX_USE: u32 = 2;
pub const REINDEX_REL_CHECK_CONSTRAINTS: u32 = 4;
pub const REINDEX_REL_FORCE_INDEXES_UNLOGGED: u32 = 8;
pub const REINDEX_REL_FORCE_INDEXES_PERMANENT: u32 = 16;
pub const AuthIdRelationId: u32 = 1260;
pub const AuthIdRelation_Rowtype_Id: u32 = 2842;
pub const Anum_pg_authid_oid: u32 = 1;
pub const Anum_pg_authid_rolname: u32 = 2;
pub const Anum_pg_authid_rolsuper: u32 = 3;
pub const Anum_pg_authid_rolinherit: u32 = 4;
pub const Anum_pg_authid_rolcreaterole: u32 = 5;
pub const Anum_pg_authid_rolcreatedb: u32 = 6;
pub const Anum_pg_authid_rolcanlogin: u32 = 7;
pub const Anum_pg_authid_rolreplication: u32 = 8;
pub const Anum_pg_authid_rolbypassrls: u32 = 9;
pub const Anum_pg_authid_rolconnlimit: u32 = 10;
pub const Anum_pg_authid_rolpassword: u32 = 11;
pub const Anum_pg_authid_rolvaliduntil: u32 = 12;
pub const Natts_pg_authid: u32 = 12;
pub const BOOTSTRAP_SUPERUSERID: u32 = 10;
pub const DEFAULT_ROLE_MONITOR: u32 = 3373;
pub const DEFAULT_ROLE_READ_ALL_SETTINGS: u32 = 3374;
pub const DEFAULT_ROLE_READ_ALL_STATS: u32 = 3375;
pub const DEFAULT_ROLE_STAT_SCAN_TABLES: u32 = 3377;
pub const DEFAULT_ROLE_READ_SERVER_FILES: u32 = 4569;
pub const DEFAULT_ROLE_WRITE_SERVER_FILES: u32 = 4570;
pub const DEFAULT_ROLE_EXECUTE_SERVER_PROGRAM: u32 = 4571;
pub const DEFAULT_ROLE_SIGNAL_BACKENDID: u32 = 4200;
pub const DatabaseRelationId: u32 = 1262;
pub const DatabaseRelation_Rowtype_Id: u32 = 1248;
pub const Anum_pg_database_oid: u32 = 1;
pub const Anum_pg_database_datname: u32 = 2;
pub const Anum_pg_database_datdba: u32 = 3;
pub const Anum_pg_database_encoding: u32 = 4;
pub const Anum_pg_database_datcollate: u32 = 5;
pub const Anum_pg_database_datctype: u32 = 6;
pub const Anum_pg_database_datistemplate: u32 = 7;
pub const Anum_pg_database_datallowconn: u32 = 8;
pub const Anum_pg_database_datconnlimit: u32 = 9;
pub const Anum_pg_database_datlastsysoid: u32 = 10;
pub const Anum_pg_database_datfrozenxid: u32 = 11;
pub const Anum_pg_database_datminmxid: u32 = 12;
pub const Anum_pg_database_dattablespace: u32 = 13;
pub const Anum_pg_database_datacl: u32 = 14;
pub const Natts_pg_database: u32 = 14;
pub const TemplateDbOid: u32 = 1;
pub const EnumRelationId: u32 = 3501;
pub const Anum_pg_enum_oid: u32 = 1;
pub const Anum_pg_enum_enumtypid: u32 = 2;
pub const Anum_pg_enum_enumsortorder: u32 = 3;
pub const Anum_pg_enum_enumlabel: u32 = 4;
pub const Natts_pg_enum: u32 = 4;
pub const OperatorRelationId: u32 = 2617;
pub const Anum_pg_operator_oid: u32 = 1;
pub const Anum_pg_operator_oprname: u32 = 2;
pub const Anum_pg_operator_oprnamespace: u32 = 3;
pub const Anum_pg_operator_oprowner: u32 = 4;
pub const Anum_pg_operator_oprkind: u32 = 5;
pub const Anum_pg_operator_oprcanmerge: u32 = 6;
pub const Anum_pg_operator_oprcanhash: u32 = 7;
pub const Anum_pg_operator_oprleft: u32 = 8;
pub const Anum_pg_operator_oprright: u32 = 9;
pub const Anum_pg_operator_oprresult: u32 = 10;
pub const Anum_pg_operator_oprcom: u32 = 11;
pub const Anum_pg_operator_oprnegate: u32 = 12;
pub const Anum_pg_operator_oprcode: u32 = 13;
pub const Anum_pg_operator_oprrest: u32 = 14;
pub const Anum_pg_operator_oprjoin: u32 = 15;
pub const Natts_pg_operator: u32 = 15;
pub const BooleanNotEqualOperator: u32 = 85;
pub const BooleanEqualOperator: u32 = 91;
pub const Int4EqualOperator: u32 = 96;
pub const Int4LessOperator: u32 = 97;
pub const TextEqualOperator: u32 = 98;
pub const NameEqualTextOperator: u32 = 254;
pub const NameLessTextOperator: u32 = 255;
pub const NameGreaterEqualTextOperator: u32 = 257;
pub const TIDEqualOperator: u32 = 387;
pub const TIDLessOperator: u32 = 2799;
pub const Int8LessOperator: u32 = 412;
pub const OID_NAME_REGEXEQ_OP: u32 = 639;
pub const OID_TEXT_REGEXEQ_OP: u32 = 641;
pub const TextLessOperator: u32 = 664;
pub const TextGreaterEqualOperator: u32 = 667;
pub const Float8LessOperator: u32 = 672;
pub const BpcharEqualOperator: u32 = 1054;
pub const OID_BPCHAR_REGEXEQ_OP: u32 = 1055;
pub const BpcharLessOperator: u32 = 1058;
pub const BpcharGreaterEqualOperator: u32 = 1061;
pub const ARRAY_EQ_OP: u32 = 1070;
pub const ARRAY_LT_OP: u32 = 1072;
pub const ARRAY_GT_OP: u32 = 1073;
pub const OID_NAME_LIKE_OP: u32 = 1207;
pub const OID_TEXT_LIKE_OP: u32 = 1209;
pub const OID_BPCHAR_LIKE_OP: u32 = 1211;
pub const OID_NAME_ICREGEXEQ_OP: u32 = 1226;
pub const OID_TEXT_ICREGEXEQ_OP: u32 = 1228;
pub const OID_BPCHAR_ICREGEXEQ_OP: u32 = 1234;
pub const OID_INET_SUB_OP: u32 = 931;
pub const OID_INET_SUBEQ_OP: u32 = 932;
pub const OID_INET_SUP_OP: u32 = 933;
pub const OID_INET_SUPEQ_OP: u32 = 934;
pub const OID_INET_OVERLAP_OP: u32 = 3552;
pub const OID_NAME_ICLIKE_OP: u32 = 1625;
pub const OID_TEXT_ICLIKE_OP: u32 = 1627;
pub const OID_BPCHAR_ICLIKE_OP: u32 = 1629;
pub const ByteaEqualOperator: u32 = 1955;
pub const ByteaLessOperator: u32 = 1957;
pub const ByteaGreaterEqualOperator: u32 = 1960;
pub const OID_BYTEA_LIKE_OP: u32 = 2016;
pub const TextPatternLessOperator: u32 = 2314;
pub const TextPatternGreaterEqualOperator: u32 = 2317;
pub const BpcharPatternLessOperator: u32 = 2326;
pub const BpcharPatternGreaterEqualOperator: u32 = 2329;
pub const OID_ARRAY_OVERLAP_OP: u32 = 2750;
pub const OID_ARRAY_CONTAINS_OP: u32 = 2751;
pub const OID_ARRAY_CONTAINED_OP: u32 = 2752;
pub const RECORD_EQ_OP: u32 = 2988;
pub const RECORD_LT_OP: u32 = 2990;
pub const RECORD_GT_OP: u32 = 2991;
pub const OID_RANGE_LESS_OP: u32 = 3884;
pub const OID_RANGE_LESS_EQUAL_OP: u32 = 3885;
pub const OID_RANGE_GREATER_EQUAL_OP: u32 = 3886;
pub const OID_RANGE_GREATER_OP: u32 = 3887;
pub const OID_RANGE_OVERLAP_OP: u32 = 3888;
pub const OID_RANGE_CONTAINS_ELEM_OP: u32 = 3889;
pub const OID_RANGE_CONTAINS_OP: u32 = 3890;
pub const OID_RANGE_ELEM_CONTAINED_OP: u32 = 3891;
pub const OID_RANGE_CONTAINED_OP: u32 = 3892;
pub const OID_RANGE_LEFT_OP: u32 = 3893;
pub const OID_RANGE_RIGHT_OP: u32 = 3894;
pub const OID_RANGE_OVERLAPS_LEFT_OP: u32 = 3895;
pub const OID_RANGE_OVERLAPS_RIGHT_OP: u32 = 3896;
pub const ProcedureRelationId: u32 = 1255;
pub const ProcedureRelation_Rowtype_Id: u32 = 81;
pub const Anum_pg_proc_oid: u32 = 1;
pub const Anum_pg_proc_proname: u32 = 2;
pub const Anum_pg_proc_pronamespace: u32 = 3;
pub const Anum_pg_proc_proowner: u32 = 4;
pub const Anum_pg_proc_prolang: u32 = 5;
pub const Anum_pg_proc_procost: u32 = 6;
pub const Anum_pg_proc_prorows: u32 = 7;
pub const Anum_pg_proc_provariadic: u32 = 8;
pub const Anum_pg_proc_prosupport: u32 = 9;
pub const Anum_pg_proc_prokind: u32 = 10;
pub const Anum_pg_proc_prosecdef: u32 = 11;
pub const Anum_pg_proc_proleakproof: u32 = 12;
pub const Anum_pg_proc_proisstrict: u32 = 13;
pub const Anum_pg_proc_proretset: u32 = 14;
pub const Anum_pg_proc_provolatile: u32 = 15;
pub const Anum_pg_proc_proparallel: u32 = 16;
pub const Anum_pg_proc_pronargs: u32 = 17;
pub const Anum_pg_proc_pronargdefaults: u32 = 18;
pub const Anum_pg_proc_prorettype: u32 = 19;
pub const Anum_pg_proc_proargtypes: u32 = 20;
pub const Anum_pg_proc_proallargtypes: u32 = 21;
pub const Anum_pg_proc_proargmodes: u32 = 22;
pub const Anum_pg_proc_proargnames: u32 = 23;
pub const Anum_pg_proc_proargdefaults: u32 = 24;
pub const Anum_pg_proc_protrftypes: u32 = 25;
pub const Anum_pg_proc_prosrc: u32 = 26;
pub const Anum_pg_proc_probin: u32 = 27;
pub const Anum_pg_proc_proconfig: u32 = 28;
pub const Anum_pg_proc_proacl: u32 = 29;
pub const Natts_pg_proc: u32 = 29;
pub const PROKIND_FUNCTION: u8 = 102u8;
pub const PROKIND_AGGREGATE: u8 = 97u8;
pub const PROKIND_WINDOW: u8 = 119u8;
pub const PROKIND_PROCEDURE: u8 = 112u8;
pub const PROVOLATILE_IMMUTABLE: u8 = 105u8;
pub const PROVOLATILE_STABLE: u8 = 115u8;
pub const PROVOLATILE_VOLATILE: u8 = 118u8;
pub const PROPARALLEL_SAFE: u8 = 115u8;
pub const PROPARALLEL_RESTRICTED: u8 = 114u8;
pub const PROPARALLEL_UNSAFE: u8 = 117u8;
pub const PROARGMODE_IN: u8 = 105u8;
pub const PROARGMODE_OUT: u8 = 111u8;
pub const PROARGMODE_INOUT: u8 = 98u8;
pub const PROARGMODE_VARIADIC: u8 = 118u8;
pub const PROARGMODE_TABLE: u8 = 116u8;
pub const HEAP_TABLE_AM_HANDLER_OID: u32 = 3;
pub const TriggerRelationId: u32 = 2620;
pub const Anum_pg_trigger_oid: u32 = 1;
pub const Anum_pg_trigger_tgrelid: u32 = 2;
pub const Anum_pg_trigger_tgparentid: u32 = 3;
pub const Anum_pg_trigger_tgname: u32 = 4;
pub const Anum_pg_trigger_tgfoid: u32 = 5;
pub const Anum_pg_trigger_tgtype: u32 = 6;
pub const Anum_pg_trigger_tgenabled: u32 = 7;
pub const Anum_pg_trigger_tgisinternal: u32 = 8;
pub const Anum_pg_trigger_tgconstrrelid: u32 = 9;
pub const Anum_pg_trigger_tgconstrindid: u32 = 10;
pub const Anum_pg_trigger_tgconstraint: u32 = 11;
pub const Anum_pg_trigger_tgdeferrable: u32 = 12;
pub const Anum_pg_trigger_tginitdeferred: u32 = 13;
pub const Anum_pg_trigger_tgnargs: u32 = 14;
pub const Anum_pg_trigger_tgattr: u32 = 15;
pub const Anum_pg_trigger_tgargs: u32 = 16;
pub const Anum_pg_trigger_tgqual: u32 = 17;
pub const Anum_pg_trigger_tgoldtable: u32 = 18;
pub const Anum_pg_trigger_tgnewtable: u32 = 19;
pub const Natts_pg_trigger: u32 = 19;
pub const TRIGGER_TYPE_ROW: u32 = 1;
pub const TRIGGER_TYPE_BEFORE: u32 = 2;
pub const TRIGGER_TYPE_INSERT: u32 = 4;
pub const TRIGGER_TYPE_DELETE: u32 = 8;
pub const TRIGGER_TYPE_UPDATE: u32 = 16;
pub const TRIGGER_TYPE_TRUNCATE: u32 = 32;
pub const TRIGGER_TYPE_INSTEAD: u32 = 64;
pub const TRIGGER_TYPE_LEVEL_MASK: u32 = 1;
pub const TRIGGER_TYPE_STATEMENT: u32 = 0;
pub const TRIGGER_TYPE_TIMING_MASK: u32 = 66;
pub const TRIGGER_TYPE_AFTER: u32 = 0;
pub const TRIGGER_TYPE_EVENT_MASK: u32 = 60;
pub const EventTriggerRelationId: u32 = 3466;
pub const Anum_pg_event_trigger_oid: u32 = 1;
pub const Anum_pg_event_trigger_evtname: u32 = 2;
pub const Anum_pg_event_trigger_evtevent: u32 = 3;
pub const Anum_pg_event_trigger_evtowner: u32 = 4;
pub const Anum_pg_event_trigger_evtfoid: u32 = 5;
pub const Anum_pg_event_trigger_evtenabled: u32 = 6;
pub const Anum_pg_event_trigger_evttags: u32 = 7;
pub const Natts_pg_event_trigger: u32 = 7;
pub const AT_REWRITE_ALTER_PERSISTENCE: u32 = 1;
pub const AT_REWRITE_DEFAULT_VAL: u32 = 2;
pub const AT_REWRITE_COLUMN_REWRITE: u32 = 4;
pub const TRIGGER_EVENT_INSERT: u32 = 0;
pub const TRIGGER_EVENT_DELETE: u32 = 1;
pub const TRIGGER_EVENT_UPDATE: u32 = 2;
pub const TRIGGER_EVENT_TRUNCATE: u32 = 3;
pub const TRIGGER_EVENT_OPMASK: u32 = 3;
pub const TRIGGER_EVENT_ROW: u32 = 4;
pub const TRIGGER_EVENT_BEFORE: u32 = 8;
pub const TRIGGER_EVENT_AFTER: u32 = 0;
pub const TRIGGER_EVENT_INSTEAD: u32 = 16;
pub const TRIGGER_EVENT_TIMINGMASK: u32 = 24;
pub const AFTER_TRIGGER_DEFERRABLE: u32 = 32;
pub const AFTER_TRIGGER_INITDEFERRED: u32 = 64;
pub const SESSION_REPLICATION_ROLE_ORIGIN: u32 = 0;
pub const SESSION_REPLICATION_ROLE_REPLICA: u32 = 1;
pub const SESSION_REPLICATION_ROLE_LOCAL: u32 = 2;
pub const TRIGGER_FIRES_ON_ORIGIN: u8 = 79u8;
pub const TRIGGER_FIRES_ALWAYS: u8 = 65u8;
pub const TRIGGER_FIRES_ON_REPLICA: u8 = 82u8;
pub const TRIGGER_DISABLED: u8 = 68u8;
pub const RI_TRIGGER_PK: u32 = 1;
pub const RI_TRIGGER_FK: u32 = 2;
pub const RI_TRIGGER_NONE: u32 = 0;
pub const StatisticRelationId: u32 = 2619;
pub const Anum_pg_statistic_starelid: u32 = 1;
pub const Anum_pg_statistic_staattnum: u32 = 2;
pub const Anum_pg_statistic_stainherit: u32 = 3;
pub const Anum_pg_statistic_stanullfrac: u32 = 4;
pub const Anum_pg_statistic_stawidth: u32 = 5;
pub const Anum_pg_statistic_stadistinct: u32 = 6;
pub const Anum_pg_statistic_stakind1: u32 = 7;
pub const Anum_pg_statistic_stakind2: u32 = 8;
pub const Anum_pg_statistic_stakind3: u32 = 9;
pub const Anum_pg_statistic_stakind4: u32 = 10;
pub const Anum_pg_statistic_stakind5: u32 = 11;
pub const Anum_pg_statistic_staop1: u32 = 12;
pub const Anum_pg_statistic_staop2: u32 = 13;
pub const Anum_pg_statistic_staop3: u32 = 14;
pub const Anum_pg_statistic_staop4: u32 = 15;
pub const Anum_pg_statistic_staop5: u32 = 16;
pub const Anum_pg_statistic_stacoll1: u32 = 17;
pub const Anum_pg_statistic_stacoll2: u32 = 18;
pub const Anum_pg_statistic_stacoll3: u32 = 19;
pub const Anum_pg_statistic_stacoll4: u32 = 20;
pub const Anum_pg_statistic_stacoll5: u32 = 21;
pub const Anum_pg_statistic_stanumbers1: u32 = 22;
pub const Anum_pg_statistic_stanumbers2: u32 = 23;
pub const Anum_pg_statistic_stanumbers3: u32 = 24;
pub const Anum_pg_statistic_stanumbers4: u32 = 25;
pub const Anum_pg_statistic_stanumbers5: u32 = 26;
pub const Anum_pg_statistic_stavalues1: u32 = 27;
pub const Anum_pg_statistic_stavalues2: u32 = 28;
pub const Anum_pg_statistic_stavalues3: u32 = 29;
pub const Anum_pg_statistic_stavalues4: u32 = 30;
pub const Anum_pg_statistic_stavalues5: u32 = 31;
pub const Natts_pg_statistic: u32 = 31;
pub const STATISTIC_KIND_MCV: u32 = 1;
pub const STATISTIC_KIND_HISTOGRAM: u32 = 2;
pub const STATISTIC_KIND_CORRELATION: u32 = 3;
pub const STATISTIC_KIND_MCELEM: u32 = 4;
pub const STATISTIC_KIND_DECHIST: u32 = 5;
pub const STATISTIC_KIND_RANGE_LENGTH_HISTOGRAM: u32 = 6;
pub const STATISTIC_KIND_BOUNDS_HISTOGRAM: u32 = 7;
pub const STATISTIC_NUM_SLOTS: u32 = 5;
pub const VACUUM_OPTION_NO_PARALLEL: u32 = 0;
pub const VACUUM_OPTION_PARALLEL_BULKDEL: u32 = 1;
pub const VACUUM_OPTION_PARALLEL_COND_CLEANUP: u32 = 2;
pub const VACUUM_OPTION_PARALLEL_CLEANUP: u32 = 4;
pub const VACUUM_OPTION_MAX_VALID_VALUE: u32 = 7;
pub const CACHEDPLANSOURCE_MAGIC: u32 = 195726186;
pub const CACHEDPLAN_MAGIC: u32 = 953717834;
pub const CACHEDEXPR_MAGIC: u32 = 838275847;
pub const SPI_ERROR_CONNECT: i32 = -1;
pub const SPI_ERROR_COPY: i32 = -2;
pub const SPI_ERROR_OPUNKNOWN: i32 = -3;
pub const SPI_ERROR_UNCONNECTED: i32 = -4;
pub const SPI_ERROR_CURSOR: i32 = -5;
pub const SPI_ERROR_ARGUMENT: i32 = -6;
pub const SPI_ERROR_PARAM: i32 = -7;
pub const SPI_ERROR_TRANSACTION: i32 = -8;
pub const SPI_ERROR_NOATTRIBUTE: i32 = -9;
pub const SPI_ERROR_NOOUTFUNC: i32 = -10;
pub const SPI_ERROR_TYPUNKNOWN: i32 = -11;
pub const SPI_ERROR_REL_DUPLICATE: i32 = -12;
pub const SPI_ERROR_REL_NOT_FOUND: i32 = -13;
pub const SPI_OK_CONNECT: u32 = 1;
pub const SPI_OK_FINISH: u32 = 2;
pub const SPI_OK_FETCH: u32 = 3;
pub const SPI_OK_UTILITY: u32 = 4;
pub const SPI_OK_SELECT: u32 = 5;
pub const SPI_OK_SELINTO: u32 = 6;
pub const SPI_OK_INSERT: u32 = 7;
pub const SPI_OK_DELETE: u32 = 8;
pub const SPI_OK_UPDATE: u32 = 9;
pub const SPI_OK_CURSOR: u32 = 10;
pub const SPI_OK_INSERT_RETURNING: u32 = 11;
pub const SPI_OK_DELETE_RETURNING: u32 = 12;
pub const SPI_OK_UPDATE_RETURNING: u32 = 13;
pub const SPI_OK_REWRITTEN: u32 = 14;
pub const SPI_OK_REL_REGISTER: u32 = 15;
pub const SPI_OK_REL_UNREGISTER: u32 = 16;
pub const SPI_OK_TD_REGISTER: u32 = 17;
pub const SPI_OPT_NONATOMIC: u32 = 1;
pub const BGWORKER_SHMEM_ACCESS: u32 = 1;
pub const BGWORKER_BACKEND_DATABASE_CONNECTION: u32 = 2;
pub const BGWORKER_CLASS_PARALLEL: u32 = 16;
pub const BGW_DEFAULT_RESTART_INTERVAL: u32 = 60;
pub const BGW_NEVER_RESTART: i32 = -1;
pub const BGW_MAXLEN: u32 = 96;
pub const BGW_EXTRALEN: u32 = 128;
pub const BGWORKER_BYPASS_ALLOWCONN: u32 = 1;
pub const HAVE_PLANNERINFO_TYPEDEF: u32 = 1;
pub const HAVE_INDEXOPTINFO_TYPEDEF: u32 = 1;
pub const HAVE_SPECIALJOININFO_TYPEDEF: u32 = 1;
pub const GROUPING_CAN_USE_SORT: u32 = 1;
pub const GROUPING_CAN_USE_HASH: u32 = 2;
pub const GROUPING_CAN_PARTIAL_AGG: u32 = 4;
pub const FSV_MISSING_OK: u32 = 1;
pub const FDW_MISSING_OK: u32 = 1;
pub const MAX_MULTIBYTE_CHAR_LEN: u32 = 4;
pub const SS2: u32 = 142;
pub const SS3: u32 = 143;
pub const LC_ISO8859_1: u32 = 129;
pub const LC_ISO8859_2: u32 = 130;
pub const LC_ISO8859_3: u32 = 131;
pub const LC_ISO8859_4: u32 = 132;
pub const LC_TIS620: u32 = 133;
pub const LC_ISO8859_7: u32 = 134;
pub const LC_ISO8859_6: u32 = 135;
pub const LC_ISO8859_8: u32 = 136;
pub const LC_JISX0201K: u32 = 137;
pub const LC_JISX0201R: u32 = 138;
pub const LC_KOI8_R: u32 = 139;
pub const LC_ISO8859_5: u32 = 140;
pub const LC_ISO8859_9: u32 = 141;
pub const LC_ISO8859_15: u32 = 142;
pub const LC_JISX0208_1978: u32 = 144;
pub const LC_GB2312_80: u32 = 145;
pub const LC_JISX0208: u32 = 146;
pub const LC_KS5601: u32 = 147;
pub const LC_JISX0212: u32 = 148;
pub const LC_CNS11643_1: u32 = 149;
pub const LC_CNS11643_2: u32 = 150;
pub const LC_JISX0213_1: u32 = 151;
pub const LC_BIG5_1: u32 = 152;
pub const LC_BIG5_2: u32 = 153;
pub const LCPRV1_A: u32 = 154;
pub const LCPRV1_B: u32 = 155;
pub const LCPRV2_A: u32 = 156;
pub const LCPRV2_B: u32 = 157;
pub const LC_SISHENG: u32 = 160;
pub const LC_IPA: u32 = 161;
pub const LC_VISCII_LOWER: u32 = 162;
pub const LC_VISCII_UPPER: u32 = 163;
pub const LC_ARABIC_DIGIT: u32 = 164;
pub const LC_ARABIC_1_COLUMN: u32 = 165;
pub const LC_ASCII_RIGHT_TO_LEFT: u32 = 166;
pub const LC_LAO: u32 = 167;
pub const LC_ARABIC_2_COLUMN: u32 = 168;
pub const LC_INDIAN_1_COLUMN: u32 = 240;
pub const LC_TIBETAN_1_COLUMN: u32 = 241;
pub const LC_UNICODE_SUBSET_2: u32 = 242;
pub const LC_UNICODE_SUBSET_3: u32 = 243;
pub const LC_UNICODE_SUBSET: u32 = 244;
pub const LC_ETHIOPIC: u32 = 245;
pub const LC_CNS11643_3: u32 = 246;
pub const LC_CNS11643_4: u32 = 247;
pub const LC_CNS11643_5: u32 = 248;
pub const LC_CNS11643_6: u32 = 249;
pub const LC_CNS11643_7: u32 = 250;
pub const LC_INDIAN_2_COLUMN: u32 = 251;
pub const LC_TIBETAN: u32 = 252;
pub const MAX_CONVERSION_GROWTH: u32 = 4;
pub const MAX_UNICODE_EQUIVALENT_STRING: u32 = 16;
pub const EXTNODENAME_MAX_LEN: u32 = 64;
pub const CUSTOMPATH_SUPPORT_BACKWARD_SCAN: u32 = 1;
pub const CUSTOMPATH_SUPPORT_MARK_RESTORE: u32 = 2;
pub const QTW_IGNORE_RT_SUBQUERIES: u32 = 1;
pub const QTW_IGNORE_CTE_SUBQUERIES: u32 = 2;
pub const QTW_IGNORE_RC_SUBQUERIES: u32 = 3;
pub const QTW_IGNORE_JOINALIASES: u32 = 4;
pub const QTW_IGNORE_RANGE_TABLE: u32 = 8;
pub const QTW_EXAMINE_RTES_BEFORE: u32 = 16;
pub const QTW_EXAMINE_RTES_AFTER: u32 = 32;
pub const QTW_DONT_COPY_QUERY: u32 = 64;
pub const QTW_EXAMINE_SORTGROUP: u32 = 128;
pub const DEFAULT_SEQ_PAGE_COST: f64 = 1.0;
pub const DEFAULT_RANDOM_PAGE_COST: f64 = 4.0;
pub const DEFAULT_CPU_TUPLE_COST: f64 = 0.01;
pub const DEFAULT_CPU_INDEX_TUPLE_COST: f64 = 0.005;
pub const DEFAULT_CPU_OPERATOR_COST: f64 = 0.0025;
pub const DEFAULT_PARALLEL_TUPLE_COST: f64 = 0.1;
pub const DEFAULT_PARALLEL_SETUP_COST: f64 = 1000.0;
pub const DEFAULT_EFFECTIVE_CACHE_SIZE: u32 = 524288;
pub const PVC_INCLUDE_AGGREGATES: u32 = 1;
pub const PVC_RECURSE_AGGREGATES: u32 = 2;
pub const PVC_INCLUDE_WINDOWFUNCS: u32 = 4;
pub const PVC_RECURSE_WINDOWFUNCS: u32 = 8;
pub const PVC_INCLUDE_PLACEHOLDERS: u32 = 16;
pub const PVC_RECURSE_PLACEHOLDERS: u32 = 32;
pub const DEFAULT_CURSOR_TUPLE_FRACTION: f64 = 0.1;
pub const RBTXN_HAS_CATALOG_CHANGES: u32 = 1;
pub const RBTXN_IS_SUBXACT: u32 = 2;
pub const RBTXN_IS_SERIALIZED: u32 = 4;
pub const OLD_SNAPSHOT_PADDING_ENTRIES: u32 = 10;
pub const MAX_IO_CONCURRENCY: u32 = 1000;
pub const BUFFER_LOCK_UNLOCK: u32 = 0;
pub const BUFFER_LOCK_SHARE: u32 = 1;
pub const BUFFER_LOCK_EXCLUSIVE: u32 = 2;
pub const XLOG_STANDBY_LOCK: u32 = 0;
pub const XLOG_RUNNING_XACTS: u32 = 16;
pub const XLOG_INVALIDATIONS: u32 = 32;
pub const PROCARRAY_VACUUM_FLAG: u32 = 2;
pub const PROCARRAY_ANALYZE_FLAG: u32 = 4;
pub const PROCARRAY_LOGICAL_DECODING_FLAG: u32 = 16;
pub const PROCARRAY_SLOTS_XMIN: u32 = 32;
pub const PROCARRAY_PROC_FLAGS_MASK: u32 = 22;
pub const PROCARRAY_FLAGS_DEFAULT: u32 = 16;
pub const PROCARRAY_FLAGS_VACUUM: u32 = 18;
pub const PROCARRAY_FLAGS_ANALYZE: u32 = 20;
pub const PROCARRAY_FLAGS_VACUUM_ANALYZE: u32 = 22;
pub const STACK_DEPTH_SLOP: u32 = 524288;
pub const COMMAND_OK_IN_READ_ONLY_TXN: u32 = 1;
pub const COMMAND_OK_IN_PARALLEL_MODE: u32 = 2;
pub const COMMAND_OK_IN_RECOVERY: u32 = 4;
pub const COMMAND_IS_STRICTLY_READ_ONLY: u32 = 7;
pub const COMMAND_IS_NOT_READ_ONLY: u32 = 0;
pub const MAXSTRLEN: u32 = 2047;
pub const MAXSTRPOS: u32 = 1048575;
pub const MAXENTRYPOS: u32 = 16384;
pub const MAXNUMPOS: u32 = 256;
pub const QI_VAL: u32 = 1;
pub const QI_OPR: u32 = 2;
pub const QI_VALSTOP: u32 = 3;
pub const OP_NOT: u32 = 1;
pub const OP_AND: u32 = 2;
pub const OP_OR: u32 = 3;
pub const OP_PHRASE: u32 = 4;
pub const OP_COUNT: u32 = 4;
pub const TSL_ADDPOS: u32 = 1;
pub const TSL_PREFIX: u32 = 2;
pub const TSL_FILTER: u32 = 4;
pub const P_TSV_OPR_IS_DELIM: u32 = 1;
pub const P_TSV_IS_TSQUERY: u32 = 2;
pub const P_TSV_IS_WEB: u32 = 4;
pub const P_TSQ_PLAIN: u32 = 1;
pub const P_TSQ_WEB: u32 = 2;
pub const TS_EXEC_EMPTY: u32 = 0;
pub const TS_EXEC_SKIP_NOT: u32 = 1;
pub const TS_EXEC_PHRASE_NO_POS: u32 = 2;
pub const TSearchStrategyNumber: u32 = 1;
pub const TSearchWithClassStrategyNumber: u32 = 2;
pub const QTN_NEEDFREE: u32 = 1;
pub const QTN_NOCHANGE: u32 = 2;
pub const QTN_WORDFREE: u32 = 4;
pub const MAXINT8LEN: u32 = 20;
pub const FORMAT_TYPE_TYPEMOD_GIVEN: u32 = 1;
pub const FORMAT_TYPE_ALLOW_INVALID: u32 = 2;
pub const FORMAT_TYPE_FORCE_QUALIFY: u32 = 4;
pub const MAX_TIME_PRECISION: u32 = 6;
pub const RADIANS_PER_DEGREE: f64 = 0.017453292519943295;
pub const NUMERIC_MAX_PRECISION: u32 = 1000;
pub const NUMERIC_MAX_DISPLAY_SCALE: u32 = 1000;
pub const NUMERIC_MIN_DISPLAY_SCALE: u32 = 0;
pub const NUMERIC_MAX_RESULT_SCALE: u32 = 2000;
pub const NUMERIC_MIN_SIG_DIGITS: u32 = 16;
pub const JsonbContainsStrategyNumber: u32 = 7;
pub const JsonbExistsStrategyNumber: u32 = 9;
pub const JsonbExistsAnyStrategyNumber: u32 = 10;
pub const JsonbExistsAllStrategyNumber: u32 = 11;
pub const JsonbJsonpathExistsStrategyNumber: u32 = 15;
pub const JsonbJsonpathPredicateStrategyNumber: u32 = 16;
pub const JGINFLAG_KEY: u32 = 1;
pub const JGINFLAG_NULL: u32 = 2;
pub const JGINFLAG_BOOL: u32 = 3;
pub const JGINFLAG_NUM: u32 = 4;
pub const JGINFLAG_STR: u32 = 5;
pub const JGINFLAG_HASHED: u32 = 16;
pub const JGIN_MAXLENGTH: u32 = 125;
pub const JENTRY_OFFLENMASK: u32 = 268435455;
pub const JENTRY_TYPEMASK: u32 = 1879048192;
pub const JENTRY_HAS_OFF: u32 = 2147483648;
pub const JENTRY_ISSTRING: u32 = 0;
pub const JENTRY_ISNUMERIC: u32 = 268435456;
pub const JENTRY_ISBOOL_FALSE: u32 = 536870912;
pub const JENTRY_ISBOOL_TRUE: u32 = 805306368;
pub const JENTRY_ISNULL: u32 = 1073741824;
pub const JENTRY_ISCONTAINER: u32 = 1342177280;
pub const JB_OFFSET_STRIDE: u32 = 32;
pub const JB_CMASK: u32 = 268435455;
pub const JB_FSCALAR: u32 = 268435456;
pub const JB_FOBJECT: u32 = 536870912;
pub const JB_FARRAY: u32 = 1073741824;
pub const ATTSTATSSLOT_VALUES: u32 = 1;
pub const ATTSTATSSLOT_NUMBERS: u32 = 2;
pub const DEFAULT_EQ_SEL: f64 = 0.005;
pub const DEFAULT_INEQ_SEL: f64 = 0.3333333333333333;
pub const DEFAULT_RANGE_INEQ_SEL: f64 = 0.005;
pub const DEFAULT_MATCH_SEL: f64 = 0.005;
pub const DEFAULT_MATCHING_SEL: f64 = 0.01;
pub const DEFAULT_NUM_DISTINCT: u32 = 200;
pub const DEFAULT_UNK_SEL: f64 = 0.005;
pub const DEFAULT_NOT_UNK_SEL: f64 = 0.995;
pub const TYPECACHE_EQ_OPR: u32 = 1;
pub const TYPECACHE_LT_OPR: u32 = 2;
pub const TYPECACHE_GT_OPR: u32 = 4;
pub const TYPECACHE_CMP_PROC: u32 = 8;
pub const TYPECACHE_HASH_PROC: u32 = 16;
pub const TYPECACHE_EQ_OPR_FINFO: u32 = 32;
pub const TYPECACHE_CMP_PROC_FINFO: u32 = 64;
pub const TYPECACHE_HASH_PROC_FINFO: u32 = 128;
pub const TYPECACHE_TUPDESC: u32 = 256;
pub const TYPECACHE_BTREE_OPFAMILY: u32 = 512;
pub const TYPECACHE_HASH_OPFAMILY: u32 = 1024;
pub const TYPECACHE_RANGE_INFO: u32 = 2048;
pub const TYPECACHE_DOMAIN_BASE_INFO: u32 = 4096;
pub const TYPECACHE_DOMAIN_CONSTR_INFO: u32 = 8192;
pub const TYPECACHE_HASH_EXTENDED_PROC: u32 = 16384;
pub const TYPECACHE_HASH_EXTENDED_PROC_FINFO: u32 = 32768;
pub const RANGE_EMPTY: u32 = 1;
pub const RANGE_LB_INC: u32 = 2;
pub const RANGE_UB_INC: u32 = 4;
pub const RANGE_LB_INF: u32 = 8;
pub const RANGE_UB_INF: u32 = 16;
pub const RANGE_LB_NULL: u32 = 32;
pub const RANGE_UB_NULL: u32 = 64;
pub const RANGE_CONTAIN_EMPTY: u32 = 128;
pub const RANGESTRAT_BEFORE: u32 = 1;
pub const RANGESTRAT_OVERLEFT: u32 = 2;
pub const RANGESTRAT_OVERLAPS: u32 = 3;
pub const RANGESTRAT_OVERRIGHT: u32 = 4;
pub const RANGESTRAT_AFTER: u32 = 5;
pub const RANGESTRAT_ADJACENT: u32 = 6;
pub const RANGESTRAT_CONTAINS: u32 = 7;
pub const RANGESTRAT_CONTAINED_BY: u32 = 8;
pub const RANGESTRAT_CONTAINS_ELEM: u32 = 16;
pub const RANGESTRAT_EQ: u32 = 18;
pub type Oid = ::std::os::raw::c_uint;
pub type pg_int64 = ::std::os::raw::c_long;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
impl Default for __mbstate_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
impl Default for __darwin_pthread_handler_rec {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
impl Default for _opaque_pthread_attr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
impl Default for _opaque_pthread_cond_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
impl Default for _opaque_pthread_mutex_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
impl Default for _opaque_pthread_rwlock_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
impl Default for _opaque_pthread_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type va_list = __darwin_va_list;
pub unsafe fn renameat(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: *const ::std::os::raw::c_char,
    arg_arg3: ::std::os::raw::c_int,
    arg_arg4: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn renameat(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: *const ::std::os::raw::c_char,
                arg_arg3: ::std::os::raw::c_int,
                arg_arg4: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        renameat(arg_arg1, arg_arg2, arg_arg3, arg_arg4)
    })
}
pub unsafe fn renamex_np(
    arg_arg1: *const ::std::os::raw::c_char,
    arg_arg2: *const ::std::os::raw::c_char,
    arg_arg3: ::std::os::raw::c_uint,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn renamex_np(
                arg_arg1: *const ::std::os::raw::c_char,
                arg_arg2: *const ::std::os::raw::c_char,
                arg_arg3: ::std::os::raw::c_uint,
            ) -> ::std::os::raw::c_int;
        }
        renamex_np(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn renameatx_np(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: *const ::std::os::raw::c_char,
    arg_arg3: ::std::os::raw::c_int,
    arg_arg4: *const ::std::os::raw::c_char,
    arg_arg5: ::std::os::raw::c_uint,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn renameatx_np(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: *const ::std::os::raw::c_char,
                arg_arg3: ::std::os::raw::c_int,
                arg_arg4: *const ::std::os::raw::c_char,
                arg_arg5: ::std::os::raw::c_uint,
            ) -> ::std::os::raw::c_int;
        }
        renameatx_np(arg_arg1, arg_arg2, arg_arg3, arg_arg4, arg_arg5)
    })
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
impl Default for __sbuf {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
impl Default for __sFILE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FILE = __sFILE;
extern "C" {
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    pub static mut __stderrp: *mut FILE;
}
pub unsafe fn clearerr(arg_arg1: *mut FILE) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn clearerr(arg_arg1: *mut FILE);
        }
        clearerr(arg_arg1)
    })
}
pub unsafe fn fclose(arg_arg1: *mut FILE) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fclose(arg_arg1: *mut FILE) -> ::std::os::raw::c_int;
        }
        fclose(arg_arg1)
    })
}
pub unsafe fn feof(arg_arg1: *mut FILE) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn feof(arg_arg1: *mut FILE) -> ::std::os::raw::c_int;
        }
        feof(arg_arg1)
    })
}
pub unsafe fn ferror(arg_arg1: *mut FILE) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ferror(arg_arg1: *mut FILE) -> ::std::os::raw::c_int;
        }
        ferror(arg_arg1)
    })
}
pub unsafe fn fflush(arg_arg1: *mut FILE) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fflush(arg_arg1: *mut FILE) -> ::std::os::raw::c_int;
        }
        fflush(arg_arg1)
    })
}
pub unsafe fn fgetc(arg_arg1: *mut FILE) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fgetc(arg_arg1: *mut FILE) -> ::std::os::raw::c_int;
        }
        fgetc(arg_arg1)
    })
}
pub unsafe fn fgetpos(arg_arg1: *mut FILE, arg_arg2: *mut fpos_t) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fgetpos(arg_arg1: *mut FILE, arg_arg2: *mut fpos_t) -> ::std::os::raw::c_int;
        }
        fgetpos(arg_arg1, arg_arg2)
    })
}
pub unsafe fn fgets(
    arg_arg1: *mut ::std::os::raw::c_char,
    arg_arg2: ::std::os::raw::c_int,
    arg_arg3: *mut FILE,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fgets(
                arg_arg1: *mut ::std::os::raw::c_char,
                arg_arg2: ::std::os::raw::c_int,
                arg_arg3: *mut FILE,
            ) -> *mut ::std::os::raw::c_char;
        }
        fgets(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn fopen(
    arg___filename: *const ::std::os::raw::c_char,
    arg___mode: *const ::std::os::raw::c_char,
) -> *mut FILE {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fopen(
                arg___filename: *const ::std::os::raw::c_char,
                arg___mode: *const ::std::os::raw::c_char,
            ) -> *mut FILE;
        }
        fopen(arg___filename, arg___mode)
    })
}
pub unsafe fn fprintf(
    arg_arg1: *mut FILE,
    arg_arg2: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fprintf(
                arg_arg1: *mut FILE,
                arg_arg2: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        fprintf(arg_arg1, arg_arg2)
    })
}
pub unsafe fn fputc(arg_arg1: ::std::os::raw::c_int, arg_arg2: *mut FILE) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fputc(arg_arg1: ::std::os::raw::c_int, arg_arg2: *mut FILE)
                -> ::std::os::raw::c_int;
        }
        fputc(arg_arg1, arg_arg2)
    })
}
pub unsafe fn fputs(
    arg_arg1: *const ::std::os::raw::c_char,
    arg_arg2: *mut FILE,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fputs(
                arg_arg1: *const ::std::os::raw::c_char,
                arg_arg2: *mut FILE,
            ) -> ::std::os::raw::c_int;
        }
        fputs(arg_arg1, arg_arg2)
    })
}
pub unsafe fn fread(
    arg___ptr: *mut ::std::os::raw::c_void,
    arg___size: ::std::os::raw::c_ulong,
    arg___nitems: ::std::os::raw::c_ulong,
    arg___stream: *mut FILE,
) -> ::std::os::raw::c_ulong {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fread(
                arg___ptr: *mut ::std::os::raw::c_void,
                arg___size: ::std::os::raw::c_ulong,
                arg___nitems: ::std::os::raw::c_ulong,
                arg___stream: *mut FILE,
            ) -> ::std::os::raw::c_ulong;
        }
        fread(arg___ptr, arg___size, arg___nitems, arg___stream)
    })
}
pub unsafe fn freopen(
    arg_arg1: *const ::std::os::raw::c_char,
    arg_arg2: *const ::std::os::raw::c_char,
    arg_arg3: *mut FILE,
) -> *mut FILE {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn freopen(
                arg_arg1: *const ::std::os::raw::c_char,
                arg_arg2: *const ::std::os::raw::c_char,
                arg_arg3: *mut FILE,
            ) -> *mut FILE;
        }
        freopen(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn fscanf(
    arg_arg1: *mut FILE,
    arg_arg2: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fscanf(
                arg_arg1: *mut FILE,
                arg_arg2: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        fscanf(arg_arg1, arg_arg2)
    })
}
pub unsafe fn fseek(
    arg_arg1: *mut FILE,
    arg_arg2: ::std::os::raw::c_long,
    arg_arg3: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fseek(
                arg_arg1: *mut FILE,
                arg_arg2: ::std::os::raw::c_long,
                arg_arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        fseek(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn fsetpos(arg_arg1: *mut FILE, arg_arg2: *const fpos_t) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fsetpos(arg_arg1: *mut FILE, arg_arg2: *const fpos_t) -> ::std::os::raw::c_int;
        }
        fsetpos(arg_arg1, arg_arg2)
    })
}
pub unsafe fn ftell(arg_arg1: *mut FILE) -> ::std::os::raw::c_long {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ftell(arg_arg1: *mut FILE) -> ::std::os::raw::c_long;
        }
        ftell(arg_arg1)
    })
}
pub unsafe fn fwrite(
    arg___ptr: *const ::std::os::raw::c_void,
    arg___size: ::std::os::raw::c_ulong,
    arg___nitems: ::std::os::raw::c_ulong,
    arg___stream: *mut FILE,
) -> ::std::os::raw::c_ulong {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fwrite(
                arg___ptr: *const ::std::os::raw::c_void,
                arg___size: ::std::os::raw::c_ulong,
                arg___nitems: ::std::os::raw::c_ulong,
                arg___stream: *mut FILE,
            ) -> ::std::os::raw::c_ulong;
        }
        fwrite(arg___ptr, arg___size, arg___nitems, arg___stream)
    })
}
pub unsafe fn getc(arg_arg1: *mut FILE) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getc(arg_arg1: *mut FILE) -> ::std::os::raw::c_int;
        }
        getc(arg_arg1)
    })
}
pub unsafe fn getchar() -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getchar() -> ::std::os::raw::c_int;
        }
        getchar()
    })
}
pub unsafe fn gets(arg_arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gets(arg_arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
        }
        gets(arg_arg1)
    })
}
pub unsafe fn perror(arg_arg1: *const ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn perror(arg_arg1: *const ::std::os::raw::c_char);
        }
        perror(arg_arg1)
    })
}
pub unsafe fn printf(arg_arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn printf(arg_arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
        }
        printf(arg_arg1)
    })
}
pub unsafe fn putc(arg_arg1: ::std::os::raw::c_int, arg_arg2: *mut FILE) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn putc(arg_arg1: ::std::os::raw::c_int, arg_arg2: *mut FILE) -> ::std::os::raw::c_int;
        }
        putc(arg_arg1, arg_arg2)
    })
}
pub unsafe fn putchar(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn putchar(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        putchar(arg_arg1)
    })
}
pub unsafe fn puts(arg_arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn puts(arg_arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
        }
        puts(arg_arg1)
    })
}
pub unsafe fn remove(arg_arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn remove(arg_arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
        }
        remove(arg_arg1)
    })
}
pub unsafe fn rename(
    arg___old: *const ::std::os::raw::c_char,
    arg___new: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn rename(
                arg___old: *const ::std::os::raw::c_char,
                arg___new: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        rename(arg___old, arg___new)
    })
}
pub unsafe fn rewind(arg_arg1: *mut FILE) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn rewind(arg_arg1: *mut FILE);
        }
        rewind(arg_arg1)
    })
}
pub unsafe fn scanf(arg_arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn scanf(arg_arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
        }
        scanf(arg_arg1)
    })
}
pub unsafe fn setbuf(arg_arg1: *mut FILE, arg_arg2: *mut ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn setbuf(arg_arg1: *mut FILE, arg_arg2: *mut ::std::os::raw::c_char);
        }
        setbuf(arg_arg1, arg_arg2)
    })
}
pub unsafe fn setvbuf(
    arg_arg1: *mut FILE,
    arg_arg2: *mut ::std::os::raw::c_char,
    arg_arg3: ::std::os::raw::c_int,
    arg_arg4: usize,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn setvbuf(
                arg_arg1: *mut FILE,
                arg_arg2: *mut ::std::os::raw::c_char,
                arg_arg3: ::std::os::raw::c_int,
                arg_arg4: usize,
            ) -> ::std::os::raw::c_int;
        }
        setvbuf(arg_arg1, arg_arg2, arg_arg3, arg_arg4)
    })
}
pub unsafe fn sprintf(
    arg_arg1: *mut ::std::os::raw::c_char,
    arg_arg2: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sprintf(
                arg_arg1: *mut ::std::os::raw::c_char,
                arg_arg2: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        sprintf(arg_arg1, arg_arg2)
    })
}
pub unsafe fn sscanf(
    arg_arg1: *const ::std::os::raw::c_char,
    arg_arg2: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sscanf(
                arg_arg1: *const ::std::os::raw::c_char,
                arg_arg2: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        sscanf(arg_arg1, arg_arg2)
    })
}
pub unsafe fn tmpfile() -> *mut FILE {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tmpfile() -> *mut FILE;
        }
        tmpfile()
    })
}
pub unsafe fn tmpnam(arg_arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tmpnam(arg_arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
        }
        tmpnam(arg_arg1)
    })
}
pub unsafe fn ungetc(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: *mut FILE,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ungetc(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: *mut FILE,
            ) -> ::std::os::raw::c_int;
        }
        ungetc(arg_arg1, arg_arg2)
    })
}
pub unsafe fn vfprintf(
    arg_arg1: *mut FILE,
    arg_arg2: *const ::std::os::raw::c_char,
    arg_arg3: __builtin_va_list,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn vfprintf(
                arg_arg1: *mut FILE,
                arg_arg2: *const ::std::os::raw::c_char,
                arg_arg3: __builtin_va_list,
            ) -> ::std::os::raw::c_int;
        }
        vfprintf(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn vprintf(
    arg_arg1: *const ::std::os::raw::c_char,
    arg_arg2: __builtin_va_list,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn vprintf(
                arg_arg1: *const ::std::os::raw::c_char,
                arg_arg2: __builtin_va_list,
            ) -> ::std::os::raw::c_int;
        }
        vprintf(arg_arg1, arg_arg2)
    })
}
pub unsafe fn vsprintf(
    arg_arg1: *mut ::std::os::raw::c_char,
    arg_arg2: *const ::std::os::raw::c_char,
    arg_arg3: __builtin_va_list,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn vsprintf(
                arg_arg1: *mut ::std::os::raw::c_char,
                arg_arg2: *const ::std::os::raw::c_char,
                arg_arg3: __builtin_va_list,
            ) -> ::std::os::raw::c_int;
        }
        vsprintf(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn ctermid(arg_arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ctermid(arg_arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
        }
        ctermid(arg_arg1)
    })
}
pub unsafe fn fdopen(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: *const ::std::os::raw::c_char,
) -> *mut FILE {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fdopen(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: *const ::std::os::raw::c_char,
            ) -> *mut FILE;
        }
        fdopen(arg_arg1, arg_arg2)
    })
}
pub unsafe fn fileno(arg_arg1: *mut FILE) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fileno(arg_arg1: *mut FILE) -> ::std::os::raw::c_int;
        }
        fileno(arg_arg1)
    })
}
pub unsafe fn pclose(arg_arg1: *mut FILE) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pclose(arg_arg1: *mut FILE) -> ::std::os::raw::c_int;
        }
        pclose(arg_arg1)
    })
}
pub unsafe fn popen(
    arg_arg1: *const ::std::os::raw::c_char,
    arg_arg2: *const ::std::os::raw::c_char,
) -> *mut FILE {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn popen(
                arg_arg1: *const ::std::os::raw::c_char,
                arg_arg2: *const ::std::os::raw::c_char,
            ) -> *mut FILE;
        }
        popen(arg_arg1, arg_arg2)
    })
}
pub unsafe fn __srget(arg_arg1: *mut FILE) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn __srget(arg_arg1: *mut FILE) -> ::std::os::raw::c_int;
        }
        __srget(arg_arg1)
    })
}
pub unsafe fn __svfscanf(
    arg_arg1: *mut FILE,
    arg_arg2: *const ::std::os::raw::c_char,
    arg_arg3: va_list,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn __svfscanf(
                arg_arg1: *mut FILE,
                arg_arg2: *const ::std::os::raw::c_char,
                arg_arg3: va_list,
            ) -> ::std::os::raw::c_int;
        }
        __svfscanf(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn __swbuf(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: *mut FILE,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn __swbuf(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: *mut FILE,
            ) -> ::std::os::raw::c_int;
        }
        __swbuf(arg_arg1, arg_arg2)
    })
}
pub unsafe fn flockfile(arg_arg1: *mut FILE) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn flockfile(arg_arg1: *mut FILE);
        }
        flockfile(arg_arg1)
    })
}
pub unsafe fn ftrylockfile(arg_arg1: *mut FILE) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ftrylockfile(arg_arg1: *mut FILE) -> ::std::os::raw::c_int;
        }
        ftrylockfile(arg_arg1)
    })
}
pub unsafe fn funlockfile(arg_arg1: *mut FILE) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn funlockfile(arg_arg1: *mut FILE);
        }
        funlockfile(arg_arg1)
    })
}
pub unsafe fn getc_unlocked(arg_arg1: *mut FILE) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getc_unlocked(arg_arg1: *mut FILE) -> ::std::os::raw::c_int;
        }
        getc_unlocked(arg_arg1)
    })
}
pub unsafe fn getchar_unlocked() -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getchar_unlocked() -> ::std::os::raw::c_int;
        }
        getchar_unlocked()
    })
}
pub unsafe fn putc_unlocked(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: *mut FILE,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn putc_unlocked(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: *mut FILE,
            ) -> ::std::os::raw::c_int;
        }
        putc_unlocked(arg_arg1, arg_arg2)
    })
}
pub unsafe fn putchar_unlocked(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn putchar_unlocked(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        putchar_unlocked(arg_arg1)
    })
}
pub unsafe fn getw(arg_arg1: *mut FILE) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getw(arg_arg1: *mut FILE) -> ::std::os::raw::c_int;
        }
        getw(arg_arg1)
    })
}
pub unsafe fn putw(arg_arg1: ::std::os::raw::c_int, arg_arg2: *mut FILE) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn putw(arg_arg1: ::std::os::raw::c_int, arg_arg2: *mut FILE) -> ::std::os::raw::c_int;
        }
        putw(arg_arg1, arg_arg2)
    })
}
pub unsafe fn tempnam(
    arg___dir: *const ::std::os::raw::c_char,
    arg___prefix: *const ::std::os::raw::c_char,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tempnam(
                arg___dir: *const ::std::os::raw::c_char,
                arg___prefix: *const ::std::os::raw::c_char,
            ) -> *mut ::std::os::raw::c_char;
        }
        tempnam(arg___dir, arg___prefix)
    })
}
pub type off_t = __darwin_off_t;
pub unsafe fn fseeko(
    arg___stream: *mut FILE,
    arg___offset: off_t,
    arg___whence: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fseeko(
                arg___stream: *mut FILE,
                arg___offset: off_t,
                arg___whence: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        fseeko(arg___stream, arg___offset, arg___whence)
    })
}
pub unsafe fn ftello(arg___stream: *mut FILE) -> off_t {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ftello(arg___stream: *mut FILE) -> off_t;
        }
        ftello(arg___stream)
    })
}
pub unsafe fn snprintf(
    arg___str: *mut ::std::os::raw::c_char,
    arg___size: ::std::os::raw::c_ulong,
    arg___format: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn snprintf(
                arg___str: *mut ::std::os::raw::c_char,
                arg___size: ::std::os::raw::c_ulong,
                arg___format: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        snprintf(arg___str, arg___size, arg___format)
    })
}
pub unsafe fn vfscanf(
    arg___stream: *mut FILE,
    arg___format: *const ::std::os::raw::c_char,
    arg_arg1: __builtin_va_list,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn vfscanf(
                arg___stream: *mut FILE,
                arg___format: *const ::std::os::raw::c_char,
                arg_arg1: __builtin_va_list,
            ) -> ::std::os::raw::c_int;
        }
        vfscanf(arg___stream, arg___format, arg_arg1)
    })
}
pub unsafe fn vscanf(
    arg___format: *const ::std::os::raw::c_char,
    arg_arg1: __builtin_va_list,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn vscanf(
                arg___format: *const ::std::os::raw::c_char,
                arg_arg1: __builtin_va_list,
            ) -> ::std::os::raw::c_int;
        }
        vscanf(arg___format, arg_arg1)
    })
}
pub unsafe fn vsnprintf(
    arg___str: *mut ::std::os::raw::c_char,
    arg___size: ::std::os::raw::c_ulong,
    arg___format: *const ::std::os::raw::c_char,
    arg_arg1: __builtin_va_list,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn vsnprintf(
                arg___str: *mut ::std::os::raw::c_char,
                arg___size: ::std::os::raw::c_ulong,
                arg___format: *const ::std::os::raw::c_char,
                arg_arg1: __builtin_va_list,
            ) -> ::std::os::raw::c_int;
        }
        vsnprintf(arg___str, arg___size, arg___format, arg_arg1)
    })
}
pub unsafe fn vsscanf(
    arg___str: *const ::std::os::raw::c_char,
    arg___format: *const ::std::os::raw::c_char,
    arg_arg1: __builtin_va_list,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn vsscanf(
                arg___str: *const ::std::os::raw::c_char,
                arg___format: *const ::std::os::raw::c_char,
                arg_arg1: __builtin_va_list,
            ) -> ::std::os::raw::c_int;
        }
        vsscanf(arg___str, arg___format, arg_arg1)
    })
}
pub unsafe fn dprintf(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dprintf(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        dprintf(arg_arg1, arg_arg2)
    })
}
pub unsafe fn vdprintf(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: *const ::std::os::raw::c_char,
    arg_arg3: va_list,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn vdprintf(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: *const ::std::os::raw::c_char,
                arg_arg3: va_list,
            ) -> ::std::os::raw::c_int;
        }
        vdprintf(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn getdelim(
    arg___linep: *mut *mut ::std::os::raw::c_char,
    arg___linecapp: *mut usize,
    arg___delimiter: ::std::os::raw::c_int,
    arg___stream: *mut FILE,
) -> isize {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getdelim(
                arg___linep: *mut *mut ::std::os::raw::c_char,
                arg___linecapp: *mut usize,
                arg___delimiter: ::std::os::raw::c_int,
                arg___stream: *mut FILE,
            ) -> isize;
        }
        getdelim(arg___linep, arg___linecapp, arg___delimiter, arg___stream)
    })
}
pub unsafe fn getline(
    arg___linep: *mut *mut ::std::os::raw::c_char,
    arg___linecapp: *mut usize,
    arg___stream: *mut FILE,
) -> isize {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getline(
                arg___linep: *mut *mut ::std::os::raw::c_char,
                arg___linecapp: *mut usize,
                arg___stream: *mut FILE,
            ) -> isize;
        }
        getline(arg___linep, arg___linecapp, arg___stream)
    })
}
pub unsafe fn fmemopen(
    arg___buf: *mut ::std::os::raw::c_void,
    arg___size: usize,
    arg___mode: *const ::std::os::raw::c_char,
) -> *mut FILE {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fmemopen(
                arg___buf: *mut ::std::os::raw::c_void,
                arg___size: usize,
                arg___mode: *const ::std::os::raw::c_char,
            ) -> *mut FILE;
        }
        fmemopen(arg___buf, arg___size, arg___mode)
    })
}
pub unsafe fn open_memstream(
    arg___bufp: *mut *mut ::std::os::raw::c_char,
    arg___sizep: *mut usize,
) -> *mut FILE {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn open_memstream(
                arg___bufp: *mut *mut ::std::os::raw::c_char,
                arg___sizep: *mut usize,
            ) -> *mut FILE;
        }
        open_memstream(arg___bufp, arg___sizep)
    })
}
extern "C" {
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
pub unsafe fn asprintf(
    arg_arg1: *mut *mut ::std::os::raw::c_char,
    arg_arg2: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn asprintf(
                arg_arg1: *mut *mut ::std::os::raw::c_char,
                arg_arg2: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        asprintf(arg_arg1, arg_arg2)
    })
}
pub unsafe fn ctermid_r(arg_arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ctermid_r(arg_arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
        }
        ctermid_r(arg_arg1)
    })
}
pub unsafe fn fgetln(arg_arg1: *mut FILE, arg_arg2: *mut usize) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fgetln(arg_arg1: *mut FILE, arg_arg2: *mut usize) -> *mut ::std::os::raw::c_char;
        }
        fgetln(arg_arg1, arg_arg2)
    })
}
pub unsafe fn fmtcheck(
    arg_arg1: *const ::std::os::raw::c_char,
    arg_arg2: *const ::std::os::raw::c_char,
) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fmtcheck(
                arg_arg1: *const ::std::os::raw::c_char,
                arg_arg2: *const ::std::os::raw::c_char,
            ) -> *const ::std::os::raw::c_char;
        }
        fmtcheck(arg_arg1, arg_arg2)
    })
}
pub unsafe fn fpurge(arg_arg1: *mut FILE) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fpurge(arg_arg1: *mut FILE) -> ::std::os::raw::c_int;
        }
        fpurge(arg_arg1)
    })
}
pub unsafe fn setbuffer(
    arg_arg1: *mut FILE,
    arg_arg2: *mut ::std::os::raw::c_char,
    arg_arg3: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn setbuffer(
                arg_arg1: *mut FILE,
                arg_arg2: *mut ::std::os::raw::c_char,
                arg_arg3: ::std::os::raw::c_int,
            );
        }
        setbuffer(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn setlinebuf(arg_arg1: *mut FILE) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn setlinebuf(arg_arg1: *mut FILE) -> ::std::os::raw::c_int;
        }
        setlinebuf(arg_arg1)
    })
}
pub unsafe fn vasprintf(
    arg_arg1: *mut *mut ::std::os::raw::c_char,
    arg_arg2: *const ::std::os::raw::c_char,
    arg_arg3: va_list,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn vasprintf(
                arg_arg1: *mut *mut ::std::os::raw::c_char,
                arg_arg2: *const ::std::os::raw::c_char,
                arg_arg3: va_list,
            ) -> ::std::os::raw::c_int;
        }
        vasprintf(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn funopen(
    arg_arg1: *const ::std::os::raw::c_void,
    arg_arg2: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    arg_arg3: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    arg_arg4: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    arg_arg5: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
) -> *mut FILE {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn funopen(
                arg_arg1: *const ::std::os::raw::c_void,
                arg_arg2: ::std::option::Option<
                    unsafe extern "C" fn(
                        arg1: *mut ::std::os::raw::c_void,
                        arg2: *mut ::std::os::raw::c_char,
                        arg3: ::std::os::raw::c_int,
                    ) -> ::std::os::raw::c_int,
                >,
                arg_arg3: ::std::option::Option<
                    unsafe extern "C" fn(
                        arg1: *mut ::std::os::raw::c_void,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: ::std::os::raw::c_int,
                    ) -> ::std::os::raw::c_int,
                >,
                arg_arg4: ::std::option::Option<
                    unsafe extern "C" fn(
                        arg1: *mut ::std::os::raw::c_void,
                        arg2: fpos_t,
                        arg3: ::std::os::raw::c_int,
                    ) -> fpos_t,
                >,
                arg_arg5: ::std::option::Option<
                    unsafe extern "C" fn(
                        arg1: *mut ::std::os::raw::c_void,
                    ) -> ::std::os::raw::c_int,
                >,
            ) -> *mut FILE;
        }
        funopen(arg_arg1, arg_arg2, arg_arg3, arg_arg4, arg_arg5)
    })
}
pub unsafe fn __sprintf_chk(
    arg_arg1: *mut ::std::os::raw::c_char,
    arg_arg2: ::std::os::raw::c_int,
    arg_arg3: usize,
    arg_arg4: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn __sprintf_chk(
                arg_arg1: *mut ::std::os::raw::c_char,
                arg_arg2: ::std::os::raw::c_int,
                arg_arg3: usize,
                arg_arg4: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        __sprintf_chk(arg_arg1, arg_arg2, arg_arg3, arg_arg4)
    })
}
pub unsafe fn __snprintf_chk(
    arg_arg1: *mut ::std::os::raw::c_char,
    arg_arg2: usize,
    arg_arg3: ::std::os::raw::c_int,
    arg_arg4: usize,
    arg_arg5: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn __snprintf_chk(
                arg_arg1: *mut ::std::os::raw::c_char,
                arg_arg2: usize,
                arg_arg3: ::std::os::raw::c_int,
                arg_arg4: usize,
                arg_arg5: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        __snprintf_chk(arg_arg1, arg_arg2, arg_arg3, arg_arg4, arg_arg5)
    })
}
pub unsafe fn __vsprintf_chk(
    arg_arg1: *mut ::std::os::raw::c_char,
    arg_arg2: ::std::os::raw::c_int,
    arg_arg3: usize,
    arg_arg4: *const ::std::os::raw::c_char,
    arg_arg5: va_list,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn __vsprintf_chk(
                arg_arg1: *mut ::std::os::raw::c_char,
                arg_arg2: ::std::os::raw::c_int,
                arg_arg3: usize,
                arg_arg4: *const ::std::os::raw::c_char,
                arg_arg5: va_list,
            ) -> ::std::os::raw::c_int;
        }
        __vsprintf_chk(arg_arg1, arg_arg2, arg_arg3, arg_arg4, arg_arg5)
    })
}
pub unsafe fn __vsnprintf_chk(
    arg_arg1: *mut ::std::os::raw::c_char,
    arg_arg2: usize,
    arg_arg3: ::std::os::raw::c_int,
    arg_arg4: usize,
    arg_arg5: *const ::std::os::raw::c_char,
    arg_arg6: va_list,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn __vsnprintf_chk(
                arg_arg1: *mut ::std::os::raw::c_char,
                arg_arg2: usize,
                arg_arg3: ::std::os::raw::c_int,
                arg_arg4: usize,
                arg_arg5: *const ::std::os::raw::c_char,
                arg_arg6: va_list,
            ) -> ::std::os::raw::c_int;
        }
        __vsnprintf_chk(arg_arg1, arg_arg2, arg_arg3, arg_arg4, arg_arg5, arg_arg6)
    })
}
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
pub type pid_t = __darwin_pid_t;
pub type id_t = __darwin_id_t;
pub type sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_arm_exception_state {
    pub __exception: __uint32_t,
    pub __fsr: __uint32_t,
    pub __far: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_arm_exception_state64 {
    pub __far: __uint64_t,
    pub __esr: __uint32_t,
    pub __exception: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_arm_thread_state {
    pub __r: [__uint32_t; 13usize],
    pub __sp: __uint32_t,
    pub __lr: __uint32_t,
    pub __pc: __uint32_t,
    pub __cpsr: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_arm_thread_state64 {
    pub __x: [__uint64_t; 29usize],
    pub __fp: __uint64_t,
    pub __lr: __uint64_t,
    pub __sp: __uint64_t,
    pub __pc: __uint64_t,
    pub __cpsr: __uint32_t,
    pub __pad: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_vfp_state {
    pub __r: [__uint32_t; 64usize],
    pub __fpscr: __uint32_t,
}
impl Default for __darwin_arm_vfp_state {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_arm_neon_state64 {
    pub __v: [__uint128_t; 32usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_arm_neon_state {
    pub __v: [__uint128_t; 16usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __arm_pagein_state {
    pub __pagein_error: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __arm_legacy_debug_state {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_arm_debug_state32 {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_arm_debug_state64 {
    pub __bvr: [__uint64_t; 16usize],
    pub __bcr: [__uint64_t; 16usize],
    pub __wvr: [__uint64_t; 16usize],
    pub __wcr: [__uint64_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_arm_cpmu_state64 {
    pub __ctrs: [__uint64_t; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_arm_exception_state,
    pub __ss: __darwin_arm_thread_state,
    pub __fs: __darwin_arm_vfp_state,
}
impl Default for __darwin_mcontext32 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_arm_exception_state64,
    pub __ss: __darwin_arm_thread_state64,
    pub __ns: __darwin_arm_neon_state64,
}
pub type mcontext_t = *mut __darwin_mcontext64;
pub type pthread_attr_t = __darwin_pthread_attr_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::std::os::raw::c_int,
}
impl Default for __darwin_sigaltstack {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::std::os::raw::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
impl Default for __darwin_ucontext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ucontext_t = __darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
pub type uid_t = __darwin_uid_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
impl Default for sigval {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
impl Default for sigevent {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_value: sigval,
    pub si_band: ::std::os::raw::c_long,
    pub __pad: [::std::os::raw::c_ulong; 7usize],
}
impl Default for __siginfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sigaction_u {
    pub __sa_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub __sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut __siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
impl Default for __sigaction_u {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: *mut siginfo_t,
            arg5: *mut ::std::os::raw::c_void,
        ),
    >,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
impl Default for __sigaction {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
impl Default for sigaction {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type sig_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sigvec {
    pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_char,
    pub ss_onstack: ::std::os::raw::c_int,
}
impl Default for sigstack {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn signal(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
) -> ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ),
> {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn signal(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
            ) -> ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: ::std::os::raw::c_int,
                    arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
                ),
            >;
        }
        signal(arg_arg1, arg_arg2)
    })
}
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
pub type rusage_info_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rusage_info_v0 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rusage_info_v1 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rusage_info_v2 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rusage_info_v3 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rusage_info_v4 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rusage_info_v5 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
}
pub type rusage_info_current = rusage_info_v5;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct proc_rlimit_control_wakeupmon {
    pub wm_flags: u32,
    pub wm_rate: i32,
}
pub unsafe fn getpriority(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: id_t,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getpriority(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: id_t,
            ) -> ::std::os::raw::c_int;
        }
        getpriority(arg_arg1, arg_arg2)
    })
}
pub unsafe fn getiopolicy_np(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getiopolicy_np(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        getiopolicy_np(arg_arg1, arg_arg2)
    })
}
pub unsafe fn getrlimit(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: *mut rlimit,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getrlimit(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: *mut rlimit,
            ) -> ::std::os::raw::c_int;
        }
        getrlimit(arg_arg1, arg_arg2)
    })
}
pub unsafe fn getrusage(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: *mut rusage,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getrusage(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: *mut rusage,
            ) -> ::std::os::raw::c_int;
        }
        getrusage(arg_arg1, arg_arg2)
    })
}
pub unsafe fn setpriority(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: id_t,
    arg_arg3: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn setpriority(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: id_t,
                arg_arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        setpriority(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn setiopolicy_np(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: ::std::os::raw::c_int,
    arg_arg3: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn setiopolicy_np(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: ::std::os::raw::c_int,
                arg_arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        setiopolicy_np(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn setrlimit(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: *const rlimit,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn setrlimit(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: *const rlimit,
            ) -> ::std::os::raw::c_int;
        }
        setrlimit(arg_arg1, arg_arg2)
    })
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _OSUnalignedU16 {
    pub __val: u16,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _OSUnalignedU32 {
    pub __val: u32,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _OSUnalignedU64 {
    pub __val: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
    pub w_status: ::std::os::raw::c_int,
    pub w_T: wait__bindgen_ty_1,
    pub w_S: wait__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn w_Termsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_w_Termsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Coredump(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_w_Coredump(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Retcode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Retcode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Termsig: ::std::os::raw::c_uint,
        w_Coredump: ::std::os::raw::c_uint,
        w_Retcode: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let w_Termsig: u32 = unsafe { ::std::mem::transmute(w_Termsig) };
            w_Termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let w_Coredump: u32 = unsafe { ::std::mem::transmute(w_Coredump) };
            w_Coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Retcode: u32 = unsafe { ::std::mem::transmute(w_Retcode) };
            w_Retcode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn w_Stopval(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopval(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Stopsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Stopval: ::std::os::raw::c_uint,
        w_Stopsig: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let w_Stopval: u32 = unsafe { ::std::mem::transmute(w_Stopval) };
            w_Stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Stopsig: u32 = unsafe { ::std::mem::transmute(w_Stopsig) };
            w_Stopsig as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for wait {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn wait(arg_arg1: *mut ::std::os::raw::c_int) -> pid_t {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn wait(arg_arg1: *mut ::std::os::raw::c_int) -> pid_t;
        }
        wait(arg_arg1)
    })
}
pub unsafe fn waitpid(
    arg_arg1: pid_t,
    arg_arg2: *mut ::std::os::raw::c_int,
    arg_arg3: ::std::os::raw::c_int,
) -> pid_t {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn waitpid(
                arg_arg1: pid_t,
                arg_arg2: *mut ::std::os::raw::c_int,
                arg_arg3: ::std::os::raw::c_int,
            ) -> pid_t;
        }
        waitpid(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn waitid(
    arg_arg1: idtype_t,
    arg_arg2: id_t,
    arg_arg3: *mut siginfo_t,
    arg_arg4: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn waitid(
                arg_arg1: idtype_t,
                arg_arg2: id_t,
                arg_arg3: *mut siginfo_t,
                arg_arg4: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        waitid(arg_arg1, arg_arg2, arg_arg3, arg_arg4)
    })
}
pub unsafe fn wait3(
    arg_arg1: *mut ::std::os::raw::c_int,
    arg_arg2: ::std::os::raw::c_int,
    arg_arg3: *mut rusage,
) -> pid_t {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn wait3(
                arg_arg1: *mut ::std::os::raw::c_int,
                arg_arg2: ::std::os::raw::c_int,
                arg_arg3: *mut rusage,
            ) -> pid_t;
        }
        wait3(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn wait4(
    arg_arg1: pid_t,
    arg_arg2: *mut ::std::os::raw::c_int,
    arg_arg3: ::std::os::raw::c_int,
    arg_arg4: *mut rusage,
) -> pid_t {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn wait4(
                arg_arg1: pid_t,
                arg_arg2: *mut ::std::os::raw::c_int,
                arg_arg3: ::std::os::raw::c_int,
                arg_arg4: *mut rusage,
            ) -> pid_t;
        }
        wait4(arg_arg1, arg_arg2, arg_arg3, arg_arg4)
    })
}
pub unsafe fn alloca(arg_arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn alloca(arg_arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
        }
        alloca(arg_arg1)
    })
}
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
pub type wchar_t = __darwin_wchar_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
extern "C" {
    pub static mut __mb_cur_max: ::std::os::raw::c_int;
}
pub unsafe fn malloc(arg___size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn malloc(arg___size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
        }
        malloc(arg___size)
    })
}
pub unsafe fn calloc(
    arg___count: ::std::os::raw::c_ulong,
    arg___size: ::std::os::raw::c_ulong,
) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn calloc(
                arg___count: ::std::os::raw::c_ulong,
                arg___size: ::std::os::raw::c_ulong,
            ) -> *mut ::std::os::raw::c_void;
        }
        calloc(arg___count, arg___size)
    })
}
pub unsafe fn free(arg_arg1: *mut ::std::os::raw::c_void) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn free(arg_arg1: *mut ::std::os::raw::c_void);
        }
        free(arg_arg1)
    })
}
pub unsafe fn realloc(
    arg___ptr: *mut ::std::os::raw::c_void,
    arg___size: ::std::os::raw::c_ulong,
) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn realloc(
                arg___ptr: *mut ::std::os::raw::c_void,
                arg___size: ::std::os::raw::c_ulong,
            ) -> *mut ::std::os::raw::c_void;
        }
        realloc(arg___ptr, arg___size)
    })
}
pub unsafe fn valloc(arg_arg1: usize) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn valloc(arg_arg1: usize) -> *mut ::std::os::raw::c_void;
        }
        valloc(arg_arg1)
    })
}
pub unsafe fn aligned_alloc(
    arg___alignment: ::std::os::raw::c_ulong,
    arg___size: ::std::os::raw::c_ulong,
) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn aligned_alloc(
                arg___alignment: ::std::os::raw::c_ulong,
                arg___size: ::std::os::raw::c_ulong,
            ) -> *mut ::std::os::raw::c_void;
        }
        aligned_alloc(arg___alignment, arg___size)
    })
}
pub unsafe fn posix_memalign(
    arg___memptr: *mut *mut ::std::os::raw::c_void,
    arg___alignment: usize,
    arg___size: usize,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn posix_memalign(
                arg___memptr: *mut *mut ::std::os::raw::c_void,
                arg___alignment: usize,
                arg___size: usize,
            ) -> ::std::os::raw::c_int;
        }
        posix_memalign(arg___memptr, arg___alignment, arg___size)
    })
}
pub unsafe fn abort() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn abort();
        }
        abort()
    })
}
pub unsafe fn abs(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn abs(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        abs(arg_arg1)
    })
}
pub unsafe fn atexit(
    arg_arg1: ::std::option::Option<unsafe extern "C" fn()>,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn atexit(
                arg_arg1: ::std::option::Option<unsafe extern "C" fn()>,
            ) -> ::std::os::raw::c_int;
        }
        atexit(arg_arg1)
    })
}
pub unsafe fn atof(arg_arg1: *const ::std::os::raw::c_char) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn atof(arg_arg1: *const ::std::os::raw::c_char) -> f64;
        }
        atof(arg_arg1)
    })
}
pub unsafe fn atoi(arg_arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn atoi(arg_arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
        }
        atoi(arg_arg1)
    })
}
pub unsafe fn atol(arg_arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn atol(arg_arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
        }
        atol(arg_arg1)
    })
}
pub unsafe fn atoll(arg_arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn atoll(arg_arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
        }
        atoll(arg_arg1)
    })
}
pub unsafe fn bsearch(
    arg___key: *const ::std::os::raw::c_void,
    arg___base: *const ::std::os::raw::c_void,
    arg___nel: usize,
    arg___width: usize,
    arg___compar: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bsearch(
                arg___key: *const ::std::os::raw::c_void,
                arg___base: *const ::std::os::raw::c_void,
                arg___nel: usize,
                arg___width: usize,
                arg___compar: ::std::option::Option<
                    unsafe extern "C" fn(
                        arg1: *const ::std::os::raw::c_void,
                        arg2: *const ::std::os::raw::c_void,
                    ) -> ::std::os::raw::c_int,
                >,
            ) -> *mut ::std::os::raw::c_void;
        }
        bsearch(arg___key, arg___base, arg___nel, arg___width, arg___compar)
    })
}
pub unsafe fn div(arg_arg1: ::std::os::raw::c_int, arg_arg2: ::std::os::raw::c_int) -> div_t {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn div(arg_arg1: ::std::os::raw::c_int, arg_arg2: ::std::os::raw::c_int) -> div_t;
        }
        div(arg_arg1, arg_arg2)
    })
}
pub unsafe fn exit(arg_arg1: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn exit(arg_arg1: ::std::os::raw::c_int);
        }
        exit(arg_arg1)
    })
}
pub unsafe fn getenv(arg_arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getenv(arg_arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
        }
        getenv(arg_arg1)
    })
}
pub unsafe fn labs(arg_arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn labs(arg_arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
        }
        labs(arg_arg1)
    })
}
pub unsafe fn ldiv(arg_arg1: ::std::os::raw::c_long, arg_arg2: ::std::os::raw::c_long) -> ldiv_t {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ldiv(arg_arg1: ::std::os::raw::c_long, arg_arg2: ::std::os::raw::c_long) -> ldiv_t;
        }
        ldiv(arg_arg1, arg_arg2)
    })
}
pub unsafe fn llabs(arg_arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn llabs(arg_arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
        }
        llabs(arg_arg1)
    })
}
pub unsafe fn lldiv(
    arg_arg1: ::std::os::raw::c_longlong,
    arg_arg2: ::std::os::raw::c_longlong,
) -> lldiv_t {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lldiv(
                arg_arg1: ::std::os::raw::c_longlong,
                arg_arg2: ::std::os::raw::c_longlong,
            ) -> lldiv_t;
        }
        lldiv(arg_arg1, arg_arg2)
    })
}
pub unsafe fn mblen(
    arg___s: *const ::std::os::raw::c_char,
    arg___n: usize,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn mblen(
                arg___s: *const ::std::os::raw::c_char,
                arg___n: usize,
            ) -> ::std::os::raw::c_int;
        }
        mblen(arg___s, arg___n)
    })
}
pub unsafe fn mbstowcs(
    arg_arg1: *mut wchar_t,
    arg_arg2: *const ::std::os::raw::c_char,
    arg_arg3: usize,
) -> usize {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn mbstowcs(
                arg_arg1: *mut wchar_t,
                arg_arg2: *const ::std::os::raw::c_char,
                arg_arg3: usize,
            ) -> usize;
        }
        mbstowcs(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn mbtowc(
    arg_arg1: *mut wchar_t,
    arg_arg2: *const ::std::os::raw::c_char,
    arg_arg3: usize,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn mbtowc(
                arg_arg1: *mut wchar_t,
                arg_arg2: *const ::std::os::raw::c_char,
                arg_arg3: usize,
            ) -> ::std::os::raw::c_int;
        }
        mbtowc(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn qsort(
    arg___base: *mut ::std::os::raw::c_void,
    arg___nel: usize,
    arg___width: usize,
    arg___compar: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn qsort(
                arg___base: *mut ::std::os::raw::c_void,
                arg___nel: usize,
                arg___width: usize,
                arg___compar: ::std::option::Option<
                    unsafe extern "C" fn(
                        arg1: *const ::std::os::raw::c_void,
                        arg2: *const ::std::os::raw::c_void,
                    ) -> ::std::os::raw::c_int,
                >,
            );
        }
        qsort(arg___base, arg___nel, arg___width, arg___compar)
    })
}
pub unsafe fn rand() -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn rand() -> ::std::os::raw::c_int;
        }
        rand()
    })
}
pub unsafe fn srand(arg_arg1: ::std::os::raw::c_uint) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn srand(arg_arg1: ::std::os::raw::c_uint);
        }
        srand(arg_arg1)
    })
}
pub unsafe fn strtod(
    arg_arg1: *const ::std::os::raw::c_char,
    arg_arg2: *mut *mut ::std::os::raw::c_char,
) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strtod(
                arg_arg1: *const ::std::os::raw::c_char,
                arg_arg2: *mut *mut ::std::os::raw::c_char,
            ) -> f64;
        }
        strtod(arg_arg1, arg_arg2)
    })
}
pub unsafe fn strtof(
    arg_arg1: *const ::std::os::raw::c_char,
    arg_arg2: *mut *mut ::std::os::raw::c_char,
) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strtof(
                arg_arg1: *const ::std::os::raw::c_char,
                arg_arg2: *mut *mut ::std::os::raw::c_char,
            ) -> f32;
        }
        strtof(arg_arg1, arg_arg2)
    })
}
pub unsafe fn strtol(
    arg___str: *const ::std::os::raw::c_char,
    arg___endptr: *mut *mut ::std::os::raw::c_char,
    arg___base: ::std::os::raw::c_int,
) -> ::std::os::raw::c_long {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strtol(
                arg___str: *const ::std::os::raw::c_char,
                arg___endptr: *mut *mut ::std::os::raw::c_char,
                arg___base: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_long;
        }
        strtol(arg___str, arg___endptr, arg___base)
    })
}
pub unsafe fn strtold(
    arg_arg1: *const ::std::os::raw::c_char,
    arg_arg2: *mut *mut ::std::os::raw::c_char,
) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strtold(
                arg_arg1: *const ::std::os::raw::c_char,
                arg_arg2: *mut *mut ::std::os::raw::c_char,
            ) -> f64;
        }
        strtold(arg_arg1, arg_arg2)
    })
}
pub unsafe fn strtoll(
    arg___str: *const ::std::os::raw::c_char,
    arg___endptr: *mut *mut ::std::os::raw::c_char,
    arg___base: ::std::os::raw::c_int,
) -> ::std::os::raw::c_longlong {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strtoll(
                arg___str: *const ::std::os::raw::c_char,
                arg___endptr: *mut *mut ::std::os::raw::c_char,
                arg___base: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_longlong;
        }
        strtoll(arg___str, arg___endptr, arg___base)
    })
}
pub unsafe fn strtoul(
    arg___str: *const ::std::os::raw::c_char,
    arg___endptr: *mut *mut ::std::os::raw::c_char,
    arg___base: ::std::os::raw::c_int,
) -> ::std::os::raw::c_ulong {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strtoul(
                arg___str: *const ::std::os::raw::c_char,
                arg___endptr: *mut *mut ::std::os::raw::c_char,
                arg___base: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_ulong;
        }
        strtoul(arg___str, arg___endptr, arg___base)
    })
}
pub unsafe fn strtoull(
    arg___str: *const ::std::os::raw::c_char,
    arg___endptr: *mut *mut ::std::os::raw::c_char,
    arg___base: ::std::os::raw::c_int,
) -> ::std::os::raw::c_ulonglong {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strtoull(
                arg___str: *const ::std::os::raw::c_char,
                arg___endptr: *mut *mut ::std::os::raw::c_char,
                arg___base: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_ulonglong;
        }
        strtoull(arg___str, arg___endptr, arg___base)
    })
}
pub unsafe fn system(arg_arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn system(arg_arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
        }
        system(arg_arg1)
    })
}
pub unsafe fn wcstombs(
    arg_arg1: *mut ::std::os::raw::c_char,
    arg_arg2: *const wchar_t,
    arg_arg3: usize,
) -> usize {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn wcstombs(
                arg_arg1: *mut ::std::os::raw::c_char,
                arg_arg2: *const wchar_t,
                arg_arg3: usize,
            ) -> usize;
        }
        wcstombs(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn wctomb(
    arg_arg1: *mut ::std::os::raw::c_char,
    arg_arg2: wchar_t,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn wctomb(
                arg_arg1: *mut ::std::os::raw::c_char,
                arg_arg2: wchar_t,
            ) -> ::std::os::raw::c_int;
        }
        wctomb(arg_arg1, arg_arg2)
    })
}
pub unsafe fn _Exit(arg_arg1: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn _Exit(arg_arg1: ::std::os::raw::c_int);
        }
        _Exit(arg_arg1)
    })
}
pub unsafe fn a64l(arg_arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn a64l(arg_arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
        }
        a64l(arg_arg1)
    })
}
pub unsafe fn drand48() -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn drand48() -> f64;
        }
        drand48()
    })
}
pub unsafe fn ecvt(
    arg_arg1: f64,
    arg_arg2: ::std::os::raw::c_int,
    arg_arg3: *mut ::std::os::raw::c_int,
    arg_arg4: *mut ::std::os::raw::c_int,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ecvt(
                arg_arg1: f64,
                arg_arg2: ::std::os::raw::c_int,
                arg_arg3: *mut ::std::os::raw::c_int,
                arg_arg4: *mut ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_char;
        }
        ecvt(arg_arg1, arg_arg2, arg_arg3, arg_arg4)
    })
}
pub unsafe fn erand48(arg_arg1: *mut ::std::os::raw::c_ushort) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn erand48(arg_arg1: *mut ::std::os::raw::c_ushort) -> f64;
        }
        erand48(arg_arg1)
    })
}
pub unsafe fn fcvt(
    arg_arg1: f64,
    arg_arg2: ::std::os::raw::c_int,
    arg_arg3: *mut ::std::os::raw::c_int,
    arg_arg4: *mut ::std::os::raw::c_int,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fcvt(
                arg_arg1: f64,
                arg_arg2: ::std::os::raw::c_int,
                arg_arg3: *mut ::std::os::raw::c_int,
                arg_arg4: *mut ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_char;
        }
        fcvt(arg_arg1, arg_arg2, arg_arg3, arg_arg4)
    })
}
pub unsafe fn gcvt(
    arg_arg1: f64,
    arg_arg2: ::std::os::raw::c_int,
    arg_arg3: *mut ::std::os::raw::c_char,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gcvt(
                arg_arg1: f64,
                arg_arg2: ::std::os::raw::c_int,
                arg_arg3: *mut ::std::os::raw::c_char,
            ) -> *mut ::std::os::raw::c_char;
        }
        gcvt(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn getsubopt(
    arg_arg1: *mut *mut ::std::os::raw::c_char,
    arg_arg2: *const *mut ::std::os::raw::c_char,
    arg_arg3: *mut *mut ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getsubopt(
                arg_arg1: *mut *mut ::std::os::raw::c_char,
                arg_arg2: *const *mut ::std::os::raw::c_char,
                arg_arg3: *mut *mut ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        getsubopt(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn grantpt(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn grantpt(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        grantpt(arg_arg1)
    })
}
pub unsafe fn initstate(
    arg_arg1: ::std::os::raw::c_uint,
    arg_arg2: *mut ::std::os::raw::c_char,
    arg_arg3: usize,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn initstate(
                arg_arg1: ::std::os::raw::c_uint,
                arg_arg2: *mut ::std::os::raw::c_char,
                arg_arg3: usize,
            ) -> *mut ::std::os::raw::c_char;
        }
        initstate(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn jrand48(arg_arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jrand48(arg_arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
        }
        jrand48(arg_arg1)
    })
}
pub unsafe fn l64a(arg_arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn l64a(arg_arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
        }
        l64a(arg_arg1)
    })
}
pub unsafe fn lcong48(arg_arg1: *mut ::std::os::raw::c_ushort) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lcong48(arg_arg1: *mut ::std::os::raw::c_ushort);
        }
        lcong48(arg_arg1)
    })
}
pub unsafe fn lrand48() -> ::std::os::raw::c_long {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lrand48() -> ::std::os::raw::c_long;
        }
        lrand48()
    })
}
pub unsafe fn mktemp(arg_arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn mktemp(arg_arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
        }
        mktemp(arg_arg1)
    })
}
pub unsafe fn mkstemp(arg_arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn mkstemp(arg_arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
        }
        mkstemp(arg_arg1)
    })
}
pub unsafe fn mrand48() -> ::std::os::raw::c_long {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn mrand48() -> ::std::os::raw::c_long;
        }
        mrand48()
    })
}
pub unsafe fn nrand48(arg_arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn nrand48(arg_arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
        }
        nrand48(arg_arg1)
    })
}
pub unsafe fn posix_openpt(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn posix_openpt(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        posix_openpt(arg_arg1)
    })
}
pub unsafe fn ptsname(arg_arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ptsname(arg_arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
        }
        ptsname(arg_arg1)
    })
}
pub unsafe fn ptsname_r(
    arg_fildes: ::std::os::raw::c_int,
    arg_buffer: *mut ::std::os::raw::c_char,
    arg_buflen: usize,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ptsname_r(
                arg_fildes: ::std::os::raw::c_int,
                arg_buffer: *mut ::std::os::raw::c_char,
                arg_buflen: usize,
            ) -> ::std::os::raw::c_int;
        }
        ptsname_r(arg_fildes, arg_buffer, arg_buflen)
    })
}
pub unsafe fn putenv(arg_arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn putenv(arg_arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
        }
        putenv(arg_arg1)
    })
}
pub unsafe fn random() -> ::std::os::raw::c_long {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn random() -> ::std::os::raw::c_long;
        }
        random()
    })
}
pub unsafe fn rand_r(arg_arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn rand_r(arg_arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
        }
        rand_r(arg_arg1)
    })
}
pub unsafe fn realpath(
    arg_arg1: *const ::std::os::raw::c_char,
    arg_arg2: *mut ::std::os::raw::c_char,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn realpath(
                arg_arg1: *const ::std::os::raw::c_char,
                arg_arg2: *mut ::std::os::raw::c_char,
            ) -> *mut ::std::os::raw::c_char;
        }
        realpath(arg_arg1, arg_arg2)
    })
}
pub unsafe fn seed48(arg_arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn seed48(arg_arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
        }
        seed48(arg_arg1)
    })
}
pub unsafe fn setenv(
    arg___name: *const ::std::os::raw::c_char,
    arg___value: *const ::std::os::raw::c_char,
    arg___overwrite: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn setenv(
                arg___name: *const ::std::os::raw::c_char,
                arg___value: *const ::std::os::raw::c_char,
                arg___overwrite: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        setenv(arg___name, arg___value, arg___overwrite)
    })
}
pub unsafe fn setkey(arg_arg1: *const ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn setkey(arg_arg1: *const ::std::os::raw::c_char);
        }
        setkey(arg_arg1)
    })
}
pub unsafe fn setstate(arg_arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn setstate(arg_arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
        }
        setstate(arg_arg1)
    })
}
pub unsafe fn srand48(arg_arg1: ::std::os::raw::c_long) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn srand48(arg_arg1: ::std::os::raw::c_long);
        }
        srand48(arg_arg1)
    })
}
pub unsafe fn srandom(arg_arg1: ::std::os::raw::c_uint) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn srandom(arg_arg1: ::std::os::raw::c_uint);
        }
        srandom(arg_arg1)
    })
}
pub unsafe fn unlockpt(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn unlockpt(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        unlockpt(arg_arg1)
    })
}
pub unsafe fn unsetenv(arg_arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn unsetenv(arg_arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
        }
        unsetenv(arg_arg1)
    })
}
pub type dev_t = __darwin_dev_t;
pub type mode_t = __darwin_mode_t;
pub unsafe fn arc4random() -> u32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn arc4random() -> u32;
        }
        arc4random()
    })
}
pub unsafe fn arc4random_addrandom(
    arg_arg1: *mut ::std::os::raw::c_uchar,
    arg_arg2: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn arc4random_addrandom(
                arg_arg1: *mut ::std::os::raw::c_uchar,
                arg_arg2: ::std::os::raw::c_int,
            );
        }
        arc4random_addrandom(arg_arg1, arg_arg2)
    })
}
pub unsafe fn arc4random_buf(arg___buf: *mut ::std::os::raw::c_void, arg___nbytes: usize) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn arc4random_buf(arg___buf: *mut ::std::os::raw::c_void, arg___nbytes: usize);
        }
        arc4random_buf(arg___buf, arg___nbytes)
    })
}
pub unsafe fn arc4random_stir() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn arc4random_stir();
        }
        arc4random_stir()
    })
}
pub unsafe fn arc4random_uniform(arg___upper_bound: u32) -> u32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn arc4random_uniform(arg___upper_bound: u32) -> u32;
        }
        arc4random_uniform(arg___upper_bound)
    })
}
pub unsafe fn atexit_b(arg_arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn atexit_b(arg_arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
        }
        atexit_b(arg_arg1)
    })
}
pub unsafe fn bsearch_b(
    arg___key: *const ::std::os::raw::c_void,
    arg___base: *const ::std::os::raw::c_void,
    arg___nel: usize,
    arg___width: usize,
    arg___compar: *mut ::std::os::raw::c_void,
) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bsearch_b(
                arg___key: *const ::std::os::raw::c_void,
                arg___base: *const ::std::os::raw::c_void,
                arg___nel: usize,
                arg___width: usize,
                arg___compar: *mut ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void;
        }
        bsearch_b(arg___key, arg___base, arg___nel, arg___width, arg___compar)
    })
}
pub unsafe fn cgetcap(
    arg_arg1: *mut ::std::os::raw::c_char,
    arg_arg2: *const ::std::os::raw::c_char,
    arg_arg3: ::std::os::raw::c_int,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cgetcap(
                arg_arg1: *mut ::std::os::raw::c_char,
                arg_arg2: *const ::std::os::raw::c_char,
                arg_arg3: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_char;
        }
        cgetcap(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn cgetclose() -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cgetclose() -> ::std::os::raw::c_int;
        }
        cgetclose()
    })
}
pub unsafe fn cgetent(
    arg_arg1: *mut *mut ::std::os::raw::c_char,
    arg_arg2: *mut *mut ::std::os::raw::c_char,
    arg_arg3: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cgetent(
                arg_arg1: *mut *mut ::std::os::raw::c_char,
                arg_arg2: *mut *mut ::std::os::raw::c_char,
                arg_arg3: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        cgetent(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn cgetfirst(
    arg_arg1: *mut *mut ::std::os::raw::c_char,
    arg_arg2: *mut *mut ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cgetfirst(
                arg_arg1: *mut *mut ::std::os::raw::c_char,
                arg_arg2: *mut *mut ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        cgetfirst(arg_arg1, arg_arg2)
    })
}
pub unsafe fn cgetmatch(
    arg_arg1: *const ::std::os::raw::c_char,
    arg_arg2: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cgetmatch(
                arg_arg1: *const ::std::os::raw::c_char,
                arg_arg2: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        cgetmatch(arg_arg1, arg_arg2)
    })
}
pub unsafe fn cgetnext(
    arg_arg1: *mut *mut ::std::os::raw::c_char,
    arg_arg2: *mut *mut ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cgetnext(
                arg_arg1: *mut *mut ::std::os::raw::c_char,
                arg_arg2: *mut *mut ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        cgetnext(arg_arg1, arg_arg2)
    })
}
pub unsafe fn cgetnum(
    arg_arg1: *mut ::std::os::raw::c_char,
    arg_arg2: *const ::std::os::raw::c_char,
    arg_arg3: *mut ::std::os::raw::c_long,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cgetnum(
                arg_arg1: *mut ::std::os::raw::c_char,
                arg_arg2: *const ::std::os::raw::c_char,
                arg_arg3: *mut ::std::os::raw::c_long,
            ) -> ::std::os::raw::c_int;
        }
        cgetnum(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn cgetset(arg_arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cgetset(arg_arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
        }
        cgetset(arg_arg1)
    })
}
pub unsafe fn cgetstr(
    arg_arg1: *mut ::std::os::raw::c_char,
    arg_arg2: *const ::std::os::raw::c_char,
    arg_arg3: *mut *mut ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cgetstr(
                arg_arg1: *mut ::std::os::raw::c_char,
                arg_arg2: *const ::std::os::raw::c_char,
                arg_arg3: *mut *mut ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        cgetstr(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn cgetustr(
    arg_arg1: *mut ::std::os::raw::c_char,
    arg_arg2: *const ::std::os::raw::c_char,
    arg_arg3: *mut *mut ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cgetustr(
                arg_arg1: *mut ::std::os::raw::c_char,
                arg_arg2: *const ::std::os::raw::c_char,
                arg_arg3: *mut *mut ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        cgetustr(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn daemon(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn daemon(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        daemon(arg_arg1, arg_arg2)
    })
}
pub unsafe fn devname(arg_arg1: dev_t, arg_arg2: mode_t) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn devname(arg_arg1: dev_t, arg_arg2: mode_t) -> *mut ::std::os::raw::c_char;
        }
        devname(arg_arg1, arg_arg2)
    })
}
pub unsafe fn devname_r(
    arg_arg1: dev_t,
    arg_arg2: mode_t,
    arg_buf: *mut ::std::os::raw::c_char,
    arg_len: ::std::os::raw::c_int,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn devname_r(
                arg_arg1: dev_t,
                arg_arg2: mode_t,
                arg_buf: *mut ::std::os::raw::c_char,
                arg_len: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_char;
        }
        devname_r(arg_arg1, arg_arg2, arg_buf, arg_len)
    })
}
pub unsafe fn getbsize(
    arg_arg1: *mut ::std::os::raw::c_int,
    arg_arg2: *mut ::std::os::raw::c_long,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getbsize(
                arg_arg1: *mut ::std::os::raw::c_int,
                arg_arg2: *mut ::std::os::raw::c_long,
            ) -> *mut ::std::os::raw::c_char;
        }
        getbsize(arg_arg1, arg_arg2)
    })
}
pub unsafe fn getloadavg(
    arg_arg1: *mut f64,
    arg_arg2: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getloadavg(
                arg_arg1: *mut f64,
                arg_arg2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        getloadavg(arg_arg1, arg_arg2)
    })
}
pub unsafe fn getprogname() -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getprogname() -> *const ::std::os::raw::c_char;
        }
        getprogname()
    })
}
pub unsafe fn setprogname(arg_arg1: *const ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn setprogname(arg_arg1: *const ::std::os::raw::c_char);
        }
        setprogname(arg_arg1)
    })
}
pub unsafe fn heapsort(
    arg___base: *mut ::std::os::raw::c_void,
    arg___nel: usize,
    arg___width: usize,
    arg___compar: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heapsort(
                arg___base: *mut ::std::os::raw::c_void,
                arg___nel: usize,
                arg___width: usize,
                arg___compar: ::std::option::Option<
                    unsafe extern "C" fn(
                        arg1: *const ::std::os::raw::c_void,
                        arg2: *const ::std::os::raw::c_void,
                    ) -> ::std::os::raw::c_int,
                >,
            ) -> ::std::os::raw::c_int;
        }
        heapsort(arg___base, arg___nel, arg___width, arg___compar)
    })
}
pub unsafe fn heapsort_b(
    arg___base: *mut ::std::os::raw::c_void,
    arg___nel: usize,
    arg___width: usize,
    arg___compar: *mut ::std::os::raw::c_void,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heapsort_b(
                arg___base: *mut ::std::os::raw::c_void,
                arg___nel: usize,
                arg___width: usize,
                arg___compar: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int;
        }
        heapsort_b(arg___base, arg___nel, arg___width, arg___compar)
    })
}
pub unsafe fn mergesort(
    arg___base: *mut ::std::os::raw::c_void,
    arg___nel: usize,
    arg___width: usize,
    arg___compar: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn mergesort(
                arg___base: *mut ::std::os::raw::c_void,
                arg___nel: usize,
                arg___width: usize,
                arg___compar: ::std::option::Option<
                    unsafe extern "C" fn(
                        arg1: *const ::std::os::raw::c_void,
                        arg2: *const ::std::os::raw::c_void,
                    ) -> ::std::os::raw::c_int,
                >,
            ) -> ::std::os::raw::c_int;
        }
        mergesort(arg___base, arg___nel, arg___width, arg___compar)
    })
}
pub unsafe fn mergesort_b(
    arg___base: *mut ::std::os::raw::c_void,
    arg___nel: usize,
    arg___width: usize,
    arg___compar: *mut ::std::os::raw::c_void,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn mergesort_b(
                arg___base: *mut ::std::os::raw::c_void,
                arg___nel: usize,
                arg___width: usize,
                arg___compar: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int;
        }
        mergesort_b(arg___base, arg___nel, arg___width, arg___compar)
    })
}
pub unsafe fn psort(
    arg___base: *mut ::std::os::raw::c_void,
    arg___nel: usize,
    arg___width: usize,
    arg___compar: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn psort(
                arg___base: *mut ::std::os::raw::c_void,
                arg___nel: usize,
                arg___width: usize,
                arg___compar: ::std::option::Option<
                    unsafe extern "C" fn(
                        arg1: *const ::std::os::raw::c_void,
                        arg2: *const ::std::os::raw::c_void,
                    ) -> ::std::os::raw::c_int,
                >,
            );
        }
        psort(arg___base, arg___nel, arg___width, arg___compar)
    })
}
pub unsafe fn psort_b(
    arg___base: *mut ::std::os::raw::c_void,
    arg___nel: usize,
    arg___width: usize,
    arg___compar: *mut ::std::os::raw::c_void,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn psort_b(
                arg___base: *mut ::std::os::raw::c_void,
                arg___nel: usize,
                arg___width: usize,
                arg___compar: *mut ::std::os::raw::c_void,
            );
        }
        psort_b(arg___base, arg___nel, arg___width, arg___compar)
    })
}
pub unsafe fn psort_r(
    arg___base: *mut ::std::os::raw::c_void,
    arg___nel: usize,
    arg___width: usize,
    arg_arg1: *mut ::std::os::raw::c_void,
    arg___compar: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_void,
            arg3: *const ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn psort_r(
                arg___base: *mut ::std::os::raw::c_void,
                arg___nel: usize,
                arg___width: usize,
                arg_arg1: *mut ::std::os::raw::c_void,
                arg___compar: ::std::option::Option<
                    unsafe extern "C" fn(
                        arg1: *mut ::std::os::raw::c_void,
                        arg2: *const ::std::os::raw::c_void,
                        arg3: *const ::std::os::raw::c_void,
                    ) -> ::std::os::raw::c_int,
                >,
            );
        }
        psort_r(arg___base, arg___nel, arg___width, arg_arg1, arg___compar)
    })
}
pub unsafe fn qsort_b(
    arg___base: *mut ::std::os::raw::c_void,
    arg___nel: usize,
    arg___width: usize,
    arg___compar: *mut ::std::os::raw::c_void,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn qsort_b(
                arg___base: *mut ::std::os::raw::c_void,
                arg___nel: usize,
                arg___width: usize,
                arg___compar: *mut ::std::os::raw::c_void,
            );
        }
        qsort_b(arg___base, arg___nel, arg___width, arg___compar)
    })
}
pub unsafe fn qsort_r(
    arg___base: *mut ::std::os::raw::c_void,
    arg___nel: usize,
    arg___width: usize,
    arg_arg1: *mut ::std::os::raw::c_void,
    arg___compar: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_void,
            arg3: *const ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn qsort_r(
                arg___base: *mut ::std::os::raw::c_void,
                arg___nel: usize,
                arg___width: usize,
                arg_arg1: *mut ::std::os::raw::c_void,
                arg___compar: ::std::option::Option<
                    unsafe extern "C" fn(
                        arg1: *mut ::std::os::raw::c_void,
                        arg2: *const ::std::os::raw::c_void,
                        arg3: *const ::std::os::raw::c_void,
                    ) -> ::std::os::raw::c_int,
                >,
            );
        }
        qsort_r(arg___base, arg___nel, arg___width, arg_arg1, arg___compar)
    })
}
pub unsafe fn radixsort(
    arg___base: *mut *const ::std::os::raw::c_uchar,
    arg___nel: ::std::os::raw::c_int,
    arg___table: *const ::std::os::raw::c_uchar,
    arg___endbyte: ::std::os::raw::c_uint,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn radixsort(
                arg___base: *mut *const ::std::os::raw::c_uchar,
                arg___nel: ::std::os::raw::c_int,
                arg___table: *const ::std::os::raw::c_uchar,
                arg___endbyte: ::std::os::raw::c_uint,
            ) -> ::std::os::raw::c_int;
        }
        radixsort(arg___base, arg___nel, arg___table, arg___endbyte)
    })
}
pub unsafe fn rpmatch(arg_arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn rpmatch(arg_arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
        }
        rpmatch(arg_arg1)
    })
}
pub unsafe fn sradixsort(
    arg___base: *mut *const ::std::os::raw::c_uchar,
    arg___nel: ::std::os::raw::c_int,
    arg___table: *const ::std::os::raw::c_uchar,
    arg___endbyte: ::std::os::raw::c_uint,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sradixsort(
                arg___base: *mut *const ::std::os::raw::c_uchar,
                arg___nel: ::std::os::raw::c_int,
                arg___table: *const ::std::os::raw::c_uchar,
                arg___endbyte: ::std::os::raw::c_uint,
            ) -> ::std::os::raw::c_int;
        }
        sradixsort(arg___base, arg___nel, arg___table, arg___endbyte)
    })
}
pub unsafe fn sranddev() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sranddev();
        }
        sranddev()
    })
}
pub unsafe fn srandomdev() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn srandomdev();
        }
        srandomdev()
    })
}
pub unsafe fn reallocf(
    arg___ptr: *mut ::std::os::raw::c_void,
    arg___size: usize,
) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn reallocf(
                arg___ptr: *mut ::std::os::raw::c_void,
                arg___size: usize,
            ) -> *mut ::std::os::raw::c_void;
        }
        reallocf(arg___ptr, arg___size)
    })
}
pub unsafe fn strtonum(
    arg___numstr: *const ::std::os::raw::c_char,
    arg___minval: ::std::os::raw::c_longlong,
    arg___maxval: ::std::os::raw::c_longlong,
    arg___errstrp: *mut *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_longlong {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strtonum(
                arg___numstr: *const ::std::os::raw::c_char,
                arg___minval: ::std::os::raw::c_longlong,
                arg___maxval: ::std::os::raw::c_longlong,
                arg___errstrp: *mut *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_longlong;
        }
        strtonum(arg___numstr, arg___minval, arg___maxval, arg___errstrp)
    })
}
pub unsafe fn strtoq(
    arg___str: *const ::std::os::raw::c_char,
    arg___endptr: *mut *mut ::std::os::raw::c_char,
    arg___base: ::std::os::raw::c_int,
) -> ::std::os::raw::c_longlong {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strtoq(
                arg___str: *const ::std::os::raw::c_char,
                arg___endptr: *mut *mut ::std::os::raw::c_char,
                arg___base: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_longlong;
        }
        strtoq(arg___str, arg___endptr, arg___base)
    })
}
pub unsafe fn strtouq(
    arg___str: *const ::std::os::raw::c_char,
    arg___endptr: *mut *mut ::std::os::raw::c_char,
    arg___base: ::std::os::raw::c_int,
) -> ::std::os::raw::c_ulonglong {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strtouq(
                arg___str: *const ::std::os::raw::c_char,
                arg___endptr: *mut *mut ::std::os::raw::c_char,
                arg___base: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_ulonglong;
        }
        strtouq(arg___str, arg___endptr, arg___base)
    })
}
extern "C" {
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
pub unsafe fn memchr(
    arg___s: *const ::std::os::raw::c_void,
    arg___c: ::std::os::raw::c_int,
    arg___n: ::std::os::raw::c_ulong,
) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn memchr(
                arg___s: *const ::std::os::raw::c_void,
                arg___c: ::std::os::raw::c_int,
                arg___n: ::std::os::raw::c_ulong,
            ) -> *mut ::std::os::raw::c_void;
        }
        memchr(arg___s, arg___c, arg___n)
    })
}
pub unsafe fn memcmp(
    arg___s1: *const ::std::os::raw::c_void,
    arg___s2: *const ::std::os::raw::c_void,
    arg___n: ::std::os::raw::c_ulong,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn memcmp(
                arg___s1: *const ::std::os::raw::c_void,
                arg___s2: *const ::std::os::raw::c_void,
                arg___n: ::std::os::raw::c_ulong,
            ) -> ::std::os::raw::c_int;
        }
        memcmp(arg___s1, arg___s2, arg___n)
    })
}
pub unsafe fn memcpy(
    arg___dst: *mut ::std::os::raw::c_void,
    arg___src: *const ::std::os::raw::c_void,
    arg___n: ::std::os::raw::c_ulong,
) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn memcpy(
                arg___dst: *mut ::std::os::raw::c_void,
                arg___src: *const ::std::os::raw::c_void,
                arg___n: ::std::os::raw::c_ulong,
            ) -> *mut ::std::os::raw::c_void;
        }
        memcpy(arg___dst, arg___src, arg___n)
    })
}
pub unsafe fn memmove(
    arg___dst: *mut ::std::os::raw::c_void,
    arg___src: *const ::std::os::raw::c_void,
    arg___len: ::std::os::raw::c_ulong,
) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn memmove(
                arg___dst: *mut ::std::os::raw::c_void,
                arg___src: *const ::std::os::raw::c_void,
                arg___len: ::std::os::raw::c_ulong,
            ) -> *mut ::std::os::raw::c_void;
        }
        memmove(arg___dst, arg___src, arg___len)
    })
}
pub unsafe fn memset(
    arg___b: *mut ::std::os::raw::c_void,
    arg___c: ::std::os::raw::c_int,
    arg___len: ::std::os::raw::c_ulong,
) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn memset(
                arg___b: *mut ::std::os::raw::c_void,
                arg___c: ::std::os::raw::c_int,
                arg___len: ::std::os::raw::c_ulong,
            ) -> *mut ::std::os::raw::c_void;
        }
        memset(arg___b, arg___c, arg___len)
    })
}
pub unsafe fn strcat(
    arg___s1: *mut ::std::os::raw::c_char,
    arg___s2: *const ::std::os::raw::c_char,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strcat(
                arg___s1: *mut ::std::os::raw::c_char,
                arg___s2: *const ::std::os::raw::c_char,
            ) -> *mut ::std::os::raw::c_char;
        }
        strcat(arg___s1, arg___s2)
    })
}
pub unsafe fn strchr(
    arg___s: *const ::std::os::raw::c_char,
    arg___c: ::std::os::raw::c_int,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strchr(
                arg___s: *const ::std::os::raw::c_char,
                arg___c: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_char;
        }
        strchr(arg___s, arg___c)
    })
}
pub unsafe fn strcmp(
    arg___s1: *const ::std::os::raw::c_char,
    arg___s2: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strcmp(
                arg___s1: *const ::std::os::raw::c_char,
                arg___s2: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        strcmp(arg___s1, arg___s2)
    })
}
pub unsafe fn strcoll(
    arg___s1: *const ::std::os::raw::c_char,
    arg___s2: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strcoll(
                arg___s1: *const ::std::os::raw::c_char,
                arg___s2: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        strcoll(arg___s1, arg___s2)
    })
}
pub unsafe fn strcpy(
    arg___dst: *mut ::std::os::raw::c_char,
    arg___src: *const ::std::os::raw::c_char,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strcpy(
                arg___dst: *mut ::std::os::raw::c_char,
                arg___src: *const ::std::os::raw::c_char,
            ) -> *mut ::std::os::raw::c_char;
        }
        strcpy(arg___dst, arg___src)
    })
}
pub unsafe fn strcspn(
    arg___s: *const ::std::os::raw::c_char,
    arg___charset: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_ulong {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strcspn(
                arg___s: *const ::std::os::raw::c_char,
                arg___charset: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_ulong;
        }
        strcspn(arg___s, arg___charset)
    })
}
pub unsafe fn strerror(arg___errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strerror(arg___errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
        }
        strerror(arg___errnum)
    })
}
pub unsafe fn strlen(arg___s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strlen(arg___s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
        }
        strlen(arg___s)
    })
}
pub unsafe fn strncat(
    arg___s1: *mut ::std::os::raw::c_char,
    arg___s2: *const ::std::os::raw::c_char,
    arg___n: ::std::os::raw::c_ulong,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strncat(
                arg___s1: *mut ::std::os::raw::c_char,
                arg___s2: *const ::std::os::raw::c_char,
                arg___n: ::std::os::raw::c_ulong,
            ) -> *mut ::std::os::raw::c_char;
        }
        strncat(arg___s1, arg___s2, arg___n)
    })
}
pub unsafe fn strncmp(
    arg___s1: *const ::std::os::raw::c_char,
    arg___s2: *const ::std::os::raw::c_char,
    arg___n: ::std::os::raw::c_ulong,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strncmp(
                arg___s1: *const ::std::os::raw::c_char,
                arg___s2: *const ::std::os::raw::c_char,
                arg___n: ::std::os::raw::c_ulong,
            ) -> ::std::os::raw::c_int;
        }
        strncmp(arg___s1, arg___s2, arg___n)
    })
}
pub unsafe fn strncpy(
    arg___dst: *mut ::std::os::raw::c_char,
    arg___src: *const ::std::os::raw::c_char,
    arg___n: ::std::os::raw::c_ulong,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strncpy(
                arg___dst: *mut ::std::os::raw::c_char,
                arg___src: *const ::std::os::raw::c_char,
                arg___n: ::std::os::raw::c_ulong,
            ) -> *mut ::std::os::raw::c_char;
        }
        strncpy(arg___dst, arg___src, arg___n)
    })
}
pub unsafe fn strpbrk(
    arg___s: *const ::std::os::raw::c_char,
    arg___charset: *const ::std::os::raw::c_char,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strpbrk(
                arg___s: *const ::std::os::raw::c_char,
                arg___charset: *const ::std::os::raw::c_char,
            ) -> *mut ::std::os::raw::c_char;
        }
        strpbrk(arg___s, arg___charset)
    })
}
pub unsafe fn strrchr(
    arg___s: *const ::std::os::raw::c_char,
    arg___c: ::std::os::raw::c_int,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strrchr(
                arg___s: *const ::std::os::raw::c_char,
                arg___c: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_char;
        }
        strrchr(arg___s, arg___c)
    })
}
pub unsafe fn strspn(
    arg___s: *const ::std::os::raw::c_char,
    arg___charset: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_ulong {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strspn(
                arg___s: *const ::std::os::raw::c_char,
                arg___charset: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_ulong;
        }
        strspn(arg___s, arg___charset)
    })
}
pub unsafe fn strstr(
    arg___big: *const ::std::os::raw::c_char,
    arg___little: *const ::std::os::raw::c_char,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strstr(
                arg___big: *const ::std::os::raw::c_char,
                arg___little: *const ::std::os::raw::c_char,
            ) -> *mut ::std::os::raw::c_char;
        }
        strstr(arg___big, arg___little)
    })
}
pub unsafe fn strtok(
    arg___str: *mut ::std::os::raw::c_char,
    arg___sep: *const ::std::os::raw::c_char,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strtok(
                arg___str: *mut ::std::os::raw::c_char,
                arg___sep: *const ::std::os::raw::c_char,
            ) -> *mut ::std::os::raw::c_char;
        }
        strtok(arg___str, arg___sep)
    })
}
pub unsafe fn strxfrm(
    arg___s1: *mut ::std::os::raw::c_char,
    arg___s2: *const ::std::os::raw::c_char,
    arg___n: ::std::os::raw::c_ulong,
) -> ::std::os::raw::c_ulong {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strxfrm(
                arg___s1: *mut ::std::os::raw::c_char,
                arg___s2: *const ::std::os::raw::c_char,
                arg___n: ::std::os::raw::c_ulong,
            ) -> ::std::os::raw::c_ulong;
        }
        strxfrm(arg___s1, arg___s2, arg___n)
    })
}
pub unsafe fn strtok_r(
    arg___str: *mut ::std::os::raw::c_char,
    arg___sep: *const ::std::os::raw::c_char,
    arg___lasts: *mut *mut ::std::os::raw::c_char,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strtok_r(
                arg___str: *mut ::std::os::raw::c_char,
                arg___sep: *const ::std::os::raw::c_char,
                arg___lasts: *mut *mut ::std::os::raw::c_char,
            ) -> *mut ::std::os::raw::c_char;
        }
        strtok_r(arg___str, arg___sep, arg___lasts)
    })
}
pub unsafe fn strerror_r(
    arg___errnum: ::std::os::raw::c_int,
    arg___strerrbuf: *mut ::std::os::raw::c_char,
    arg___buflen: usize,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strerror_r(
                arg___errnum: ::std::os::raw::c_int,
                arg___strerrbuf: *mut ::std::os::raw::c_char,
                arg___buflen: usize,
            ) -> ::std::os::raw::c_int;
        }
        strerror_r(arg___errnum, arg___strerrbuf, arg___buflen)
    })
}
pub unsafe fn strdup(arg___s1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strdup(arg___s1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
        }
        strdup(arg___s1)
    })
}
pub unsafe fn memccpy(
    arg___dst: *mut ::std::os::raw::c_void,
    arg___src: *const ::std::os::raw::c_void,
    arg___c: ::std::os::raw::c_int,
    arg___n: ::std::os::raw::c_ulong,
) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn memccpy(
                arg___dst: *mut ::std::os::raw::c_void,
                arg___src: *const ::std::os::raw::c_void,
                arg___c: ::std::os::raw::c_int,
                arg___n: ::std::os::raw::c_ulong,
            ) -> *mut ::std::os::raw::c_void;
        }
        memccpy(arg___dst, arg___src, arg___c, arg___n)
    })
}
pub unsafe fn stpcpy(
    arg___dst: *mut ::std::os::raw::c_char,
    arg___src: *const ::std::os::raw::c_char,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn stpcpy(
                arg___dst: *mut ::std::os::raw::c_char,
                arg___src: *const ::std::os::raw::c_char,
            ) -> *mut ::std::os::raw::c_char;
        }
        stpcpy(arg___dst, arg___src)
    })
}
pub unsafe fn stpncpy(
    arg___dst: *mut ::std::os::raw::c_char,
    arg___src: *const ::std::os::raw::c_char,
    arg___n: ::std::os::raw::c_ulong,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn stpncpy(
                arg___dst: *mut ::std::os::raw::c_char,
                arg___src: *const ::std::os::raw::c_char,
                arg___n: ::std::os::raw::c_ulong,
            ) -> *mut ::std::os::raw::c_char;
        }
        stpncpy(arg___dst, arg___src, arg___n)
    })
}
pub unsafe fn strndup(
    arg___s1: *const ::std::os::raw::c_char,
    arg___n: ::std::os::raw::c_ulong,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strndup(
                arg___s1: *const ::std::os::raw::c_char,
                arg___n: ::std::os::raw::c_ulong,
            ) -> *mut ::std::os::raw::c_char;
        }
        strndup(arg___s1, arg___n)
    })
}
pub unsafe fn strnlen(arg___s1: *const ::std::os::raw::c_char, arg___n: usize) -> usize {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strnlen(arg___s1: *const ::std::os::raw::c_char, arg___n: usize) -> usize;
        }
        strnlen(arg___s1, arg___n)
    })
}
pub unsafe fn strsignal(arg___sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strsignal(arg___sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
        }
        strsignal(arg___sig)
    })
}
pub type rsize_t = __darwin_size_t;
pub type errno_t = ::std::os::raw::c_int;
pub unsafe fn memset_s(
    arg___s: *mut ::std::os::raw::c_void,
    arg___smax: rsize_t,
    arg___c: ::std::os::raw::c_int,
    arg___n: rsize_t,
) -> errno_t {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn memset_s(
                arg___s: *mut ::std::os::raw::c_void,
                arg___smax: rsize_t,
                arg___c: ::std::os::raw::c_int,
                arg___n: rsize_t,
            ) -> errno_t;
        }
        memset_s(arg___s, arg___smax, arg___c, arg___n)
    })
}
pub unsafe fn memmem(
    arg___big: *const ::std::os::raw::c_void,
    arg___big_len: usize,
    arg___little: *const ::std::os::raw::c_void,
    arg___little_len: usize,
) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn memmem(
                arg___big: *const ::std::os::raw::c_void,
                arg___big_len: usize,
                arg___little: *const ::std::os::raw::c_void,
                arg___little_len: usize,
            ) -> *mut ::std::os::raw::c_void;
        }
        memmem(arg___big, arg___big_len, arg___little, arg___little_len)
    })
}
pub unsafe fn memset_pattern4(
    arg___b: *mut ::std::os::raw::c_void,
    arg___pattern4: *const ::std::os::raw::c_void,
    arg___len: usize,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn memset_pattern4(
                arg___b: *mut ::std::os::raw::c_void,
                arg___pattern4: *const ::std::os::raw::c_void,
                arg___len: usize,
            );
        }
        memset_pattern4(arg___b, arg___pattern4, arg___len)
    })
}
pub unsafe fn memset_pattern8(
    arg___b: *mut ::std::os::raw::c_void,
    arg___pattern8: *const ::std::os::raw::c_void,
    arg___len: usize,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn memset_pattern8(
                arg___b: *mut ::std::os::raw::c_void,
                arg___pattern8: *const ::std::os::raw::c_void,
                arg___len: usize,
            );
        }
        memset_pattern8(arg___b, arg___pattern8, arg___len)
    })
}
pub unsafe fn memset_pattern16(
    arg___b: *mut ::std::os::raw::c_void,
    arg___pattern16: *const ::std::os::raw::c_void,
    arg___len: usize,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn memset_pattern16(
                arg___b: *mut ::std::os::raw::c_void,
                arg___pattern16: *const ::std::os::raw::c_void,
                arg___len: usize,
            );
        }
        memset_pattern16(arg___b, arg___pattern16, arg___len)
    })
}
pub unsafe fn strcasestr(
    arg___big: *const ::std::os::raw::c_char,
    arg___little: *const ::std::os::raw::c_char,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strcasestr(
                arg___big: *const ::std::os::raw::c_char,
                arg___little: *const ::std::os::raw::c_char,
            ) -> *mut ::std::os::raw::c_char;
        }
        strcasestr(arg___big, arg___little)
    })
}
pub unsafe fn strnstr(
    arg___big: *const ::std::os::raw::c_char,
    arg___little: *const ::std::os::raw::c_char,
    arg___len: usize,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strnstr(
                arg___big: *const ::std::os::raw::c_char,
                arg___little: *const ::std::os::raw::c_char,
                arg___len: usize,
            ) -> *mut ::std::os::raw::c_char;
        }
        strnstr(arg___big, arg___little, arg___len)
    })
}
pub unsafe fn strlcat(
    arg___dst: *mut ::std::os::raw::c_char,
    arg___source: *const ::std::os::raw::c_char,
    arg___size: ::std::os::raw::c_ulong,
) -> ::std::os::raw::c_ulong {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strlcat(
                arg___dst: *mut ::std::os::raw::c_char,
                arg___source: *const ::std::os::raw::c_char,
                arg___size: ::std::os::raw::c_ulong,
            ) -> ::std::os::raw::c_ulong;
        }
        strlcat(arg___dst, arg___source, arg___size)
    })
}
pub unsafe fn strlcpy(
    arg___dst: *mut ::std::os::raw::c_char,
    arg___source: *const ::std::os::raw::c_char,
    arg___size: ::std::os::raw::c_ulong,
) -> ::std::os::raw::c_ulong {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strlcpy(
                arg___dst: *mut ::std::os::raw::c_char,
                arg___source: *const ::std::os::raw::c_char,
                arg___size: ::std::os::raw::c_ulong,
            ) -> ::std::os::raw::c_ulong;
        }
        strlcpy(arg___dst, arg___source, arg___size)
    })
}
pub unsafe fn strmode(arg___mode: ::std::os::raw::c_int, arg___bp: *mut ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strmode(arg___mode: ::std::os::raw::c_int, arg___bp: *mut ::std::os::raw::c_char);
        }
        strmode(arg___mode, arg___bp)
    })
}
pub unsafe fn strsep(
    arg___stringp: *mut *mut ::std::os::raw::c_char,
    arg___delim: *const ::std::os::raw::c_char,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strsep(
                arg___stringp: *mut *mut ::std::os::raw::c_char,
                arg___delim: *const ::std::os::raw::c_char,
            ) -> *mut ::std::os::raw::c_char;
        }
        strsep(arg___stringp, arg___delim)
    })
}
pub unsafe fn swab(
    arg_arg1: *const ::std::os::raw::c_void,
    arg_arg2: *mut ::std::os::raw::c_void,
    arg_arg3: isize,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn swab(
                arg_arg1: *const ::std::os::raw::c_void,
                arg_arg2: *mut ::std::os::raw::c_void,
                arg_arg3: isize,
            );
        }
        swab(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn timingsafe_bcmp(
    arg___b1: *const ::std::os::raw::c_void,
    arg___b2: *const ::std::os::raw::c_void,
    arg___len: usize,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timingsafe_bcmp(
                arg___b1: *const ::std::os::raw::c_void,
                arg___b2: *const ::std::os::raw::c_void,
                arg___len: usize,
            ) -> ::std::os::raw::c_int;
        }
        timingsafe_bcmp(arg___b1, arg___b2, arg___len)
    })
}
pub unsafe fn strsignal_r(
    arg___sig: ::std::os::raw::c_int,
    arg___strsignalbuf: *mut ::std::os::raw::c_char,
    arg___buflen: usize,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strsignal_r(
                arg___sig: ::std::os::raw::c_int,
                arg___strsignalbuf: *mut ::std::os::raw::c_char,
                arg___buflen: usize,
            ) -> ::std::os::raw::c_int;
        }
        strsignal_r(arg___sig, arg___strsignalbuf, arg___buflen)
    })
}
pub unsafe fn bcmp(
    arg_arg1: *const ::std::os::raw::c_void,
    arg_arg2: *const ::std::os::raw::c_void,
    arg_arg3: ::std::os::raw::c_ulong,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bcmp(
                arg_arg1: *const ::std::os::raw::c_void,
                arg_arg2: *const ::std::os::raw::c_void,
                arg_arg3: ::std::os::raw::c_ulong,
            ) -> ::std::os::raw::c_int;
        }
        bcmp(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn bcopy(
    arg_arg1: *const ::std::os::raw::c_void,
    arg_arg2: *mut ::std::os::raw::c_void,
    arg_arg3: usize,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bcopy(
                arg_arg1: *const ::std::os::raw::c_void,
                arg_arg2: *mut ::std::os::raw::c_void,
                arg_arg3: usize,
            );
        }
        bcopy(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn bzero(arg_arg1: *mut ::std::os::raw::c_void, arg_arg2: ::std::os::raw::c_ulong) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bzero(arg_arg1: *mut ::std::os::raw::c_void, arg_arg2: ::std::os::raw::c_ulong);
        }
        bzero(arg_arg1, arg_arg2)
    })
}
pub unsafe fn index(
    arg_arg1: *const ::std::os::raw::c_char,
    arg_arg2: ::std::os::raw::c_int,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index(
                arg_arg1: *const ::std::os::raw::c_char,
                arg_arg2: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_char;
        }
        index(arg_arg1, arg_arg2)
    })
}
pub unsafe fn rindex(
    arg_arg1: *const ::std::os::raw::c_char,
    arg_arg2: ::std::os::raw::c_int,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn rindex(
                arg_arg1: *const ::std::os::raw::c_char,
                arg_arg2: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_char;
        }
        rindex(arg_arg1, arg_arg2)
    })
}
pub unsafe fn ffs(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ffs(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        ffs(arg_arg1)
    })
}
pub unsafe fn strcasecmp(
    arg_arg1: *const ::std::os::raw::c_char,
    arg_arg2: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strcasecmp(
                arg_arg1: *const ::std::os::raw::c_char,
                arg_arg2: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        strcasecmp(arg_arg1, arg_arg2)
    })
}
pub unsafe fn strncasecmp(
    arg_arg1: *const ::std::os::raw::c_char,
    arg_arg2: *const ::std::os::raw::c_char,
    arg_arg3: ::std::os::raw::c_ulong,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strncasecmp(
                arg_arg1: *const ::std::os::raw::c_char,
                arg_arg2: *const ::std::os::raw::c_char,
                arg_arg3: ::std::os::raw::c_ulong,
            ) -> ::std::os::raw::c_int;
        }
        strncasecmp(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn ffsl(arg_arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ffsl(arg_arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
        }
        ffsl(arg_arg1)
    })
}
pub unsafe fn ffsll(arg_arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ffsll(arg_arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
        }
        ffsll(arg_arg1)
    })
}
pub unsafe fn fls(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fls(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        fls(arg_arg1)
    })
}
pub unsafe fn flsl(arg_arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn flsl(arg_arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
        }
        flsl(arg_arg1)
    })
}
pub unsafe fn flsll(arg_arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn flsll(arg_arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
        }
        flsll(arg_arg1)
    })
}
pub type max_align_t = f64;
pub type __gnuc_va_list = __builtin_va_list;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = i64;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type daddr_t = i32;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type ino_t = __darwin_ino_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type nlink_t = __uint16_t;
pub type segsz_t = i32;
pub type swblk_t = i32;
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
pub unsafe fn __darwin_check_fd_set_overflow(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: *const ::std::os::raw::c_void,
    arg_arg3: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn __darwin_check_fd_set_overflow(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: *const ::std::os::raw::c_void,
                arg_arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        __darwin_check_fd_set_overflow(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub type fd_mask = __int32_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = __darwin_pthread_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
pub unsafe fn __error() -> *mut ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn __error() -> *mut ::std::os::raw::c_int;
        }
        __error()
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lconv {
    pub decimal_point: *mut ::std::os::raw::c_char,
    pub thousands_sep: *mut ::std::os::raw::c_char,
    pub grouping: *mut ::std::os::raw::c_char,
    pub int_curr_symbol: *mut ::std::os::raw::c_char,
    pub currency_symbol: *mut ::std::os::raw::c_char,
    pub mon_decimal_point: *mut ::std::os::raw::c_char,
    pub mon_thousands_sep: *mut ::std::os::raw::c_char,
    pub mon_grouping: *mut ::std::os::raw::c_char,
    pub positive_sign: *mut ::std::os::raw::c_char,
    pub negative_sign: *mut ::std::os::raw::c_char,
    pub int_frac_digits: ::std::os::raw::c_char,
    pub frac_digits: ::std::os::raw::c_char,
    pub p_cs_precedes: ::std::os::raw::c_char,
    pub p_sep_by_space: ::std::os::raw::c_char,
    pub n_cs_precedes: ::std::os::raw::c_char,
    pub n_sep_by_space: ::std::os::raw::c_char,
    pub p_sign_posn: ::std::os::raw::c_char,
    pub n_sign_posn: ::std::os::raw::c_char,
    pub int_p_cs_precedes: ::std::os::raw::c_char,
    pub int_n_cs_precedes: ::std::os::raw::c_char,
    pub int_p_sep_by_space: ::std::os::raw::c_char,
    pub int_n_sep_by_space: ::std::os::raw::c_char,
    pub int_p_sign_posn: ::std::os::raw::c_char,
    pub int_n_sign_posn: ::std::os::raw::c_char,
}
impl Default for lconv {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn localeconv() -> *mut lconv {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn localeconv() -> *mut lconv;
        }
        localeconv()
    })
}
pub unsafe fn setlocale(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: *const ::std::os::raw::c_char,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn setlocale(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: *const ::std::os::raw::c_char,
            ) -> *mut ::std::os::raw::c_char;
        }
        setlocale(arg_arg1, arg_arg2)
    })
}
pub type Pointer = *mut ::std::os::raw::c_char;
pub type int8 = ::std::os::raw::c_schar;
pub type int16 = ::std::os::raw::c_short;
pub type int32 = ::std::os::raw::c_int;
pub type uint8 = ::std::os::raw::c_uchar;
pub type uint16 = ::std::os::raw::c_ushort;
pub type uint32 = ::std::os::raw::c_uint;
pub type bits8 = uint8;
pub type bits16 = uint16;
pub type bits32 = uint32;
pub type int64 = ::std::os::raw::c_long;
pub type uint64 = ::std::os::raw::c_ulong;
pub type int128 = i128;
pub type uint128 = u128;
pub type Size = usize;
pub type Index = ::std::os::raw::c_uint;
pub type Offset = ::std::os::raw::c_int;
pub type float4 = f32;
pub type float8 = f64;
pub type regproc = Oid;
pub type RegProcedure = regproc;
pub type TransactionId = uint32;
pub type LocalTransactionId = uint32;
pub type SubTransactionId = uint32;
pub type MultiXactId = TransactionId;
pub type MultiXactOffset = uint32;
pub type CommandId = uint32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IntArray {
    pub indx: [::std::os::raw::c_int; 6usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct varlena {
    pub vl_len_: [::std::os::raw::c_char; 4usize],
    pub vl_dat: __IncompleteArrayField<::std::os::raw::c_char>,
}
pub type bytea = varlena;
pub type text = varlena;
pub type BpChar = varlena;
pub type VarChar = varlena;
#[repr(C)]
#[derive(Debug, Default)]
pub struct int2vector {
    pub vl_len_: int32,
    pub ndim: ::std::os::raw::c_int,
    pub dataoffset: int32,
    pub elemtype: Oid,
    pub dim1: ::std::os::raw::c_int,
    pub lbound1: ::std::os::raw::c_int,
    pub values: __IncompleteArrayField<int16>,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct oidvector {
    pub vl_len_: int32,
    pub ndim: ::std::os::raw::c_int,
    pub dataoffset: int32,
    pub elemtype: Oid,
    pub dim1: ::std::os::raw::c_int,
    pub lbound1: ::std::os::raw::c_int,
    pub values: __IncompleteArrayField<Oid>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nameData {
    pub data: [::std::os::raw::c_char; 64usize],
}
impl Default for nameData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NameData = nameData;
pub type Name = *mut NameData;
pub unsafe fn ExceptionalCondition(
    arg_conditionName: *const ::std::os::raw::c_char,
    arg_errorType: *const ::std::os::raw::c_char,
    arg_fileName: *const ::std::os::raw::c_char,
    arg_lineNumber: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExceptionalCondition(
                arg_conditionName: *const ::std::os::raw::c_char,
                arg_errorType: *const ::std::os::raw::c_char,
                arg_fileName: *const ::std::os::raw::c_char,
                arg_lineNumber: ::std::os::raw::c_int,
            );
        }
        ExceptionalCondition(arg_conditionName, arg_errorType, arg_fileName, arg_lineNumber)
    })
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PGAlignedBlock {
    pub data: [::std::os::raw::c_char; 8192usize],
    pub force_align_d: f64,
    pub force_align_i64: int64,
}
impl Default for PGAlignedBlock {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PGAlignedXLogBlock {
    pub data: [::std::os::raw::c_char; 8192usize],
    pub force_align_d: f64,
    pub force_align_i64: int64,
}
impl Default for PGAlignedXLogBlock {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn fdatasync(arg_fildes: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fdatasync(arg_fildes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        fdatasync(arg_fildes)
    })
}
pub type wint_t = __darwin_wint_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneEntry {
    pub __min: __darwin_rune_t,
    pub __max: __darwin_rune_t,
    pub __map: __darwin_rune_t,
    pub __types: *mut __uint32_t,
}
impl Default for _RuneEntry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneRange {
    pub __nranges: ::std::os::raw::c_int,
    pub __ranges: *mut _RuneEntry,
}
impl Default for _RuneRange {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _RuneCharClass {
    pub __name: [::std::os::raw::c_char; 14usize],
    pub __mask: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneLocale {
    pub __magic: [::std::os::raw::c_char; 8usize],
    pub __encoding: [::std::os::raw::c_char; 32usize],
    pub __sgetrune: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: __darwin_size_t,
            arg3: *mut *const ::std::os::raw::c_char,
        ) -> __darwin_rune_t,
    >,
    pub __sputrune: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: __darwin_rune_t,
            arg2: *mut ::std::os::raw::c_char,
            arg3: __darwin_size_t,
            arg4: *mut *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub __invalid_rune: __darwin_rune_t,
    pub __runetype: [__uint32_t; 256usize],
    pub __maplower: [__darwin_rune_t; 256usize],
    pub __mapupper: [__darwin_rune_t; 256usize],
    pub __runetype_ext: _RuneRange,
    pub __maplower_ext: _RuneRange,
    pub __mapupper_ext: _RuneRange,
    pub __variable: *mut ::std::os::raw::c_void,
    pub __variable_len: ::std::os::raw::c_int,
    pub __ncharclasses: ::std::os::raw::c_int,
    pub __charclasses: *mut _RuneCharClass,
}
impl Default for _RuneLocale {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut _DefaultRuneLocale: _RuneLocale;
}
extern "C" {
    pub static mut _CurrentRuneLocale: *mut _RuneLocale;
}
pub unsafe fn ___runetype(arg_arg1: __darwin_ct_rune_t) -> ::std::os::raw::c_ulong {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ___runetype(arg_arg1: __darwin_ct_rune_t) -> ::std::os::raw::c_ulong;
        }
        ___runetype(arg_arg1)
    })
}
pub unsafe fn ___tolower(arg_arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ___tolower(arg_arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
        }
        ___tolower(arg_arg1)
    })
}
pub unsafe fn ___toupper(arg_arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ___toupper(arg_arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
        }
        ___toupper(arg_arg1)
    })
}
pub unsafe fn __maskrune(
    arg_arg1: __darwin_ct_rune_t,
    arg_arg2: ::std::os::raw::c_ulong,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn __maskrune(
                arg_arg1: __darwin_ct_rune_t,
                arg_arg2: ::std::os::raw::c_ulong,
            ) -> ::std::os::raw::c_int;
        }
        __maskrune(arg_arg1, arg_arg2)
    })
}
pub unsafe fn __toupper(arg_arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn __toupper(arg_arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
        }
        __toupper(arg_arg1)
    })
}
pub unsafe fn __tolower(arg_arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn __tolower(arg_arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
        }
        __tolower(arg_arg1)
    })
}
pub type socklen_t = __darwin_socklen_t;
pub type sa_family_t = __uint8_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
impl Default for iovec {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type sae_associd_t = __uint32_t;
pub type sae_connid_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sa_endpoints {
    pub sae_srcif: ::std::os::raw::c_uint,
    pub sae_srcaddr: *const sockaddr,
    pub sae_srcaddrlen: socklen_t,
    pub sae_dstaddr: *const sockaddr,
    pub sae_dstaddrlen: socklen_t,
}
impl Default for sa_endpoints {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type sa_endpoints_t = sa_endpoints;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct so_np_extensions {
    pub npx_flags: u_int32_t,
    pub npx_mask: u_int32_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr {
    pub sa_len: __uint8_t,
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockproto {
    pub sp_family: __uint16_t,
    pub sp_protocol: __uint16_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_len: __uint8_t,
    pub ss_family: sa_family_t,
    pub __ss_pad1: [::std::os::raw::c_char; 6usize],
    pub __ss_align: __int64_t,
    pub __ss_pad2: [::std::os::raw::c_char; 112usize],
}
impl Default for sockaddr_storage {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: ::std::os::raw::c_int,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: socklen_t,
    pub msg_flags: ::std::os::raw::c_int,
}
impl Default for msghdr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cmsghdr {
    pub cmsg_len: socklen_t,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sf_hdtr {
    pub headers: *mut iovec,
    pub hdr_cnt: ::std::os::raw::c_int,
    pub trailers: *mut iovec,
    pub trl_cnt: ::std::os::raw::c_int,
}
impl Default for sf_hdtr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn accept(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: *mut sockaddr,
    arg_arg3: *mut socklen_t,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn accept(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: *mut sockaddr,
                arg_arg3: *mut socklen_t,
            ) -> ::std::os::raw::c_int;
        }
        accept(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn bind(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: *const sockaddr,
    arg_arg3: socklen_t,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bind(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: *const sockaddr,
                arg_arg3: socklen_t,
            ) -> ::std::os::raw::c_int;
        }
        bind(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn connect(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: *const sockaddr,
    arg_arg3: socklen_t,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn connect(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: *const sockaddr,
                arg_arg3: socklen_t,
            ) -> ::std::os::raw::c_int;
        }
        connect(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn getpeername(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: *mut sockaddr,
    arg_arg3: *mut socklen_t,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getpeername(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: *mut sockaddr,
                arg_arg3: *mut socklen_t,
            ) -> ::std::os::raw::c_int;
        }
        getpeername(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn getsockname(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: *mut sockaddr,
    arg_arg3: *mut socklen_t,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getsockname(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: *mut sockaddr,
                arg_arg3: *mut socklen_t,
            ) -> ::std::os::raw::c_int;
        }
        getsockname(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn getsockopt(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: ::std::os::raw::c_int,
    arg_arg3: ::std::os::raw::c_int,
    arg_arg4: *mut ::std::os::raw::c_void,
    arg_arg5: *mut socklen_t,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getsockopt(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: ::std::os::raw::c_int,
                arg_arg3: ::std::os::raw::c_int,
                arg_arg4: *mut ::std::os::raw::c_void,
                arg_arg5: *mut socklen_t,
            ) -> ::std::os::raw::c_int;
        }
        getsockopt(arg_arg1, arg_arg2, arg_arg3, arg_arg4, arg_arg5)
    })
}
pub unsafe fn listen(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn listen(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        listen(arg_arg1, arg_arg2)
    })
}
pub unsafe fn recv(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: *mut ::std::os::raw::c_void,
    arg_arg3: usize,
    arg_arg4: ::std::os::raw::c_int,
) -> isize {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn recv(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: *mut ::std::os::raw::c_void,
                arg_arg3: usize,
                arg_arg4: ::std::os::raw::c_int,
            ) -> isize;
        }
        recv(arg_arg1, arg_arg2, arg_arg3, arg_arg4)
    })
}
pub unsafe fn recvfrom(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: *mut ::std::os::raw::c_void,
    arg_arg3: usize,
    arg_arg4: ::std::os::raw::c_int,
    arg_arg5: *mut sockaddr,
    arg_arg6: *mut socklen_t,
) -> isize {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn recvfrom(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: *mut ::std::os::raw::c_void,
                arg_arg3: usize,
                arg_arg4: ::std::os::raw::c_int,
                arg_arg5: *mut sockaddr,
                arg_arg6: *mut socklen_t,
            ) -> isize;
        }
        recvfrom(arg_arg1, arg_arg2, arg_arg3, arg_arg4, arg_arg5, arg_arg6)
    })
}
pub unsafe fn recvmsg(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: *mut msghdr,
    arg_arg3: ::std::os::raw::c_int,
) -> isize {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn recvmsg(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: *mut msghdr,
                arg_arg3: ::std::os::raw::c_int,
            ) -> isize;
        }
        recvmsg(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn send(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: *const ::std::os::raw::c_void,
    arg_arg3: usize,
    arg_arg4: ::std::os::raw::c_int,
) -> isize {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn send(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: *const ::std::os::raw::c_void,
                arg_arg3: usize,
                arg_arg4: ::std::os::raw::c_int,
            ) -> isize;
        }
        send(arg_arg1, arg_arg2, arg_arg3, arg_arg4)
    })
}
pub unsafe fn sendmsg(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: *const msghdr,
    arg_arg3: ::std::os::raw::c_int,
) -> isize {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sendmsg(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: *const msghdr,
                arg_arg3: ::std::os::raw::c_int,
            ) -> isize;
        }
        sendmsg(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn sendto(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: *const ::std::os::raw::c_void,
    arg_arg3: usize,
    arg_arg4: ::std::os::raw::c_int,
    arg_arg5: *const sockaddr,
    arg_arg6: socklen_t,
) -> isize {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sendto(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: *const ::std::os::raw::c_void,
                arg_arg3: usize,
                arg_arg4: ::std::os::raw::c_int,
                arg_arg5: *const sockaddr,
                arg_arg6: socklen_t,
            ) -> isize;
        }
        sendto(arg_arg1, arg_arg2, arg_arg3, arg_arg4, arg_arg5, arg_arg6)
    })
}
pub unsafe fn setsockopt(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: ::std::os::raw::c_int,
    arg_arg3: ::std::os::raw::c_int,
    arg_arg4: *const ::std::os::raw::c_void,
    arg_arg5: socklen_t,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn setsockopt(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: ::std::os::raw::c_int,
                arg_arg3: ::std::os::raw::c_int,
                arg_arg4: *const ::std::os::raw::c_void,
                arg_arg5: socklen_t,
            ) -> ::std::os::raw::c_int;
        }
        setsockopt(arg_arg1, arg_arg2, arg_arg3, arg_arg4, arg_arg5)
    })
}
pub unsafe fn shutdown(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn shutdown(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        shutdown(arg_arg1, arg_arg2)
    })
}
pub unsafe fn sockatmark(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sockatmark(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        sockatmark(arg_arg1)
    })
}
pub unsafe fn socket(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: ::std::os::raw::c_int,
    arg_arg3: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn socket(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: ::std::os::raw::c_int,
                arg_arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        socket(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn socketpair(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: ::std::os::raw::c_int,
    arg_arg3: ::std::os::raw::c_int,
    arg_arg4: *mut ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn socketpair(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: ::std::os::raw::c_int,
                arg_arg3: ::std::os::raw::c_int,
                arg_arg4: *mut ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        socketpair(arg_arg1, arg_arg2, arg_arg3, arg_arg4)
    })
}
pub unsafe fn sendfile(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: ::std::os::raw::c_int,
    arg_arg3: off_t,
    arg_arg4: *mut off_t,
    arg_arg5: *mut sf_hdtr,
    arg_arg6: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sendfile(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: ::std::os::raw::c_int,
                arg_arg3: off_t,
                arg_arg4: *mut off_t,
                arg_arg5: *mut sf_hdtr,
                arg_arg6: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        sendfile(arg_arg1, arg_arg2, arg_arg3, arg_arg4, arg_arg5, arg_arg6)
    })
}
pub unsafe fn pfctlinput(arg_arg1: ::std::os::raw::c_int, arg_arg2: *mut sockaddr) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pfctlinput(arg_arg1: ::std::os::raw::c_int, arg_arg2: *mut sockaddr);
        }
        pfctlinput(arg_arg1, arg_arg2)
    })
}
pub unsafe fn connectx(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: *const sa_endpoints_t,
    arg_arg3: sae_associd_t,
    arg_arg4: ::std::os::raw::c_uint,
    arg_arg5: *const iovec,
    arg_arg6: ::std::os::raw::c_uint,
    arg_arg7: *mut usize,
    arg_arg8: *mut sae_connid_t,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn connectx(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: *const sa_endpoints_t,
                arg_arg3: sae_associd_t,
                arg_arg4: ::std::os::raw::c_uint,
                arg_arg5: *const iovec,
                arg_arg6: ::std::os::raw::c_uint,
                arg_arg7: *mut usize,
                arg_arg8: *mut sae_connid_t,
            ) -> ::std::os::raw::c_int;
        }
        connectx(arg_arg1, arg_arg2, arg_arg3, arg_arg4, arg_arg5, arg_arg6, arg_arg7, arg_arg8)
    })
}
pub unsafe fn disconnectx(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: sae_associd_t,
    arg_arg3: sae_connid_t,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn disconnectx(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: sae_associd_t,
                arg_arg3: sae_connid_t,
            ) -> ::std::os::raw::c_int;
        }
        disconnectx(arg_arg1, arg_arg2, arg_arg3)
    })
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_len: __uint8_t,
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_char; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_opts {
    pub ip_dst: in_addr,
    pub ip_opts: [::std::os::raw::c_char; 40usize],
}
impl Default for ip_opts {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_sourceaddr: in_addr,
    pub imr_interface: in_addr,
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct group_req {
    pub gr_interface: u32,
    pub gr_group: sockaddr_storage,
}
impl Default for group_req {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct group_source_req {
    pub gsr_interface: u32,
    pub gsr_group: sockaddr_storage,
    pub gsr_source: sockaddr_storage,
}
impl Default for group_source_req {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct __msfilterreq {
    pub msfr_ifindex: u32,
    pub msfr_fmode: u32,
    pub msfr_nsrcs: u32,
    pub __msfr_align: u32,
    pub msfr_group: sockaddr_storage,
    pub msfr_srcs: *mut sockaddr_storage,
}
impl Default for __msfilterreq {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn setipv4sourcefilter(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: in_addr,
    arg_arg3: in_addr,
    arg_arg4: u32,
    arg_arg5: u32,
    arg_arg6: *mut in_addr,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn setipv4sourcefilter(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: in_addr,
                arg_arg3: in_addr,
                arg_arg4: u32,
                arg_arg5: u32,
                arg_arg6: *mut in_addr,
            ) -> ::std::os::raw::c_int;
        }
        setipv4sourcefilter(arg_arg1, arg_arg2, arg_arg3, arg_arg4, arg_arg5, arg_arg6)
    })
}
pub unsafe fn getipv4sourcefilter(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: in_addr,
    arg_arg3: in_addr,
    arg_arg4: *mut u32,
    arg_arg5: *mut u32,
    arg_arg6: *mut in_addr,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getipv4sourcefilter(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: in_addr,
                arg_arg3: in_addr,
                arg_arg4: *mut u32,
                arg_arg5: *mut u32,
                arg_arg6: *mut in_addr,
            ) -> ::std::os::raw::c_int;
        }
        getipv4sourcefilter(arg_arg1, arg_arg2, arg_arg3, arg_arg4, arg_arg5, arg_arg6)
    })
}
pub unsafe fn setsourcefilter(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: u32,
    arg_arg3: *mut sockaddr,
    arg_arg4: socklen_t,
    arg_arg5: u32,
    arg_arg6: u32,
    arg_arg7: *mut sockaddr_storage,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn setsourcefilter(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: u32,
                arg_arg3: *mut sockaddr,
                arg_arg4: socklen_t,
                arg_arg5: u32,
                arg_arg6: u32,
                arg_arg7: *mut sockaddr_storage,
            ) -> ::std::os::raw::c_int;
        }
        setsourcefilter(arg_arg1, arg_arg2, arg_arg3, arg_arg4, arg_arg5, arg_arg6, arg_arg7)
    })
}
pub unsafe fn getsourcefilter(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: u32,
    arg_arg3: *mut sockaddr,
    arg_arg4: socklen_t,
    arg_arg5: *mut u32,
    arg_arg6: *mut u32,
    arg_arg7: *mut sockaddr_storage,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getsourcefilter(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: u32,
                arg_arg3: *mut sockaddr,
                arg_arg4: socklen_t,
                arg_arg5: *mut u32,
                arg_arg6: *mut u32,
                arg_arg7: *mut sockaddr_storage,
            ) -> ::std::os::raw::c_int;
        }
        getsourcefilter(arg_arg1, arg_arg2, arg_arg3, arg_arg4, arg_arg5, arg_arg6, arg_arg7)
    })
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_uint,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __u6_addr: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [__uint8_t; 16usize],
    pub __u6_addr16: [__uint16_t; 8usize],
    pub __u6_addr32: [__uint32_t; 4usize],
}
impl Default for in6_addr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for in6_addr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type in6_addr_t = in6_addr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_len: __uint8_t,
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: __uint32_t,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: __uint32_t,
}
impl Default for sockaddr_in6 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static in6addr_any: in6_addr;
}
extern "C" {
    pub static in6addr_loopback: in6_addr;
}
extern "C" {
    pub static in6addr_nodelocal_allnodes: in6_addr;
}
extern "C" {
    pub static in6addr_linklocal_allnodes: in6_addr;
}
extern "C" {
    pub static in6addr_linklocal_allrouters: in6_addr;
}
extern "C" {
    pub static in6addr_linklocal_allv2routers: in6_addr;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::std::os::raw::c_uint,
}
impl Default for ipv6_mreq {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_pktinfo {
    pub ipi6_addr: in6_addr,
    pub ipi6_ifindex: ::std::os::raw::c_uint,
}
impl Default for in6_pktinfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_mtuinfo {
    pub ip6m_addr: sockaddr_in6,
    pub ip6m_mtu: u32,
}
impl Default for ip6_mtuinfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn inet6_option_space(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet6_option_space(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        inet6_option_space(arg_arg1)
    })
}
pub unsafe fn inet6_option_init(
    arg_arg1: *mut ::std::os::raw::c_void,
    arg_arg2: *mut *mut cmsghdr,
    arg_arg3: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet6_option_init(
                arg_arg1: *mut ::std::os::raw::c_void,
                arg_arg2: *mut *mut cmsghdr,
                arg_arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        inet6_option_init(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn inet6_option_append(
    arg_arg1: *mut cmsghdr,
    arg_arg2: *const __uint8_t,
    arg_arg3: ::std::os::raw::c_int,
    arg_arg4: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet6_option_append(
                arg_arg1: *mut cmsghdr,
                arg_arg2: *const __uint8_t,
                arg_arg3: ::std::os::raw::c_int,
                arg_arg4: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        inet6_option_append(arg_arg1, arg_arg2, arg_arg3, arg_arg4)
    })
}
pub unsafe fn inet6_option_alloc(
    arg_arg1: *mut cmsghdr,
    arg_arg2: ::std::os::raw::c_int,
    arg_arg3: ::std::os::raw::c_int,
    arg_arg4: ::std::os::raw::c_int,
) -> *mut __uint8_t {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet6_option_alloc(
                arg_arg1: *mut cmsghdr,
                arg_arg2: ::std::os::raw::c_int,
                arg_arg3: ::std::os::raw::c_int,
                arg_arg4: ::std::os::raw::c_int,
            ) -> *mut __uint8_t;
        }
        inet6_option_alloc(arg_arg1, arg_arg2, arg_arg3, arg_arg4)
    })
}
pub unsafe fn inet6_option_next(
    arg_arg1: *const cmsghdr,
    arg_arg2: *mut *mut __uint8_t,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet6_option_next(
                arg_arg1: *const cmsghdr,
                arg_arg2: *mut *mut __uint8_t,
            ) -> ::std::os::raw::c_int;
        }
        inet6_option_next(arg_arg1, arg_arg2)
    })
}
pub unsafe fn inet6_option_find(
    arg_arg1: *const cmsghdr,
    arg_arg2: *mut *mut __uint8_t,
    arg_arg3: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet6_option_find(
                arg_arg1: *const cmsghdr,
                arg_arg2: *mut *mut __uint8_t,
                arg_arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        inet6_option_find(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn inet6_rthdr_space(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: ::std::os::raw::c_int,
) -> usize {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet6_rthdr_space(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: ::std::os::raw::c_int,
            ) -> usize;
        }
        inet6_rthdr_space(arg_arg1, arg_arg2)
    })
}
pub unsafe fn inet6_rthdr_init(
    arg_arg1: *mut ::std::os::raw::c_void,
    arg_arg2: ::std::os::raw::c_int,
) -> *mut cmsghdr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet6_rthdr_init(
                arg_arg1: *mut ::std::os::raw::c_void,
                arg_arg2: ::std::os::raw::c_int,
            ) -> *mut cmsghdr;
        }
        inet6_rthdr_init(arg_arg1, arg_arg2)
    })
}
pub unsafe fn inet6_rthdr_add(
    arg_arg1: *mut cmsghdr,
    arg_arg2: *const in6_addr,
    arg_arg3: ::std::os::raw::c_uint,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet6_rthdr_add(
                arg_arg1: *mut cmsghdr,
                arg_arg2: *const in6_addr,
                arg_arg3: ::std::os::raw::c_uint,
            ) -> ::std::os::raw::c_int;
        }
        inet6_rthdr_add(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn inet6_rthdr_lasthop(
    arg_arg1: *mut cmsghdr,
    arg_arg2: ::std::os::raw::c_uint,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet6_rthdr_lasthop(
                arg_arg1: *mut cmsghdr,
                arg_arg2: ::std::os::raw::c_uint,
            ) -> ::std::os::raw::c_int;
        }
        inet6_rthdr_lasthop(arg_arg1, arg_arg2)
    })
}
pub unsafe fn inet6_rthdr_segments(arg_arg1: *const cmsghdr) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet6_rthdr_segments(arg_arg1: *const cmsghdr) -> ::std::os::raw::c_int;
        }
        inet6_rthdr_segments(arg_arg1)
    })
}
pub unsafe fn inet6_rthdr_getaddr(
    arg_arg1: *mut cmsghdr,
    arg_arg2: ::std::os::raw::c_int,
) -> *mut in6_addr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet6_rthdr_getaddr(
                arg_arg1: *mut cmsghdr,
                arg_arg2: ::std::os::raw::c_int,
            ) -> *mut in6_addr;
        }
        inet6_rthdr_getaddr(arg_arg1, arg_arg2)
    })
}
pub unsafe fn inet6_rthdr_getflags(
    arg_arg1: *const cmsghdr,
    arg_arg2: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet6_rthdr_getflags(
                arg_arg1: *const cmsghdr,
                arg_arg2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        inet6_rthdr_getflags(arg_arg1, arg_arg2)
    })
}
pub unsafe fn inet6_opt_init(
    arg_arg1: *mut ::std::os::raw::c_void,
    arg_arg2: socklen_t,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet6_opt_init(
                arg_arg1: *mut ::std::os::raw::c_void,
                arg_arg2: socklen_t,
            ) -> ::std::os::raw::c_int;
        }
        inet6_opt_init(arg_arg1, arg_arg2)
    })
}
pub unsafe fn inet6_opt_append(
    arg_arg1: *mut ::std::os::raw::c_void,
    arg_arg2: socklen_t,
    arg_arg3: ::std::os::raw::c_int,
    arg_arg4: __uint8_t,
    arg_arg5: socklen_t,
    arg_arg6: __uint8_t,
    arg_arg7: *mut *mut ::std::os::raw::c_void,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet6_opt_append(
                arg_arg1: *mut ::std::os::raw::c_void,
                arg_arg2: socklen_t,
                arg_arg3: ::std::os::raw::c_int,
                arg_arg4: __uint8_t,
                arg_arg5: socklen_t,
                arg_arg6: __uint8_t,
                arg_arg7: *mut *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int;
        }
        inet6_opt_append(arg_arg1, arg_arg2, arg_arg3, arg_arg4, arg_arg5, arg_arg6, arg_arg7)
    })
}
pub unsafe fn inet6_opt_finish(
    arg_arg1: *mut ::std::os::raw::c_void,
    arg_arg2: socklen_t,
    arg_arg3: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet6_opt_finish(
                arg_arg1: *mut ::std::os::raw::c_void,
                arg_arg2: socklen_t,
                arg_arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        inet6_opt_finish(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn inet6_opt_set_val(
    arg_arg1: *mut ::std::os::raw::c_void,
    arg_arg2: ::std::os::raw::c_int,
    arg_arg3: *mut ::std::os::raw::c_void,
    arg_arg4: socklen_t,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet6_opt_set_val(
                arg_arg1: *mut ::std::os::raw::c_void,
                arg_arg2: ::std::os::raw::c_int,
                arg_arg3: *mut ::std::os::raw::c_void,
                arg_arg4: socklen_t,
            ) -> ::std::os::raw::c_int;
        }
        inet6_opt_set_val(arg_arg1, arg_arg2, arg_arg3, arg_arg4)
    })
}
pub unsafe fn inet6_opt_next(
    arg_arg1: *mut ::std::os::raw::c_void,
    arg_arg2: socklen_t,
    arg_arg3: ::std::os::raw::c_int,
    arg_arg4: *mut __uint8_t,
    arg_arg5: *mut socklen_t,
    arg_arg6: *mut *mut ::std::os::raw::c_void,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet6_opt_next(
                arg_arg1: *mut ::std::os::raw::c_void,
                arg_arg2: socklen_t,
                arg_arg3: ::std::os::raw::c_int,
                arg_arg4: *mut __uint8_t,
                arg_arg5: *mut socklen_t,
                arg_arg6: *mut *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int;
        }
        inet6_opt_next(arg_arg1, arg_arg2, arg_arg3, arg_arg4, arg_arg5, arg_arg6)
    })
}
pub unsafe fn inet6_opt_find(
    arg_arg1: *mut ::std::os::raw::c_void,
    arg_arg2: socklen_t,
    arg_arg3: ::std::os::raw::c_int,
    arg_arg4: __uint8_t,
    arg_arg5: *mut socklen_t,
    arg_arg6: *mut *mut ::std::os::raw::c_void,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet6_opt_find(
                arg_arg1: *mut ::std::os::raw::c_void,
                arg_arg2: socklen_t,
                arg_arg3: ::std::os::raw::c_int,
                arg_arg4: __uint8_t,
                arg_arg5: *mut socklen_t,
                arg_arg6: *mut *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int;
        }
        inet6_opt_find(arg_arg1, arg_arg2, arg_arg3, arg_arg4, arg_arg5, arg_arg6)
    })
}
pub unsafe fn inet6_opt_get_val(
    arg_arg1: *mut ::std::os::raw::c_void,
    arg_arg2: ::std::os::raw::c_int,
    arg_arg3: *mut ::std::os::raw::c_void,
    arg_arg4: socklen_t,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet6_opt_get_val(
                arg_arg1: *mut ::std::os::raw::c_void,
                arg_arg2: ::std::os::raw::c_int,
                arg_arg3: *mut ::std::os::raw::c_void,
                arg_arg4: socklen_t,
            ) -> ::std::os::raw::c_int;
        }
        inet6_opt_get_val(arg_arg1, arg_arg2, arg_arg3, arg_arg4)
    })
}
pub unsafe fn inet6_rth_space(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: ::std::os::raw::c_int,
) -> socklen_t {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet6_rth_space(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: ::std::os::raw::c_int,
            ) -> socklen_t;
        }
        inet6_rth_space(arg_arg1, arg_arg2)
    })
}
pub unsafe fn inet6_rth_init(
    arg_arg1: *mut ::std::os::raw::c_void,
    arg_arg2: socklen_t,
    arg_arg3: ::std::os::raw::c_int,
    arg_arg4: ::std::os::raw::c_int,
) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet6_rth_init(
                arg_arg1: *mut ::std::os::raw::c_void,
                arg_arg2: socklen_t,
                arg_arg3: ::std::os::raw::c_int,
                arg_arg4: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_void;
        }
        inet6_rth_init(arg_arg1, arg_arg2, arg_arg3, arg_arg4)
    })
}
pub unsafe fn inet6_rth_add(
    arg_arg1: *mut ::std::os::raw::c_void,
    arg_arg2: *const in6_addr,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet6_rth_add(
                arg_arg1: *mut ::std::os::raw::c_void,
                arg_arg2: *const in6_addr,
            ) -> ::std::os::raw::c_int;
        }
        inet6_rth_add(arg_arg1, arg_arg2)
    })
}
pub unsafe fn inet6_rth_reverse(
    arg_arg1: *const ::std::os::raw::c_void,
    arg_arg2: *mut ::std::os::raw::c_void,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet6_rth_reverse(
                arg_arg1: *const ::std::os::raw::c_void,
                arg_arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int;
        }
        inet6_rth_reverse(arg_arg1, arg_arg2)
    })
}
pub unsafe fn inet6_rth_segments(arg_arg1: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet6_rth_segments(arg_arg1: *const ::std::os::raw::c_void)
                -> ::std::os::raw::c_int;
        }
        inet6_rth_segments(arg_arg1)
    })
}
pub unsafe fn inet6_rth_getaddr(
    arg_arg1: *const ::std::os::raw::c_void,
    arg_arg2: ::std::os::raw::c_int,
) -> *mut in6_addr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet6_rth_getaddr(
                arg_arg1: *const ::std::os::raw::c_void,
                arg_arg2: ::std::os::raw::c_int,
            ) -> *mut in6_addr;
        }
        inet6_rth_getaddr(arg_arg1, arg_arg2)
    })
}
pub unsafe fn bindresvport(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: *mut sockaddr_in,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bindresvport(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: *mut sockaddr_in,
            ) -> ::std::os::raw::c_int;
        }
        bindresvport(arg_arg1, arg_arg2)
    })
}
pub unsafe fn bindresvport_sa(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: *mut sockaddr,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bindresvport_sa(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: *mut sockaddr,
            ) -> ::std::os::raw::c_int;
        }
        bindresvport_sa(arg_arg1, arg_arg2)
    })
}
extern "C" {
    pub static mut h_errno: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hostent {
    pub h_name: *mut ::std::os::raw::c_char,
    pub h_aliases: *mut *mut ::std::os::raw::c_char,
    pub h_addrtype: ::std::os::raw::c_int,
    pub h_length: ::std::os::raw::c_int,
    pub h_addr_list: *mut *mut ::std::os::raw::c_char,
}
impl Default for hostent {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netent {
    pub n_name: *mut ::std::os::raw::c_char,
    pub n_aliases: *mut *mut ::std::os::raw::c_char,
    pub n_addrtype: ::std::os::raw::c_int,
    pub n_net: u32,
}
impl Default for netent {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct servent {
    pub s_name: *mut ::std::os::raw::c_char,
    pub s_aliases: *mut *mut ::std::os::raw::c_char,
    pub s_port: ::std::os::raw::c_int,
    pub s_proto: *mut ::std::os::raw::c_char,
}
impl Default for servent {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct protoent {
    pub p_name: *mut ::std::os::raw::c_char,
    pub p_aliases: *mut *mut ::std::os::raw::c_char,
    pub p_proto: ::std::os::raw::c_int,
}
impl Default for protoent {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct addrinfo {
    pub ai_flags: ::std::os::raw::c_int,
    pub ai_family: ::std::os::raw::c_int,
    pub ai_socktype: ::std::os::raw::c_int,
    pub ai_protocol: ::std::os::raw::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_canonname: *mut ::std::os::raw::c_char,
    pub ai_addr: *mut sockaddr,
    pub ai_next: *mut addrinfo,
}
impl Default for addrinfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpcent {
    pub r_name: *mut ::std::os::raw::c_char,
    pub r_aliases: *mut *mut ::std::os::raw::c_char,
    pub r_number: ::std::os::raw::c_int,
}
impl Default for rpcent {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn endhostent() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn endhostent();
        }
        endhostent()
    })
}
pub unsafe fn endnetent() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn endnetent();
        }
        endnetent()
    })
}
pub unsafe fn endprotoent() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn endprotoent();
        }
        endprotoent()
    })
}
pub unsafe fn endservent() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn endservent();
        }
        endservent()
    })
}
pub unsafe fn freeaddrinfo(arg_arg1: *mut addrinfo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn freeaddrinfo(arg_arg1: *mut addrinfo);
        }
        freeaddrinfo(arg_arg1)
    })
}
pub unsafe fn gai_strerror(arg_arg1: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gai_strerror(arg_arg1: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
        }
        gai_strerror(arg_arg1)
    })
}
pub unsafe fn getaddrinfo(
    arg_arg1: *const ::std::os::raw::c_char,
    arg_arg2: *const ::std::os::raw::c_char,
    arg_arg3: *const addrinfo,
    arg_arg4: *mut *mut addrinfo,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getaddrinfo(
                arg_arg1: *const ::std::os::raw::c_char,
                arg_arg2: *const ::std::os::raw::c_char,
                arg_arg3: *const addrinfo,
                arg_arg4: *mut *mut addrinfo,
            ) -> ::std::os::raw::c_int;
        }
        getaddrinfo(arg_arg1, arg_arg2, arg_arg3, arg_arg4)
    })
}
pub unsafe fn gethostbyaddr(
    arg_arg1: *const ::std::os::raw::c_void,
    arg_arg2: socklen_t,
    arg_arg3: ::std::os::raw::c_int,
) -> *mut hostent {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gethostbyaddr(
                arg_arg1: *const ::std::os::raw::c_void,
                arg_arg2: socklen_t,
                arg_arg3: ::std::os::raw::c_int,
            ) -> *mut hostent;
        }
        gethostbyaddr(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn gethostbyname(arg_arg1: *const ::std::os::raw::c_char) -> *mut hostent {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gethostbyname(arg_arg1: *const ::std::os::raw::c_char) -> *mut hostent;
        }
        gethostbyname(arg_arg1)
    })
}
pub unsafe fn gethostent() -> *mut hostent {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gethostent() -> *mut hostent;
        }
        gethostent()
    })
}
pub unsafe fn getnameinfo(
    arg_arg1: *const sockaddr,
    arg_arg2: socklen_t,
    arg_arg3: *mut ::std::os::raw::c_char,
    arg_arg4: socklen_t,
    arg_arg5: *mut ::std::os::raw::c_char,
    arg_arg6: socklen_t,
    arg_arg7: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getnameinfo(
                arg_arg1: *const sockaddr,
                arg_arg2: socklen_t,
                arg_arg3: *mut ::std::os::raw::c_char,
                arg_arg4: socklen_t,
                arg_arg5: *mut ::std::os::raw::c_char,
                arg_arg6: socklen_t,
                arg_arg7: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        getnameinfo(arg_arg1, arg_arg2, arg_arg3, arg_arg4, arg_arg5, arg_arg6, arg_arg7)
    })
}
pub unsafe fn getnetbyaddr(arg_arg1: u32, arg_arg2: ::std::os::raw::c_int) -> *mut netent {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getnetbyaddr(arg_arg1: u32, arg_arg2: ::std::os::raw::c_int) -> *mut netent;
        }
        getnetbyaddr(arg_arg1, arg_arg2)
    })
}
pub unsafe fn getnetbyname(arg_arg1: *const ::std::os::raw::c_char) -> *mut netent {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getnetbyname(arg_arg1: *const ::std::os::raw::c_char) -> *mut netent;
        }
        getnetbyname(arg_arg1)
    })
}
pub unsafe fn getnetent() -> *mut netent {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getnetent() -> *mut netent;
        }
        getnetent()
    })
}
pub unsafe fn getprotobyname(arg_arg1: *const ::std::os::raw::c_char) -> *mut protoent {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getprotobyname(arg_arg1: *const ::std::os::raw::c_char) -> *mut protoent;
        }
        getprotobyname(arg_arg1)
    })
}
pub unsafe fn getprotobynumber(arg_arg1: ::std::os::raw::c_int) -> *mut protoent {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getprotobynumber(arg_arg1: ::std::os::raw::c_int) -> *mut protoent;
        }
        getprotobynumber(arg_arg1)
    })
}
pub unsafe fn getprotoent() -> *mut protoent {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getprotoent() -> *mut protoent;
        }
        getprotoent()
    })
}
pub unsafe fn getservbyname(
    arg_arg1: *const ::std::os::raw::c_char,
    arg_arg2: *const ::std::os::raw::c_char,
) -> *mut servent {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getservbyname(
                arg_arg1: *const ::std::os::raw::c_char,
                arg_arg2: *const ::std::os::raw::c_char,
            ) -> *mut servent;
        }
        getservbyname(arg_arg1, arg_arg2)
    })
}
pub unsafe fn getservbyport(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: *const ::std::os::raw::c_char,
) -> *mut servent {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getservbyport(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: *const ::std::os::raw::c_char,
            ) -> *mut servent;
        }
        getservbyport(arg_arg1, arg_arg2)
    })
}
pub unsafe fn getservent() -> *mut servent {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getservent() -> *mut servent;
        }
        getservent()
    })
}
pub unsafe fn sethostent(arg_arg1: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sethostent(arg_arg1: ::std::os::raw::c_int);
        }
        sethostent(arg_arg1)
    })
}
pub unsafe fn setnetent(arg_arg1: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn setnetent(arg_arg1: ::std::os::raw::c_int);
        }
        setnetent(arg_arg1)
    })
}
pub unsafe fn setprotoent(arg_arg1: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn setprotoent(arg_arg1: ::std::os::raw::c_int);
        }
        setprotoent(arg_arg1)
    })
}
pub unsafe fn setservent(arg_arg1: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn setservent(arg_arg1: ::std::os::raw::c_int);
        }
        setservent(arg_arg1)
    })
}
pub unsafe fn freehostent(arg_arg1: *mut hostent) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn freehostent(arg_arg1: *mut hostent);
        }
        freehostent(arg_arg1)
    })
}
pub unsafe fn gethostbyname2(
    arg_arg1: *const ::std::os::raw::c_char,
    arg_arg2: ::std::os::raw::c_int,
) -> *mut hostent {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gethostbyname2(
                arg_arg1: *const ::std::os::raw::c_char,
                arg_arg2: ::std::os::raw::c_int,
            ) -> *mut hostent;
        }
        gethostbyname2(arg_arg1, arg_arg2)
    })
}
pub unsafe fn getipnodebyaddr(
    arg_arg1: *const ::std::os::raw::c_void,
    arg_arg2: usize,
    arg_arg3: ::std::os::raw::c_int,
    arg_arg4: *mut ::std::os::raw::c_int,
) -> *mut hostent {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getipnodebyaddr(
                arg_arg1: *const ::std::os::raw::c_void,
                arg_arg2: usize,
                arg_arg3: ::std::os::raw::c_int,
                arg_arg4: *mut ::std::os::raw::c_int,
            ) -> *mut hostent;
        }
        getipnodebyaddr(arg_arg1, arg_arg2, arg_arg3, arg_arg4)
    })
}
pub unsafe fn getipnodebyname(
    arg_arg1: *const ::std::os::raw::c_char,
    arg_arg2: ::std::os::raw::c_int,
    arg_arg3: ::std::os::raw::c_int,
    arg_arg4: *mut ::std::os::raw::c_int,
) -> *mut hostent {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getipnodebyname(
                arg_arg1: *const ::std::os::raw::c_char,
                arg_arg2: ::std::os::raw::c_int,
                arg_arg3: ::std::os::raw::c_int,
                arg_arg4: *mut ::std::os::raw::c_int,
            ) -> *mut hostent;
        }
        getipnodebyname(arg_arg1, arg_arg2, arg_arg3, arg_arg4)
    })
}
pub unsafe fn getrpcbyname(arg_name: *const ::std::os::raw::c_char) -> *mut rpcent {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getrpcbyname(arg_name: *const ::std::os::raw::c_char) -> *mut rpcent;
        }
        getrpcbyname(arg_name)
    })
}
pub unsafe fn getrpcbynumber(arg_number: ::std::os::raw::c_int) -> *mut rpcent {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getrpcbynumber(arg_number: ::std::os::raw::c_int) -> *mut rpcent;
        }
        getrpcbynumber(arg_number)
    })
}
pub unsafe fn getrpcent() -> *mut rpcent {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getrpcent() -> *mut rpcent;
        }
        getrpcent()
    })
}
pub unsafe fn setrpcent(arg_stayopen: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn setrpcent(arg_stayopen: ::std::os::raw::c_int);
        }
        setrpcent(arg_stayopen)
    })
}
pub unsafe fn endrpcent() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn endrpcent();
        }
        endrpcent()
    })
}
pub unsafe fn herror(arg_arg1: *const ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn herror(arg_arg1: *const ::std::os::raw::c_char);
        }
        herror(arg_arg1)
    })
}
pub unsafe fn hstrerror(arg_arg1: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hstrerror(arg_arg1: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
        }
        hstrerror(arg_arg1)
    })
}
pub unsafe fn innetgr(
    arg_arg1: *const ::std::os::raw::c_char,
    arg_arg2: *const ::std::os::raw::c_char,
    arg_arg3: *const ::std::os::raw::c_char,
    arg_arg4: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn innetgr(
                arg_arg1: *const ::std::os::raw::c_char,
                arg_arg2: *const ::std::os::raw::c_char,
                arg_arg3: *const ::std::os::raw::c_char,
                arg_arg4: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        innetgr(arg_arg1, arg_arg2, arg_arg3, arg_arg4)
    })
}
pub unsafe fn getnetgrent(
    arg_arg1: *mut *mut ::std::os::raw::c_char,
    arg_arg2: *mut *mut ::std::os::raw::c_char,
    arg_arg3: *mut *mut ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getnetgrent(
                arg_arg1: *mut *mut ::std::os::raw::c_char,
                arg_arg2: *mut *mut ::std::os::raw::c_char,
                arg_arg3: *mut *mut ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        getnetgrent(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn endnetgrent() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn endnetgrent();
        }
        endnetgrent()
    })
}
pub unsafe fn setnetgrent(arg_arg1: *const ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn setnetgrent(arg_arg1: *const ::std::os::raw::c_char);
        }
        setnetgrent(arg_arg1)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct passwd {
    pub pw_name: *mut ::std::os::raw::c_char,
    pub pw_passwd: *mut ::std::os::raw::c_char,
    pub pw_uid: uid_t,
    pub pw_gid: gid_t,
    pub pw_change: __darwin_time_t,
    pub pw_class: *mut ::std::os::raw::c_char,
    pub pw_gecos: *mut ::std::os::raw::c_char,
    pub pw_dir: *mut ::std::os::raw::c_char,
    pub pw_shell: *mut ::std::os::raw::c_char,
    pub pw_expire: __darwin_time_t,
}
impl Default for passwd {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn getpwuid(arg_arg1: uid_t) -> *mut passwd {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getpwuid(arg_arg1: uid_t) -> *mut passwd;
        }
        getpwuid(arg_arg1)
    })
}
pub unsafe fn getpwnam(arg_arg1: *const ::std::os::raw::c_char) -> *mut passwd {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getpwnam(arg_arg1: *const ::std::os::raw::c_char) -> *mut passwd;
        }
        getpwnam(arg_arg1)
    })
}
pub unsafe fn getpwuid_r(
    arg_arg1: uid_t,
    arg_arg2: *mut passwd,
    arg_arg3: *mut ::std::os::raw::c_char,
    arg_arg4: usize,
    arg_arg5: *mut *mut passwd,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getpwuid_r(
                arg_arg1: uid_t,
                arg_arg2: *mut passwd,
                arg_arg3: *mut ::std::os::raw::c_char,
                arg_arg4: usize,
                arg_arg5: *mut *mut passwd,
            ) -> ::std::os::raw::c_int;
        }
        getpwuid_r(arg_arg1, arg_arg2, arg_arg3, arg_arg4, arg_arg5)
    })
}
pub unsafe fn getpwnam_r(
    arg_arg1: *const ::std::os::raw::c_char,
    arg_arg2: *mut passwd,
    arg_arg3: *mut ::std::os::raw::c_char,
    arg_arg4: usize,
    arg_arg5: *mut *mut passwd,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getpwnam_r(
                arg_arg1: *const ::std::os::raw::c_char,
                arg_arg2: *mut passwd,
                arg_arg3: *mut ::std::os::raw::c_char,
                arg_arg4: usize,
                arg_arg5: *mut *mut passwd,
            ) -> ::std::os::raw::c_int;
        }
        getpwnam_r(arg_arg1, arg_arg2, arg_arg3, arg_arg4, arg_arg5)
    })
}
pub unsafe fn getpwent() -> *mut passwd {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getpwent() -> *mut passwd;
        }
        getpwent()
    })
}
pub unsafe fn setpwent() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn setpwent();
        }
        setpwent()
    })
}
pub unsafe fn endpwent() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn endpwent();
        }
        endpwent()
    })
}
pub type uuid_t = __darwin_uuid_t;
pub type uuid_string_t = __darwin_uuid_string_t;
extern "C" {
    pub static UUID_NULL: uuid_t;
}
pub unsafe fn uuid_clear(arg_uu: *mut ::std::os::raw::c_uchar) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn uuid_clear(arg_uu: *mut ::std::os::raw::c_uchar);
        }
        uuid_clear(arg_uu)
    })
}
pub unsafe fn uuid_compare(
    arg_uu1: *mut ::std::os::raw::c_uchar,
    arg_uu2: *mut ::std::os::raw::c_uchar,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn uuid_compare(
                arg_uu1: *mut ::std::os::raw::c_uchar,
                arg_uu2: *mut ::std::os::raw::c_uchar,
            ) -> ::std::os::raw::c_int;
        }
        uuid_compare(arg_uu1, arg_uu2)
    })
}
pub unsafe fn uuid_copy(
    arg_dst: *mut ::std::os::raw::c_uchar,
    arg_src: *mut ::std::os::raw::c_uchar,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn uuid_copy(
                arg_dst: *mut ::std::os::raw::c_uchar,
                arg_src: *mut ::std::os::raw::c_uchar,
            );
        }
        uuid_copy(arg_dst, arg_src)
    })
}
pub unsafe fn uuid_generate(arg_out: *mut ::std::os::raw::c_uchar) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn uuid_generate(arg_out: *mut ::std::os::raw::c_uchar);
        }
        uuid_generate(arg_out)
    })
}
pub unsafe fn uuid_generate_random(arg_out: *mut ::std::os::raw::c_uchar) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn uuid_generate_random(arg_out: *mut ::std::os::raw::c_uchar);
        }
        uuid_generate_random(arg_out)
    })
}
pub unsafe fn uuid_generate_time(arg_out: *mut ::std::os::raw::c_uchar) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn uuid_generate_time(arg_out: *mut ::std::os::raw::c_uchar);
        }
        uuid_generate_time(arg_out)
    })
}
pub unsafe fn uuid_is_null(arg_uu: *mut ::std::os::raw::c_uchar) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn uuid_is_null(arg_uu: *mut ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
        }
        uuid_is_null(arg_uu)
    })
}
pub unsafe fn uuid_parse(
    arg_in_: *mut ::std::os::raw::c_char,
    arg_uu: *mut ::std::os::raw::c_uchar,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn uuid_parse(
                arg_in_: *mut ::std::os::raw::c_char,
                arg_uu: *mut ::std::os::raw::c_uchar,
            ) -> ::std::os::raw::c_int;
        }
        uuid_parse(arg_in_, arg_uu)
    })
}
pub unsafe fn uuid_unparse(
    arg_uu: *mut ::std::os::raw::c_uchar,
    arg_out: *mut ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn uuid_unparse(
                arg_uu: *mut ::std::os::raw::c_uchar,
                arg_out: *mut ::std::os::raw::c_char,
            );
        }
        uuid_unparse(arg_uu, arg_out)
    })
}
pub unsafe fn uuid_unparse_lower(
    arg_uu: *mut ::std::os::raw::c_uchar,
    arg_out: *mut ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn uuid_unparse_lower(
                arg_uu: *mut ::std::os::raw::c_uchar,
                arg_out: *mut ::std::os::raw::c_char,
            );
        }
        uuid_unparse_lower(arg_uu, arg_out)
    })
}
pub unsafe fn uuid_unparse_upper(
    arg_uu: *mut ::std::os::raw::c_uchar,
    arg_out: *mut ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn uuid_unparse_upper(
                arg_uu: *mut ::std::os::raw::c_uchar,
                arg_out: *mut ::std::os::raw::c_char,
            );
        }
        uuid_unparse_upper(arg_uu, arg_out)
    })
}
pub unsafe fn setpassent(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn setpassent(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        setpassent(arg_arg1)
    })
}
pub unsafe fn user_from_uid(
    arg_arg1: uid_t,
    arg_arg2: ::std::os::raw::c_int,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn user_from_uid(
                arg_arg1: uid_t,
                arg_arg2: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_char;
        }
        user_from_uid(arg_arg1, arg_arg2)
    })
}
pub unsafe fn getpwuuid(arg_arg1: *mut ::std::os::raw::c_uchar) -> *mut passwd {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getpwuuid(arg_arg1: *mut ::std::os::raw::c_uchar) -> *mut passwd;
        }
        getpwuuid(arg_arg1)
    })
}
pub unsafe fn getpwuuid_r(
    arg_arg1: *mut ::std::os::raw::c_uchar,
    arg_arg2: *mut passwd,
    arg_arg3: *mut ::std::os::raw::c_char,
    arg_arg4: usize,
    arg_arg5: *mut *mut passwd,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getpwuuid_r(
                arg_arg1: *mut ::std::os::raw::c_uchar,
                arg_arg2: *mut passwd,
                arg_arg3: *mut ::std::os::raw::c_char,
                arg_arg4: usize,
                arg_arg5: *mut *mut passwd,
            ) -> ::std::os::raw::c_int;
        }
        getpwuuid_r(arg_arg1, arg_arg2, arg_arg3, arg_arg4, arg_arg5)
    })
}
pub type pgsocket = ::std::os::raw::c_int;
pub unsafe fn pg_set_noblock(arg_sock: pgsocket) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_set_noblock(arg_sock: pgsocket) -> bool;
        }
        pg_set_noblock(arg_sock)
    })
}
pub unsafe fn pg_set_block(arg_sock: pgsocket) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_set_block(arg_sock: pgsocket) -> bool;
        }
        pg_set_block(arg_sock)
    })
}
pub unsafe fn has_drive_prefix(arg_filename: *const ::std::os::raw::c_char) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_drive_prefix(arg_filename: *const ::std::os::raw::c_char) -> bool;
        }
        has_drive_prefix(arg_filename)
    })
}
pub unsafe fn first_dir_separator(
    arg_filename: *const ::std::os::raw::c_char,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn first_dir_separator(
                arg_filename: *const ::std::os::raw::c_char,
            ) -> *mut ::std::os::raw::c_char;
        }
        first_dir_separator(arg_filename)
    })
}
pub unsafe fn last_dir_separator(
    arg_filename: *const ::std::os::raw::c_char,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn last_dir_separator(
                arg_filename: *const ::std::os::raw::c_char,
            ) -> *mut ::std::os::raw::c_char;
        }
        last_dir_separator(arg_filename)
    })
}
pub unsafe fn first_path_var_separator(
    arg_pathlist: *const ::std::os::raw::c_char,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn first_path_var_separator(
                arg_pathlist: *const ::std::os::raw::c_char,
            ) -> *mut ::std::os::raw::c_char;
        }
        first_path_var_separator(arg_pathlist)
    })
}
pub unsafe fn join_path_components(
    arg_ret_path: *mut ::std::os::raw::c_char,
    arg_head: *const ::std::os::raw::c_char,
    arg_tail: *const ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn join_path_components(
                arg_ret_path: *mut ::std::os::raw::c_char,
                arg_head: *const ::std::os::raw::c_char,
                arg_tail: *const ::std::os::raw::c_char,
            );
        }
        join_path_components(arg_ret_path, arg_head, arg_tail)
    })
}
pub unsafe fn canonicalize_path(arg_path: *mut ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn canonicalize_path(arg_path: *mut ::std::os::raw::c_char);
        }
        canonicalize_path(arg_path)
    })
}
pub unsafe fn make_native_path(arg_path: *mut ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_native_path(arg_path: *mut ::std::os::raw::c_char);
        }
        make_native_path(arg_path)
    })
}
pub unsafe fn cleanup_path(arg_path: *mut ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cleanup_path(arg_path: *mut ::std::os::raw::c_char);
        }
        cleanup_path(arg_path)
    })
}
pub unsafe fn path_contains_parent_reference(arg_path: *const ::std::os::raw::c_char) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn path_contains_parent_reference(arg_path: *const ::std::os::raw::c_char) -> bool;
        }
        path_contains_parent_reference(arg_path)
    })
}
pub unsafe fn path_is_relative_and_below_cwd(arg_path: *const ::std::os::raw::c_char) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn path_is_relative_and_below_cwd(arg_path: *const ::std::os::raw::c_char) -> bool;
        }
        path_is_relative_and_below_cwd(arg_path)
    })
}
pub unsafe fn path_is_prefix_of_path(
    arg_path1: *const ::std::os::raw::c_char,
    arg_path2: *const ::std::os::raw::c_char,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn path_is_prefix_of_path(
                arg_path1: *const ::std::os::raw::c_char,
                arg_path2: *const ::std::os::raw::c_char,
            ) -> bool;
        }
        path_is_prefix_of_path(arg_path1, arg_path2)
    })
}
pub unsafe fn make_absolute_path(
    arg_path: *const ::std::os::raw::c_char,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_absolute_path(
                arg_path: *const ::std::os::raw::c_char,
            ) -> *mut ::std::os::raw::c_char;
        }
        make_absolute_path(arg_path)
    })
}
pub unsafe fn get_progname(
    arg_argv0: *const ::std::os::raw::c_char,
) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_progname(
                arg_argv0: *const ::std::os::raw::c_char,
            ) -> *const ::std::os::raw::c_char;
        }
        get_progname(arg_argv0)
    })
}
pub unsafe fn get_share_path(
    arg_my_exec_path: *const ::std::os::raw::c_char,
    arg_ret_path: *mut ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_share_path(
                arg_my_exec_path: *const ::std::os::raw::c_char,
                arg_ret_path: *mut ::std::os::raw::c_char,
            );
        }
        get_share_path(arg_my_exec_path, arg_ret_path)
    })
}
pub unsafe fn get_etc_path(
    arg_my_exec_path: *const ::std::os::raw::c_char,
    arg_ret_path: *mut ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_etc_path(
                arg_my_exec_path: *const ::std::os::raw::c_char,
                arg_ret_path: *mut ::std::os::raw::c_char,
            );
        }
        get_etc_path(arg_my_exec_path, arg_ret_path)
    })
}
pub unsafe fn get_include_path(
    arg_my_exec_path: *const ::std::os::raw::c_char,
    arg_ret_path: *mut ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_include_path(
                arg_my_exec_path: *const ::std::os::raw::c_char,
                arg_ret_path: *mut ::std::os::raw::c_char,
            );
        }
        get_include_path(arg_my_exec_path, arg_ret_path)
    })
}
pub unsafe fn get_pkginclude_path(
    arg_my_exec_path: *const ::std::os::raw::c_char,
    arg_ret_path: *mut ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_pkginclude_path(
                arg_my_exec_path: *const ::std::os::raw::c_char,
                arg_ret_path: *mut ::std::os::raw::c_char,
            );
        }
        get_pkginclude_path(arg_my_exec_path, arg_ret_path)
    })
}
pub unsafe fn get_includeserver_path(
    arg_my_exec_path: *const ::std::os::raw::c_char,
    arg_ret_path: *mut ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_includeserver_path(
                arg_my_exec_path: *const ::std::os::raw::c_char,
                arg_ret_path: *mut ::std::os::raw::c_char,
            );
        }
        get_includeserver_path(arg_my_exec_path, arg_ret_path)
    })
}
pub unsafe fn get_lib_path(
    arg_my_exec_path: *const ::std::os::raw::c_char,
    arg_ret_path: *mut ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_lib_path(
                arg_my_exec_path: *const ::std::os::raw::c_char,
                arg_ret_path: *mut ::std::os::raw::c_char,
            );
        }
        get_lib_path(arg_my_exec_path, arg_ret_path)
    })
}
pub unsafe fn get_pkglib_path(
    arg_my_exec_path: *const ::std::os::raw::c_char,
    arg_ret_path: *mut ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_pkglib_path(
                arg_my_exec_path: *const ::std::os::raw::c_char,
                arg_ret_path: *mut ::std::os::raw::c_char,
            );
        }
        get_pkglib_path(arg_my_exec_path, arg_ret_path)
    })
}
pub unsafe fn get_locale_path(
    arg_my_exec_path: *const ::std::os::raw::c_char,
    arg_ret_path: *mut ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_locale_path(
                arg_my_exec_path: *const ::std::os::raw::c_char,
                arg_ret_path: *mut ::std::os::raw::c_char,
            );
        }
        get_locale_path(arg_my_exec_path, arg_ret_path)
    })
}
pub unsafe fn get_doc_path(
    arg_my_exec_path: *const ::std::os::raw::c_char,
    arg_ret_path: *mut ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_doc_path(
                arg_my_exec_path: *const ::std::os::raw::c_char,
                arg_ret_path: *mut ::std::os::raw::c_char,
            );
        }
        get_doc_path(arg_my_exec_path, arg_ret_path)
    })
}
pub unsafe fn get_html_path(
    arg_my_exec_path: *const ::std::os::raw::c_char,
    arg_ret_path: *mut ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_html_path(
                arg_my_exec_path: *const ::std::os::raw::c_char,
                arg_ret_path: *mut ::std::os::raw::c_char,
            );
        }
        get_html_path(arg_my_exec_path, arg_ret_path)
    })
}
pub unsafe fn get_man_path(
    arg_my_exec_path: *const ::std::os::raw::c_char,
    arg_ret_path: *mut ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_man_path(
                arg_my_exec_path: *const ::std::os::raw::c_char,
                arg_ret_path: *mut ::std::os::raw::c_char,
            );
        }
        get_man_path(arg_my_exec_path, arg_ret_path)
    })
}
pub unsafe fn get_home_path(arg_ret_path: *mut ::std::os::raw::c_char) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_home_path(arg_ret_path: *mut ::std::os::raw::c_char) -> bool;
        }
        get_home_path(arg_ret_path)
    })
}
pub unsafe fn get_parent_directory(arg_path: *mut ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_parent_directory(arg_path: *mut ::std::os::raw::c_char);
        }
        get_parent_directory(arg_path)
    })
}
pub unsafe fn pgfnames(
    arg_path: *const ::std::os::raw::c_char,
) -> *mut *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgfnames(
                arg_path: *const ::std::os::raw::c_char,
            ) -> *mut *mut ::std::os::raw::c_char;
        }
        pgfnames(arg_path)
    })
}
pub unsafe fn pgfnames_cleanup(arg_filenames: *mut *mut ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgfnames_cleanup(arg_filenames: *mut *mut ::std::os::raw::c_char);
        }
        pgfnames_cleanup(arg_filenames)
    })
}
pub unsafe fn set_pglocale_pgservice(
    arg_argv0: *const ::std::os::raw::c_char,
    arg_app: *const ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn set_pglocale_pgservice(
                arg_argv0: *const ::std::os::raw::c_char,
                arg_app: *const ::std::os::raw::c_char,
            );
        }
        set_pglocale_pgservice(arg_argv0, arg_app)
    })
}
pub unsafe fn find_my_exec(
    arg_argv0: *const ::std::os::raw::c_char,
    arg_retpath: *mut ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn find_my_exec(
                arg_argv0: *const ::std::os::raw::c_char,
                arg_retpath: *mut ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        find_my_exec(arg_argv0, arg_retpath)
    })
}
pub unsafe fn find_other_exec(
    arg_argv0: *const ::std::os::raw::c_char,
    arg_target: *const ::std::os::raw::c_char,
    arg_versionstr: *const ::std::os::raw::c_char,
    arg_retpath: *mut ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn find_other_exec(
                arg_argv0: *const ::std::os::raw::c_char,
                arg_target: *const ::std::os::raw::c_char,
                arg_versionstr: *const ::std::os::raw::c_char,
                arg_retpath: *mut ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        find_other_exec(arg_argv0, arg_target, arg_versionstr, arg_retpath)
    })
}
pub unsafe fn pipe_read_line(
    arg_cmd: *mut ::std::os::raw::c_char,
    arg_line: *mut ::std::os::raw::c_char,
    arg_maxsize: ::std::os::raw::c_int,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pipe_read_line(
                arg_cmd: *mut ::std::os::raw::c_char,
                arg_line: *mut ::std::os::raw::c_char,
                arg_maxsize: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_char;
        }
        pipe_read_line(arg_cmd, arg_line, arg_maxsize)
    })
}
pub unsafe fn pg_usleep(arg_microsec: ::std::os::raw::c_long) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_usleep(arg_microsec: ::std::os::raw::c_long);
        }
        pg_usleep(arg_microsec)
    })
}
pub unsafe fn pg_strcasecmp(
    arg_s1: *const ::std::os::raw::c_char,
    arg_s2: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_strcasecmp(
                arg_s1: *const ::std::os::raw::c_char,
                arg_s2: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        pg_strcasecmp(arg_s1, arg_s2)
    })
}
pub unsafe fn pg_strncasecmp(
    arg_s1: *const ::std::os::raw::c_char,
    arg_s2: *const ::std::os::raw::c_char,
    arg_n: usize,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_strncasecmp(
                arg_s1: *const ::std::os::raw::c_char,
                arg_s2: *const ::std::os::raw::c_char,
                arg_n: usize,
            ) -> ::std::os::raw::c_int;
        }
        pg_strncasecmp(arg_s1, arg_s2, arg_n)
    })
}
pub unsafe fn pg_toupper(arg_ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_uchar {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_toupper(arg_ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_uchar;
        }
        pg_toupper(arg_ch)
    })
}
pub unsafe fn pg_tolower(arg_ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_uchar {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_tolower(arg_ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_uchar;
        }
        pg_tolower(arg_ch)
    })
}
pub unsafe fn pg_ascii_toupper(arg_ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_uchar {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_ascii_toupper(arg_ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_uchar;
        }
        pg_ascii_toupper(arg_ch)
    })
}
pub unsafe fn pg_ascii_tolower(arg_ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_uchar {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_ascii_tolower(arg_ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_uchar;
        }
        pg_ascii_tolower(arg_ch)
    })
}
pub unsafe fn pg_snprintf(
    arg_str_: *mut ::std::os::raw::c_char,
    arg_count: usize,
    arg_fmt: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_snprintf(
                arg_str_: *mut ::std::os::raw::c_char,
                arg_count: usize,
                arg_fmt: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        pg_snprintf(arg_str_, arg_count, arg_fmt)
    })
}
pub unsafe fn pg_sprintf(
    arg_str_: *mut ::std::os::raw::c_char,
    arg_fmt: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_sprintf(
                arg_str_: *mut ::std::os::raw::c_char,
                arg_fmt: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        pg_sprintf(arg_str_, arg_fmt)
    })
}
pub unsafe fn pg_fprintf(
    arg_stream: *mut FILE,
    arg_fmt: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_fprintf(
                arg_stream: *mut FILE,
                arg_fmt: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        pg_fprintf(arg_stream, arg_fmt)
    })
}
pub unsafe fn pg_printf(arg_fmt: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_printf(arg_fmt: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
        }
        pg_printf(arg_fmt)
    })
}
pub unsafe fn pg_strfromd(
    arg_str_: *mut ::std::os::raw::c_char,
    arg_count: usize,
    arg_precision: ::std::os::raw::c_int,
    arg_value: f64,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_strfromd(
                arg_str_: *mut ::std::os::raw::c_char,
                arg_count: usize,
                arg_precision: ::std::os::raw::c_int,
                arg_value: f64,
            ) -> ::std::os::raw::c_int;
        }
        pg_strfromd(arg_str_, arg_count, arg_precision, arg_value)
    })
}
pub unsafe fn pg_strerror(arg_errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_strerror(arg_errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
        }
        pg_strerror(arg_errnum)
    })
}
pub unsafe fn pg_strerror_r(
    arg_errnum: ::std::os::raw::c_int,
    arg_buf: *mut ::std::os::raw::c_char,
    arg_buflen: usize,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_strerror_r(
                arg_errnum: ::std::os::raw::c_int,
                arg_buf: *mut ::std::os::raw::c_char,
                arg_buflen: usize,
            ) -> *mut ::std::os::raw::c_char;
        }
        pg_strerror_r(arg_errnum, arg_buf, arg_buflen)
    })
}
pub unsafe fn pg_strsignal(arg_signum: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_strsignal(arg_signum: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
        }
        pg_strsignal(arg_signum)
    })
}
pub unsafe fn simple_prompt(
    arg_prompt: *const ::std::os::raw::c_char,
    arg_destination: *mut ::std::os::raw::c_char,
    arg_destlen: usize,
    arg_echo: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn simple_prompt(
                arg_prompt: *const ::std::os::raw::c_char,
                arg_destination: *mut ::std::os::raw::c_char,
                arg_destlen: usize,
                arg_echo: bool,
            );
        }
        simple_prompt(arg_prompt, arg_destination, arg_destlen, arg_echo)
    })
}
pub unsafe fn pclose_check(arg_stream: *mut FILE) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pclose_check(arg_stream: *mut FILE) -> ::std::os::raw::c_int;
        }
        pclose_check(arg_stream)
    })
}
pub unsafe fn rmtree(arg_path: *const ::std::os::raw::c_char, arg_rmtopdir: bool) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn rmtree(arg_path: *const ::std::os::raw::c_char, arg_rmtopdir: bool) -> bool;
        }
        rmtree(arg_path, arg_rmtopdir)
    })
}
pub unsafe fn pg_erand48(arg_xseed: *mut ::std::os::raw::c_ushort) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_erand48(arg_xseed: *mut ::std::os::raw::c_ushort) -> f64;
        }
        pg_erand48(arg_xseed)
    })
}
pub unsafe fn pg_lrand48() -> ::std::os::raw::c_long {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_lrand48() -> ::std::os::raw::c_long;
        }
        pg_lrand48()
    })
}
pub unsafe fn pg_jrand48(arg_xseed: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_jrand48(arg_xseed: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
        }
        pg_jrand48(arg_xseed)
    })
}
pub unsafe fn pg_srand48(arg_seed: ::std::os::raw::c_long) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_srand48(arg_seed: ::std::os::raw::c_long);
        }
        pg_srand48(arg_seed)
    })
}
pub type float_t = f32;
pub type double_t = f64;
pub unsafe fn __math_errhandling() -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn __math_errhandling() -> ::std::os::raw::c_int;
        }
        __math_errhandling()
    })
}
pub unsafe fn __fpclassifyf(arg_arg1: f32) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn __fpclassifyf(arg_arg1: f32) -> ::std::os::raw::c_int;
        }
        __fpclassifyf(arg_arg1)
    })
}
pub unsafe fn __fpclassifyd(arg_arg1: f64) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn __fpclassifyd(arg_arg1: f64) -> ::std::os::raw::c_int;
        }
        __fpclassifyd(arg_arg1)
    })
}
pub unsafe fn __fpclassifyl(arg_arg1: f64) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn __fpclassifyl(arg_arg1: f64) -> ::std::os::raw::c_int;
        }
        __fpclassifyl(arg_arg1)
    })
}
pub unsafe fn acosf(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn acosf(arg_arg1: f32) -> f32;
        }
        acosf(arg_arg1)
    })
}
pub unsafe fn acos(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn acos(arg_arg1: f64) -> f64;
        }
        acos(arg_arg1)
    })
}
pub unsafe fn acosl(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn acosl(arg_arg1: f64) -> f64;
        }
        acosl(arg_arg1)
    })
}
pub unsafe fn asinf(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn asinf(arg_arg1: f32) -> f32;
        }
        asinf(arg_arg1)
    })
}
pub unsafe fn asin(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn asin(arg_arg1: f64) -> f64;
        }
        asin(arg_arg1)
    })
}
pub unsafe fn asinl(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn asinl(arg_arg1: f64) -> f64;
        }
        asinl(arg_arg1)
    })
}
pub unsafe fn atanf(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn atanf(arg_arg1: f32) -> f32;
        }
        atanf(arg_arg1)
    })
}
pub unsafe fn atan(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn atan(arg_arg1: f64) -> f64;
        }
        atan(arg_arg1)
    })
}
pub unsafe fn atanl(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn atanl(arg_arg1: f64) -> f64;
        }
        atanl(arg_arg1)
    })
}
pub unsafe fn atan2f(arg_arg1: f32, arg_arg2: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn atan2f(arg_arg1: f32, arg_arg2: f32) -> f32;
        }
        atan2f(arg_arg1, arg_arg2)
    })
}
pub unsafe fn atan2(arg_arg1: f64, arg_arg2: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn atan2(arg_arg1: f64, arg_arg2: f64) -> f64;
        }
        atan2(arg_arg1, arg_arg2)
    })
}
pub unsafe fn atan2l(arg_arg1: f64, arg_arg2: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn atan2l(arg_arg1: f64, arg_arg2: f64) -> f64;
        }
        atan2l(arg_arg1, arg_arg2)
    })
}
pub unsafe fn cosf(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cosf(arg_arg1: f32) -> f32;
        }
        cosf(arg_arg1)
    })
}
pub unsafe fn cos(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cos(arg_arg1: f64) -> f64;
        }
        cos(arg_arg1)
    })
}
pub unsafe fn cosl(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cosl(arg_arg1: f64) -> f64;
        }
        cosl(arg_arg1)
    })
}
pub unsafe fn sinf(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sinf(arg_arg1: f32) -> f32;
        }
        sinf(arg_arg1)
    })
}
pub unsafe fn sin(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sin(arg_arg1: f64) -> f64;
        }
        sin(arg_arg1)
    })
}
pub unsafe fn sinl(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sinl(arg_arg1: f64) -> f64;
        }
        sinl(arg_arg1)
    })
}
pub unsafe fn tanf(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tanf(arg_arg1: f32) -> f32;
        }
        tanf(arg_arg1)
    })
}
pub unsafe fn tan(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tan(arg_arg1: f64) -> f64;
        }
        tan(arg_arg1)
    })
}
pub unsafe fn tanl(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tanl(arg_arg1: f64) -> f64;
        }
        tanl(arg_arg1)
    })
}
pub unsafe fn acoshf(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn acoshf(arg_arg1: f32) -> f32;
        }
        acoshf(arg_arg1)
    })
}
pub unsafe fn acosh(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn acosh(arg_arg1: f64) -> f64;
        }
        acosh(arg_arg1)
    })
}
pub unsafe fn acoshl(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn acoshl(arg_arg1: f64) -> f64;
        }
        acoshl(arg_arg1)
    })
}
pub unsafe fn asinhf(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn asinhf(arg_arg1: f32) -> f32;
        }
        asinhf(arg_arg1)
    })
}
pub unsafe fn asinh(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn asinh(arg_arg1: f64) -> f64;
        }
        asinh(arg_arg1)
    })
}
pub unsafe fn asinhl(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn asinhl(arg_arg1: f64) -> f64;
        }
        asinhl(arg_arg1)
    })
}
pub unsafe fn atanhf(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn atanhf(arg_arg1: f32) -> f32;
        }
        atanhf(arg_arg1)
    })
}
pub unsafe fn atanh(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn atanh(arg_arg1: f64) -> f64;
        }
        atanh(arg_arg1)
    })
}
pub unsafe fn atanhl(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn atanhl(arg_arg1: f64) -> f64;
        }
        atanhl(arg_arg1)
    })
}
pub unsafe fn coshf(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn coshf(arg_arg1: f32) -> f32;
        }
        coshf(arg_arg1)
    })
}
pub unsafe fn cosh(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cosh(arg_arg1: f64) -> f64;
        }
        cosh(arg_arg1)
    })
}
pub unsafe fn coshl(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn coshl(arg_arg1: f64) -> f64;
        }
        coshl(arg_arg1)
    })
}
pub unsafe fn sinhf(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sinhf(arg_arg1: f32) -> f32;
        }
        sinhf(arg_arg1)
    })
}
pub unsafe fn sinh(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sinh(arg_arg1: f64) -> f64;
        }
        sinh(arg_arg1)
    })
}
pub unsafe fn sinhl(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sinhl(arg_arg1: f64) -> f64;
        }
        sinhl(arg_arg1)
    })
}
pub unsafe fn tanhf(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tanhf(arg_arg1: f32) -> f32;
        }
        tanhf(arg_arg1)
    })
}
pub unsafe fn tanh(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tanh(arg_arg1: f64) -> f64;
        }
        tanh(arg_arg1)
    })
}
pub unsafe fn tanhl(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tanhl(arg_arg1: f64) -> f64;
        }
        tanhl(arg_arg1)
    })
}
pub unsafe fn expf(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn expf(arg_arg1: f32) -> f32;
        }
        expf(arg_arg1)
    })
}
pub unsafe fn exp(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn exp(arg_arg1: f64) -> f64;
        }
        exp(arg_arg1)
    })
}
pub unsafe fn expl(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn expl(arg_arg1: f64) -> f64;
        }
        expl(arg_arg1)
    })
}
pub unsafe fn exp2f(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn exp2f(arg_arg1: f32) -> f32;
        }
        exp2f(arg_arg1)
    })
}
pub unsafe fn exp2(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn exp2(arg_arg1: f64) -> f64;
        }
        exp2(arg_arg1)
    })
}
pub unsafe fn exp2l(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn exp2l(arg_arg1: f64) -> f64;
        }
        exp2l(arg_arg1)
    })
}
pub unsafe fn expm1f(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn expm1f(arg_arg1: f32) -> f32;
        }
        expm1f(arg_arg1)
    })
}
pub unsafe fn expm1(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn expm1(arg_arg1: f64) -> f64;
        }
        expm1(arg_arg1)
    })
}
pub unsafe fn expm1l(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn expm1l(arg_arg1: f64) -> f64;
        }
        expm1l(arg_arg1)
    })
}
pub unsafe fn logf(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn logf(arg_arg1: f32) -> f32;
        }
        logf(arg_arg1)
    })
}
pub unsafe fn log(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn log(arg_arg1: f64) -> f64;
        }
        log(arg_arg1)
    })
}
pub unsafe fn logl(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn logl(arg_arg1: f64) -> f64;
        }
        logl(arg_arg1)
    })
}
pub unsafe fn log10f(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn log10f(arg_arg1: f32) -> f32;
        }
        log10f(arg_arg1)
    })
}
pub unsafe fn log10(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn log10(arg_arg1: f64) -> f64;
        }
        log10(arg_arg1)
    })
}
pub unsafe fn log10l(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn log10l(arg_arg1: f64) -> f64;
        }
        log10l(arg_arg1)
    })
}
pub unsafe fn log2f(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn log2f(arg_arg1: f32) -> f32;
        }
        log2f(arg_arg1)
    })
}
pub unsafe fn log2(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn log2(arg_arg1: f64) -> f64;
        }
        log2(arg_arg1)
    })
}
pub unsafe fn log2l(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn log2l(arg_arg1: f64) -> f64;
        }
        log2l(arg_arg1)
    })
}
pub unsafe fn log1pf(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn log1pf(arg_arg1: f32) -> f32;
        }
        log1pf(arg_arg1)
    })
}
pub unsafe fn log1p(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn log1p(arg_arg1: f64) -> f64;
        }
        log1p(arg_arg1)
    })
}
pub unsafe fn log1pl(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn log1pl(arg_arg1: f64) -> f64;
        }
        log1pl(arg_arg1)
    })
}
pub unsafe fn logbf(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn logbf(arg_arg1: f32) -> f32;
        }
        logbf(arg_arg1)
    })
}
pub unsafe fn logb(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn logb(arg_arg1: f64) -> f64;
        }
        logb(arg_arg1)
    })
}
pub unsafe fn logbl(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn logbl(arg_arg1: f64) -> f64;
        }
        logbl(arg_arg1)
    })
}
pub unsafe fn modff(arg_arg1: f32, arg_arg2: *mut f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn modff(arg_arg1: f32, arg_arg2: *mut f32) -> f32;
        }
        modff(arg_arg1, arg_arg2)
    })
}
pub unsafe fn modf(arg_arg1: f64, arg_arg2: *mut f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn modf(arg_arg1: f64, arg_arg2: *mut f64) -> f64;
        }
        modf(arg_arg1, arg_arg2)
    })
}
pub unsafe fn modfl(arg_arg1: f64, arg_arg2: *mut f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn modfl(arg_arg1: f64, arg_arg2: *mut f64) -> f64;
        }
        modfl(arg_arg1, arg_arg2)
    })
}
pub unsafe fn ldexpf(arg_arg1: f32, arg_arg2: ::std::os::raw::c_int) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ldexpf(arg_arg1: f32, arg_arg2: ::std::os::raw::c_int) -> f32;
        }
        ldexpf(arg_arg1, arg_arg2)
    })
}
pub unsafe fn ldexp(arg_arg1: f64, arg_arg2: ::std::os::raw::c_int) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ldexp(arg_arg1: f64, arg_arg2: ::std::os::raw::c_int) -> f64;
        }
        ldexp(arg_arg1, arg_arg2)
    })
}
pub unsafe fn ldexpl(arg_arg1: f64, arg_arg2: ::std::os::raw::c_int) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ldexpl(arg_arg1: f64, arg_arg2: ::std::os::raw::c_int) -> f64;
        }
        ldexpl(arg_arg1, arg_arg2)
    })
}
pub unsafe fn frexpf(arg_arg1: f32, arg_arg2: *mut ::std::os::raw::c_int) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn frexpf(arg_arg1: f32, arg_arg2: *mut ::std::os::raw::c_int) -> f32;
        }
        frexpf(arg_arg1, arg_arg2)
    })
}
pub unsafe fn frexp(arg_arg1: f64, arg_arg2: *mut ::std::os::raw::c_int) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn frexp(arg_arg1: f64, arg_arg2: *mut ::std::os::raw::c_int) -> f64;
        }
        frexp(arg_arg1, arg_arg2)
    })
}
pub unsafe fn frexpl(arg_arg1: f64, arg_arg2: *mut ::std::os::raw::c_int) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn frexpl(arg_arg1: f64, arg_arg2: *mut ::std::os::raw::c_int) -> f64;
        }
        frexpl(arg_arg1, arg_arg2)
    })
}
pub unsafe fn ilogbf(arg_arg1: f32) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ilogbf(arg_arg1: f32) -> ::std::os::raw::c_int;
        }
        ilogbf(arg_arg1)
    })
}
pub unsafe fn ilogb(arg_arg1: f64) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ilogb(arg_arg1: f64) -> ::std::os::raw::c_int;
        }
        ilogb(arg_arg1)
    })
}
pub unsafe fn ilogbl(arg_arg1: f64) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ilogbl(arg_arg1: f64) -> ::std::os::raw::c_int;
        }
        ilogbl(arg_arg1)
    })
}
pub unsafe fn scalbnf(arg_arg1: f32, arg_arg2: ::std::os::raw::c_int) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn scalbnf(arg_arg1: f32, arg_arg2: ::std::os::raw::c_int) -> f32;
        }
        scalbnf(arg_arg1, arg_arg2)
    })
}
pub unsafe fn scalbn(arg_arg1: f64, arg_arg2: ::std::os::raw::c_int) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn scalbn(arg_arg1: f64, arg_arg2: ::std::os::raw::c_int) -> f64;
        }
        scalbn(arg_arg1, arg_arg2)
    })
}
pub unsafe fn scalbnl(arg_arg1: f64, arg_arg2: ::std::os::raw::c_int) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn scalbnl(arg_arg1: f64, arg_arg2: ::std::os::raw::c_int) -> f64;
        }
        scalbnl(arg_arg1, arg_arg2)
    })
}
pub unsafe fn scalblnf(arg_arg1: f32, arg_arg2: ::std::os::raw::c_long) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn scalblnf(arg_arg1: f32, arg_arg2: ::std::os::raw::c_long) -> f32;
        }
        scalblnf(arg_arg1, arg_arg2)
    })
}
pub unsafe fn scalbln(arg_arg1: f64, arg_arg2: ::std::os::raw::c_long) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn scalbln(arg_arg1: f64, arg_arg2: ::std::os::raw::c_long) -> f64;
        }
        scalbln(arg_arg1, arg_arg2)
    })
}
pub unsafe fn scalblnl(arg_arg1: f64, arg_arg2: ::std::os::raw::c_long) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn scalblnl(arg_arg1: f64, arg_arg2: ::std::os::raw::c_long) -> f64;
        }
        scalblnl(arg_arg1, arg_arg2)
    })
}
pub unsafe fn fabsf(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fabsf(arg_arg1: f32) -> f32;
        }
        fabsf(arg_arg1)
    })
}
pub unsafe fn fabs(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fabs(arg_arg1: f64) -> f64;
        }
        fabs(arg_arg1)
    })
}
pub unsafe fn fabsl(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fabsl(arg_arg1: f64) -> f64;
        }
        fabsl(arg_arg1)
    })
}
pub unsafe fn cbrtf(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cbrtf(arg_arg1: f32) -> f32;
        }
        cbrtf(arg_arg1)
    })
}
pub unsafe fn cbrt(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cbrt(arg_arg1: f64) -> f64;
        }
        cbrt(arg_arg1)
    })
}
pub unsafe fn cbrtl(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cbrtl(arg_arg1: f64) -> f64;
        }
        cbrtl(arg_arg1)
    })
}
pub unsafe fn hypotf(arg_arg1: f32, arg_arg2: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hypotf(arg_arg1: f32, arg_arg2: f32) -> f32;
        }
        hypotf(arg_arg1, arg_arg2)
    })
}
pub unsafe fn hypot(arg_arg1: f64, arg_arg2: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hypot(arg_arg1: f64, arg_arg2: f64) -> f64;
        }
        hypot(arg_arg1, arg_arg2)
    })
}
pub unsafe fn hypotl(arg_arg1: f64, arg_arg2: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hypotl(arg_arg1: f64, arg_arg2: f64) -> f64;
        }
        hypotl(arg_arg1, arg_arg2)
    })
}
pub unsafe fn powf(arg_arg1: f32, arg_arg2: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn powf(arg_arg1: f32, arg_arg2: f32) -> f32;
        }
        powf(arg_arg1, arg_arg2)
    })
}
pub unsafe fn pow(arg_arg1: f64, arg_arg2: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pow(arg_arg1: f64, arg_arg2: f64) -> f64;
        }
        pow(arg_arg1, arg_arg2)
    })
}
pub unsafe fn powl(arg_arg1: f64, arg_arg2: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn powl(arg_arg1: f64, arg_arg2: f64) -> f64;
        }
        powl(arg_arg1, arg_arg2)
    })
}
pub unsafe fn sqrtf(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sqrtf(arg_arg1: f32) -> f32;
        }
        sqrtf(arg_arg1)
    })
}
pub unsafe fn sqrt(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sqrt(arg_arg1: f64) -> f64;
        }
        sqrt(arg_arg1)
    })
}
pub unsafe fn sqrtl(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sqrtl(arg_arg1: f64) -> f64;
        }
        sqrtl(arg_arg1)
    })
}
pub unsafe fn erff(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn erff(arg_arg1: f32) -> f32;
        }
        erff(arg_arg1)
    })
}
pub unsafe fn erf(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn erf(arg_arg1: f64) -> f64;
        }
        erf(arg_arg1)
    })
}
pub unsafe fn erfl(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn erfl(arg_arg1: f64) -> f64;
        }
        erfl(arg_arg1)
    })
}
pub unsafe fn erfcf(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn erfcf(arg_arg1: f32) -> f32;
        }
        erfcf(arg_arg1)
    })
}
pub unsafe fn erfc(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn erfc(arg_arg1: f64) -> f64;
        }
        erfc(arg_arg1)
    })
}
pub unsafe fn erfcl(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn erfcl(arg_arg1: f64) -> f64;
        }
        erfcl(arg_arg1)
    })
}
pub unsafe fn lgammaf(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lgammaf(arg_arg1: f32) -> f32;
        }
        lgammaf(arg_arg1)
    })
}
pub unsafe fn lgamma(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lgamma(arg_arg1: f64) -> f64;
        }
        lgamma(arg_arg1)
    })
}
pub unsafe fn lgammal(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lgammal(arg_arg1: f64) -> f64;
        }
        lgammal(arg_arg1)
    })
}
pub unsafe fn tgammaf(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tgammaf(arg_arg1: f32) -> f32;
        }
        tgammaf(arg_arg1)
    })
}
pub unsafe fn tgamma(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tgamma(arg_arg1: f64) -> f64;
        }
        tgamma(arg_arg1)
    })
}
pub unsafe fn tgammal(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tgammal(arg_arg1: f64) -> f64;
        }
        tgammal(arg_arg1)
    })
}
pub unsafe fn ceilf(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ceilf(arg_arg1: f32) -> f32;
        }
        ceilf(arg_arg1)
    })
}
pub unsafe fn ceil(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ceil(arg_arg1: f64) -> f64;
        }
        ceil(arg_arg1)
    })
}
pub unsafe fn ceill(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ceill(arg_arg1: f64) -> f64;
        }
        ceill(arg_arg1)
    })
}
pub unsafe fn floorf(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn floorf(arg_arg1: f32) -> f32;
        }
        floorf(arg_arg1)
    })
}
pub unsafe fn floor(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn floor(arg_arg1: f64) -> f64;
        }
        floor(arg_arg1)
    })
}
pub unsafe fn floorl(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn floorl(arg_arg1: f64) -> f64;
        }
        floorl(arg_arg1)
    })
}
pub unsafe fn nearbyintf(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn nearbyintf(arg_arg1: f32) -> f32;
        }
        nearbyintf(arg_arg1)
    })
}
pub unsafe fn nearbyint(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn nearbyint(arg_arg1: f64) -> f64;
        }
        nearbyint(arg_arg1)
    })
}
pub unsafe fn nearbyintl(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn nearbyintl(arg_arg1: f64) -> f64;
        }
        nearbyintl(arg_arg1)
    })
}
pub unsafe fn rintf(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn rintf(arg_arg1: f32) -> f32;
        }
        rintf(arg_arg1)
    })
}
pub unsafe fn rint(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn rint(arg_arg1: f64) -> f64;
        }
        rint(arg_arg1)
    })
}
pub unsafe fn rintl(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn rintl(arg_arg1: f64) -> f64;
        }
        rintl(arg_arg1)
    })
}
pub unsafe fn lrintf(arg_arg1: f32) -> ::std::os::raw::c_long {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lrintf(arg_arg1: f32) -> ::std::os::raw::c_long;
        }
        lrintf(arg_arg1)
    })
}
pub unsafe fn lrint(arg_arg1: f64) -> ::std::os::raw::c_long {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lrint(arg_arg1: f64) -> ::std::os::raw::c_long;
        }
        lrint(arg_arg1)
    })
}
pub unsafe fn lrintl(arg_arg1: f64) -> ::std::os::raw::c_long {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lrintl(arg_arg1: f64) -> ::std::os::raw::c_long;
        }
        lrintl(arg_arg1)
    })
}
pub unsafe fn roundf(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn roundf(arg_arg1: f32) -> f32;
        }
        roundf(arg_arg1)
    })
}
pub unsafe fn round(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn round(arg_arg1: f64) -> f64;
        }
        round(arg_arg1)
    })
}
pub unsafe fn roundl(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn roundl(arg_arg1: f64) -> f64;
        }
        roundl(arg_arg1)
    })
}
pub unsafe fn lroundf(arg_arg1: f32) -> ::std::os::raw::c_long {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lroundf(arg_arg1: f32) -> ::std::os::raw::c_long;
        }
        lroundf(arg_arg1)
    })
}
pub unsafe fn lround(arg_arg1: f64) -> ::std::os::raw::c_long {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lround(arg_arg1: f64) -> ::std::os::raw::c_long;
        }
        lround(arg_arg1)
    })
}
pub unsafe fn lroundl(arg_arg1: f64) -> ::std::os::raw::c_long {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lroundl(arg_arg1: f64) -> ::std::os::raw::c_long;
        }
        lroundl(arg_arg1)
    })
}
pub unsafe fn llrintf(arg_arg1: f32) -> ::std::os::raw::c_longlong {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn llrintf(arg_arg1: f32) -> ::std::os::raw::c_longlong;
        }
        llrintf(arg_arg1)
    })
}
pub unsafe fn llrint(arg_arg1: f64) -> ::std::os::raw::c_longlong {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn llrint(arg_arg1: f64) -> ::std::os::raw::c_longlong;
        }
        llrint(arg_arg1)
    })
}
pub unsafe fn llrintl(arg_arg1: f64) -> ::std::os::raw::c_longlong {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn llrintl(arg_arg1: f64) -> ::std::os::raw::c_longlong;
        }
        llrintl(arg_arg1)
    })
}
pub unsafe fn llroundf(arg_arg1: f32) -> ::std::os::raw::c_longlong {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn llroundf(arg_arg1: f32) -> ::std::os::raw::c_longlong;
        }
        llroundf(arg_arg1)
    })
}
pub unsafe fn llround(arg_arg1: f64) -> ::std::os::raw::c_longlong {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn llround(arg_arg1: f64) -> ::std::os::raw::c_longlong;
        }
        llround(arg_arg1)
    })
}
pub unsafe fn llroundl(arg_arg1: f64) -> ::std::os::raw::c_longlong {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn llroundl(arg_arg1: f64) -> ::std::os::raw::c_longlong;
        }
        llroundl(arg_arg1)
    })
}
pub unsafe fn truncf(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn truncf(arg_arg1: f32) -> f32;
        }
        truncf(arg_arg1)
    })
}
pub unsafe fn trunc(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn trunc(arg_arg1: f64) -> f64;
        }
        trunc(arg_arg1)
    })
}
pub unsafe fn truncl(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn truncl(arg_arg1: f64) -> f64;
        }
        truncl(arg_arg1)
    })
}
pub unsafe fn fmodf(arg_arg1: f32, arg_arg2: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fmodf(arg_arg1: f32, arg_arg2: f32) -> f32;
        }
        fmodf(arg_arg1, arg_arg2)
    })
}
pub unsafe fn fmod(arg_arg1: f64, arg_arg2: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fmod(arg_arg1: f64, arg_arg2: f64) -> f64;
        }
        fmod(arg_arg1, arg_arg2)
    })
}
pub unsafe fn fmodl(arg_arg1: f64, arg_arg2: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fmodl(arg_arg1: f64, arg_arg2: f64) -> f64;
        }
        fmodl(arg_arg1, arg_arg2)
    })
}
pub unsafe fn remainderf(arg_arg1: f32, arg_arg2: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn remainderf(arg_arg1: f32, arg_arg2: f32) -> f32;
        }
        remainderf(arg_arg1, arg_arg2)
    })
}
pub unsafe fn remainder(arg_arg1: f64, arg_arg2: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn remainder(arg_arg1: f64, arg_arg2: f64) -> f64;
        }
        remainder(arg_arg1, arg_arg2)
    })
}
pub unsafe fn remainderl(arg_arg1: f64, arg_arg2: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn remainderl(arg_arg1: f64, arg_arg2: f64) -> f64;
        }
        remainderl(arg_arg1, arg_arg2)
    })
}
pub unsafe fn remquof(arg_arg1: f32, arg_arg2: f32, arg_arg3: *mut ::std::os::raw::c_int) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn remquof(arg_arg1: f32, arg_arg2: f32, arg_arg3: *mut ::std::os::raw::c_int) -> f32;
        }
        remquof(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn remquo(arg_arg1: f64, arg_arg2: f64, arg_arg3: *mut ::std::os::raw::c_int) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn remquo(arg_arg1: f64, arg_arg2: f64, arg_arg3: *mut ::std::os::raw::c_int) -> f64;
        }
        remquo(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn remquol(arg_arg1: f64, arg_arg2: f64, arg_arg3: *mut ::std::os::raw::c_int) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn remquol(arg_arg1: f64, arg_arg2: f64, arg_arg3: *mut ::std::os::raw::c_int) -> f64;
        }
        remquol(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn copysignf(arg_arg1: f32, arg_arg2: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn copysignf(arg_arg1: f32, arg_arg2: f32) -> f32;
        }
        copysignf(arg_arg1, arg_arg2)
    })
}
pub unsafe fn copysign(arg_arg1: f64, arg_arg2: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn copysign(arg_arg1: f64, arg_arg2: f64) -> f64;
        }
        copysign(arg_arg1, arg_arg2)
    })
}
pub unsafe fn copysignl(arg_arg1: f64, arg_arg2: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn copysignl(arg_arg1: f64, arg_arg2: f64) -> f64;
        }
        copysignl(arg_arg1, arg_arg2)
    })
}
pub unsafe fn nanf(arg_arg1: *const ::std::os::raw::c_char) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn nanf(arg_arg1: *const ::std::os::raw::c_char) -> f32;
        }
        nanf(arg_arg1)
    })
}
pub unsafe fn nan(arg_arg1: *const ::std::os::raw::c_char) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn nan(arg_arg1: *const ::std::os::raw::c_char) -> f64;
        }
        nan(arg_arg1)
    })
}
pub unsafe fn nanl(arg_arg1: *const ::std::os::raw::c_char) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn nanl(arg_arg1: *const ::std::os::raw::c_char) -> f64;
        }
        nanl(arg_arg1)
    })
}
pub unsafe fn nextafterf(arg_arg1: f32, arg_arg2: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn nextafterf(arg_arg1: f32, arg_arg2: f32) -> f32;
        }
        nextafterf(arg_arg1, arg_arg2)
    })
}
pub unsafe fn nextafter(arg_arg1: f64, arg_arg2: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn nextafter(arg_arg1: f64, arg_arg2: f64) -> f64;
        }
        nextafter(arg_arg1, arg_arg2)
    })
}
pub unsafe fn nextafterl(arg_arg1: f64, arg_arg2: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn nextafterl(arg_arg1: f64, arg_arg2: f64) -> f64;
        }
        nextafterl(arg_arg1, arg_arg2)
    })
}
pub unsafe fn nexttoward(arg_arg1: f64, arg_arg2: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn nexttoward(arg_arg1: f64, arg_arg2: f64) -> f64;
        }
        nexttoward(arg_arg1, arg_arg2)
    })
}
pub unsafe fn nexttowardf(arg_arg1: f32, arg_arg2: f64) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn nexttowardf(arg_arg1: f32, arg_arg2: f64) -> f32;
        }
        nexttowardf(arg_arg1, arg_arg2)
    })
}
pub unsafe fn nexttowardl(arg_arg1: f64, arg_arg2: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn nexttowardl(arg_arg1: f64, arg_arg2: f64) -> f64;
        }
        nexttowardl(arg_arg1, arg_arg2)
    })
}
pub unsafe fn fdimf(arg_arg1: f32, arg_arg2: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fdimf(arg_arg1: f32, arg_arg2: f32) -> f32;
        }
        fdimf(arg_arg1, arg_arg2)
    })
}
pub unsafe fn fdim(arg_arg1: f64, arg_arg2: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fdim(arg_arg1: f64, arg_arg2: f64) -> f64;
        }
        fdim(arg_arg1, arg_arg2)
    })
}
pub unsafe fn fdiml(arg_arg1: f64, arg_arg2: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fdiml(arg_arg1: f64, arg_arg2: f64) -> f64;
        }
        fdiml(arg_arg1, arg_arg2)
    })
}
pub unsafe fn fmaxf(arg_arg1: f32, arg_arg2: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fmaxf(arg_arg1: f32, arg_arg2: f32) -> f32;
        }
        fmaxf(arg_arg1, arg_arg2)
    })
}
pub unsafe fn fmax(arg_arg1: f64, arg_arg2: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fmax(arg_arg1: f64, arg_arg2: f64) -> f64;
        }
        fmax(arg_arg1, arg_arg2)
    })
}
pub unsafe fn fmaxl(arg_arg1: f64, arg_arg2: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fmaxl(arg_arg1: f64, arg_arg2: f64) -> f64;
        }
        fmaxl(arg_arg1, arg_arg2)
    })
}
pub unsafe fn fminf(arg_arg1: f32, arg_arg2: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fminf(arg_arg1: f32, arg_arg2: f32) -> f32;
        }
        fminf(arg_arg1, arg_arg2)
    })
}
pub unsafe fn fmin(arg_arg1: f64, arg_arg2: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fmin(arg_arg1: f64, arg_arg2: f64) -> f64;
        }
        fmin(arg_arg1, arg_arg2)
    })
}
pub unsafe fn fminl(arg_arg1: f64, arg_arg2: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fminl(arg_arg1: f64, arg_arg2: f64) -> f64;
        }
        fminl(arg_arg1, arg_arg2)
    })
}
pub unsafe fn fmaf(arg_arg1: f32, arg_arg2: f32, arg_arg3: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fmaf(arg_arg1: f32, arg_arg2: f32, arg_arg3: f32) -> f32;
        }
        fmaf(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn fma(arg_arg1: f64, arg_arg2: f64, arg_arg3: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fma(arg_arg1: f64, arg_arg2: f64, arg_arg3: f64) -> f64;
        }
        fma(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn fmal(arg_arg1: f64, arg_arg2: f64, arg_arg3: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fmal(arg_arg1: f64, arg_arg2: f64, arg_arg3: f64) -> f64;
        }
        fmal(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn __exp10f(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn __exp10f(arg_arg1: f32) -> f32;
        }
        __exp10f(arg_arg1)
    })
}
pub unsafe fn __exp10(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn __exp10(arg_arg1: f64) -> f64;
        }
        __exp10(arg_arg1)
    })
}
pub unsafe fn __cospif(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn __cospif(arg_arg1: f32) -> f32;
        }
        __cospif(arg_arg1)
    })
}
pub unsafe fn __cospi(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn __cospi(arg_arg1: f64) -> f64;
        }
        __cospi(arg_arg1)
    })
}
pub unsafe fn __sinpif(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn __sinpif(arg_arg1: f32) -> f32;
        }
        __sinpif(arg_arg1)
    })
}
pub unsafe fn __sinpi(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn __sinpi(arg_arg1: f64) -> f64;
        }
        __sinpi(arg_arg1)
    })
}
pub unsafe fn __tanpif(arg_arg1: f32) -> f32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn __tanpif(arg_arg1: f32) -> f32;
        }
        __tanpif(arg_arg1)
    })
}
pub unsafe fn __tanpi(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn __tanpi(arg_arg1: f64) -> f64;
        }
        __tanpi(arg_arg1)
    })
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __float2 {
    pub __sinval: f32,
    pub __cosval: f32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __double2 {
    pub __sinval: f64,
    pub __cosval: f64,
}
pub unsafe fn __sincosf_stret(arg_arg1: f32) -> __float2 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn __sincosf_stret(arg_arg1: f32) -> __float2;
        }
        __sincosf_stret(arg_arg1)
    })
}
pub unsafe fn __sincos_stret(arg_arg1: f64) -> __double2 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn __sincos_stret(arg_arg1: f64) -> __double2;
        }
        __sincos_stret(arg_arg1)
    })
}
pub unsafe fn __sincospif_stret(arg_arg1: f32) -> __float2 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn __sincospif_stret(arg_arg1: f32) -> __float2;
        }
        __sincospif_stret(arg_arg1)
    })
}
pub unsafe fn __sincospi_stret(arg_arg1: f64) -> __double2 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn __sincospi_stret(arg_arg1: f64) -> __double2;
        }
        __sincospi_stret(arg_arg1)
    })
}
pub unsafe fn j0(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn j0(arg_arg1: f64) -> f64;
        }
        j0(arg_arg1)
    })
}
pub unsafe fn j1(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn j1(arg_arg1: f64) -> f64;
        }
        j1(arg_arg1)
    })
}
pub unsafe fn jn(arg_arg1: ::std::os::raw::c_int, arg_arg2: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jn(arg_arg1: ::std::os::raw::c_int, arg_arg2: f64) -> f64;
        }
        jn(arg_arg1, arg_arg2)
    })
}
pub unsafe fn y0(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn y0(arg_arg1: f64) -> f64;
        }
        y0(arg_arg1)
    })
}
pub unsafe fn y1(arg_arg1: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn y1(arg_arg1: f64) -> f64;
        }
        y1(arg_arg1)
    })
}
pub unsafe fn yn(arg_arg1: ::std::os::raw::c_int, arg_arg2: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn yn(arg_arg1: ::std::os::raw::c_int, arg_arg2: f64) -> f64;
        }
        yn(arg_arg1, arg_arg2)
    })
}
pub unsafe fn scalb(arg_arg1: f64, arg_arg2: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn scalb(arg_arg1: f64, arg_arg2: f64) -> f64;
        }
        scalb(arg_arg1, arg_arg2)
    })
}
extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exception {
    pub type_: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
impl Default for exception {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn explicit_bzero(arg_buf: *mut ::std::os::raw::c_void, arg_len: usize) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn explicit_bzero(arg_buf: *mut ::std::os::raw::c_void, arg_len: usize);
        }
        explicit_bzero(arg_buf, arg_len)
    })
}
pub unsafe fn pg_qsort(
    arg_base: *mut ::std::os::raw::c_void,
    arg_nel: usize,
    arg_elsize: usize,
    arg_cmp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_qsort(
                arg_base: *mut ::std::os::raw::c_void,
                arg_nel: usize,
                arg_elsize: usize,
                arg_cmp: ::std::option::Option<
                    unsafe extern "C" fn(
                        arg1: *const ::std::os::raw::c_void,
                        arg2: *const ::std::os::raw::c_void,
                    ) -> ::std::os::raw::c_int,
                >,
            );
        }
        pg_qsort(arg_base, arg_nel, arg_elsize, arg_cmp)
    })
}
pub unsafe fn pg_qsort_strcmp(
    arg_a: *const ::std::os::raw::c_void,
    arg_b: *const ::std::os::raw::c_void,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_qsort_strcmp(
                arg_a: *const ::std::os::raw::c_void,
                arg_b: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int;
        }
        pg_qsort_strcmp(arg_a, arg_b)
    })
}
pub type qsort_arg_comparator = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub unsafe fn qsort_arg(
    arg_base: *mut ::std::os::raw::c_void,
    arg_nel: usize,
    arg_elsize: usize,
    arg_cmp: qsort_arg_comparator,
    arg_arg: *mut ::std::os::raw::c_void,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn qsort_arg(
                arg_base: *mut ::std::os::raw::c_void,
                arg_nel: usize,
                arg_elsize: usize,
                arg_cmp: qsort_arg_comparator,
                arg_arg: *mut ::std::os::raw::c_void,
            );
        }
        qsort_arg(arg_base, arg_nel, arg_elsize, arg_cmp, arg_arg)
    })
}
pub unsafe fn pg_get_encoding_from_locale(
    arg_ctype: *const ::std::os::raw::c_char,
    arg_write_message: bool,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_encoding_from_locale(
                arg_ctype: *const ::std::os::raw::c_char,
                arg_write_message: bool,
            ) -> ::std::os::raw::c_int;
        }
        pg_get_encoding_from_locale(arg_ctype, arg_write_message)
    })
}
pub unsafe fn pg_inet_net_ntop(
    arg_af: ::std::os::raw::c_int,
    arg_src: *const ::std::os::raw::c_void,
    arg_bits: ::std::os::raw::c_int,
    arg_dst: *mut ::std::os::raw::c_char,
    arg_size: usize,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_inet_net_ntop(
                arg_af: ::std::os::raw::c_int,
                arg_src: *const ::std::os::raw::c_void,
                arg_bits: ::std::os::raw::c_int,
                arg_dst: *mut ::std::os::raw::c_char,
                arg_size: usize,
            ) -> *mut ::std::os::raw::c_char;
        }
        pg_inet_net_ntop(arg_af, arg_src, arg_bits, arg_dst, arg_size)
    })
}
pub unsafe fn pg_strong_random(arg_buf: *mut ::std::os::raw::c_void, arg_len: usize) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_strong_random(arg_buf: *mut ::std::os::raw::c_void, arg_len: usize) -> bool;
        }
        pg_strong_random(arg_buf, arg_len)
    })
}
pub unsafe fn pg_check_dir(arg_dir: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_check_dir(arg_dir: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
        }
        pg_check_dir(arg_dir)
    })
}
pub unsafe fn pg_mkdir_p(
    arg_path: *mut ::std::os::raw::c_char,
    arg_omode: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_mkdir_p(
                arg_path: *mut ::std::os::raw::c_char,
                arg_omode: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        pg_mkdir_p(arg_path, arg_omode)
    })
}
pub type pqsigfunc = ::std::option::Option<unsafe extern "C" fn(signo: ::std::os::raw::c_int)>;
pub unsafe fn pqsignal(arg_signo: ::std::os::raw::c_int, arg_func: pqsigfunc) -> pqsigfunc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pqsignal(arg_signo: ::std::os::raw::c_int, arg_func: pqsigfunc) -> pqsigfunc;
        }
        pqsignal(arg_signo, arg_func)
    })
}
pub unsafe fn escape_single_quotes_ascii(
    arg_src: *const ::std::os::raw::c_char,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn escape_single_quotes_ascii(
                arg_src: *const ::std::os::raw::c_char,
            ) -> *mut ::std::os::raw::c_char;
        }
        escape_single_quotes_ascii(arg_src)
    })
}
pub unsafe fn wait_result_to_str(
    arg_exit_status: ::std::os::raw::c_int,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn wait_result_to_str(
                arg_exit_status: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_char;
        }
        wait_result_to_str(arg_exit_status)
    })
}
pub unsafe fn wait_result_is_signal(
    arg_exit_status: ::std::os::raw::c_int,
    arg_signum: ::std::os::raw::c_int,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn wait_result_is_signal(
                arg_exit_status: ::std::os::raw::c_int,
                arg_signum: ::std::os::raw::c_int,
            ) -> bool;
        }
        wait_result_is_signal(arg_exit_status, arg_signum)
    })
}
pub unsafe fn wait_result_is_any_signal(
    arg_exit_status: ::std::os::raw::c_int,
    arg_include_command_not_found: bool,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn wait_result_is_any_signal(
                arg_exit_status: ::std::os::raw::c_int,
                arg_include_command_not_found: bool,
            ) -> bool;
        }
        wait_result_is_any_signal(arg_exit_status, arg_include_command_not_found)
    })
}
pub type jmp_buf = [::std::os::raw::c_int; 48usize];
pub type sigjmp_buf = [::std::os::raw::c_int; 49usize];
pub unsafe fn longjmperror() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn longjmperror();
        }
        longjmperror()
    })
}
pub unsafe fn errstart(
    arg_elevel: ::std::os::raw::c_int,
    arg_domain: *const ::std::os::raw::c_char,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn errstart(
                arg_elevel: ::std::os::raw::c_int,
                arg_domain: *const ::std::os::raw::c_char,
            ) -> bool;
        }
        errstart(arg_elevel, arg_domain)
    })
}
pub unsafe fn errfinish(
    arg_filename: *const ::std::os::raw::c_char,
    arg_lineno: ::std::os::raw::c_int,
    arg_funcname: *const ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn errfinish(
                arg_filename: *const ::std::os::raw::c_char,
                arg_lineno: ::std::os::raw::c_int,
                arg_funcname: *const ::std::os::raw::c_char,
            );
        }
        errfinish(arg_filename, arg_lineno, arg_funcname)
    })
}
pub unsafe fn errcode(arg_sqlerrcode: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn errcode(arg_sqlerrcode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        errcode(arg_sqlerrcode)
    })
}
pub unsafe fn errcode_for_file_access() -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn errcode_for_file_access() -> ::std::os::raw::c_int;
        }
        errcode_for_file_access()
    })
}
pub unsafe fn errcode_for_socket_access() -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn errcode_for_socket_access() -> ::std::os::raw::c_int;
        }
        errcode_for_socket_access()
    })
}
pub unsafe fn errmsg(arg_fmt: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn errmsg(arg_fmt: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
        }
        errmsg(arg_fmt)
    })
}
pub unsafe fn errmsg_internal(arg_fmt: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn errmsg_internal(arg_fmt: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
        }
        errmsg_internal(arg_fmt)
    })
}
pub unsafe fn errmsg_plural(
    arg_fmt_singular: *const ::std::os::raw::c_char,
    arg_fmt_plural: *const ::std::os::raw::c_char,
    arg_n: ::std::os::raw::c_ulong,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn errmsg_plural(
                arg_fmt_singular: *const ::std::os::raw::c_char,
                arg_fmt_plural: *const ::std::os::raw::c_char,
                arg_n: ::std::os::raw::c_ulong,
            ) -> ::std::os::raw::c_int;
        }
        errmsg_plural(arg_fmt_singular, arg_fmt_plural, arg_n)
    })
}
pub unsafe fn errdetail(arg_fmt: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn errdetail(arg_fmt: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
        }
        errdetail(arg_fmt)
    })
}
pub unsafe fn errdetail_internal(arg_fmt: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn errdetail_internal(arg_fmt: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
        }
        errdetail_internal(arg_fmt)
    })
}
pub unsafe fn errdetail_log(arg_fmt: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn errdetail_log(arg_fmt: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
        }
        errdetail_log(arg_fmt)
    })
}
pub unsafe fn errdetail_log_plural(
    arg_fmt_singular: *const ::std::os::raw::c_char,
    arg_fmt_plural: *const ::std::os::raw::c_char,
    arg_n: ::std::os::raw::c_ulong,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn errdetail_log_plural(
                arg_fmt_singular: *const ::std::os::raw::c_char,
                arg_fmt_plural: *const ::std::os::raw::c_char,
                arg_n: ::std::os::raw::c_ulong,
            ) -> ::std::os::raw::c_int;
        }
        errdetail_log_plural(arg_fmt_singular, arg_fmt_plural, arg_n)
    })
}
pub unsafe fn errdetail_plural(
    arg_fmt_singular: *const ::std::os::raw::c_char,
    arg_fmt_plural: *const ::std::os::raw::c_char,
    arg_n: ::std::os::raw::c_ulong,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn errdetail_plural(
                arg_fmt_singular: *const ::std::os::raw::c_char,
                arg_fmt_plural: *const ::std::os::raw::c_char,
                arg_n: ::std::os::raw::c_ulong,
            ) -> ::std::os::raw::c_int;
        }
        errdetail_plural(arg_fmt_singular, arg_fmt_plural, arg_n)
    })
}
pub unsafe fn errhint(arg_fmt: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn errhint(arg_fmt: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
        }
        errhint(arg_fmt)
    })
}
pub unsafe fn set_errcontext_domain(
    arg_domain: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn set_errcontext_domain(
                arg_domain: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        set_errcontext_domain(arg_domain)
    })
}
pub unsafe fn errcontext_msg(arg_fmt: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn errcontext_msg(arg_fmt: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
        }
        errcontext_msg(arg_fmt)
    })
}
pub unsafe fn errhidestmt(arg_hide_stmt: bool) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn errhidestmt(arg_hide_stmt: bool) -> ::std::os::raw::c_int;
        }
        errhidestmt(arg_hide_stmt)
    })
}
pub unsafe fn errhidecontext(arg_hide_ctx: bool) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn errhidecontext(arg_hide_ctx: bool) -> ::std::os::raw::c_int;
        }
        errhidecontext(arg_hide_ctx)
    })
}
pub unsafe fn errbacktrace() -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn errbacktrace() -> ::std::os::raw::c_int;
        }
        errbacktrace()
    })
}
pub unsafe fn errfunction(arg_funcname: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn errfunction(arg_funcname: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
        }
        errfunction(arg_funcname)
    })
}
pub unsafe fn errposition(arg_cursorpos: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn errposition(arg_cursorpos: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        errposition(arg_cursorpos)
    })
}
pub unsafe fn internalerrposition(arg_cursorpos: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn internalerrposition(arg_cursorpos: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        internalerrposition(arg_cursorpos)
    })
}
pub unsafe fn internalerrquery(arg_query: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn internalerrquery(arg_query: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
        }
        internalerrquery(arg_query)
    })
}
pub unsafe fn err_generic_string(
    arg_field: ::std::os::raw::c_int,
    arg_str_: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn err_generic_string(
                arg_field: ::std::os::raw::c_int,
                arg_str_: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        err_generic_string(arg_field, arg_str_)
    })
}
pub unsafe fn geterrcode() -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn geterrcode() -> ::std::os::raw::c_int;
        }
        geterrcode()
    })
}
pub unsafe fn geterrposition() -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn geterrposition() -> ::std::os::raw::c_int;
        }
        geterrposition()
    })
}
pub unsafe fn getinternalerrposition() -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getinternalerrposition() -> ::std::os::raw::c_int;
        }
        getinternalerrposition()
    })
}
pub unsafe fn pre_format_elog_string(
    arg_errnumber: ::std::os::raw::c_int,
    arg_domain: *const ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pre_format_elog_string(
                arg_errnumber: ::std::os::raw::c_int,
                arg_domain: *const ::std::os::raw::c_char,
            );
        }
        pre_format_elog_string(arg_errnumber, arg_domain)
    })
}
pub unsafe fn format_elog_string(
    arg_fmt: *const ::std::os::raw::c_char,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn format_elog_string(
                arg_fmt: *const ::std::os::raw::c_char,
            ) -> *mut ::std::os::raw::c_char;
        }
        format_elog_string(arg_fmt)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ErrorContextCallback {
    pub previous: *mut ErrorContextCallback,
    pub callback: ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void)>,
    pub arg: *mut ::std::os::raw::c_void,
}
impl Default for ErrorContextCallback {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut error_context_stack: *mut ErrorContextCallback;
}
extern "C" {
    pub static mut PG_exception_stack: *mut sigjmp_buf;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ErrorData {
    pub elevel: ::std::os::raw::c_int,
    pub output_to_server: bool,
    pub output_to_client: bool,
    pub show_funcname: bool,
    pub hide_stmt: bool,
    pub hide_ctx: bool,
    pub filename: *const ::std::os::raw::c_char,
    pub lineno: ::std::os::raw::c_int,
    pub funcname: *const ::std::os::raw::c_char,
    pub domain: *const ::std::os::raw::c_char,
    pub context_domain: *const ::std::os::raw::c_char,
    pub sqlerrcode: ::std::os::raw::c_int,
    pub message: *mut ::std::os::raw::c_char,
    pub detail: *mut ::std::os::raw::c_char,
    pub detail_log: *mut ::std::os::raw::c_char,
    pub hint: *mut ::std::os::raw::c_char,
    pub context: *mut ::std::os::raw::c_char,
    pub backtrace: *mut ::std::os::raw::c_char,
    pub message_id: *const ::std::os::raw::c_char,
    pub schema_name: *mut ::std::os::raw::c_char,
    pub table_name: *mut ::std::os::raw::c_char,
    pub column_name: *mut ::std::os::raw::c_char,
    pub datatype_name: *mut ::std::os::raw::c_char,
    pub constraint_name: *mut ::std::os::raw::c_char,
    pub cursorpos: ::std::os::raw::c_int,
    pub internalpos: ::std::os::raw::c_int,
    pub internalquery: *mut ::std::os::raw::c_char,
    pub saved_errno: ::std::os::raw::c_int,
    pub assoc_context: *mut MemoryContextData,
}
impl Default for ErrorData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn EmitErrorReport() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EmitErrorReport();
        }
        EmitErrorReport()
    })
}
pub unsafe fn CopyErrorData() -> *mut ErrorData {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CopyErrorData() -> *mut ErrorData;
        }
        CopyErrorData()
    })
}
pub unsafe fn FreeErrorData(arg_edata: *mut ErrorData) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FreeErrorData(arg_edata: *mut ErrorData);
        }
        FreeErrorData(arg_edata)
    })
}
pub unsafe fn FlushErrorState() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FlushErrorState();
        }
        FlushErrorState()
    })
}
pub unsafe fn ReThrowError(arg_edata: *mut ErrorData) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReThrowError(arg_edata: *mut ErrorData);
        }
        ReThrowError(arg_edata)
    })
}
pub unsafe fn ThrowErrorData(arg_edata: *mut ErrorData) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ThrowErrorData(arg_edata: *mut ErrorData);
        }
        ThrowErrorData(arg_edata)
    })
}
pub unsafe fn GetErrorContextStack() -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetErrorContextStack() -> *mut ::std::os::raw::c_char;
        }
        GetErrorContextStack()
    })
}
pub type emit_log_hook_type = ::std::option::Option<unsafe extern "C" fn(edata: *mut ErrorData)>;
extern "C" {
    pub static mut emit_log_hook: emit_log_hook_type;
}
pub const PGErrorVerbosity_PGERROR_TERSE: PGErrorVerbosity = 0;
pub const PGErrorVerbosity_PGERROR_DEFAULT: PGErrorVerbosity = 1;
pub const PGErrorVerbosity_PGERROR_VERBOSE: PGErrorVerbosity = 2;
pub type PGErrorVerbosity = ::std::os::raw::c_uint;
extern "C" {
    pub static mut Log_error_verbosity: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut Log_line_prefix: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut Log_destination: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut Log_destination_string: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut syslog_sequence_numbers: bool;
}
extern "C" {
    pub static mut syslog_split_messages: bool;
}
pub unsafe fn DebugFileOpen() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DebugFileOpen();
        }
        DebugFileOpen()
    })
}
pub unsafe fn unpack_sql_state(
    arg_sql_state: ::std::os::raw::c_int,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn unpack_sql_state(
                arg_sql_state: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_char;
        }
        unpack_sql_state(arg_sql_state)
    })
}
pub unsafe fn in_error_recursion_trouble() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn in_error_recursion_trouble() -> bool;
        }
        in_error_recursion_trouble()
    })
}
pub unsafe fn set_syslog_parameters(
    arg_ident: *const ::std::os::raw::c_char,
    arg_facility: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn set_syslog_parameters(
                arg_ident: *const ::std::os::raw::c_char,
                arg_facility: ::std::os::raw::c_int,
            );
        }
        set_syslog_parameters(arg_ident, arg_facility)
    })
}
pub unsafe fn write_stderr(arg_fmt: *const ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn write_stderr(arg_fmt: *const ::std::os::raw::c_char);
        }
        write_stderr(arg_fmt)
    })
}
pub type MemoryContext = *mut MemoryContextData;
pub type MemoryContextCallbackFunction =
    ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryContextCallback {
    pub func: MemoryContextCallbackFunction,
    pub arg: *mut ::std::os::raw::c_void,
    pub next: *mut MemoryContextCallback,
}
impl Default for MemoryContextCallback {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut CurrentMemoryContext: MemoryContext;
}
pub unsafe fn MemoryContextAlloc(
    arg_context: MemoryContext,
    arg_size: Size,
) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MemoryContextAlloc(
                arg_context: MemoryContext,
                arg_size: Size,
            ) -> *mut ::std::os::raw::c_void;
        }
        MemoryContextAlloc(arg_context, arg_size)
    })
}
pub unsafe fn MemoryContextAllocZero(
    arg_context: MemoryContext,
    arg_size: Size,
) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MemoryContextAllocZero(
                arg_context: MemoryContext,
                arg_size: Size,
            ) -> *mut ::std::os::raw::c_void;
        }
        MemoryContextAllocZero(arg_context, arg_size)
    })
}
pub unsafe fn MemoryContextAllocZeroAligned(
    arg_context: MemoryContext,
    arg_size: Size,
) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MemoryContextAllocZeroAligned(
                arg_context: MemoryContext,
                arg_size: Size,
            ) -> *mut ::std::os::raw::c_void;
        }
        MemoryContextAllocZeroAligned(arg_context, arg_size)
    })
}
pub unsafe fn MemoryContextAllocExtended(
    arg_context: MemoryContext,
    arg_size: Size,
    arg_flags: ::std::os::raw::c_int,
) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MemoryContextAllocExtended(
                arg_context: MemoryContext,
                arg_size: Size,
                arg_flags: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_void;
        }
        MemoryContextAllocExtended(arg_context, arg_size, arg_flags)
    })
}
pub unsafe fn palloc(arg_size: Size) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn palloc(arg_size: Size) -> *mut ::std::os::raw::c_void;
        }
        palloc(arg_size)
    })
}
pub unsafe fn palloc0(arg_size: Size) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn palloc0(arg_size: Size) -> *mut ::std::os::raw::c_void;
        }
        palloc0(arg_size)
    })
}
pub unsafe fn palloc_extended(
    arg_size: Size,
    arg_flags: ::std::os::raw::c_int,
) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn palloc_extended(
                arg_size: Size,
                arg_flags: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_void;
        }
        palloc_extended(arg_size, arg_flags)
    })
}
pub unsafe fn repalloc(
    arg_pointer: *mut ::std::os::raw::c_void,
    arg_size: Size,
) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn repalloc(
                arg_pointer: *mut ::std::os::raw::c_void,
                arg_size: Size,
            ) -> *mut ::std::os::raw::c_void;
        }
        repalloc(arg_pointer, arg_size)
    })
}
pub unsafe fn pfree(arg_pointer: *mut ::std::os::raw::c_void) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pfree(arg_pointer: *mut ::std::os::raw::c_void);
        }
        pfree(arg_pointer)
    })
}
pub unsafe fn MemoryContextAllocHuge(
    arg_context: MemoryContext,
    arg_size: Size,
) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MemoryContextAllocHuge(
                arg_context: MemoryContext,
                arg_size: Size,
            ) -> *mut ::std::os::raw::c_void;
        }
        MemoryContextAllocHuge(arg_context, arg_size)
    })
}
pub unsafe fn repalloc_huge(
    arg_pointer: *mut ::std::os::raw::c_void,
    arg_size: Size,
) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn repalloc_huge(
                arg_pointer: *mut ::std::os::raw::c_void,
                arg_size: Size,
            ) -> *mut ::std::os::raw::c_void;
        }
        repalloc_huge(arg_pointer, arg_size)
    })
}
pub unsafe fn MemoryContextRegisterResetCallback(
    arg_context: MemoryContext,
    arg_cb: *mut MemoryContextCallback,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MemoryContextRegisterResetCallback(
                arg_context: MemoryContext,
                arg_cb: *mut MemoryContextCallback,
            );
        }
        MemoryContextRegisterResetCallback(arg_context, arg_cb)
    })
}
pub unsafe fn MemoryContextStrdup(
    arg_context: MemoryContext,
    arg_string: *const ::std::os::raw::c_char,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MemoryContextStrdup(
                arg_context: MemoryContext,
                arg_string: *const ::std::os::raw::c_char,
            ) -> *mut ::std::os::raw::c_char;
        }
        MemoryContextStrdup(arg_context, arg_string)
    })
}
pub unsafe fn pstrdup(arg_in_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pstrdup(arg_in_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
        }
        pstrdup(arg_in_)
    })
}
pub unsafe fn pnstrdup(
    arg_in_: *const ::std::os::raw::c_char,
    arg_len: Size,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pnstrdup(
                arg_in_: *const ::std::os::raw::c_char,
                arg_len: Size,
            ) -> *mut ::std::os::raw::c_char;
        }
        pnstrdup(arg_in_, arg_len)
    })
}
pub unsafe fn pchomp(arg_in_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pchomp(arg_in_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
        }
        pchomp(arg_in_)
    })
}
pub unsafe fn psprintf(arg_fmt: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn psprintf(arg_fmt: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
        }
        psprintf(arg_fmt)
    })
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct varatt_external {
    pub va_rawsize: int32,
    pub va_extsize: int32,
    pub va_valueid: Oid,
    pub va_toastrelid: Oid,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct varatt_indirect {
    pub pointer: *mut varlena,
}
impl Default for varatt_indirect {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct varatt_expanded {
    pub eohptr: *mut ExpandedObjectHeader,
}
impl Default for varatt_expanded {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const vartag_external_VARTAG_INDIRECT: vartag_external = 1;
pub const vartag_external_VARTAG_EXPANDED_RO: vartag_external = 2;
pub const vartag_external_VARTAG_EXPANDED_RW: vartag_external = 3;
pub const vartag_external_VARTAG_ONDISK: vartag_external = 18;
pub type vartag_external = ::std::os::raw::c_uint;
#[repr(C)]
pub struct varattrib_4b {
    pub va_4byte: __BindgenUnionField<varattrib_4b__bindgen_ty_1>,
    pub va_compressed: __BindgenUnionField<varattrib_4b__bindgen_ty_2>,
    pub bindgen_union_field: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct varattrib_4b__bindgen_ty_1 {
    pub va_header: uint32,
    pub va_data: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct varattrib_4b__bindgen_ty_2 {
    pub va_header: uint32,
    pub va_rawsize: uint32,
    pub va_data: __IncompleteArrayField<::std::os::raw::c_char>,
}
impl Default for varattrib_4b {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct varattrib_1b {
    pub va_header: uint8,
    pub va_data: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct varattrib_1b_e {
    pub va_header: uint8,
    pub va_tag: uint8,
    pub va_data: __IncompleteArrayField<::std::os::raw::c_char>,
}
pub type AttrNumber = int16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_attribute {
    pub attrelid: Oid,
    pub attname: NameData,
    pub atttypid: Oid,
    pub attstattarget: int32,
    pub attlen: int16,
    pub attnum: int16,
    pub attndims: int32,
    pub attcacheoff: int32,
    pub atttypmod: int32,
    pub attbyval: bool,
    pub attstorage: ::std::os::raw::c_char,
    pub attalign: ::std::os::raw::c_char,
    pub attnotnull: bool,
    pub atthasdef: bool,
    pub atthasmissing: bool,
    pub attidentity: ::std::os::raw::c_char,
    pub attgenerated: ::std::os::raw::c_char,
    pub attisdropped: bool,
    pub attislocal: bool,
    pub attinhcount: int32,
    pub attcollation: Oid,
}
impl Default for FormData_pg_attribute {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_attribute = *mut FormData_pg_attribute;
pub const NodeTag_T_Invalid: NodeTag = 0;
pub const NodeTag_T_IndexInfo: NodeTag = 1;
pub const NodeTag_T_ExprContext: NodeTag = 2;
pub const NodeTag_T_ProjectionInfo: NodeTag = 3;
pub const NodeTag_T_JunkFilter: NodeTag = 4;
pub const NodeTag_T_OnConflictSetState: NodeTag = 5;
pub const NodeTag_T_ResultRelInfo: NodeTag = 6;
pub const NodeTag_T_EState: NodeTag = 7;
pub const NodeTag_T_TupleTableSlot: NodeTag = 8;
pub const NodeTag_T_Plan: NodeTag = 9;
pub const NodeTag_T_Result: NodeTag = 10;
pub const NodeTag_T_ProjectSet: NodeTag = 11;
pub const NodeTag_T_ModifyTable: NodeTag = 12;
pub const NodeTag_T_Append: NodeTag = 13;
pub const NodeTag_T_MergeAppend: NodeTag = 14;
pub const NodeTag_T_RecursiveUnion: NodeTag = 15;
pub const NodeTag_T_BitmapAnd: NodeTag = 16;
pub const NodeTag_T_BitmapOr: NodeTag = 17;
pub const NodeTag_T_Scan: NodeTag = 18;
pub const NodeTag_T_SeqScan: NodeTag = 19;
pub const NodeTag_T_SampleScan: NodeTag = 20;
pub const NodeTag_T_IndexScan: NodeTag = 21;
pub const NodeTag_T_IndexOnlyScan: NodeTag = 22;
pub const NodeTag_T_BitmapIndexScan: NodeTag = 23;
pub const NodeTag_T_BitmapHeapScan: NodeTag = 24;
pub const NodeTag_T_TidScan: NodeTag = 25;
pub const NodeTag_T_SubqueryScan: NodeTag = 26;
pub const NodeTag_T_FunctionScan: NodeTag = 27;
pub const NodeTag_T_ValuesScan: NodeTag = 28;
pub const NodeTag_T_TableFuncScan: NodeTag = 29;
pub const NodeTag_T_CteScan: NodeTag = 30;
pub const NodeTag_T_NamedTuplestoreScan: NodeTag = 31;
pub const NodeTag_T_WorkTableScan: NodeTag = 32;
pub const NodeTag_T_ForeignScan: NodeTag = 33;
pub const NodeTag_T_CustomScan: NodeTag = 34;
pub const NodeTag_T_Join: NodeTag = 35;
pub const NodeTag_T_NestLoop: NodeTag = 36;
pub const NodeTag_T_MergeJoin: NodeTag = 37;
pub const NodeTag_T_HashJoin: NodeTag = 38;
pub const NodeTag_T_Material: NodeTag = 39;
pub const NodeTag_T_Sort: NodeTag = 40;
pub const NodeTag_T_IncrementalSort: NodeTag = 41;
pub const NodeTag_T_Group: NodeTag = 42;
pub const NodeTag_T_Agg: NodeTag = 43;
pub const NodeTag_T_WindowAgg: NodeTag = 44;
pub const NodeTag_T_Unique: NodeTag = 45;
pub const NodeTag_T_Gather: NodeTag = 46;
pub const NodeTag_T_GatherMerge: NodeTag = 47;
pub const NodeTag_T_Hash: NodeTag = 48;
pub const NodeTag_T_SetOp: NodeTag = 49;
pub const NodeTag_T_LockRows: NodeTag = 50;
pub const NodeTag_T_Limit: NodeTag = 51;
pub const NodeTag_T_NestLoopParam: NodeTag = 52;
pub const NodeTag_T_PlanRowMark: NodeTag = 53;
pub const NodeTag_T_PartitionPruneInfo: NodeTag = 54;
pub const NodeTag_T_PartitionedRelPruneInfo: NodeTag = 55;
pub const NodeTag_T_PartitionPruneStepOp: NodeTag = 56;
pub const NodeTag_T_PartitionPruneStepCombine: NodeTag = 57;
pub const NodeTag_T_PlanInvalItem: NodeTag = 58;
pub const NodeTag_T_PlanState: NodeTag = 59;
pub const NodeTag_T_ResultState: NodeTag = 60;
pub const NodeTag_T_ProjectSetState: NodeTag = 61;
pub const NodeTag_T_ModifyTableState: NodeTag = 62;
pub const NodeTag_T_AppendState: NodeTag = 63;
pub const NodeTag_T_MergeAppendState: NodeTag = 64;
pub const NodeTag_T_RecursiveUnionState: NodeTag = 65;
pub const NodeTag_T_BitmapAndState: NodeTag = 66;
pub const NodeTag_T_BitmapOrState: NodeTag = 67;
pub const NodeTag_T_ScanState: NodeTag = 68;
pub const NodeTag_T_SeqScanState: NodeTag = 69;
pub const NodeTag_T_SampleScanState: NodeTag = 70;
pub const NodeTag_T_IndexScanState: NodeTag = 71;
pub const NodeTag_T_IndexOnlyScanState: NodeTag = 72;
pub const NodeTag_T_BitmapIndexScanState: NodeTag = 73;
pub const NodeTag_T_BitmapHeapScanState: NodeTag = 74;
pub const NodeTag_T_TidScanState: NodeTag = 75;
pub const NodeTag_T_SubqueryScanState: NodeTag = 76;
pub const NodeTag_T_FunctionScanState: NodeTag = 77;
pub const NodeTag_T_TableFuncScanState: NodeTag = 78;
pub const NodeTag_T_ValuesScanState: NodeTag = 79;
pub const NodeTag_T_CteScanState: NodeTag = 80;
pub const NodeTag_T_NamedTuplestoreScanState: NodeTag = 81;
pub const NodeTag_T_WorkTableScanState: NodeTag = 82;
pub const NodeTag_T_ForeignScanState: NodeTag = 83;
pub const NodeTag_T_CustomScanState: NodeTag = 84;
pub const NodeTag_T_JoinState: NodeTag = 85;
pub const NodeTag_T_NestLoopState: NodeTag = 86;
pub const NodeTag_T_MergeJoinState: NodeTag = 87;
pub const NodeTag_T_HashJoinState: NodeTag = 88;
pub const NodeTag_T_MaterialState: NodeTag = 89;
pub const NodeTag_T_SortState: NodeTag = 90;
pub const NodeTag_T_IncrementalSortState: NodeTag = 91;
pub const NodeTag_T_GroupState: NodeTag = 92;
pub const NodeTag_T_AggState: NodeTag = 93;
pub const NodeTag_T_WindowAggState: NodeTag = 94;
pub const NodeTag_T_UniqueState: NodeTag = 95;
pub const NodeTag_T_GatherState: NodeTag = 96;
pub const NodeTag_T_GatherMergeState: NodeTag = 97;
pub const NodeTag_T_HashState: NodeTag = 98;
pub const NodeTag_T_SetOpState: NodeTag = 99;
pub const NodeTag_T_LockRowsState: NodeTag = 100;
pub const NodeTag_T_LimitState: NodeTag = 101;
pub const NodeTag_T_Alias: NodeTag = 102;
pub const NodeTag_T_RangeVar: NodeTag = 103;
pub const NodeTag_T_TableFunc: NodeTag = 104;
pub const NodeTag_T_Expr: NodeTag = 105;
pub const NodeTag_T_Var: NodeTag = 106;
pub const NodeTag_T_Const: NodeTag = 107;
pub const NodeTag_T_Param: NodeTag = 108;
pub const NodeTag_T_Aggref: NodeTag = 109;
pub const NodeTag_T_GroupingFunc: NodeTag = 110;
pub const NodeTag_T_WindowFunc: NodeTag = 111;
pub const NodeTag_T_SubscriptingRef: NodeTag = 112;
pub const NodeTag_T_FuncExpr: NodeTag = 113;
pub const NodeTag_T_NamedArgExpr: NodeTag = 114;
pub const NodeTag_T_OpExpr: NodeTag = 115;
pub const NodeTag_T_DistinctExpr: NodeTag = 116;
pub const NodeTag_T_NullIfExpr: NodeTag = 117;
pub const NodeTag_T_ScalarArrayOpExpr: NodeTag = 118;
pub const NodeTag_T_BoolExpr: NodeTag = 119;
pub const NodeTag_T_SubLink: NodeTag = 120;
pub const NodeTag_T_SubPlan: NodeTag = 121;
pub const NodeTag_T_AlternativeSubPlan: NodeTag = 122;
pub const NodeTag_T_FieldSelect: NodeTag = 123;
pub const NodeTag_T_FieldStore: NodeTag = 124;
pub const NodeTag_T_RelabelType: NodeTag = 125;
pub const NodeTag_T_CoerceViaIO: NodeTag = 126;
pub const NodeTag_T_ArrayCoerceExpr: NodeTag = 127;
pub const NodeTag_T_ConvertRowtypeExpr: NodeTag = 128;
pub const NodeTag_T_CollateExpr: NodeTag = 129;
pub const NodeTag_T_CaseExpr: NodeTag = 130;
pub const NodeTag_T_CaseWhen: NodeTag = 131;
pub const NodeTag_T_CaseTestExpr: NodeTag = 132;
pub const NodeTag_T_ArrayExpr: NodeTag = 133;
pub const NodeTag_T_RowExpr: NodeTag = 134;
pub const NodeTag_T_RowCompareExpr: NodeTag = 135;
pub const NodeTag_T_CoalesceExpr: NodeTag = 136;
pub const NodeTag_T_MinMaxExpr: NodeTag = 137;
pub const NodeTag_T_SQLValueFunction: NodeTag = 138;
pub const NodeTag_T_XmlExpr: NodeTag = 139;
pub const NodeTag_T_NullTest: NodeTag = 140;
pub const NodeTag_T_BooleanTest: NodeTag = 141;
pub const NodeTag_T_CoerceToDomain: NodeTag = 142;
pub const NodeTag_T_CoerceToDomainValue: NodeTag = 143;
pub const NodeTag_T_SetToDefault: NodeTag = 144;
pub const NodeTag_T_CurrentOfExpr: NodeTag = 145;
pub const NodeTag_T_NextValueExpr: NodeTag = 146;
pub const NodeTag_T_InferenceElem: NodeTag = 147;
pub const NodeTag_T_TargetEntry: NodeTag = 148;
pub const NodeTag_T_RangeTblRef: NodeTag = 149;
pub const NodeTag_T_JoinExpr: NodeTag = 150;
pub const NodeTag_T_FromExpr: NodeTag = 151;
pub const NodeTag_T_OnConflictExpr: NodeTag = 152;
pub const NodeTag_T_IntoClause: NodeTag = 153;
pub const NodeTag_T_ExprState: NodeTag = 154;
pub const NodeTag_T_AggrefExprState: NodeTag = 155;
pub const NodeTag_T_WindowFuncExprState: NodeTag = 156;
pub const NodeTag_T_SetExprState: NodeTag = 157;
pub const NodeTag_T_SubPlanState: NodeTag = 158;
pub const NodeTag_T_AlternativeSubPlanState: NodeTag = 159;
pub const NodeTag_T_DomainConstraintState: NodeTag = 160;
pub const NodeTag_T_PlannerInfo: NodeTag = 161;
pub const NodeTag_T_PlannerGlobal: NodeTag = 162;
pub const NodeTag_T_RelOptInfo: NodeTag = 163;
pub const NodeTag_T_IndexOptInfo: NodeTag = 164;
pub const NodeTag_T_ForeignKeyOptInfo: NodeTag = 165;
pub const NodeTag_T_ParamPathInfo: NodeTag = 166;
pub const NodeTag_T_Path: NodeTag = 167;
pub const NodeTag_T_IndexPath: NodeTag = 168;
pub const NodeTag_T_BitmapHeapPath: NodeTag = 169;
pub const NodeTag_T_BitmapAndPath: NodeTag = 170;
pub const NodeTag_T_BitmapOrPath: NodeTag = 171;
pub const NodeTag_T_TidPath: NodeTag = 172;
pub const NodeTag_T_SubqueryScanPath: NodeTag = 173;
pub const NodeTag_T_ForeignPath: NodeTag = 174;
pub const NodeTag_T_CustomPath: NodeTag = 175;
pub const NodeTag_T_NestPath: NodeTag = 176;
pub const NodeTag_T_MergePath: NodeTag = 177;
pub const NodeTag_T_HashPath: NodeTag = 178;
pub const NodeTag_T_AppendPath: NodeTag = 179;
pub const NodeTag_T_MergeAppendPath: NodeTag = 180;
pub const NodeTag_T_GroupResultPath: NodeTag = 181;
pub const NodeTag_T_MaterialPath: NodeTag = 182;
pub const NodeTag_T_UniquePath: NodeTag = 183;
pub const NodeTag_T_GatherPath: NodeTag = 184;
pub const NodeTag_T_GatherMergePath: NodeTag = 185;
pub const NodeTag_T_ProjectionPath: NodeTag = 186;
pub const NodeTag_T_ProjectSetPath: NodeTag = 187;
pub const NodeTag_T_SortPath: NodeTag = 188;
pub const NodeTag_T_IncrementalSortPath: NodeTag = 189;
pub const NodeTag_T_GroupPath: NodeTag = 190;
pub const NodeTag_T_UpperUniquePath: NodeTag = 191;
pub const NodeTag_T_AggPath: NodeTag = 192;
pub const NodeTag_T_GroupingSetsPath: NodeTag = 193;
pub const NodeTag_T_MinMaxAggPath: NodeTag = 194;
pub const NodeTag_T_WindowAggPath: NodeTag = 195;
pub const NodeTag_T_SetOpPath: NodeTag = 196;
pub const NodeTag_T_RecursiveUnionPath: NodeTag = 197;
pub const NodeTag_T_LockRowsPath: NodeTag = 198;
pub const NodeTag_T_ModifyTablePath: NodeTag = 199;
pub const NodeTag_T_LimitPath: NodeTag = 200;
pub const NodeTag_T_EquivalenceClass: NodeTag = 201;
pub const NodeTag_T_EquivalenceMember: NodeTag = 202;
pub const NodeTag_T_PathKey: NodeTag = 203;
pub const NodeTag_T_PathTarget: NodeTag = 204;
pub const NodeTag_T_RestrictInfo: NodeTag = 205;
pub const NodeTag_T_IndexClause: NodeTag = 206;
pub const NodeTag_T_PlaceHolderVar: NodeTag = 207;
pub const NodeTag_T_SpecialJoinInfo: NodeTag = 208;
pub const NodeTag_T_AppendRelInfo: NodeTag = 209;
pub const NodeTag_T_PlaceHolderInfo: NodeTag = 210;
pub const NodeTag_T_MinMaxAggInfo: NodeTag = 211;
pub const NodeTag_T_PlannerParamItem: NodeTag = 212;
pub const NodeTag_T_RollupData: NodeTag = 213;
pub const NodeTag_T_GroupingSetData: NodeTag = 214;
pub const NodeTag_T_StatisticExtInfo: NodeTag = 215;
pub const NodeTag_T_MemoryContext: NodeTag = 216;
pub const NodeTag_T_AllocSetContext: NodeTag = 217;
pub const NodeTag_T_SlabContext: NodeTag = 218;
pub const NodeTag_T_GenerationContext: NodeTag = 219;
pub const NodeTag_T_Value: NodeTag = 220;
pub const NodeTag_T_Integer: NodeTag = 221;
pub const NodeTag_T_Float: NodeTag = 222;
pub const NodeTag_T_String: NodeTag = 223;
pub const NodeTag_T_BitString: NodeTag = 224;
pub const NodeTag_T_Null: NodeTag = 225;
pub const NodeTag_T_List: NodeTag = 226;
pub const NodeTag_T_IntList: NodeTag = 227;
pub const NodeTag_T_OidList: NodeTag = 228;
pub const NodeTag_T_ExtensibleNode: NodeTag = 229;
pub const NodeTag_T_RawStmt: NodeTag = 230;
pub const NodeTag_T_Query: NodeTag = 231;
pub const NodeTag_T_PlannedStmt: NodeTag = 232;
pub const NodeTag_T_InsertStmt: NodeTag = 233;
pub const NodeTag_T_DeleteStmt: NodeTag = 234;
pub const NodeTag_T_UpdateStmt: NodeTag = 235;
pub const NodeTag_T_SelectStmt: NodeTag = 236;
pub const NodeTag_T_AlterTableStmt: NodeTag = 237;
pub const NodeTag_T_AlterTableCmd: NodeTag = 238;
pub const NodeTag_T_AlterDomainStmt: NodeTag = 239;
pub const NodeTag_T_SetOperationStmt: NodeTag = 240;
pub const NodeTag_T_GrantStmt: NodeTag = 241;
pub const NodeTag_T_GrantRoleStmt: NodeTag = 242;
pub const NodeTag_T_AlterDefaultPrivilegesStmt: NodeTag = 243;
pub const NodeTag_T_ClosePortalStmt: NodeTag = 244;
pub const NodeTag_T_ClusterStmt: NodeTag = 245;
pub const NodeTag_T_CopyStmt: NodeTag = 246;
pub const NodeTag_T_CreateStmt: NodeTag = 247;
pub const NodeTag_T_DefineStmt: NodeTag = 248;
pub const NodeTag_T_DropStmt: NodeTag = 249;
pub const NodeTag_T_TruncateStmt: NodeTag = 250;
pub const NodeTag_T_CommentStmt: NodeTag = 251;
pub const NodeTag_T_FetchStmt: NodeTag = 252;
pub const NodeTag_T_IndexStmt: NodeTag = 253;
pub const NodeTag_T_CreateFunctionStmt: NodeTag = 254;
pub const NodeTag_T_AlterFunctionStmt: NodeTag = 255;
pub const NodeTag_T_DoStmt: NodeTag = 256;
pub const NodeTag_T_RenameStmt: NodeTag = 257;
pub const NodeTag_T_RuleStmt: NodeTag = 258;
pub const NodeTag_T_NotifyStmt: NodeTag = 259;
pub const NodeTag_T_ListenStmt: NodeTag = 260;
pub const NodeTag_T_UnlistenStmt: NodeTag = 261;
pub const NodeTag_T_TransactionStmt: NodeTag = 262;
pub const NodeTag_T_ViewStmt: NodeTag = 263;
pub const NodeTag_T_LoadStmt: NodeTag = 264;
pub const NodeTag_T_CreateDomainStmt: NodeTag = 265;
pub const NodeTag_T_CreatedbStmt: NodeTag = 266;
pub const NodeTag_T_DropdbStmt: NodeTag = 267;
pub const NodeTag_T_VacuumStmt: NodeTag = 268;
pub const NodeTag_T_ExplainStmt: NodeTag = 269;
pub const NodeTag_T_CreateTableAsStmt: NodeTag = 270;
pub const NodeTag_T_CreateSeqStmt: NodeTag = 271;
pub const NodeTag_T_AlterSeqStmt: NodeTag = 272;
pub const NodeTag_T_VariableSetStmt: NodeTag = 273;
pub const NodeTag_T_VariableShowStmt: NodeTag = 274;
pub const NodeTag_T_DiscardStmt: NodeTag = 275;
pub const NodeTag_T_CreateTrigStmt: NodeTag = 276;
pub const NodeTag_T_CreatePLangStmt: NodeTag = 277;
pub const NodeTag_T_CreateRoleStmt: NodeTag = 278;
pub const NodeTag_T_AlterRoleStmt: NodeTag = 279;
pub const NodeTag_T_DropRoleStmt: NodeTag = 280;
pub const NodeTag_T_LockStmt: NodeTag = 281;
pub const NodeTag_T_ConstraintsSetStmt: NodeTag = 282;
pub const NodeTag_T_ReindexStmt: NodeTag = 283;
pub const NodeTag_T_CheckPointStmt: NodeTag = 284;
pub const NodeTag_T_CreateSchemaStmt: NodeTag = 285;
pub const NodeTag_T_AlterDatabaseStmt: NodeTag = 286;
pub const NodeTag_T_AlterDatabaseSetStmt: NodeTag = 287;
pub const NodeTag_T_AlterRoleSetStmt: NodeTag = 288;
pub const NodeTag_T_CreateConversionStmt: NodeTag = 289;
pub const NodeTag_T_CreateCastStmt: NodeTag = 290;
pub const NodeTag_T_CreateOpClassStmt: NodeTag = 291;
pub const NodeTag_T_CreateOpFamilyStmt: NodeTag = 292;
pub const NodeTag_T_AlterOpFamilyStmt: NodeTag = 293;
pub const NodeTag_T_PrepareStmt: NodeTag = 294;
pub const NodeTag_T_ExecuteStmt: NodeTag = 295;
pub const NodeTag_T_DeallocateStmt: NodeTag = 296;
pub const NodeTag_T_DeclareCursorStmt: NodeTag = 297;
pub const NodeTag_T_CreateTableSpaceStmt: NodeTag = 298;
pub const NodeTag_T_DropTableSpaceStmt: NodeTag = 299;
pub const NodeTag_T_AlterObjectDependsStmt: NodeTag = 300;
pub const NodeTag_T_AlterObjectSchemaStmt: NodeTag = 301;
pub const NodeTag_T_AlterOwnerStmt: NodeTag = 302;
pub const NodeTag_T_AlterOperatorStmt: NodeTag = 303;
pub const NodeTag_T_AlterTypeStmt: NodeTag = 304;
pub const NodeTag_T_DropOwnedStmt: NodeTag = 305;
pub const NodeTag_T_ReassignOwnedStmt: NodeTag = 306;
pub const NodeTag_T_CompositeTypeStmt: NodeTag = 307;
pub const NodeTag_T_CreateEnumStmt: NodeTag = 308;
pub const NodeTag_T_CreateRangeStmt: NodeTag = 309;
pub const NodeTag_T_AlterEnumStmt: NodeTag = 310;
pub const NodeTag_T_AlterTSDictionaryStmt: NodeTag = 311;
pub const NodeTag_T_AlterTSConfigurationStmt: NodeTag = 312;
pub const NodeTag_T_CreateFdwStmt: NodeTag = 313;
pub const NodeTag_T_AlterFdwStmt: NodeTag = 314;
pub const NodeTag_T_CreateForeignServerStmt: NodeTag = 315;
pub const NodeTag_T_AlterForeignServerStmt: NodeTag = 316;
pub const NodeTag_T_CreateUserMappingStmt: NodeTag = 317;
pub const NodeTag_T_AlterUserMappingStmt: NodeTag = 318;
pub const NodeTag_T_DropUserMappingStmt: NodeTag = 319;
pub const NodeTag_T_AlterTableSpaceOptionsStmt: NodeTag = 320;
pub const NodeTag_T_AlterTableMoveAllStmt: NodeTag = 321;
pub const NodeTag_T_SecLabelStmt: NodeTag = 322;
pub const NodeTag_T_CreateForeignTableStmt: NodeTag = 323;
pub const NodeTag_T_ImportForeignSchemaStmt: NodeTag = 324;
pub const NodeTag_T_CreateExtensionStmt: NodeTag = 325;
pub const NodeTag_T_AlterExtensionStmt: NodeTag = 326;
pub const NodeTag_T_AlterExtensionContentsStmt: NodeTag = 327;
pub const NodeTag_T_CreateEventTrigStmt: NodeTag = 328;
pub const NodeTag_T_AlterEventTrigStmt: NodeTag = 329;
pub const NodeTag_T_RefreshMatViewStmt: NodeTag = 330;
pub const NodeTag_T_ReplicaIdentityStmt: NodeTag = 331;
pub const NodeTag_T_AlterSystemStmt: NodeTag = 332;
pub const NodeTag_T_CreatePolicyStmt: NodeTag = 333;
pub const NodeTag_T_AlterPolicyStmt: NodeTag = 334;
pub const NodeTag_T_CreateTransformStmt: NodeTag = 335;
pub const NodeTag_T_CreateAmStmt: NodeTag = 336;
pub const NodeTag_T_CreatePublicationStmt: NodeTag = 337;
pub const NodeTag_T_AlterPublicationStmt: NodeTag = 338;
pub const NodeTag_T_CreateSubscriptionStmt: NodeTag = 339;
pub const NodeTag_T_AlterSubscriptionStmt: NodeTag = 340;
pub const NodeTag_T_DropSubscriptionStmt: NodeTag = 341;
pub const NodeTag_T_CreateStatsStmt: NodeTag = 342;
pub const NodeTag_T_AlterCollationStmt: NodeTag = 343;
pub const NodeTag_T_CallStmt: NodeTag = 344;
pub const NodeTag_T_AlterStatsStmt: NodeTag = 345;
pub const NodeTag_T_A_Expr: NodeTag = 346;
pub const NodeTag_T_ColumnRef: NodeTag = 347;
pub const NodeTag_T_ParamRef: NodeTag = 348;
pub const NodeTag_T_A_Const: NodeTag = 349;
pub const NodeTag_T_FuncCall: NodeTag = 350;
pub const NodeTag_T_A_Star: NodeTag = 351;
pub const NodeTag_T_A_Indices: NodeTag = 352;
pub const NodeTag_T_A_Indirection: NodeTag = 353;
pub const NodeTag_T_A_ArrayExpr: NodeTag = 354;
pub const NodeTag_T_ResTarget: NodeTag = 355;
pub const NodeTag_T_MultiAssignRef: NodeTag = 356;
pub const NodeTag_T_TypeCast: NodeTag = 357;
pub const NodeTag_T_CollateClause: NodeTag = 358;
pub const NodeTag_T_SortBy: NodeTag = 359;
pub const NodeTag_T_WindowDef: NodeTag = 360;
pub const NodeTag_T_RangeSubselect: NodeTag = 361;
pub const NodeTag_T_RangeFunction: NodeTag = 362;
pub const NodeTag_T_RangeTableSample: NodeTag = 363;
pub const NodeTag_T_RangeTableFunc: NodeTag = 364;
pub const NodeTag_T_RangeTableFuncCol: NodeTag = 365;
pub const NodeTag_T_TypeName: NodeTag = 366;
pub const NodeTag_T_ColumnDef: NodeTag = 367;
pub const NodeTag_T_IndexElem: NodeTag = 368;
pub const NodeTag_T_Constraint: NodeTag = 369;
pub const NodeTag_T_DefElem: NodeTag = 370;
pub const NodeTag_T_RangeTblEntry: NodeTag = 371;
pub const NodeTag_T_RangeTblFunction: NodeTag = 372;
pub const NodeTag_T_TableSampleClause: NodeTag = 373;
pub const NodeTag_T_WithCheckOption: NodeTag = 374;
pub const NodeTag_T_SortGroupClause: NodeTag = 375;
pub const NodeTag_T_GroupingSet: NodeTag = 376;
pub const NodeTag_T_WindowClause: NodeTag = 377;
pub const NodeTag_T_ObjectWithArgs: NodeTag = 378;
pub const NodeTag_T_AccessPriv: NodeTag = 379;
pub const NodeTag_T_CreateOpClassItem: NodeTag = 380;
pub const NodeTag_T_TableLikeClause: NodeTag = 381;
pub const NodeTag_T_FunctionParameter: NodeTag = 382;
pub const NodeTag_T_LockingClause: NodeTag = 383;
pub const NodeTag_T_RowMarkClause: NodeTag = 384;
pub const NodeTag_T_XmlSerialize: NodeTag = 385;
pub const NodeTag_T_WithClause: NodeTag = 386;
pub const NodeTag_T_InferClause: NodeTag = 387;
pub const NodeTag_T_OnConflictClause: NodeTag = 388;
pub const NodeTag_T_CommonTableExpr: NodeTag = 389;
pub const NodeTag_T_RoleSpec: NodeTag = 390;
pub const NodeTag_T_TriggerTransition: NodeTag = 391;
pub const NodeTag_T_PartitionElem: NodeTag = 392;
pub const NodeTag_T_PartitionSpec: NodeTag = 393;
pub const NodeTag_T_PartitionBoundSpec: NodeTag = 394;
pub const NodeTag_T_PartitionRangeDatum: NodeTag = 395;
pub const NodeTag_T_PartitionCmd: NodeTag = 396;
pub const NodeTag_T_VacuumRelation: NodeTag = 397;
pub const NodeTag_T_IdentifySystemCmd: NodeTag = 398;
pub const NodeTag_T_BaseBackupCmd: NodeTag = 399;
pub const NodeTag_T_CreateReplicationSlotCmd: NodeTag = 400;
pub const NodeTag_T_DropReplicationSlotCmd: NodeTag = 401;
pub const NodeTag_T_StartReplicationCmd: NodeTag = 402;
pub const NodeTag_T_TimeLineHistoryCmd: NodeTag = 403;
pub const NodeTag_T_SQLCmd: NodeTag = 404;
pub const NodeTag_T_TriggerData: NodeTag = 405;
pub const NodeTag_T_EventTriggerData: NodeTag = 406;
pub const NodeTag_T_ReturnSetInfo: NodeTag = 407;
pub const NodeTag_T_WindowObjectData: NodeTag = 408;
pub const NodeTag_T_TIDBitmap: NodeTag = 409;
pub const NodeTag_T_InlineCodeBlock: NodeTag = 410;
pub const NodeTag_T_FdwRoutine: NodeTag = 411;
pub const NodeTag_T_IndexAmRoutine: NodeTag = 412;
pub const NodeTag_T_TableAmRoutine: NodeTag = 413;
pub const NodeTag_T_TsmRoutine: NodeTag = 414;
pub const NodeTag_T_ForeignKeyCacheInfo: NodeTag = 415;
pub const NodeTag_T_CallContext: NodeTag = 416;
pub const NodeTag_T_SupportRequestSimplify: NodeTag = 417;
pub const NodeTag_T_SupportRequestSelectivity: NodeTag = 418;
pub const NodeTag_T_SupportRequestCost: NodeTag = 419;
pub const NodeTag_T_SupportRequestRows: NodeTag = 420;
pub const NodeTag_T_SupportRequestIndexCondition: NodeTag = 421;
pub type NodeTag = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Node {
    pub type_: NodeTag,
}
impl Default for Node {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn outNode(arg_str_: *mut StringInfoData, arg_obj: *const ::std::os::raw::c_void) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn outNode(arg_str_: *mut StringInfoData, arg_obj: *const ::std::os::raw::c_void);
        }
        outNode(arg_str_, arg_obj)
    })
}
pub unsafe fn outToken(arg_str_: *mut StringInfoData, arg_s: *const ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn outToken(arg_str_: *mut StringInfoData, arg_s: *const ::std::os::raw::c_char);
        }
        outToken(arg_str_, arg_s)
    })
}
pub unsafe fn outBitmapset(arg_str_: *mut StringInfoData, arg_bms: *const Bitmapset) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn outBitmapset(arg_str_: *mut StringInfoData, arg_bms: *const Bitmapset);
        }
        outBitmapset(arg_str_, arg_bms)
    })
}
pub unsafe fn outDatum(
    arg_str_: *mut StringInfoData,
    arg_value: usize,
    arg_typlen: ::std::os::raw::c_int,
    arg_typbyval: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn outDatum(
                arg_str_: *mut StringInfoData,
                arg_value: usize,
                arg_typlen: ::std::os::raw::c_int,
                arg_typbyval: bool,
            );
        }
        outDatum(arg_str_, arg_value, arg_typlen, arg_typbyval)
    })
}
pub unsafe fn nodeToString(arg_obj: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn nodeToString(arg_obj: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_char;
        }
        nodeToString(arg_obj)
    })
}
pub unsafe fn bmsToString(arg_bms: *const Bitmapset) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bmsToString(arg_bms: *const Bitmapset) -> *mut ::std::os::raw::c_char;
        }
        bmsToString(arg_bms)
    })
}
pub unsafe fn stringToNode(arg_str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn stringToNode(arg_str_: *const ::std::os::raw::c_char)
                -> *mut ::std::os::raw::c_void;
        }
        stringToNode(arg_str_)
    })
}
pub unsafe fn readBitmapset() -> *mut Bitmapset {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn readBitmapset() -> *mut Bitmapset;
        }
        readBitmapset()
    })
}
pub unsafe fn readDatum(arg_typbyval: bool) -> usize {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn readDatum(arg_typbyval: bool) -> usize;
        }
        readDatum(arg_typbyval)
    })
}
pub unsafe fn readBoolCols(arg_numCols: ::std::os::raw::c_int) -> *mut bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn readBoolCols(arg_numCols: ::std::os::raw::c_int) -> *mut bool;
        }
        readBoolCols(arg_numCols)
    })
}
pub unsafe fn readIntCols(arg_numCols: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn readIntCols(arg_numCols: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_int;
        }
        readIntCols(arg_numCols)
    })
}
pub unsafe fn readOidCols(arg_numCols: ::std::os::raw::c_int) -> *mut Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn readOidCols(arg_numCols: ::std::os::raw::c_int) -> *mut Oid;
        }
        readOidCols(arg_numCols)
    })
}
pub unsafe fn readAttrNumberCols(arg_numCols: ::std::os::raw::c_int) -> *mut int16 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn readAttrNumberCols(arg_numCols: ::std::os::raw::c_int) -> *mut int16;
        }
        readAttrNumberCols(arg_numCols)
    })
}
pub unsafe fn copyObjectImpl(
    arg_obj: *const ::std::os::raw::c_void,
) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn copyObjectImpl(
                arg_obj: *const ::std::os::raw::c_void,
            ) -> *mut ::std::os::raw::c_void;
        }
        copyObjectImpl(arg_obj)
    })
}
pub unsafe fn equal(
    arg_a: *const ::std::os::raw::c_void,
    arg_b: *const ::std::os::raw::c_void,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn equal(
                arg_a: *const ::std::os::raw::c_void,
                arg_b: *const ::std::os::raw::c_void,
            ) -> bool;
        }
        equal(arg_a, arg_b)
    })
}
pub type Selectivity = f64;
pub type Cost = f64;
pub const CmdType_CMD_UNKNOWN: CmdType = 0;
pub const CmdType_CMD_SELECT: CmdType = 1;
pub const CmdType_CMD_UPDATE: CmdType = 2;
pub const CmdType_CMD_INSERT: CmdType = 3;
pub const CmdType_CMD_DELETE: CmdType = 4;
pub const CmdType_CMD_UTILITY: CmdType = 5;
pub const CmdType_CMD_NOTHING: CmdType = 6;
pub type CmdType = ::std::os::raw::c_uint;
pub const JoinType_JOIN_INNER: JoinType = 0;
pub const JoinType_JOIN_LEFT: JoinType = 1;
pub const JoinType_JOIN_FULL: JoinType = 2;
pub const JoinType_JOIN_RIGHT: JoinType = 3;
pub const JoinType_JOIN_SEMI: JoinType = 4;
pub const JoinType_JOIN_ANTI: JoinType = 5;
pub const JoinType_JOIN_UNIQUE_OUTER: JoinType = 6;
pub const JoinType_JOIN_UNIQUE_INNER: JoinType = 7;
pub type JoinType = ::std::os::raw::c_uint;
pub const AggStrategy_AGG_PLAIN: AggStrategy = 0;
pub const AggStrategy_AGG_SORTED: AggStrategy = 1;
pub const AggStrategy_AGG_HASHED: AggStrategy = 2;
pub const AggStrategy_AGG_MIXED: AggStrategy = 3;
pub type AggStrategy = ::std::os::raw::c_uint;
pub const AggSplit_AGGSPLIT_SIMPLE: AggSplit = 0;
pub const AggSplit_AGGSPLIT_INITIAL_SERIAL: AggSplit = 6;
pub const AggSplit_AGGSPLIT_FINAL_DESERIAL: AggSplit = 9;
pub type AggSplit = ::std::os::raw::c_uint;
pub const SetOpCmd_SETOPCMD_INTERSECT: SetOpCmd = 0;
pub const SetOpCmd_SETOPCMD_INTERSECT_ALL: SetOpCmd = 1;
pub const SetOpCmd_SETOPCMD_EXCEPT: SetOpCmd = 2;
pub const SetOpCmd_SETOPCMD_EXCEPT_ALL: SetOpCmd = 3;
pub type SetOpCmd = ::std::os::raw::c_uint;
pub const SetOpStrategy_SETOP_SORTED: SetOpStrategy = 0;
pub const SetOpStrategy_SETOP_HASHED: SetOpStrategy = 1;
pub type SetOpStrategy = ::std::os::raw::c_uint;
pub const OnConflictAction_ONCONFLICT_NONE: OnConflictAction = 0;
pub const OnConflictAction_ONCONFLICT_NOTHING: OnConflictAction = 1;
pub const OnConflictAction_ONCONFLICT_UPDATE: OnConflictAction = 2;
pub type OnConflictAction = ::std::os::raw::c_uint;
pub const LimitOption_LIMIT_OPTION_COUNT: LimitOption = 0;
pub const LimitOption_LIMIT_OPTION_WITH_TIES: LimitOption = 1;
pub const LimitOption_LIMIT_OPTION_DEFAULT: LimitOption = 2;
pub type LimitOption = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union ListCell {
    pub ptr_value: *mut ::std::os::raw::c_void,
    pub int_value: ::std::os::raw::c_int,
    pub oid_value: Oid,
}
impl Default for ListCell {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct List {
    pub type_: NodeTag,
    pub length: ::std::os::raw::c_int,
    pub max_length: ::std::os::raw::c_int,
    pub elements: *mut ListCell,
    pub initial_elements: __IncompleteArrayField<ListCell>,
}
impl Default for List {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForEachState {
    pub l: *const List,
    pub i: ::std::os::raw::c_int,
}
impl Default for ForEachState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForBothState {
    pub l1: *const List,
    pub l2: *const List,
    pub i: ::std::os::raw::c_int,
}
impl Default for ForBothState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForBothCellState {
    pub l1: *const List,
    pub l2: *const List,
    pub i1: ::std::os::raw::c_int,
    pub i2: ::std::os::raw::c_int,
}
impl Default for ForBothCellState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForThreeState {
    pub l1: *const List,
    pub l2: *const List,
    pub l3: *const List,
    pub i: ::std::os::raw::c_int,
}
impl Default for ForThreeState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForFourState {
    pub l1: *const List,
    pub l2: *const List,
    pub l3: *const List,
    pub l4: *const List,
    pub i: ::std::os::raw::c_int,
}
impl Default for ForFourState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForFiveState {
    pub l1: *const List,
    pub l2: *const List,
    pub l3: *const List,
    pub l4: *const List,
    pub l5: *const List,
    pub i: ::std::os::raw::c_int,
}
impl Default for ForFiveState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn list_make1_impl(arg_t: NodeTag, arg_datum1: ListCell) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_make1_impl(arg_t: NodeTag, arg_datum1: ListCell) -> *mut List;
        }
        list_make1_impl(arg_t, arg_datum1)
    })
}
pub unsafe fn list_make2_impl(
    arg_t: NodeTag,
    arg_datum1: ListCell,
    arg_datum2: ListCell,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_make2_impl(
                arg_t: NodeTag,
                arg_datum1: ListCell,
                arg_datum2: ListCell,
            ) -> *mut List;
        }
        list_make2_impl(arg_t, arg_datum1, arg_datum2)
    })
}
pub unsafe fn list_make3_impl(
    arg_t: NodeTag,
    arg_datum1: ListCell,
    arg_datum2: ListCell,
    arg_datum3: ListCell,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_make3_impl(
                arg_t: NodeTag,
                arg_datum1: ListCell,
                arg_datum2: ListCell,
                arg_datum3: ListCell,
            ) -> *mut List;
        }
        list_make3_impl(arg_t, arg_datum1, arg_datum2, arg_datum3)
    })
}
pub unsafe fn list_make4_impl(
    arg_t: NodeTag,
    arg_datum1: ListCell,
    arg_datum2: ListCell,
    arg_datum3: ListCell,
    arg_datum4: ListCell,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_make4_impl(
                arg_t: NodeTag,
                arg_datum1: ListCell,
                arg_datum2: ListCell,
                arg_datum3: ListCell,
                arg_datum4: ListCell,
            ) -> *mut List;
        }
        list_make4_impl(arg_t, arg_datum1, arg_datum2, arg_datum3, arg_datum4)
    })
}
pub unsafe fn lappend(arg_list: *mut List, arg_datum: *mut ::std::os::raw::c_void) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lappend(arg_list: *mut List, arg_datum: *mut ::std::os::raw::c_void) -> *mut List;
        }
        lappend(arg_list, arg_datum)
    })
}
pub unsafe fn lappend_int(arg_list: *mut List, arg_datum: ::std::os::raw::c_int) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lappend_int(arg_list: *mut List, arg_datum: ::std::os::raw::c_int) -> *mut List;
        }
        lappend_int(arg_list, arg_datum)
    })
}
pub unsafe fn lappend_oid(arg_list: *mut List, arg_datum: Oid) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lappend_oid(arg_list: *mut List, arg_datum: Oid) -> *mut List;
        }
        lappend_oid(arg_list, arg_datum)
    })
}
pub unsafe fn list_insert_nth(
    arg_list: *mut List,
    arg_pos: ::std::os::raw::c_int,
    arg_datum: *mut ::std::os::raw::c_void,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_insert_nth(
                arg_list: *mut List,
                arg_pos: ::std::os::raw::c_int,
                arg_datum: *mut ::std::os::raw::c_void,
            ) -> *mut List;
        }
        list_insert_nth(arg_list, arg_pos, arg_datum)
    })
}
pub unsafe fn list_insert_nth_int(
    arg_list: *mut List,
    arg_pos: ::std::os::raw::c_int,
    arg_datum: ::std::os::raw::c_int,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_insert_nth_int(
                arg_list: *mut List,
                arg_pos: ::std::os::raw::c_int,
                arg_datum: ::std::os::raw::c_int,
            ) -> *mut List;
        }
        list_insert_nth_int(arg_list, arg_pos, arg_datum)
    })
}
pub unsafe fn list_insert_nth_oid(
    arg_list: *mut List,
    arg_pos: ::std::os::raw::c_int,
    arg_datum: Oid,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_insert_nth_oid(
                arg_list: *mut List,
                arg_pos: ::std::os::raw::c_int,
                arg_datum: Oid,
            ) -> *mut List;
        }
        list_insert_nth_oid(arg_list, arg_pos, arg_datum)
    })
}
pub unsafe fn lcons(arg_datum: *mut ::std::os::raw::c_void, arg_list: *mut List) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lcons(arg_datum: *mut ::std::os::raw::c_void, arg_list: *mut List) -> *mut List;
        }
        lcons(arg_datum, arg_list)
    })
}
pub unsafe fn lcons_int(arg_datum: ::std::os::raw::c_int, arg_list: *mut List) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lcons_int(arg_datum: ::std::os::raw::c_int, arg_list: *mut List) -> *mut List;
        }
        lcons_int(arg_datum, arg_list)
    })
}
pub unsafe fn lcons_oid(arg_datum: Oid, arg_list: *mut List) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lcons_oid(arg_datum: Oid, arg_list: *mut List) -> *mut List;
        }
        lcons_oid(arg_datum, arg_list)
    })
}
pub unsafe fn list_concat(arg_list1: *mut List, arg_list2: *const List) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_concat(arg_list1: *mut List, arg_list2: *const List) -> *mut List;
        }
        list_concat(arg_list1, arg_list2)
    })
}
pub unsafe fn list_concat_copy(arg_list1: *const List, arg_list2: *const List) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_concat_copy(arg_list1: *const List, arg_list2: *const List) -> *mut List;
        }
        list_concat_copy(arg_list1, arg_list2)
    })
}
pub unsafe fn list_truncate(arg_list: *mut List, arg_new_size: ::std::os::raw::c_int) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_truncate(arg_list: *mut List, arg_new_size: ::std::os::raw::c_int)
                -> *mut List;
        }
        list_truncate(arg_list, arg_new_size)
    })
}
pub unsafe fn list_member(arg_list: *const List, arg_datum: *const ::std::os::raw::c_void) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_member(arg_list: *const List, arg_datum: *const ::std::os::raw::c_void)
                -> bool;
        }
        list_member(arg_list, arg_datum)
    })
}
pub unsafe fn list_member_ptr(
    arg_list: *const List,
    arg_datum: *const ::std::os::raw::c_void,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_member_ptr(
                arg_list: *const List,
                arg_datum: *const ::std::os::raw::c_void,
            ) -> bool;
        }
        list_member_ptr(arg_list, arg_datum)
    })
}
pub unsafe fn list_member_int(arg_list: *const List, arg_datum: ::std::os::raw::c_int) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_member_int(arg_list: *const List, arg_datum: ::std::os::raw::c_int) -> bool;
        }
        list_member_int(arg_list, arg_datum)
    })
}
pub unsafe fn list_member_oid(arg_list: *const List, arg_datum: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_member_oid(arg_list: *const List, arg_datum: Oid) -> bool;
        }
        list_member_oid(arg_list, arg_datum)
    })
}
pub unsafe fn list_delete(
    arg_list: *mut List,
    arg_datum: *mut ::std::os::raw::c_void,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_delete(
                arg_list: *mut List,
                arg_datum: *mut ::std::os::raw::c_void,
            ) -> *mut List;
        }
        list_delete(arg_list, arg_datum)
    })
}
pub unsafe fn list_delete_ptr(
    arg_list: *mut List,
    arg_datum: *mut ::std::os::raw::c_void,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_delete_ptr(
                arg_list: *mut List,
                arg_datum: *mut ::std::os::raw::c_void,
            ) -> *mut List;
        }
        list_delete_ptr(arg_list, arg_datum)
    })
}
pub unsafe fn list_delete_int(arg_list: *mut List, arg_datum: ::std::os::raw::c_int) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_delete_int(arg_list: *mut List, arg_datum: ::std::os::raw::c_int) -> *mut List;
        }
        list_delete_int(arg_list, arg_datum)
    })
}
pub unsafe fn list_delete_oid(arg_list: *mut List, arg_datum: Oid) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_delete_oid(arg_list: *mut List, arg_datum: Oid) -> *mut List;
        }
        list_delete_oid(arg_list, arg_datum)
    })
}
pub unsafe fn list_delete_first(arg_list: *mut List) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_delete_first(arg_list: *mut List) -> *mut List;
        }
        list_delete_first(arg_list)
    })
}
pub unsafe fn list_delete_last(arg_list: *mut List) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_delete_last(arg_list: *mut List) -> *mut List;
        }
        list_delete_last(arg_list)
    })
}
pub unsafe fn list_delete_first_n(arg_list: *mut List, arg_n: ::std::os::raw::c_int) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_delete_first_n(arg_list: *mut List, arg_n: ::std::os::raw::c_int) -> *mut List;
        }
        list_delete_first_n(arg_list, arg_n)
    })
}
pub unsafe fn list_delete_nth_cell(arg_list: *mut List, arg_n: ::std::os::raw::c_int) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_delete_nth_cell(arg_list: *mut List, arg_n: ::std::os::raw::c_int)
                -> *mut List;
        }
        list_delete_nth_cell(arg_list, arg_n)
    })
}
pub unsafe fn list_delete_cell(arg_list: *mut List, arg_cell: *mut ListCell) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_delete_cell(arg_list: *mut List, arg_cell: *mut ListCell) -> *mut List;
        }
        list_delete_cell(arg_list, arg_cell)
    })
}
pub unsafe fn list_union(arg_list1: *const List, arg_list2: *const List) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_union(arg_list1: *const List, arg_list2: *const List) -> *mut List;
        }
        list_union(arg_list1, arg_list2)
    })
}
pub unsafe fn list_union_ptr(arg_list1: *const List, arg_list2: *const List) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_union_ptr(arg_list1: *const List, arg_list2: *const List) -> *mut List;
        }
        list_union_ptr(arg_list1, arg_list2)
    })
}
pub unsafe fn list_union_int(arg_list1: *const List, arg_list2: *const List) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_union_int(arg_list1: *const List, arg_list2: *const List) -> *mut List;
        }
        list_union_int(arg_list1, arg_list2)
    })
}
pub unsafe fn list_union_oid(arg_list1: *const List, arg_list2: *const List) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_union_oid(arg_list1: *const List, arg_list2: *const List) -> *mut List;
        }
        list_union_oid(arg_list1, arg_list2)
    })
}
pub unsafe fn list_intersection(arg_list1: *const List, arg_list2: *const List) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_intersection(arg_list1: *const List, arg_list2: *const List) -> *mut List;
        }
        list_intersection(arg_list1, arg_list2)
    })
}
pub unsafe fn list_intersection_int(arg_list1: *const List, arg_list2: *const List) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_intersection_int(arg_list1: *const List, arg_list2: *const List) -> *mut List;
        }
        list_intersection_int(arg_list1, arg_list2)
    })
}
pub unsafe fn list_difference(arg_list1: *const List, arg_list2: *const List) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_difference(arg_list1: *const List, arg_list2: *const List) -> *mut List;
        }
        list_difference(arg_list1, arg_list2)
    })
}
pub unsafe fn list_difference_ptr(arg_list1: *const List, arg_list2: *const List) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_difference_ptr(arg_list1: *const List, arg_list2: *const List) -> *mut List;
        }
        list_difference_ptr(arg_list1, arg_list2)
    })
}
pub unsafe fn list_difference_int(arg_list1: *const List, arg_list2: *const List) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_difference_int(arg_list1: *const List, arg_list2: *const List) -> *mut List;
        }
        list_difference_int(arg_list1, arg_list2)
    })
}
pub unsafe fn list_difference_oid(arg_list1: *const List, arg_list2: *const List) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_difference_oid(arg_list1: *const List, arg_list2: *const List) -> *mut List;
        }
        list_difference_oid(arg_list1, arg_list2)
    })
}
pub unsafe fn list_append_unique(
    arg_list: *mut List,
    arg_datum: *mut ::std::os::raw::c_void,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_append_unique(
                arg_list: *mut List,
                arg_datum: *mut ::std::os::raw::c_void,
            ) -> *mut List;
        }
        list_append_unique(arg_list, arg_datum)
    })
}
pub unsafe fn list_append_unique_ptr(
    arg_list: *mut List,
    arg_datum: *mut ::std::os::raw::c_void,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_append_unique_ptr(
                arg_list: *mut List,
                arg_datum: *mut ::std::os::raw::c_void,
            ) -> *mut List;
        }
        list_append_unique_ptr(arg_list, arg_datum)
    })
}
pub unsafe fn list_append_unique_int(
    arg_list: *mut List,
    arg_datum: ::std::os::raw::c_int,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_append_unique_int(
                arg_list: *mut List,
                arg_datum: ::std::os::raw::c_int,
            ) -> *mut List;
        }
        list_append_unique_int(arg_list, arg_datum)
    })
}
pub unsafe fn list_append_unique_oid(arg_list: *mut List, arg_datum: Oid) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_append_unique_oid(arg_list: *mut List, arg_datum: Oid) -> *mut List;
        }
        list_append_unique_oid(arg_list, arg_datum)
    })
}
pub unsafe fn list_concat_unique(arg_list1: *mut List, arg_list2: *const List) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_concat_unique(arg_list1: *mut List, arg_list2: *const List) -> *mut List;
        }
        list_concat_unique(arg_list1, arg_list2)
    })
}
pub unsafe fn list_concat_unique_ptr(arg_list1: *mut List, arg_list2: *const List) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_concat_unique_ptr(arg_list1: *mut List, arg_list2: *const List) -> *mut List;
        }
        list_concat_unique_ptr(arg_list1, arg_list2)
    })
}
pub unsafe fn list_concat_unique_int(arg_list1: *mut List, arg_list2: *const List) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_concat_unique_int(arg_list1: *mut List, arg_list2: *const List) -> *mut List;
        }
        list_concat_unique_int(arg_list1, arg_list2)
    })
}
pub unsafe fn list_concat_unique_oid(arg_list1: *mut List, arg_list2: *const List) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_concat_unique_oid(arg_list1: *mut List, arg_list2: *const List) -> *mut List;
        }
        list_concat_unique_oid(arg_list1, arg_list2)
    })
}
pub unsafe fn list_deduplicate_oid(arg_list: *mut List) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_deduplicate_oid(arg_list: *mut List);
        }
        list_deduplicate_oid(arg_list)
    })
}
pub unsafe fn list_free(arg_list: *mut List) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_free(arg_list: *mut List);
        }
        list_free(arg_list)
    })
}
pub unsafe fn list_free_deep(arg_list: *mut List) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_free_deep(arg_list: *mut List);
        }
        list_free_deep(arg_list)
    })
}
pub unsafe fn list_copy(arg_list: *const List) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_copy(arg_list: *const List) -> *mut List;
        }
        list_copy(arg_list)
    })
}
pub unsafe fn list_copy_tail(arg_list: *const List, arg_nskip: ::std::os::raw::c_int) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_copy_tail(arg_list: *const List, arg_nskip: ::std::os::raw::c_int)
                -> *mut List;
        }
        list_copy_tail(arg_list, arg_nskip)
    })
}
pub unsafe fn list_copy_deep(arg_oldlist: *const List) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_copy_deep(arg_oldlist: *const List) -> *mut List;
        }
        list_copy_deep(arg_oldlist)
    })
}
pub type list_sort_comparator = ::std::option::Option<
    unsafe extern "C" fn(a: *const ListCell, b: *const ListCell) -> ::std::os::raw::c_int,
>;
pub unsafe fn list_sort(arg_list: *mut List, arg_cmp: list_sort_comparator) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_sort(arg_list: *mut List, arg_cmp: list_sort_comparator);
        }
        list_sort(arg_list, arg_cmp)
    })
}
pub unsafe fn list_oid_cmp(
    arg_p1: *const ListCell,
    arg_p2: *const ListCell,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn list_oid_cmp(
                arg_p1: *const ListCell,
                arg_p2: *const ListCell,
            ) -> ::std::os::raw::c_int;
        }
        list_oid_cmp(arg_p1, arg_p2)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AttrDefault {
    pub adnum: AttrNumber,
    pub adbin: *mut ::std::os::raw::c_char,
}
impl Default for AttrDefault {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConstrCheck {
    pub ccname: *mut ::std::os::raw::c_char,
    pub ccbin: *mut ::std::os::raw::c_char,
    pub ccvalid: bool,
    pub ccnoinherit: bool,
}
impl Default for ConstrCheck {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TupleConstr {
    pub defval: *mut AttrDefault,
    pub check: *mut ConstrCheck,
    pub missing: *mut AttrMissing,
    pub num_defval: uint16,
    pub num_check: uint16,
    pub has_not_null: bool,
    pub has_generated_stored: bool,
}
impl Default for TupleConstr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct TupleDescData {
    pub natts: ::std::os::raw::c_int,
    pub tdtypeid: Oid,
    pub tdtypmod: int32,
    pub tdrefcount: ::std::os::raw::c_int,
    pub constr: *mut TupleConstr,
    pub attrs: __IncompleteArrayField<FormData_pg_attribute>,
}
impl Default for TupleDescData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TupleDesc = *mut TupleDescData;
pub unsafe fn CreateTemplateTupleDesc(arg_natts: ::std::os::raw::c_int) -> TupleDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateTemplateTupleDesc(arg_natts: ::std::os::raw::c_int) -> TupleDesc;
        }
        CreateTemplateTupleDesc(arg_natts)
    })
}
pub unsafe fn CreateTupleDesc(
    arg_natts: ::std::os::raw::c_int,
    arg_attrs: *mut Form_pg_attribute,
) -> TupleDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateTupleDesc(
                arg_natts: ::std::os::raw::c_int,
                arg_attrs: *mut Form_pg_attribute,
            ) -> TupleDesc;
        }
        CreateTupleDesc(arg_natts, arg_attrs)
    })
}
pub unsafe fn CreateTupleDescCopy(arg_tupdesc: TupleDesc) -> TupleDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateTupleDescCopy(arg_tupdesc: TupleDesc) -> TupleDesc;
        }
        CreateTupleDescCopy(arg_tupdesc)
    })
}
pub unsafe fn CreateTupleDescCopyConstr(arg_tupdesc: TupleDesc) -> TupleDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateTupleDescCopyConstr(arg_tupdesc: TupleDesc) -> TupleDesc;
        }
        CreateTupleDescCopyConstr(arg_tupdesc)
    })
}
pub unsafe fn TupleDescCopy(arg_dst: TupleDesc, arg_src: TupleDesc) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TupleDescCopy(arg_dst: TupleDesc, arg_src: TupleDesc);
        }
        TupleDescCopy(arg_dst, arg_src)
    })
}
pub unsafe fn TupleDescCopyEntry(
    arg_dst: TupleDesc,
    arg_dstAttno: AttrNumber,
    arg_src: TupleDesc,
    arg_srcAttno: AttrNumber,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TupleDescCopyEntry(
                arg_dst: TupleDesc,
                arg_dstAttno: AttrNumber,
                arg_src: TupleDesc,
                arg_srcAttno: AttrNumber,
            );
        }
        TupleDescCopyEntry(arg_dst, arg_dstAttno, arg_src, arg_srcAttno)
    })
}
pub unsafe fn FreeTupleDesc(arg_tupdesc: TupleDesc) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FreeTupleDesc(arg_tupdesc: TupleDesc);
        }
        FreeTupleDesc(arg_tupdesc)
    })
}
pub unsafe fn IncrTupleDescRefCount(arg_tupdesc: TupleDesc) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn IncrTupleDescRefCount(arg_tupdesc: TupleDesc);
        }
        IncrTupleDescRefCount(arg_tupdesc)
    })
}
pub unsafe fn DecrTupleDescRefCount(arg_tupdesc: TupleDesc) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DecrTupleDescRefCount(arg_tupdesc: TupleDesc);
        }
        DecrTupleDescRefCount(arg_tupdesc)
    })
}
pub unsafe fn equalTupleDescs(arg_tupdesc1: TupleDesc, arg_tupdesc2: TupleDesc) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn equalTupleDescs(arg_tupdesc1: TupleDesc, arg_tupdesc2: TupleDesc) -> bool;
        }
        equalTupleDescs(arg_tupdesc1, arg_tupdesc2)
    })
}
pub unsafe fn hashTupleDesc(arg_tupdesc: TupleDesc) -> uint32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashTupleDesc(arg_tupdesc: TupleDesc) -> uint32;
        }
        hashTupleDesc(arg_tupdesc)
    })
}
pub unsafe fn TupleDescInitEntry(
    arg_desc: TupleDesc,
    arg_attributeNumber: AttrNumber,
    arg_attributeName: *const ::std::os::raw::c_char,
    arg_oidtypeid: Oid,
    arg_typmod: int32,
    arg_attdim: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TupleDescInitEntry(
                arg_desc: TupleDesc,
                arg_attributeNumber: AttrNumber,
                arg_attributeName: *const ::std::os::raw::c_char,
                arg_oidtypeid: Oid,
                arg_typmod: int32,
                arg_attdim: ::std::os::raw::c_int,
            );
        }
        TupleDescInitEntry(
            arg_desc,
            arg_attributeNumber,
            arg_attributeName,
            arg_oidtypeid,
            arg_typmod,
            arg_attdim,
        )
    })
}
pub unsafe fn TupleDescInitBuiltinEntry(
    arg_desc: TupleDesc,
    arg_attributeNumber: AttrNumber,
    arg_attributeName: *const ::std::os::raw::c_char,
    arg_oidtypeid: Oid,
    arg_typmod: int32,
    arg_attdim: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TupleDescInitBuiltinEntry(
                arg_desc: TupleDesc,
                arg_attributeNumber: AttrNumber,
                arg_attributeName: *const ::std::os::raw::c_char,
                arg_oidtypeid: Oid,
                arg_typmod: int32,
                arg_attdim: ::std::os::raw::c_int,
            );
        }
        TupleDescInitBuiltinEntry(
            arg_desc,
            arg_attributeNumber,
            arg_attributeName,
            arg_oidtypeid,
            arg_typmod,
            arg_attdim,
        )
    })
}
pub unsafe fn TupleDescInitEntryCollation(
    arg_desc: TupleDesc,
    arg_attributeNumber: AttrNumber,
    arg_collationid: Oid,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TupleDescInitEntryCollation(
                arg_desc: TupleDesc,
                arg_attributeNumber: AttrNumber,
                arg_collationid: Oid,
            );
        }
        TupleDescInitEntryCollation(arg_desc, arg_attributeNumber, arg_collationid)
    })
}
pub unsafe fn BuildDescForRelation(arg_schema: *mut List) -> TupleDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BuildDescForRelation(arg_schema: *mut List) -> TupleDesc;
        }
        BuildDescForRelation(arg_schema)
    })
}
pub unsafe fn BuildDescFromLists(
    arg_names: *mut List,
    arg_types: *mut List,
    arg_typmods: *mut List,
    arg_collations: *mut List,
) -> TupleDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BuildDescFromLists(
                arg_names: *mut List,
                arg_types: *mut List,
                arg_typmods: *mut List,
                arg_collations: *mut List,
            ) -> TupleDesc;
        }
        BuildDescFromLists(arg_names, arg_types, arg_typmods, arg_collations)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AttrMap {
    pub attnums: *mut AttrNumber,
    pub maplen: ::std::os::raw::c_int,
}
impl Default for AttrMap {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn make_attrmap(arg_maplen: ::std::os::raw::c_int) -> *mut AttrMap {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_attrmap(arg_maplen: ::std::os::raw::c_int) -> *mut AttrMap;
        }
        make_attrmap(arg_maplen)
    })
}
pub unsafe fn free_attrmap(arg_map: *mut AttrMap) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn free_attrmap(arg_map: *mut AttrMap);
        }
        free_attrmap(arg_map)
    })
}
pub unsafe fn build_attrmap_by_name(arg_indesc: TupleDesc, arg_outdesc: TupleDesc) -> *mut AttrMap {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn build_attrmap_by_name(arg_indesc: TupleDesc, arg_outdesc: TupleDesc)
                -> *mut AttrMap;
        }
        build_attrmap_by_name(arg_indesc, arg_outdesc)
    })
}
pub unsafe fn build_attrmap_by_name_if_req(
    arg_indesc: TupleDesc,
    arg_outdesc: TupleDesc,
) -> *mut AttrMap {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn build_attrmap_by_name_if_req(
                arg_indesc: TupleDesc,
                arg_outdesc: TupleDesc,
            ) -> *mut AttrMap;
        }
        build_attrmap_by_name_if_req(arg_indesc, arg_outdesc)
    })
}
pub unsafe fn build_attrmap_by_position(
    arg_indesc: TupleDesc,
    arg_outdesc: TupleDesc,
    arg_msg: *const ::std::os::raw::c_char,
) -> *mut AttrMap {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn build_attrmap_by_position(
                arg_indesc: TupleDesc,
                arg_outdesc: TupleDesc,
                arg_msg: *const ::std::os::raw::c_char,
            ) -> *mut AttrMap;
        }
        build_attrmap_by_position(arg_indesc, arg_outdesc, arg_msg)
    })
}
pub type BlockNumber = uint32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct BlockIdData {
    pub bi_hi: uint16,
    pub bi_lo: uint16,
}
pub type BlockId = *mut BlockIdData;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct ItemIdData {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl ItemIdData {
    #[inline]
    pub fn lp_off(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_lp_off(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn lp_flags(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_lp_flags(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn lp_len(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_lp_len(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        lp_off: ::std::os::raw::c_uint,
        lp_flags: ::std::os::raw::c_uint,
        lp_len: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 15u8, {
            let lp_off: u32 = unsafe { ::std::mem::transmute(lp_off) };
            lp_off as u64
        });
        __bindgen_bitfield_unit.set(15usize, 2u8, {
            let lp_flags: u32 = unsafe { ::std::mem::transmute(lp_flags) };
            lp_flags as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let lp_len: u32 = unsafe { ::std::mem::transmute(lp_len) };
            lp_len as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ItemId = *mut ItemIdData;
pub type ItemOffset = uint16;
pub type ItemLength = uint16;
pub type OffsetNumber = uint16;
#[repr(C, packed(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct ItemPointerData {
    pub ip_blkid: BlockIdData,
    pub ip_posid: OffsetNumber,
}
pub type ItemPointer = *mut ItemPointerData;
pub unsafe fn ItemPointerEquals(arg_pointer1: ItemPointer, arg_pointer2: ItemPointer) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ItemPointerEquals(arg_pointer1: ItemPointer, arg_pointer2: ItemPointer) -> bool;
        }
        ItemPointerEquals(arg_pointer1, arg_pointer2)
    })
}
pub unsafe fn ItemPointerCompare(arg_arg1: ItemPointer, arg_arg2: ItemPointer) -> int32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ItemPointerCompare(arg_arg1: ItemPointer, arg_arg2: ItemPointer) -> int32;
        }
        ItemPointerCompare(arg_arg1, arg_arg2)
    })
}
pub type HeapTupleHeader = *mut HeapTupleHeaderData;
pub type MinimalTuple = *mut MinimalTupleData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HeapTupleData {
    pub t_len: uint32,
    pub t_self: ItemPointerData,
    pub t_tableOid: Oid,
    pub t_data: HeapTupleHeader,
}
impl Default for HeapTupleData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type HeapTuple = *mut HeapTupleData;
pub unsafe fn HeapTupleHeaderGetCmin(arg_tup: HeapTupleHeader) -> CommandId {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn HeapTupleHeaderGetCmin(arg_tup: HeapTupleHeader) -> CommandId;
        }
        HeapTupleHeaderGetCmin(arg_tup)
    })
}
pub unsafe fn HeapTupleHeaderGetCmax(arg_tup: HeapTupleHeader) -> CommandId {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn HeapTupleHeaderGetCmax(arg_tup: HeapTupleHeader) -> CommandId;
        }
        HeapTupleHeaderGetCmax(arg_tup)
    })
}
pub unsafe fn HeapTupleHeaderAdjustCmax(
    arg_tup: HeapTupleHeader,
    arg_cmax: *mut CommandId,
    arg_iscombo: *mut bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn HeapTupleHeaderAdjustCmax(
                arg_tup: HeapTupleHeader,
                arg_cmax: *mut CommandId,
                arg_iscombo: *mut bool,
            );
        }
        HeapTupleHeaderAdjustCmax(arg_tup, arg_cmax, arg_iscombo)
    })
}
pub unsafe fn HeapTupleGetUpdateXid(arg_tuple: HeapTupleHeader) -> TransactionId {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn HeapTupleGetUpdateXid(arg_tuple: HeapTupleHeader) -> TransactionId;
        }
        HeapTupleGetUpdateXid(arg_tuple)
    })
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct flock {
    pub l_start: off_t,
    pub l_len: off_t,
    pub l_pid: pid_t,
    pub l_type: ::std::os::raw::c_short,
    pub l_whence: ::std::os::raw::c_short,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct flocktimeout {
    pub fl: flock,
    pub timeout: timespec,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct radvisory {
    pub ra_offset: off_t,
    pub ra_count: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsignatures {
    pub fs_file_start: off_t,
    pub fs_blob_start: *mut ::std::os::raw::c_void,
    pub fs_blob_size: usize,
    pub fs_fsignatures_size: usize,
    pub fs_cdhash: [::std::os::raw::c_char; 20usize],
    pub fs_hash_type: ::std::os::raw::c_int,
}
impl Default for fsignatures {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type fsignatures_t = fsignatures;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fsupplement {
    pub fs_file_start: off_t,
    pub fs_blob_start: off_t,
    pub fs_blob_size: usize,
    pub fs_orig_fd: ::std::os::raw::c_int,
}
pub type fsupplement_t = fsupplement;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fchecklv {
    pub lv_file_start: off_t,
    pub lv_error_message_size: usize,
    pub lv_error_message: *mut ::std::os::raw::c_void,
}
impl Default for fchecklv {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type fchecklv_t = fchecklv;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fgetsigsinfo {
    pub fg_file_start: off_t,
    pub fg_info_request: ::std::os::raw::c_int,
    pub fg_sig_is_platform: ::std::os::raw::c_int,
}
pub type fgetsigsinfo_t = fgetsigsinfo;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fstore {
    pub fst_flags: ::std::os::raw::c_uint,
    pub fst_posmode: ::std::os::raw::c_int,
    pub fst_offset: off_t,
    pub fst_length: off_t,
    pub fst_bytesalloc: off_t,
}
pub type fstore_t = fstore;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fpunchhole {
    pub fp_flags: ::std::os::raw::c_uint,
    pub reserved: ::std::os::raw::c_uint,
    pub fp_offset: off_t,
    pub fp_length: off_t,
}
pub type fpunchhole_t = fpunchhole;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ftrimactivefile {
    pub fta_offset: off_t,
    pub fta_length: off_t,
}
pub type ftrimactivefile_t = ftrimactivefile;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fspecread {
    pub fsr_flags: ::std::os::raw::c_uint,
    pub reserved: ::std::os::raw::c_uint,
    pub fsr_offset: off_t,
    pub fsr_length: off_t,
}
pub type fspecread_t = fspecread;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fbootstraptransfer {
    pub fbt_offset: off_t,
    pub fbt_length: usize,
    pub fbt_buffer: *mut ::std::os::raw::c_void,
}
impl Default for fbootstraptransfer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type fbootstraptransfer_t = fbootstraptransfer;
#[repr(C, packed(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct log2phys {
    pub l2p_flags: ::std::os::raw::c_uint,
    pub l2p_contigbytes: off_t,
    pub l2p_devoffset: off_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _filesec {
    _unused: [u8; 0],
}
pub type filesec_t = *mut _filesec;
pub const filesec_property_t_FILESEC_OWNER: filesec_property_t = 1;
pub const filesec_property_t_FILESEC_GROUP: filesec_property_t = 2;
pub const filesec_property_t_FILESEC_UUID: filesec_property_t = 3;
pub const filesec_property_t_FILESEC_MODE: filesec_property_t = 4;
pub const filesec_property_t_FILESEC_ACL: filesec_property_t = 5;
pub const filesec_property_t_FILESEC_GRPUUID: filesec_property_t = 6;
pub const filesec_property_t_FILESEC_ACL_RAW: filesec_property_t = 100;
pub const filesec_property_t_FILESEC_ACL_ALLOCSIZE: filesec_property_t = 101;
pub type filesec_property_t = ::std::os::raw::c_uint;
pub unsafe fn open(
    arg_arg1: *const ::std::os::raw::c_char,
    arg_arg2: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn open(
                arg_arg1: *const ::std::os::raw::c_char,
                arg_arg2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        open(arg_arg1, arg_arg2)
    })
}
pub unsafe fn openat(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: *const ::std::os::raw::c_char,
    arg_arg3: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn openat(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: *const ::std::os::raw::c_char,
                arg_arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        openat(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn creat(
    arg_arg1: *const ::std::os::raw::c_char,
    arg_arg2: mode_t,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn creat(
                arg_arg1: *const ::std::os::raw::c_char,
                arg_arg2: mode_t,
            ) -> ::std::os::raw::c_int;
        }
        creat(arg_arg1, arg_arg2)
    })
}
pub unsafe fn fcntl(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fcntl(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        fcntl(arg_arg1, arg_arg2)
    })
}
pub unsafe fn openx_np(
    arg_arg1: *const ::std::os::raw::c_char,
    arg_arg2: ::std::os::raw::c_int,
    arg_arg3: filesec_t,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn openx_np(
                arg_arg1: *const ::std::os::raw::c_char,
                arg_arg2: ::std::os::raw::c_int,
                arg_arg3: filesec_t,
            ) -> ::std::os::raw::c_int;
        }
        openx_np(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn open_dprotected_np(
    arg_arg1: *const ::std::os::raw::c_char,
    arg_arg2: ::std::os::raw::c_int,
    arg_arg3: ::std::os::raw::c_int,
    arg_arg4: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn open_dprotected_np(
                arg_arg1: *const ::std::os::raw::c_char,
                arg_arg2: ::std::os::raw::c_int,
                arg_arg3: ::std::os::raw::c_int,
                arg_arg4: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        open_dprotected_np(arg_arg1, arg_arg2, arg_arg3, arg_arg4)
    })
}
pub unsafe fn flock(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn flock(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        flock(arg_arg1, arg_arg2)
    })
}
pub unsafe fn filesec_init() -> filesec_t {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn filesec_init() -> filesec_t;
        }
        filesec_init()
    })
}
pub unsafe fn filesec_dup(arg_arg1: filesec_t) -> filesec_t {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn filesec_dup(arg_arg1: filesec_t) -> filesec_t;
        }
        filesec_dup(arg_arg1)
    })
}
pub unsafe fn filesec_free(arg_arg1: filesec_t) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn filesec_free(arg_arg1: filesec_t);
        }
        filesec_free(arg_arg1)
    })
}
pub unsafe fn filesec_get_property(
    arg_arg1: filesec_t,
    arg_arg2: filesec_property_t,
    arg_arg3: *mut ::std::os::raw::c_void,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn filesec_get_property(
                arg_arg1: filesec_t,
                arg_arg2: filesec_property_t,
                arg_arg3: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int;
        }
        filesec_get_property(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn filesec_query_property(
    arg_arg1: filesec_t,
    arg_arg2: filesec_property_t,
    arg_arg3: *mut ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn filesec_query_property(
                arg_arg1: filesec_t,
                arg_arg2: filesec_property_t,
                arg_arg3: *mut ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        filesec_query_property(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn filesec_set_property(
    arg_arg1: filesec_t,
    arg_arg2: filesec_property_t,
    arg_arg3: *const ::std::os::raw::c_void,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn filesec_set_property(
                arg_arg1: filesec_t,
                arg_arg2: filesec_property_t,
                arg_arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int;
        }
        filesec_set_property(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn filesec_unset_property(
    arg_arg1: filesec_t,
    arg_arg2: filesec_property_t,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn filesec_unset_property(
                arg_arg1: filesec_t,
                arg_arg2: filesec_property_t,
            ) -> ::std::os::raw::c_int;
        }
        filesec_unset_property(arg_arg1, arg_arg2)
    })
}
pub type XLogRecPtr = uint64;
pub type XLogSegNo = uint64;
pub type TimeLineID = uint32;
pub type RepOriginId = uint16;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FullTransactionId {
    pub value: uint64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VariableCacheData {
    pub nextOid: Oid,
    pub oidCount: uint32,
    pub nextFullXid: FullTransactionId,
    pub oldestXid: TransactionId,
    pub xidVacLimit: TransactionId,
    pub xidWarnLimit: TransactionId,
    pub xidStopLimit: TransactionId,
    pub xidWrapLimit: TransactionId,
    pub oldestXidDB: Oid,
    pub oldestCommitTsXid: TransactionId,
    pub newestCommitTsXid: TransactionId,
    pub latestCompletedXid: TransactionId,
    pub oldestClogXid: TransactionId,
}
pub type VariableCache = *mut VariableCacheData;
pub unsafe fn TransactionStartedDuringRecovery() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TransactionStartedDuringRecovery() -> bool;
        }
        TransactionStartedDuringRecovery()
    })
}
extern "C" {
    pub static mut ShmemVariableCache: VariableCache;
}
pub unsafe fn TransactionIdDidCommit(arg_transactionId: TransactionId) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TransactionIdDidCommit(arg_transactionId: TransactionId) -> bool;
        }
        TransactionIdDidCommit(arg_transactionId)
    })
}
pub unsafe fn TransactionIdDidAbort(arg_transactionId: TransactionId) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TransactionIdDidAbort(arg_transactionId: TransactionId) -> bool;
        }
        TransactionIdDidAbort(arg_transactionId)
    })
}
pub unsafe fn TransactionIdIsKnownCompleted(arg_transactionId: TransactionId) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TransactionIdIsKnownCompleted(arg_transactionId: TransactionId) -> bool;
        }
        TransactionIdIsKnownCompleted(arg_transactionId)
    })
}
pub unsafe fn TransactionIdCommitTree(
    arg_xid: TransactionId,
    arg_nxids: ::std::os::raw::c_int,
    arg_xids: *mut TransactionId,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TransactionIdCommitTree(
                arg_xid: TransactionId,
                arg_nxids: ::std::os::raw::c_int,
                arg_xids: *mut TransactionId,
            );
        }
        TransactionIdCommitTree(arg_xid, arg_nxids, arg_xids)
    })
}
pub unsafe fn TransactionIdAsyncCommitTree(
    arg_xid: TransactionId,
    arg_nxids: ::std::os::raw::c_int,
    arg_xids: *mut TransactionId,
    arg_lsn: XLogRecPtr,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TransactionIdAsyncCommitTree(
                arg_xid: TransactionId,
                arg_nxids: ::std::os::raw::c_int,
                arg_xids: *mut TransactionId,
                arg_lsn: XLogRecPtr,
            );
        }
        TransactionIdAsyncCommitTree(arg_xid, arg_nxids, arg_xids, arg_lsn)
    })
}
pub unsafe fn TransactionIdAbortTree(
    arg_xid: TransactionId,
    arg_nxids: ::std::os::raw::c_int,
    arg_xids: *mut TransactionId,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TransactionIdAbortTree(
                arg_xid: TransactionId,
                arg_nxids: ::std::os::raw::c_int,
                arg_xids: *mut TransactionId,
            );
        }
        TransactionIdAbortTree(arg_xid, arg_nxids, arg_xids)
    })
}
pub unsafe fn TransactionIdPrecedes(arg_id1: TransactionId, arg_id2: TransactionId) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TransactionIdPrecedes(arg_id1: TransactionId, arg_id2: TransactionId) -> bool;
        }
        TransactionIdPrecedes(arg_id1, arg_id2)
    })
}
pub unsafe fn TransactionIdPrecedesOrEquals(
    arg_id1: TransactionId,
    arg_id2: TransactionId,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TransactionIdPrecedesOrEquals(
                arg_id1: TransactionId,
                arg_id2: TransactionId,
            ) -> bool;
        }
        TransactionIdPrecedesOrEquals(arg_id1, arg_id2)
    })
}
pub unsafe fn TransactionIdFollows(arg_id1: TransactionId, arg_id2: TransactionId) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TransactionIdFollows(arg_id1: TransactionId, arg_id2: TransactionId) -> bool;
        }
        TransactionIdFollows(arg_id1, arg_id2)
    })
}
pub unsafe fn TransactionIdFollowsOrEquals(arg_id1: TransactionId, arg_id2: TransactionId) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TransactionIdFollowsOrEquals(arg_id1: TransactionId, arg_id2: TransactionId)
                -> bool;
        }
        TransactionIdFollowsOrEquals(arg_id1, arg_id2)
    })
}
pub unsafe fn TransactionIdLatest(
    arg_mainxid: TransactionId,
    arg_nxids: ::std::os::raw::c_int,
    arg_xids: *const TransactionId,
) -> TransactionId {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TransactionIdLatest(
                arg_mainxid: TransactionId,
                arg_nxids: ::std::os::raw::c_int,
                arg_xids: *const TransactionId,
            ) -> TransactionId;
        }
        TransactionIdLatest(arg_mainxid, arg_nxids, arg_xids)
    })
}
pub unsafe fn TransactionIdGetCommitLSN(arg_xid: TransactionId) -> XLogRecPtr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TransactionIdGetCommitLSN(arg_xid: TransactionId) -> XLogRecPtr;
        }
        TransactionIdGetCommitLSN(arg_xid)
    })
}
pub unsafe fn GetNewTransactionId(arg_isSubXact: bool) -> FullTransactionId {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetNewTransactionId(arg_isSubXact: bool) -> FullTransactionId;
        }
        GetNewTransactionId(arg_isSubXact)
    })
}
pub unsafe fn AdvanceNextFullTransactionIdPastXid(arg_xid: TransactionId) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AdvanceNextFullTransactionIdPastXid(arg_xid: TransactionId);
        }
        AdvanceNextFullTransactionIdPastXid(arg_xid)
    })
}
pub unsafe fn ReadNextFullTransactionId() -> FullTransactionId {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReadNextFullTransactionId() -> FullTransactionId;
        }
        ReadNextFullTransactionId()
    })
}
pub unsafe fn SetTransactionIdLimit(
    arg_oldest_datfrozenxid: TransactionId,
    arg_oldest_datoid: Oid,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SetTransactionIdLimit(
                arg_oldest_datfrozenxid: TransactionId,
                arg_oldest_datoid: Oid,
            );
        }
        SetTransactionIdLimit(arg_oldest_datfrozenxid, arg_oldest_datoid)
    })
}
pub unsafe fn AdvanceOldestClogXid(arg_oldest_datfrozenxid: TransactionId) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AdvanceOldestClogXid(arg_oldest_datfrozenxid: TransactionId);
        }
        AdvanceOldestClogXid(arg_oldest_datfrozenxid)
    })
}
pub unsafe fn ForceTransactionIdLimitUpdate() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ForceTransactionIdLimitUpdate() -> bool;
        }
        ForceTransactionIdLimitUpdate()
    })
}
pub unsafe fn GetNewObjectId() -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetNewObjectId() -> Oid;
        }
        GetNewObjectId()
    })
}
pub type Item = Pointer;
pub type Page = Pointer;
pub type LocationIndex = uint16;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PageXLogRecPtr {
    pub xlogid: uint32,
    pub xrecoff: uint32,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct PageHeaderData {
    pub pd_lsn: PageXLogRecPtr,
    pub pd_checksum: uint16,
    pub pd_flags: uint16,
    pub pd_lower: LocationIndex,
    pub pd_upper: LocationIndex,
    pub pd_special: LocationIndex,
    pub pd_pagesize_version: uint16,
    pub pd_prune_xid: TransactionId,
    pub pd_linp: __IncompleteArrayField<ItemIdData>,
}
pub type PageHeader = *mut PageHeaderData;
pub unsafe fn PageInit(arg_page: Page, arg_pageSize: Size, arg_specialSize: Size) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PageInit(arg_page: Page, arg_pageSize: Size, arg_specialSize: Size);
        }
        PageInit(arg_page, arg_pageSize, arg_specialSize)
    })
}
pub unsafe fn PageIsVerified(arg_page: Page, arg_blkno: BlockNumber) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PageIsVerified(arg_page: Page, arg_blkno: BlockNumber) -> bool;
        }
        PageIsVerified(arg_page, arg_blkno)
    })
}
pub unsafe fn PageIsVerifiedExtended(
    arg_page: Page,
    arg_blkno: BlockNumber,
    arg_flags: ::std::os::raw::c_int,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PageIsVerifiedExtended(
                arg_page: Page,
                arg_blkno: BlockNumber,
                arg_flags: ::std::os::raw::c_int,
            ) -> bool;
        }
        PageIsVerifiedExtended(arg_page, arg_blkno, arg_flags)
    })
}
pub unsafe fn PageAddItemExtended(
    arg_page: Page,
    arg_item: Item,
    arg_size: Size,
    arg_offsetNumber: OffsetNumber,
    arg_flags: ::std::os::raw::c_int,
) -> OffsetNumber {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PageAddItemExtended(
                arg_page: Page,
                arg_item: Item,
                arg_size: Size,
                arg_offsetNumber: OffsetNumber,
                arg_flags: ::std::os::raw::c_int,
            ) -> OffsetNumber;
        }
        PageAddItemExtended(arg_page, arg_item, arg_size, arg_offsetNumber, arg_flags)
    })
}
pub unsafe fn PageGetTempPage(arg_page: Page) -> Page {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PageGetTempPage(arg_page: Page) -> Page;
        }
        PageGetTempPage(arg_page)
    })
}
pub unsafe fn PageGetTempPageCopy(arg_page: Page) -> Page {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PageGetTempPageCopy(arg_page: Page) -> Page;
        }
        PageGetTempPageCopy(arg_page)
    })
}
pub unsafe fn PageGetTempPageCopySpecial(arg_page: Page) -> Page {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PageGetTempPageCopySpecial(arg_page: Page) -> Page;
        }
        PageGetTempPageCopySpecial(arg_page)
    })
}
pub unsafe fn PageRestoreTempPage(arg_tempPage: Page, arg_oldPage: Page) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PageRestoreTempPage(arg_tempPage: Page, arg_oldPage: Page);
        }
        PageRestoreTempPage(arg_tempPage, arg_oldPage)
    })
}
pub unsafe fn PageRepairFragmentation(arg_page: Page) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PageRepairFragmentation(arg_page: Page);
        }
        PageRepairFragmentation(arg_page)
    })
}
pub unsafe fn PageGetFreeSpace(arg_page: Page) -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PageGetFreeSpace(arg_page: Page) -> Size;
        }
        PageGetFreeSpace(arg_page)
    })
}
pub unsafe fn PageGetFreeSpaceForMultipleTuples(
    arg_page: Page,
    arg_ntups: ::std::os::raw::c_int,
) -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PageGetFreeSpaceForMultipleTuples(
                arg_page: Page,
                arg_ntups: ::std::os::raw::c_int,
            ) -> Size;
        }
        PageGetFreeSpaceForMultipleTuples(arg_page, arg_ntups)
    })
}
pub unsafe fn PageGetExactFreeSpace(arg_page: Page) -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PageGetExactFreeSpace(arg_page: Page) -> Size;
        }
        PageGetExactFreeSpace(arg_page)
    })
}
pub unsafe fn PageGetHeapFreeSpace(arg_page: Page) -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PageGetHeapFreeSpace(arg_page: Page) -> Size;
        }
        PageGetHeapFreeSpace(arg_page)
    })
}
pub unsafe fn PageIndexTupleDelete(arg_page: Page, arg_offset: OffsetNumber) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PageIndexTupleDelete(arg_page: Page, arg_offset: OffsetNumber);
        }
        PageIndexTupleDelete(arg_page, arg_offset)
    })
}
pub unsafe fn PageIndexMultiDelete(
    arg_page: Page,
    arg_itemnos: *mut OffsetNumber,
    arg_nitems: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PageIndexMultiDelete(
                arg_page: Page,
                arg_itemnos: *mut OffsetNumber,
                arg_nitems: ::std::os::raw::c_int,
            );
        }
        PageIndexMultiDelete(arg_page, arg_itemnos, arg_nitems)
    })
}
pub unsafe fn PageIndexTupleDeleteNoCompact(arg_page: Page, arg_offset: OffsetNumber) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PageIndexTupleDeleteNoCompact(arg_page: Page, arg_offset: OffsetNumber);
        }
        PageIndexTupleDeleteNoCompact(arg_page, arg_offset)
    })
}
pub unsafe fn PageIndexTupleOverwrite(
    arg_page: Page,
    arg_offnum: OffsetNumber,
    arg_newtup: Item,
    arg_newsize: Size,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PageIndexTupleOverwrite(
                arg_page: Page,
                arg_offnum: OffsetNumber,
                arg_newtup: Item,
                arg_newsize: Size,
            ) -> bool;
        }
        PageIndexTupleOverwrite(arg_page, arg_offnum, arg_newtup, arg_newsize)
    })
}
pub unsafe fn PageSetChecksumCopy(
    arg_page: Page,
    arg_blkno: BlockNumber,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PageSetChecksumCopy(
                arg_page: Page,
                arg_blkno: BlockNumber,
            ) -> *mut ::std::os::raw::c_char;
        }
        PageSetChecksumCopy(arg_page, arg_blkno)
    })
}
pub unsafe fn PageSetChecksumInplace(arg_page: Page, arg_blkno: BlockNumber) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PageSetChecksumInplace(arg_page: Page, arg_blkno: BlockNumber);
        }
        PageSetChecksumInplace(arg_page, arg_blkno)
    })
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HeapTupleFields {
    pub t_xmin: TransactionId,
    pub t_xmax: TransactionId,
    pub t_field3: HeapTupleFields__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union HeapTupleFields__bindgen_ty_1 {
    pub t_cid: CommandId,
    pub t_xvac: TransactionId,
}
impl Default for HeapTupleFields__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for HeapTupleFields {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DatumTupleFields {
    pub datum_len_: int32,
    pub datum_typmod: int32,
    pub datum_typeid: Oid,
}
#[repr(C)]
pub struct HeapTupleHeaderData {
    pub t_choice: HeapTupleHeaderData__bindgen_ty_1,
    pub t_ctid: ItemPointerData,
    pub t_infomask2: uint16,
    pub t_infomask: uint16,
    pub t_hoff: uint8,
    pub t_bits: __IncompleteArrayField<bits8>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union HeapTupleHeaderData__bindgen_ty_1 {
    pub t_heap: HeapTupleFields,
    pub t_datum: DatumTupleFields,
}
impl Default for HeapTupleHeaderData__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for HeapTupleHeaderData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct MinimalTupleData {
    pub t_len: uint32,
    pub mt_padding: [::std::os::raw::c_char; 6usize],
    pub t_infomask2: uint16,
    pub t_infomask: uint16,
    pub t_hoff: uint8,
    pub t_bits: __IncompleteArrayField<bits8>,
}
pub unsafe fn heap_compute_data_size(
    arg_tupleDesc: TupleDesc,
    arg_values: *mut Datum,
    arg_isnull: *mut bool,
) -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_compute_data_size(
                arg_tupleDesc: TupleDesc,
                arg_values: *mut Datum,
                arg_isnull: *mut bool,
            ) -> Size;
        }
        heap_compute_data_size(arg_tupleDesc, arg_values, arg_isnull)
    })
}
pub unsafe fn heap_fill_tuple(
    arg_tupleDesc: TupleDesc,
    arg_values: *mut Datum,
    arg_isnull: *mut bool,
    arg_data: *mut ::std::os::raw::c_char,
    arg_data_size: Size,
    arg_infomask: *mut uint16,
    arg_bit: *mut bits8,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_fill_tuple(
                arg_tupleDesc: TupleDesc,
                arg_values: *mut Datum,
                arg_isnull: *mut bool,
                arg_data: *mut ::std::os::raw::c_char,
                arg_data_size: Size,
                arg_infomask: *mut uint16,
                arg_bit: *mut bits8,
            );
        }
        heap_fill_tuple(
            arg_tupleDesc,
            arg_values,
            arg_isnull,
            arg_data,
            arg_data_size,
            arg_infomask,
            arg_bit,
        )
    })
}
pub unsafe fn heap_attisnull(
    arg_tup: HeapTuple,
    arg_attnum: ::std::os::raw::c_int,
    arg_tupleDesc: TupleDesc,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_attisnull(
                arg_tup: HeapTuple,
                arg_attnum: ::std::os::raw::c_int,
                arg_tupleDesc: TupleDesc,
            ) -> bool;
        }
        heap_attisnull(arg_tup, arg_attnum, arg_tupleDesc)
    })
}
pub unsafe fn nocachegetattr(
    arg_tup: HeapTuple,
    arg_attnum: ::std::os::raw::c_int,
    arg_att: TupleDesc,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn nocachegetattr(
                arg_tup: HeapTuple,
                arg_attnum: ::std::os::raw::c_int,
                arg_att: TupleDesc,
            ) -> Datum;
        }
        nocachegetattr(arg_tup, arg_attnum, arg_att)
    })
}
pub unsafe fn heap_getsysattr(
    arg_tup: HeapTuple,
    arg_attnum: ::std::os::raw::c_int,
    arg_tupleDesc: TupleDesc,
    arg_isnull: *mut bool,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_getsysattr(
                arg_tup: HeapTuple,
                arg_attnum: ::std::os::raw::c_int,
                arg_tupleDesc: TupleDesc,
                arg_isnull: *mut bool,
            ) -> Datum;
        }
        heap_getsysattr(arg_tup, arg_attnum, arg_tupleDesc, arg_isnull)
    })
}
pub unsafe fn getmissingattr(
    arg_tupleDesc: TupleDesc,
    arg_attnum: ::std::os::raw::c_int,
    arg_isnull: *mut bool,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getmissingattr(
                arg_tupleDesc: TupleDesc,
                arg_attnum: ::std::os::raw::c_int,
                arg_isnull: *mut bool,
            ) -> Datum;
        }
        getmissingattr(arg_tupleDesc, arg_attnum, arg_isnull)
    })
}
pub unsafe fn heap_copytuple(arg_tuple: HeapTuple) -> HeapTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_copytuple(arg_tuple: HeapTuple) -> HeapTuple;
        }
        heap_copytuple(arg_tuple)
    })
}
pub unsafe fn heap_copytuple_with_tuple(arg_src: HeapTuple, arg_dest: HeapTuple) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_copytuple_with_tuple(arg_src: HeapTuple, arg_dest: HeapTuple);
        }
        heap_copytuple_with_tuple(arg_src, arg_dest)
    })
}
pub unsafe fn heap_copy_tuple_as_datum(arg_tuple: HeapTuple, arg_tupleDesc: TupleDesc) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_copy_tuple_as_datum(arg_tuple: HeapTuple, arg_tupleDesc: TupleDesc) -> Datum;
        }
        heap_copy_tuple_as_datum(arg_tuple, arg_tupleDesc)
    })
}
pub unsafe fn heap_form_tuple(
    arg_tupleDescriptor: TupleDesc,
    arg_values: *mut Datum,
    arg_isnull: *mut bool,
) -> HeapTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_form_tuple(
                arg_tupleDescriptor: TupleDesc,
                arg_values: *mut Datum,
                arg_isnull: *mut bool,
            ) -> HeapTuple;
        }
        heap_form_tuple(arg_tupleDescriptor, arg_values, arg_isnull)
    })
}
pub unsafe fn heap_modify_tuple(
    arg_tuple: HeapTuple,
    arg_tupleDesc: TupleDesc,
    arg_replValues: *mut Datum,
    arg_replIsnull: *mut bool,
    arg_doReplace: *mut bool,
) -> HeapTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_modify_tuple(
                arg_tuple: HeapTuple,
                arg_tupleDesc: TupleDesc,
                arg_replValues: *mut Datum,
                arg_replIsnull: *mut bool,
                arg_doReplace: *mut bool,
            ) -> HeapTuple;
        }
        heap_modify_tuple(arg_tuple, arg_tupleDesc, arg_replValues, arg_replIsnull, arg_doReplace)
    })
}
pub unsafe fn heap_modify_tuple_by_cols(
    arg_tuple: HeapTuple,
    arg_tupleDesc: TupleDesc,
    arg_nCols: ::std::os::raw::c_int,
    arg_replCols: *mut ::std::os::raw::c_int,
    arg_replValues: *mut Datum,
    arg_replIsnull: *mut bool,
) -> HeapTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_modify_tuple_by_cols(
                arg_tuple: HeapTuple,
                arg_tupleDesc: TupleDesc,
                arg_nCols: ::std::os::raw::c_int,
                arg_replCols: *mut ::std::os::raw::c_int,
                arg_replValues: *mut Datum,
                arg_replIsnull: *mut bool,
            ) -> HeapTuple;
        }
        heap_modify_tuple_by_cols(
            arg_tuple,
            arg_tupleDesc,
            arg_nCols,
            arg_replCols,
            arg_replValues,
            arg_replIsnull,
        )
    })
}
pub unsafe fn heap_deform_tuple(
    arg_tuple: HeapTuple,
    arg_tupleDesc: TupleDesc,
    arg_values: *mut Datum,
    arg_isnull: *mut bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_deform_tuple(
                arg_tuple: HeapTuple,
                arg_tupleDesc: TupleDesc,
                arg_values: *mut Datum,
                arg_isnull: *mut bool,
            );
        }
        heap_deform_tuple(arg_tuple, arg_tupleDesc, arg_values, arg_isnull)
    })
}
pub unsafe fn heap_freetuple(arg_htup: HeapTuple) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_freetuple(arg_htup: HeapTuple);
        }
        heap_freetuple(arg_htup)
    })
}
pub unsafe fn heap_form_minimal_tuple(
    arg_tupleDescriptor: TupleDesc,
    arg_values: *mut Datum,
    arg_isnull: *mut bool,
) -> MinimalTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_form_minimal_tuple(
                arg_tupleDescriptor: TupleDesc,
                arg_values: *mut Datum,
                arg_isnull: *mut bool,
            ) -> MinimalTuple;
        }
        heap_form_minimal_tuple(arg_tupleDescriptor, arg_values, arg_isnull)
    })
}
pub unsafe fn heap_free_minimal_tuple(arg_mtup: MinimalTuple) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_free_minimal_tuple(arg_mtup: MinimalTuple);
        }
        heap_free_minimal_tuple(arg_mtup)
    })
}
pub unsafe fn heap_copy_minimal_tuple(arg_mtup: MinimalTuple) -> MinimalTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_copy_minimal_tuple(arg_mtup: MinimalTuple) -> MinimalTuple;
        }
        heap_copy_minimal_tuple(arg_mtup)
    })
}
pub unsafe fn heap_tuple_from_minimal_tuple(arg_mtup: MinimalTuple) -> HeapTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_tuple_from_minimal_tuple(arg_mtup: MinimalTuple) -> HeapTuple;
        }
        heap_tuple_from_minimal_tuple(arg_mtup)
    })
}
pub unsafe fn minimal_tuple_from_heap_tuple(arg_htup: HeapTuple) -> MinimalTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn minimal_tuple_from_heap_tuple(arg_htup: HeapTuple) -> MinimalTuple;
        }
        minimal_tuple_from_heap_tuple(arg_htup)
    })
}
pub unsafe fn heap_expand_tuple(arg_sourceTuple: HeapTuple, arg_tupleDesc: TupleDesc) -> HeapTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_expand_tuple(arg_sourceTuple: HeapTuple, arg_tupleDesc: TupleDesc)
                -> HeapTuple;
        }
        heap_expand_tuple(arg_sourceTuple, arg_tupleDesc)
    })
}
pub unsafe fn minimal_expand_tuple(
    arg_sourceTuple: HeapTuple,
    arg_tupleDesc: TupleDesc,
) -> MinimalTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn minimal_expand_tuple(
                arg_sourceTuple: HeapTuple,
                arg_tupleDesc: TupleDesc,
            ) -> MinimalTuple;
        }
        minimal_expand_tuple(arg_sourceTuple, arg_tupleDesc)
    })
}
pub type Buffer = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BufferAccessStrategyData {
    _unused: [u8; 0],
}
pub type BufferAccessStrategy = *mut BufferAccessStrategyData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TupleTableSlot {
    pub type_: NodeTag,
    pub tts_flags: uint16,
    pub tts_nvalid: AttrNumber,
    pub tts_ops: *const TupleTableSlotOps,
    pub tts_tupleDescriptor: TupleDesc,
    pub tts_values: *mut Datum,
    pub tts_isnull: *mut bool,
    pub tts_mcxt: MemoryContext,
    pub tts_tid: ItemPointerData,
    pub tts_tableOid: Oid,
}
impl Default for TupleTableSlot {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TupleTableSlotOps {
    pub base_slot_size: usize,
    pub init: ::std::option::Option<unsafe extern "C" fn(slot: *mut TupleTableSlot)>,
    pub release: ::std::option::Option<unsafe extern "C" fn(slot: *mut TupleTableSlot)>,
    pub clear: ::std::option::Option<unsafe extern "C" fn(slot: *mut TupleTableSlot)>,
    pub getsomeattrs: ::std::option::Option<
        unsafe extern "C" fn(slot: *mut TupleTableSlot, natts: ::std::os::raw::c_int),
    >,
    pub getsysattr: ::std::option::Option<
        unsafe extern "C" fn(
            slot: *mut TupleTableSlot,
            attnum: ::std::os::raw::c_int,
            isnull: *mut bool,
        ) -> Datum,
    >,
    pub materialize: ::std::option::Option<unsafe extern "C" fn(slot: *mut TupleTableSlot)>,
    pub copyslot: ::std::option::Option<
        unsafe extern "C" fn(dstslot: *mut TupleTableSlot, srcslot: *mut TupleTableSlot),
    >,
    pub get_heap_tuple:
        ::std::option::Option<unsafe extern "C" fn(slot: *mut TupleTableSlot) -> HeapTuple>,
    pub get_minimal_tuple:
        ::std::option::Option<unsafe extern "C" fn(slot: *mut TupleTableSlot) -> MinimalTuple>,
    pub copy_heap_tuple:
        ::std::option::Option<unsafe extern "C" fn(slot: *mut TupleTableSlot) -> HeapTuple>,
    pub copy_minimal_tuple:
        ::std::option::Option<unsafe extern "C" fn(slot: *mut TupleTableSlot) -> MinimalTuple>,
}
extern "C" {
    pub static TTSOpsVirtual: TupleTableSlotOps;
}
extern "C" {
    pub static TTSOpsHeapTuple: TupleTableSlotOps;
}
extern "C" {
    pub static TTSOpsMinimalTuple: TupleTableSlotOps;
}
extern "C" {
    pub static TTSOpsBufferHeapTuple: TupleTableSlotOps;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VirtualTupleTableSlot {
    pub base: TupleTableSlot,
    pub data: *mut ::std::os::raw::c_char,
}
impl Default for VirtualTupleTableSlot {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HeapTupleTableSlot {
    pub base: TupleTableSlot,
    pub tuple: HeapTuple,
    pub off: uint32,
    pub tupdata: HeapTupleData,
}
impl Default for HeapTupleTableSlot {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BufferHeapTupleTableSlot {
    pub base: HeapTupleTableSlot,
    pub buffer: Buffer,
}
impl Default for BufferHeapTupleTableSlot {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MinimalTupleTableSlot {
    pub base: TupleTableSlot,
    pub tuple: HeapTuple,
    pub mintuple: MinimalTuple,
    pub minhdr: HeapTupleData,
    pub off: uint32,
}
impl Default for MinimalTupleTableSlot {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn MakeTupleTableSlot(
    arg_tupleDesc: TupleDesc,
    arg_tts_ops: *const TupleTableSlotOps,
) -> *mut TupleTableSlot {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MakeTupleTableSlot(
                arg_tupleDesc: TupleDesc,
                arg_tts_ops: *const TupleTableSlotOps,
            ) -> *mut TupleTableSlot;
        }
        MakeTupleTableSlot(arg_tupleDesc, arg_tts_ops)
    })
}
pub unsafe fn ExecAllocTableSlot(
    arg_tupleTable: *mut *mut List,
    arg_desc: TupleDesc,
    arg_tts_ops: *const TupleTableSlotOps,
) -> *mut TupleTableSlot {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecAllocTableSlot(
                arg_tupleTable: *mut *mut List,
                arg_desc: TupleDesc,
                arg_tts_ops: *const TupleTableSlotOps,
            ) -> *mut TupleTableSlot;
        }
        ExecAllocTableSlot(arg_tupleTable, arg_desc, arg_tts_ops)
    })
}
pub unsafe fn ExecResetTupleTable(arg_tupleTable: *mut List, arg_shouldFree: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecResetTupleTable(arg_tupleTable: *mut List, arg_shouldFree: bool);
        }
        ExecResetTupleTable(arg_tupleTable, arg_shouldFree)
    })
}
pub unsafe fn MakeSingleTupleTableSlot(
    arg_tupdesc: TupleDesc,
    arg_tts_ops: *const TupleTableSlotOps,
) -> *mut TupleTableSlot {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MakeSingleTupleTableSlot(
                arg_tupdesc: TupleDesc,
                arg_tts_ops: *const TupleTableSlotOps,
            ) -> *mut TupleTableSlot;
        }
        MakeSingleTupleTableSlot(arg_tupdesc, arg_tts_ops)
    })
}
pub unsafe fn ExecDropSingleTupleTableSlot(arg_slot: *mut TupleTableSlot) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecDropSingleTupleTableSlot(arg_slot: *mut TupleTableSlot);
        }
        ExecDropSingleTupleTableSlot(arg_slot)
    })
}
pub unsafe fn ExecSetSlotDescriptor(arg_slot: *mut TupleTableSlot, arg_tupdesc: TupleDesc) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecSetSlotDescriptor(arg_slot: *mut TupleTableSlot, arg_tupdesc: TupleDesc);
        }
        ExecSetSlotDescriptor(arg_slot, arg_tupdesc)
    })
}
pub unsafe fn ExecStoreHeapTuple(
    arg_tuple: HeapTuple,
    arg_slot: *mut TupleTableSlot,
    arg_shouldFree: bool,
) -> *mut TupleTableSlot {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecStoreHeapTuple(
                arg_tuple: HeapTuple,
                arg_slot: *mut TupleTableSlot,
                arg_shouldFree: bool,
            ) -> *mut TupleTableSlot;
        }
        ExecStoreHeapTuple(arg_tuple, arg_slot, arg_shouldFree)
    })
}
pub unsafe fn ExecForceStoreHeapTuple(
    arg_tuple: HeapTuple,
    arg_slot: *mut TupleTableSlot,
    arg_shouldFree: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecForceStoreHeapTuple(
                arg_tuple: HeapTuple,
                arg_slot: *mut TupleTableSlot,
                arg_shouldFree: bool,
            );
        }
        ExecForceStoreHeapTuple(arg_tuple, arg_slot, arg_shouldFree)
    })
}
pub unsafe fn ExecStoreBufferHeapTuple(
    arg_tuple: HeapTuple,
    arg_slot: *mut TupleTableSlot,
    arg_buffer: Buffer,
) -> *mut TupleTableSlot {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecStoreBufferHeapTuple(
                arg_tuple: HeapTuple,
                arg_slot: *mut TupleTableSlot,
                arg_buffer: Buffer,
            ) -> *mut TupleTableSlot;
        }
        ExecStoreBufferHeapTuple(arg_tuple, arg_slot, arg_buffer)
    })
}
pub unsafe fn ExecStorePinnedBufferHeapTuple(
    arg_tuple: HeapTuple,
    arg_slot: *mut TupleTableSlot,
    arg_buffer: Buffer,
) -> *mut TupleTableSlot {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecStorePinnedBufferHeapTuple(
                arg_tuple: HeapTuple,
                arg_slot: *mut TupleTableSlot,
                arg_buffer: Buffer,
            ) -> *mut TupleTableSlot;
        }
        ExecStorePinnedBufferHeapTuple(arg_tuple, arg_slot, arg_buffer)
    })
}
pub unsafe fn ExecStoreMinimalTuple(
    arg_mtup: MinimalTuple,
    arg_slot: *mut TupleTableSlot,
    arg_shouldFree: bool,
) -> *mut TupleTableSlot {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecStoreMinimalTuple(
                arg_mtup: MinimalTuple,
                arg_slot: *mut TupleTableSlot,
                arg_shouldFree: bool,
            ) -> *mut TupleTableSlot;
        }
        ExecStoreMinimalTuple(arg_mtup, arg_slot, arg_shouldFree)
    })
}
pub unsafe fn ExecForceStoreMinimalTuple(
    arg_mtup: MinimalTuple,
    arg_slot: *mut TupleTableSlot,
    arg_shouldFree: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecForceStoreMinimalTuple(
                arg_mtup: MinimalTuple,
                arg_slot: *mut TupleTableSlot,
                arg_shouldFree: bool,
            );
        }
        ExecForceStoreMinimalTuple(arg_mtup, arg_slot, arg_shouldFree)
    })
}
pub unsafe fn ExecStoreVirtualTuple(arg_slot: *mut TupleTableSlot) -> *mut TupleTableSlot {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecStoreVirtualTuple(arg_slot: *mut TupleTableSlot) -> *mut TupleTableSlot;
        }
        ExecStoreVirtualTuple(arg_slot)
    })
}
pub unsafe fn ExecStoreAllNullTuple(arg_slot: *mut TupleTableSlot) -> *mut TupleTableSlot {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecStoreAllNullTuple(arg_slot: *mut TupleTableSlot) -> *mut TupleTableSlot;
        }
        ExecStoreAllNullTuple(arg_slot)
    })
}
pub unsafe fn ExecStoreHeapTupleDatum(arg_data: Datum, arg_slot: *mut TupleTableSlot) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecStoreHeapTupleDatum(arg_data: Datum, arg_slot: *mut TupleTableSlot);
        }
        ExecStoreHeapTupleDatum(arg_data, arg_slot)
    })
}
pub unsafe fn ExecFetchSlotHeapTuple(
    arg_slot: *mut TupleTableSlot,
    arg_materialize: bool,
    arg_shouldFree: *mut bool,
) -> HeapTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecFetchSlotHeapTuple(
                arg_slot: *mut TupleTableSlot,
                arg_materialize: bool,
                arg_shouldFree: *mut bool,
            ) -> HeapTuple;
        }
        ExecFetchSlotHeapTuple(arg_slot, arg_materialize, arg_shouldFree)
    })
}
pub unsafe fn ExecFetchSlotMinimalTuple(
    arg_slot: *mut TupleTableSlot,
    arg_shouldFree: *mut bool,
) -> MinimalTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecFetchSlotMinimalTuple(
                arg_slot: *mut TupleTableSlot,
                arg_shouldFree: *mut bool,
            ) -> MinimalTuple;
        }
        ExecFetchSlotMinimalTuple(arg_slot, arg_shouldFree)
    })
}
pub unsafe fn ExecFetchSlotHeapTupleDatum(arg_slot: *mut TupleTableSlot) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecFetchSlotHeapTupleDatum(arg_slot: *mut TupleTableSlot) -> Datum;
        }
        ExecFetchSlotHeapTupleDatum(arg_slot)
    })
}
pub unsafe fn slot_getmissingattrs(
    arg_slot: *mut TupleTableSlot,
    arg_startAttNum: ::std::os::raw::c_int,
    arg_lastAttNum: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn slot_getmissingattrs(
                arg_slot: *mut TupleTableSlot,
                arg_startAttNum: ::std::os::raw::c_int,
                arg_lastAttNum: ::std::os::raw::c_int,
            );
        }
        slot_getmissingattrs(arg_slot, arg_startAttNum, arg_lastAttNum)
    })
}
pub unsafe fn slot_getsomeattrs_int(
    arg_slot: *mut TupleTableSlot,
    arg_attnum: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn slot_getsomeattrs_int(
                arg_slot: *mut TupleTableSlot,
                arg_attnum: ::std::os::raw::c_int,
            );
        }
        slot_getsomeattrs_int(arg_slot, arg_attnum)
    })
}
pub type bitmapword = uint64;
pub type signedbitmapword = int64;
#[repr(C)]
#[derive(Debug, Default)]
pub struct Bitmapset {
    pub nwords: ::std::os::raw::c_int,
    pub words: __IncompleteArrayField<bitmapword>,
}
pub const BMS_Comparison_BMS_EQUAL: BMS_Comparison = 0;
pub const BMS_Comparison_BMS_SUBSET1: BMS_Comparison = 1;
pub const BMS_Comparison_BMS_SUBSET2: BMS_Comparison = 2;
pub const BMS_Comparison_BMS_DIFFERENT: BMS_Comparison = 3;
pub type BMS_Comparison = ::std::os::raw::c_uint;
pub const BMS_Membership_BMS_EMPTY_SET: BMS_Membership = 0;
pub const BMS_Membership_BMS_SINGLETON: BMS_Membership = 1;
pub const BMS_Membership_BMS_MULTIPLE: BMS_Membership = 2;
pub type BMS_Membership = ::std::os::raw::c_uint;
pub unsafe fn bms_copy(arg_a: *const Bitmapset) -> *mut Bitmapset {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bms_copy(arg_a: *const Bitmapset) -> *mut Bitmapset;
        }
        bms_copy(arg_a)
    })
}
pub unsafe fn bms_equal(arg_a: *const Bitmapset, arg_b: *const Bitmapset) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bms_equal(arg_a: *const Bitmapset, arg_b: *const Bitmapset) -> bool;
        }
        bms_equal(arg_a, arg_b)
    })
}
pub unsafe fn bms_compare(
    arg_a: *const Bitmapset,
    arg_b: *const Bitmapset,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bms_compare(
                arg_a: *const Bitmapset,
                arg_b: *const Bitmapset,
            ) -> ::std::os::raw::c_int;
        }
        bms_compare(arg_a, arg_b)
    })
}
pub unsafe fn bms_make_singleton(arg_x: ::std::os::raw::c_int) -> *mut Bitmapset {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bms_make_singleton(arg_x: ::std::os::raw::c_int) -> *mut Bitmapset;
        }
        bms_make_singleton(arg_x)
    })
}
pub unsafe fn bms_free(arg_a: *mut Bitmapset) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bms_free(arg_a: *mut Bitmapset);
        }
        bms_free(arg_a)
    })
}
pub unsafe fn bms_union(arg_a: *const Bitmapset, arg_b: *const Bitmapset) -> *mut Bitmapset {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bms_union(arg_a: *const Bitmapset, arg_b: *const Bitmapset) -> *mut Bitmapset;
        }
        bms_union(arg_a, arg_b)
    })
}
pub unsafe fn bms_intersect(arg_a: *const Bitmapset, arg_b: *const Bitmapset) -> *mut Bitmapset {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bms_intersect(arg_a: *const Bitmapset, arg_b: *const Bitmapset) -> *mut Bitmapset;
        }
        bms_intersect(arg_a, arg_b)
    })
}
pub unsafe fn bms_difference(arg_a: *const Bitmapset, arg_b: *const Bitmapset) -> *mut Bitmapset {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bms_difference(arg_a: *const Bitmapset, arg_b: *const Bitmapset) -> *mut Bitmapset;
        }
        bms_difference(arg_a, arg_b)
    })
}
pub unsafe fn bms_is_subset(arg_a: *const Bitmapset, arg_b: *const Bitmapset) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bms_is_subset(arg_a: *const Bitmapset, arg_b: *const Bitmapset) -> bool;
        }
        bms_is_subset(arg_a, arg_b)
    })
}
pub unsafe fn bms_subset_compare(
    arg_a: *const Bitmapset,
    arg_b: *const Bitmapset,
) -> BMS_Comparison {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bms_subset_compare(
                arg_a: *const Bitmapset,
                arg_b: *const Bitmapset,
            ) -> BMS_Comparison;
        }
        bms_subset_compare(arg_a, arg_b)
    })
}
pub unsafe fn bms_is_member(arg_x: ::std::os::raw::c_int, arg_a: *const Bitmapset) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bms_is_member(arg_x: ::std::os::raw::c_int, arg_a: *const Bitmapset) -> bool;
        }
        bms_is_member(arg_x, arg_a)
    })
}
pub unsafe fn bms_member_index(
    arg_a: *mut Bitmapset,
    arg_x: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bms_member_index(
                arg_a: *mut Bitmapset,
                arg_x: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        bms_member_index(arg_a, arg_x)
    })
}
pub unsafe fn bms_overlap(arg_a: *const Bitmapset, arg_b: *const Bitmapset) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bms_overlap(arg_a: *const Bitmapset, arg_b: *const Bitmapset) -> bool;
        }
        bms_overlap(arg_a, arg_b)
    })
}
pub unsafe fn bms_overlap_list(arg_a: *const Bitmapset, arg_b: *const List) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bms_overlap_list(arg_a: *const Bitmapset, arg_b: *const List) -> bool;
        }
        bms_overlap_list(arg_a, arg_b)
    })
}
pub unsafe fn bms_nonempty_difference(arg_a: *const Bitmapset, arg_b: *const Bitmapset) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bms_nonempty_difference(arg_a: *const Bitmapset, arg_b: *const Bitmapset) -> bool;
        }
        bms_nonempty_difference(arg_a, arg_b)
    })
}
pub unsafe fn bms_singleton_member(arg_a: *const Bitmapset) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bms_singleton_member(arg_a: *const Bitmapset) -> ::std::os::raw::c_int;
        }
        bms_singleton_member(arg_a)
    })
}
pub unsafe fn bms_get_singleton_member(
    arg_a: *const Bitmapset,
    arg_member: *mut ::std::os::raw::c_int,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bms_get_singleton_member(
                arg_a: *const Bitmapset,
                arg_member: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        bms_get_singleton_member(arg_a, arg_member)
    })
}
pub unsafe fn bms_num_members(arg_a: *const Bitmapset) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bms_num_members(arg_a: *const Bitmapset) -> ::std::os::raw::c_int;
        }
        bms_num_members(arg_a)
    })
}
pub unsafe fn bms_membership(arg_a: *const Bitmapset) -> BMS_Membership {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bms_membership(arg_a: *const Bitmapset) -> BMS_Membership;
        }
        bms_membership(arg_a)
    })
}
pub unsafe fn bms_is_empty(arg_a: *const Bitmapset) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bms_is_empty(arg_a: *const Bitmapset) -> bool;
        }
        bms_is_empty(arg_a)
    })
}
pub unsafe fn bms_add_member(
    arg_a: *mut Bitmapset,
    arg_x: ::std::os::raw::c_int,
) -> *mut Bitmapset {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bms_add_member(
                arg_a: *mut Bitmapset,
                arg_x: ::std::os::raw::c_int,
            ) -> *mut Bitmapset;
        }
        bms_add_member(arg_a, arg_x)
    })
}
pub unsafe fn bms_del_member(
    arg_a: *mut Bitmapset,
    arg_x: ::std::os::raw::c_int,
) -> *mut Bitmapset {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bms_del_member(
                arg_a: *mut Bitmapset,
                arg_x: ::std::os::raw::c_int,
            ) -> *mut Bitmapset;
        }
        bms_del_member(arg_a, arg_x)
    })
}
pub unsafe fn bms_add_members(arg_a: *mut Bitmapset, arg_b: *const Bitmapset) -> *mut Bitmapset {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bms_add_members(arg_a: *mut Bitmapset, arg_b: *const Bitmapset) -> *mut Bitmapset;
        }
        bms_add_members(arg_a, arg_b)
    })
}
pub unsafe fn bms_add_range(
    arg_a: *mut Bitmapset,
    arg_lower: ::std::os::raw::c_int,
    arg_upper: ::std::os::raw::c_int,
) -> *mut Bitmapset {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bms_add_range(
                arg_a: *mut Bitmapset,
                arg_lower: ::std::os::raw::c_int,
                arg_upper: ::std::os::raw::c_int,
            ) -> *mut Bitmapset;
        }
        bms_add_range(arg_a, arg_lower, arg_upper)
    })
}
pub unsafe fn bms_int_members(arg_a: *mut Bitmapset, arg_b: *const Bitmapset) -> *mut Bitmapset {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bms_int_members(arg_a: *mut Bitmapset, arg_b: *const Bitmapset) -> *mut Bitmapset;
        }
        bms_int_members(arg_a, arg_b)
    })
}
pub unsafe fn bms_del_members(arg_a: *mut Bitmapset, arg_b: *const Bitmapset) -> *mut Bitmapset {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bms_del_members(arg_a: *mut Bitmapset, arg_b: *const Bitmapset) -> *mut Bitmapset;
        }
        bms_del_members(arg_a, arg_b)
    })
}
pub unsafe fn bms_join(arg_a: *mut Bitmapset, arg_b: *mut Bitmapset) -> *mut Bitmapset {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bms_join(arg_a: *mut Bitmapset, arg_b: *mut Bitmapset) -> *mut Bitmapset;
        }
        bms_join(arg_a, arg_b)
    })
}
pub unsafe fn bms_first_member(arg_a: *mut Bitmapset) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bms_first_member(arg_a: *mut Bitmapset) -> ::std::os::raw::c_int;
        }
        bms_first_member(arg_a)
    })
}
pub unsafe fn bms_next_member(
    arg_a: *const Bitmapset,
    arg_prevbit: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bms_next_member(
                arg_a: *const Bitmapset,
                arg_prevbit: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        bms_next_member(arg_a, arg_prevbit)
    })
}
pub unsafe fn bms_prev_member(
    arg_a: *const Bitmapset,
    arg_prevbit: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bms_prev_member(
                arg_a: *const Bitmapset,
                arg_prevbit: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        bms_prev_member(arg_a, arg_prevbit)
    })
}
pub unsafe fn bms_hash_value(arg_a: *const Bitmapset) -> uint32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bms_hash_value(arg_a: *const Bitmapset) -> uint32;
        }
        bms_hash_value(arg_a)
    })
}
pub unsafe fn bitmap_hash(arg_key: *const ::std::os::raw::c_void, arg_keysize: Size) -> uint32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bitmap_hash(arg_key: *const ::std::os::raw::c_void, arg_keysize: Size) -> uint32;
        }
        bitmap_hash(arg_key, arg_keysize)
    })
}
pub unsafe fn bitmap_match(
    arg_key1: *const ::std::os::raw::c_void,
    arg_key2: *const ::std::os::raw::c_void,
    arg_keysize: Size,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bitmap_match(
                arg_key1: *const ::std::os::raw::c_void,
                arg_key2: *const ::std::os::raw::c_void,
                arg_keysize: Size,
            ) -> ::std::os::raw::c_int;
        }
        bitmap_match(arg_key1, arg_key2, arg_keysize)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TupleConversionMap {
    pub indesc: TupleDesc,
    pub outdesc: TupleDesc,
    pub attrMap: *mut AttrMap,
    pub invalues: *mut Datum,
    pub inisnull: *mut bool,
    pub outvalues: *mut Datum,
    pub outisnull: *mut bool,
}
impl Default for TupleConversionMap {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn convert_tuples_by_position(
    arg_indesc: TupleDesc,
    arg_outdesc: TupleDesc,
    arg_msg: *const ::std::os::raw::c_char,
) -> *mut TupleConversionMap {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn convert_tuples_by_position(
                arg_indesc: TupleDesc,
                arg_outdesc: TupleDesc,
                arg_msg: *const ::std::os::raw::c_char,
            ) -> *mut TupleConversionMap;
        }
        convert_tuples_by_position(arg_indesc, arg_outdesc, arg_msg)
    })
}
pub unsafe fn convert_tuples_by_name(
    arg_indesc: TupleDesc,
    arg_outdesc: TupleDesc,
) -> *mut TupleConversionMap {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn convert_tuples_by_name(
                arg_indesc: TupleDesc,
                arg_outdesc: TupleDesc,
            ) -> *mut TupleConversionMap;
        }
        convert_tuples_by_name(arg_indesc, arg_outdesc)
    })
}
pub unsafe fn execute_attr_map_tuple(
    arg_tuple: HeapTuple,
    arg_map: *mut TupleConversionMap,
) -> HeapTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn execute_attr_map_tuple(
                arg_tuple: HeapTuple,
                arg_map: *mut TupleConversionMap,
            ) -> HeapTuple;
        }
        execute_attr_map_tuple(arg_tuple, arg_map)
    })
}
pub unsafe fn execute_attr_map_slot(
    arg_attrMap: *mut AttrMap,
    arg_in_slot: *mut TupleTableSlot,
    arg_out_slot: *mut TupleTableSlot,
) -> *mut TupleTableSlot {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn execute_attr_map_slot(
                arg_attrMap: *mut AttrMap,
                arg_in_slot: *mut TupleTableSlot,
                arg_out_slot: *mut TupleTableSlot,
            ) -> *mut TupleTableSlot;
        }
        execute_attr_map_slot(arg_attrMap, arg_in_slot, arg_out_slot)
    })
}
pub unsafe fn execute_attr_map_cols(
    arg_attrMap: *mut AttrMap,
    arg_inbitmap: *mut Bitmapset,
) -> *mut Bitmapset {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn execute_attr_map_cols(
                arg_attrMap: *mut AttrMap,
                arg_inbitmap: *mut Bitmapset,
            ) -> *mut Bitmapset;
        }
        execute_attr_map_cols(arg_attrMap, arg_inbitmap)
    })
}
pub unsafe fn free_conversion_map(arg_map: *mut TupleConversionMap) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn free_conversion_map(arg_map: *mut TupleConversionMap);
        }
        free_conversion_map(arg_map)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *mut ::std::os::raw::c_char,
}
impl Default for tm {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut getdate_err: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
pub unsafe fn asctime(arg_arg1: *const tm) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn asctime(arg_arg1: *const tm) -> *mut ::std::os::raw::c_char;
        }
        asctime(arg_arg1)
    })
}
pub unsafe fn clock() -> clock_t {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn clock() -> clock_t;
        }
        clock()
    })
}
pub unsafe fn ctime(arg_arg1: *const time_t) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ctime(arg_arg1: *const time_t) -> *mut ::std::os::raw::c_char;
        }
        ctime(arg_arg1)
    })
}
pub unsafe fn difftime(arg_arg1: time_t, arg_arg2: time_t) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn difftime(arg_arg1: time_t, arg_arg2: time_t) -> f64;
        }
        difftime(arg_arg1, arg_arg2)
    })
}
pub unsafe fn getdate(arg_arg1: *const ::std::os::raw::c_char) -> *mut tm {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getdate(arg_arg1: *const ::std::os::raw::c_char) -> *mut tm;
        }
        getdate(arg_arg1)
    })
}
pub unsafe fn gmtime(arg_arg1: *const time_t) -> *mut tm {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gmtime(arg_arg1: *const time_t) -> *mut tm;
        }
        gmtime(arg_arg1)
    })
}
pub unsafe fn localtime(arg_arg1: *const time_t) -> *mut tm {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn localtime(arg_arg1: *const time_t) -> *mut tm;
        }
        localtime(arg_arg1)
    })
}
pub unsafe fn mktime(arg_arg1: *mut tm) -> time_t {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn mktime(arg_arg1: *mut tm) -> time_t;
        }
        mktime(arg_arg1)
    })
}
pub unsafe fn strftime(
    arg_arg1: *mut ::std::os::raw::c_char,
    arg_arg2: usize,
    arg_arg3: *const ::std::os::raw::c_char,
    arg_arg4: *const tm,
) -> usize {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strftime(
                arg_arg1: *mut ::std::os::raw::c_char,
                arg_arg2: usize,
                arg_arg3: *const ::std::os::raw::c_char,
                arg_arg4: *const tm,
            ) -> usize;
        }
        strftime(arg_arg1, arg_arg2, arg_arg3, arg_arg4)
    })
}
pub unsafe fn strptime(
    arg_arg1: *const ::std::os::raw::c_char,
    arg_arg2: *const ::std::os::raw::c_char,
    arg_arg3: *mut tm,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strptime(
                arg_arg1: *const ::std::os::raw::c_char,
                arg_arg2: *const ::std::os::raw::c_char,
                arg_arg3: *mut tm,
            ) -> *mut ::std::os::raw::c_char;
        }
        strptime(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn time(arg_arg1: *mut time_t) -> time_t {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn time(arg_arg1: *mut time_t) -> time_t;
        }
        time(arg_arg1)
    })
}
pub unsafe fn tzset() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tzset();
        }
        tzset()
    })
}
pub unsafe fn asctime_r(
    arg_arg1: *const tm,
    arg_arg2: *mut ::std::os::raw::c_char,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn asctime_r(
                arg_arg1: *const tm,
                arg_arg2: *mut ::std::os::raw::c_char,
            ) -> *mut ::std::os::raw::c_char;
        }
        asctime_r(arg_arg1, arg_arg2)
    })
}
pub unsafe fn ctime_r(
    arg_arg1: *const time_t,
    arg_arg2: *mut ::std::os::raw::c_char,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ctime_r(
                arg_arg1: *const time_t,
                arg_arg2: *mut ::std::os::raw::c_char,
            ) -> *mut ::std::os::raw::c_char;
        }
        ctime_r(arg_arg1, arg_arg2)
    })
}
pub unsafe fn gmtime_r(arg_arg1: *const time_t, arg_arg2: *mut tm) -> *mut tm {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gmtime_r(arg_arg1: *const time_t, arg_arg2: *mut tm) -> *mut tm;
        }
        gmtime_r(arg_arg1, arg_arg2)
    })
}
pub unsafe fn localtime_r(arg_arg1: *const time_t, arg_arg2: *mut tm) -> *mut tm {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn localtime_r(arg_arg1: *const time_t, arg_arg2: *mut tm) -> *mut tm;
        }
        localtime_r(arg_arg1, arg_arg2)
    })
}
pub unsafe fn posix2time(arg_arg1: time_t) -> time_t {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn posix2time(arg_arg1: time_t) -> time_t;
        }
        posix2time(arg_arg1)
    })
}
pub unsafe fn tzsetwall() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tzsetwall();
        }
        tzsetwall()
    })
}
pub unsafe fn time2posix(arg_arg1: time_t) -> time_t {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn time2posix(arg_arg1: time_t) -> time_t;
        }
        time2posix(arg_arg1)
    })
}
pub unsafe fn timelocal(arg_arg1: *mut tm) -> time_t {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timelocal(arg_arg1: *mut tm) -> time_t;
        }
        timelocal(arg_arg1)
    })
}
pub unsafe fn timegm(arg_arg1: *mut tm) -> time_t {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timegm(arg_arg1: *mut tm) -> time_t;
        }
        timegm(arg_arg1)
    })
}
pub unsafe fn nanosleep(
    arg___rqtp: *const timespec,
    arg___rmtp: *mut timespec,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn nanosleep(
                arg___rqtp: *const timespec,
                arg___rmtp: *mut timespec,
            ) -> ::std::os::raw::c_int;
        }
        nanosleep(arg___rqtp, arg___rmtp)
    })
}
pub const clockid_t__CLOCK_REALTIME: clockid_t = 0;
pub const clockid_t__CLOCK_MONOTONIC: clockid_t = 6;
pub const clockid_t__CLOCK_MONOTONIC_RAW: clockid_t = 4;
pub const clockid_t__CLOCK_MONOTONIC_RAW_APPROX: clockid_t = 5;
pub const clockid_t__CLOCK_UPTIME_RAW: clockid_t = 8;
pub const clockid_t__CLOCK_UPTIME_RAW_APPROX: clockid_t = 9;
pub const clockid_t__CLOCK_PROCESS_CPUTIME_ID: clockid_t = 12;
pub const clockid_t__CLOCK_THREAD_CPUTIME_ID: clockid_t = 16;
pub type clockid_t = ::std::os::raw::c_uint;
pub unsafe fn clock_getres(
    arg___clock_id: clockid_t,
    arg___res: *mut timespec,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn clock_getres(
                arg___clock_id: clockid_t,
                arg___res: *mut timespec,
            ) -> ::std::os::raw::c_int;
        }
        clock_getres(arg___clock_id, arg___res)
    })
}
pub unsafe fn clock_gettime(
    arg___clock_id: clockid_t,
    arg___tp: *mut timespec,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn clock_gettime(
                arg___clock_id: clockid_t,
                arg___tp: *mut timespec,
            ) -> ::std::os::raw::c_int;
        }
        clock_gettime(arg___clock_id, arg___tp)
    })
}
pub unsafe fn clock_gettime_nsec_np(arg___clock_id: clockid_t) -> __uint64_t {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn clock_gettime_nsec_np(arg___clock_id: clockid_t) -> __uint64_t;
        }
        clock_gettime_nsec_np(arg___clock_id)
    })
}
pub unsafe fn clock_settime(
    arg___clock_id: clockid_t,
    arg___tp: *const timespec,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn clock_settime(
                arg___clock_id: clockid_t,
                arg___tp: *const timespec,
            ) -> ::std::os::raw::c_int;
        }
        clock_settime(arg___clock_id, arg___tp)
    })
}
pub unsafe fn timespec_get(
    arg_ts: *mut timespec,
    arg_base: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timespec_get(
                arg_ts: *mut timespec,
                arg_base: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        timespec_get(arg_ts, arg_base)
    })
}
pub type instr_time = timespec;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct BufferUsage {
    pub shared_blks_hit: ::std::os::raw::c_long,
    pub shared_blks_read: ::std::os::raw::c_long,
    pub shared_blks_dirtied: ::std::os::raw::c_long,
    pub shared_blks_written: ::std::os::raw::c_long,
    pub local_blks_hit: ::std::os::raw::c_long,
    pub local_blks_read: ::std::os::raw::c_long,
    pub local_blks_dirtied: ::std::os::raw::c_long,
    pub local_blks_written: ::std::os::raw::c_long,
    pub temp_blks_read: ::std::os::raw::c_long,
    pub temp_blks_written: ::std::os::raw::c_long,
    pub blk_read_time: instr_time,
    pub blk_write_time: instr_time,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WalUsage {
    pub wal_records: ::std::os::raw::c_long,
    pub wal_fpi: ::std::os::raw::c_long,
    pub wal_bytes: uint64,
}
pub const InstrumentOption_INSTRUMENT_TIMER: InstrumentOption = 1;
pub const InstrumentOption_INSTRUMENT_BUFFERS: InstrumentOption = 2;
pub const InstrumentOption_INSTRUMENT_ROWS: InstrumentOption = 4;
pub const InstrumentOption_INSTRUMENT_WAL: InstrumentOption = 8;
pub const InstrumentOption_INSTRUMENT_ALL: InstrumentOption = 2147483647;
pub type InstrumentOption = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Instrumentation {
    pub need_timer: bool,
    pub need_bufusage: bool,
    pub need_walusage: bool,
    pub running: bool,
    pub starttime: instr_time,
    pub counter: instr_time,
    pub firsttuple: f64,
    pub tuplecount: f64,
    pub bufusage_start: BufferUsage,
    pub walusage_start: WalUsage,
    pub startup: f64,
    pub total: f64,
    pub ntuples: f64,
    pub ntuples2: f64,
    pub nloops: f64,
    pub nfiltered1: f64,
    pub nfiltered2: f64,
    pub bufusage: BufferUsage,
    pub walusage: WalUsage,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct WorkerInstrumentation {
    pub num_workers: ::std::os::raw::c_int,
    pub instrument: __IncompleteArrayField<Instrumentation>,
}
extern "C" {
    pub static mut pgBufferUsage: BufferUsage;
}
extern "C" {
    pub static mut pgWalUsage: WalUsage;
}
pub unsafe fn InstrAlloc(
    arg_n: ::std::os::raw::c_int,
    arg_instrument_options: ::std::os::raw::c_int,
) -> *mut Instrumentation {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InstrAlloc(
                arg_n: ::std::os::raw::c_int,
                arg_instrument_options: ::std::os::raw::c_int,
            ) -> *mut Instrumentation;
        }
        InstrAlloc(arg_n, arg_instrument_options)
    })
}
pub unsafe fn InstrInit(
    arg_instr: *mut Instrumentation,
    arg_instrument_options: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InstrInit(
                arg_instr: *mut Instrumentation,
                arg_instrument_options: ::std::os::raw::c_int,
            );
        }
        InstrInit(arg_instr, arg_instrument_options)
    })
}
pub unsafe fn InstrStartNode(arg_instr: *mut Instrumentation) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InstrStartNode(arg_instr: *mut Instrumentation);
        }
        InstrStartNode(arg_instr)
    })
}
pub unsafe fn InstrStopNode(arg_instr: *mut Instrumentation, arg_nTuples: f64) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InstrStopNode(arg_instr: *mut Instrumentation, arg_nTuples: f64);
        }
        InstrStopNode(arg_instr, arg_nTuples)
    })
}
pub unsafe fn InstrEndLoop(arg_instr: *mut Instrumentation) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InstrEndLoop(arg_instr: *mut Instrumentation);
        }
        InstrEndLoop(arg_instr)
    })
}
pub unsafe fn InstrAggNode(arg_dst: *mut Instrumentation, arg_add: *mut Instrumentation) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InstrAggNode(arg_dst: *mut Instrumentation, arg_add: *mut Instrumentation);
        }
        InstrAggNode(arg_dst, arg_add)
    })
}
pub unsafe fn InstrStartParallelQuery() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InstrStartParallelQuery();
        }
        InstrStartParallelQuery()
    })
}
pub unsafe fn InstrEndParallelQuery(arg_bufusage: *mut BufferUsage, arg_walusage: *mut WalUsage) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InstrEndParallelQuery(arg_bufusage: *mut BufferUsage, arg_walusage: *mut WalUsage);
        }
        InstrEndParallelQuery(arg_bufusage, arg_walusage)
    })
}
pub unsafe fn InstrAccumParallelQuery(arg_bufusage: *mut BufferUsage, arg_walusage: *mut WalUsage) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InstrAccumParallelQuery(arg_bufusage: *mut BufferUsage, arg_walusage: *mut WalUsage);
        }
        InstrAccumParallelQuery(arg_bufusage, arg_walusage)
    })
}
pub unsafe fn BufferUsageAccumDiff(
    arg_dst: *mut BufferUsage,
    arg_add: *const BufferUsage,
    arg_sub: *const BufferUsage,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BufferUsageAccumDiff(
                arg_dst: *mut BufferUsage,
                arg_add: *const BufferUsage,
                arg_sub: *const BufferUsage,
            );
        }
        BufferUsageAccumDiff(arg_dst, arg_add, arg_sub)
    })
}
pub unsafe fn WalUsageAccumDiff(
    arg_dst: *mut WalUsage,
    arg_add: *const WalUsage,
    arg_sub: *const WalUsage,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn WalUsageAccumDiff(
                arg_dst: *mut WalUsage,
                arg_add: *const WalUsage,
                arg_sub: *const WalUsage,
            );
        }
        WalUsageAccumDiff(arg_dst, arg_add, arg_sub)
    })
}
pub type fmNodePtr = *mut Node;
pub type fmAggrefPtr = *mut Aggref;
pub type fmExprContextCallbackFunction = ::std::option::Option<unsafe extern "C" fn(arg: Datum)>;
pub type fmStringInfo = *mut StringInfoData;
pub type FunctionCallInfo = *mut FunctionCallInfoBaseData;
pub type PGFunction =
    ::std::option::Option<unsafe extern "C" fn(fcinfo: FunctionCallInfo) -> Datum>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FmgrInfo {
    pub fn_addr: PGFunction,
    pub fn_oid: Oid,
    pub fn_nargs: ::std::os::raw::c_short,
    pub fn_strict: bool,
    pub fn_retset: bool,
    pub fn_stats: ::std::os::raw::c_uchar,
    pub fn_extra: *mut ::std::os::raw::c_void,
    pub fn_mcxt: MemoryContext,
    pub fn_expr: fmNodePtr,
}
impl Default for FmgrInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct FunctionCallInfoBaseData {
    pub flinfo: *mut FmgrInfo,
    pub context: fmNodePtr,
    pub resultinfo: fmNodePtr,
    pub fncollation: Oid,
    pub isnull: bool,
    pub nargs: ::std::os::raw::c_short,
    pub args: __IncompleteArrayField<NullableDatum>,
}
impl Default for FunctionCallInfoBaseData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn fmgr_info(arg_functionId: Oid, arg_finfo: *mut FmgrInfo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fmgr_info(arg_functionId: Oid, arg_finfo: *mut FmgrInfo);
        }
        fmgr_info(arg_functionId, arg_finfo)
    })
}
pub unsafe fn fmgr_info_cxt(
    arg_functionId: Oid,
    arg_finfo: *mut FmgrInfo,
    arg_mcxt: MemoryContext,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fmgr_info_cxt(
                arg_functionId: Oid,
                arg_finfo: *mut FmgrInfo,
                arg_mcxt: MemoryContext,
            );
        }
        fmgr_info_cxt(arg_functionId, arg_finfo, arg_mcxt)
    })
}
pub unsafe fn fmgr_info_copy(
    arg_dstinfo: *mut FmgrInfo,
    arg_srcinfo: *mut FmgrInfo,
    arg_destcxt: MemoryContext,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fmgr_info_copy(
                arg_dstinfo: *mut FmgrInfo,
                arg_srcinfo: *mut FmgrInfo,
                arg_destcxt: MemoryContext,
            );
        }
        fmgr_info_copy(arg_dstinfo, arg_srcinfo, arg_destcxt)
    })
}
pub unsafe fn fmgr_symbol(
    arg_functionId: Oid,
    arg_mod_: *mut *mut ::std::os::raw::c_char,
    arg_fn_: *mut *mut ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fmgr_symbol(
                arg_functionId: Oid,
                arg_mod_: *mut *mut ::std::os::raw::c_char,
                arg_fn_: *mut *mut ::std::os::raw::c_char,
            );
        }
        fmgr_symbol(arg_functionId, arg_mod_, arg_fn_)
    })
}
pub unsafe fn pg_detoast_datum(arg_datum: *mut varlena) -> *mut varlena {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_detoast_datum(arg_datum: *mut varlena) -> *mut varlena;
        }
        pg_detoast_datum(arg_datum)
    })
}
pub unsafe fn pg_detoast_datum_copy(arg_datum: *mut varlena) -> *mut varlena {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_detoast_datum_copy(arg_datum: *mut varlena) -> *mut varlena;
        }
        pg_detoast_datum_copy(arg_datum)
    })
}
pub unsafe fn pg_detoast_datum_slice(
    arg_datum: *mut varlena,
    arg_first: int32,
    arg_count: int32,
) -> *mut varlena {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_detoast_datum_slice(
                arg_datum: *mut varlena,
                arg_first: int32,
                arg_count: int32,
            ) -> *mut varlena;
        }
        pg_detoast_datum_slice(arg_datum, arg_first, arg_count)
    })
}
pub unsafe fn pg_detoast_datum_packed(arg_datum: *mut varlena) -> *mut varlena {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_detoast_datum_packed(arg_datum: *mut varlena) -> *mut varlena;
        }
        pg_detoast_datum_packed(arg_datum)
    })
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Pg_finfo_record {
    pub api_version: ::std::os::raw::c_int,
}
pub type PGFInfoFunction = ::std::option::Option<unsafe extern "C" fn() -> *const Pg_finfo_record>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Pg_magic_struct {
    pub len: ::std::os::raw::c_int,
    pub version: ::std::os::raw::c_int,
    pub funcmaxargs: ::std::os::raw::c_int,
    pub indexmaxkeys: ::std::os::raw::c_int,
    pub namedatalen: ::std::os::raw::c_int,
    pub float8byval: ::std::os::raw::c_int,
}
pub type PGModuleMagicFunction =
    ::std::option::Option<unsafe extern "C" fn() -> *const Pg_magic_struct>;
pub unsafe fn DirectFunctionCall1Coll(
    arg_func: PGFunction,
    arg_collation: Oid,
    arg_arg1: Datum,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DirectFunctionCall1Coll(
                arg_func: PGFunction,
                arg_collation: Oid,
                arg_arg1: Datum,
            ) -> Datum;
        }
        DirectFunctionCall1Coll(arg_func, arg_collation, arg_arg1)
    })
}
pub unsafe fn DirectFunctionCall2Coll(
    arg_func: PGFunction,
    arg_collation: Oid,
    arg_arg1: Datum,
    arg_arg2: Datum,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DirectFunctionCall2Coll(
                arg_func: PGFunction,
                arg_collation: Oid,
                arg_arg1: Datum,
                arg_arg2: Datum,
            ) -> Datum;
        }
        DirectFunctionCall2Coll(arg_func, arg_collation, arg_arg1, arg_arg2)
    })
}
pub unsafe fn DirectFunctionCall3Coll(
    arg_func: PGFunction,
    arg_collation: Oid,
    arg_arg1: Datum,
    arg_arg2: Datum,
    arg_arg3: Datum,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DirectFunctionCall3Coll(
                arg_func: PGFunction,
                arg_collation: Oid,
                arg_arg1: Datum,
                arg_arg2: Datum,
                arg_arg3: Datum,
            ) -> Datum;
        }
        DirectFunctionCall3Coll(arg_func, arg_collation, arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn DirectFunctionCall4Coll(
    arg_func: PGFunction,
    arg_collation: Oid,
    arg_arg1: Datum,
    arg_arg2: Datum,
    arg_arg3: Datum,
    arg_arg4: Datum,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DirectFunctionCall4Coll(
                arg_func: PGFunction,
                arg_collation: Oid,
                arg_arg1: Datum,
                arg_arg2: Datum,
                arg_arg3: Datum,
                arg_arg4: Datum,
            ) -> Datum;
        }
        DirectFunctionCall4Coll(arg_func, arg_collation, arg_arg1, arg_arg2, arg_arg3, arg_arg4)
    })
}
pub unsafe fn DirectFunctionCall5Coll(
    arg_func: PGFunction,
    arg_collation: Oid,
    arg_arg1: Datum,
    arg_arg2: Datum,
    arg_arg3: Datum,
    arg_arg4: Datum,
    arg_arg5: Datum,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DirectFunctionCall5Coll(
                arg_func: PGFunction,
                arg_collation: Oid,
                arg_arg1: Datum,
                arg_arg2: Datum,
                arg_arg3: Datum,
                arg_arg4: Datum,
                arg_arg5: Datum,
            ) -> Datum;
        }
        DirectFunctionCall5Coll(
            arg_func,
            arg_collation,
            arg_arg1,
            arg_arg2,
            arg_arg3,
            arg_arg4,
            arg_arg5,
        )
    })
}
pub unsafe fn DirectFunctionCall6Coll(
    arg_func: PGFunction,
    arg_collation: Oid,
    arg_arg1: Datum,
    arg_arg2: Datum,
    arg_arg3: Datum,
    arg_arg4: Datum,
    arg_arg5: Datum,
    arg_arg6: Datum,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DirectFunctionCall6Coll(
                arg_func: PGFunction,
                arg_collation: Oid,
                arg_arg1: Datum,
                arg_arg2: Datum,
                arg_arg3: Datum,
                arg_arg4: Datum,
                arg_arg5: Datum,
                arg_arg6: Datum,
            ) -> Datum;
        }
        DirectFunctionCall6Coll(
            arg_func,
            arg_collation,
            arg_arg1,
            arg_arg2,
            arg_arg3,
            arg_arg4,
            arg_arg5,
            arg_arg6,
        )
    })
}
pub unsafe fn DirectFunctionCall7Coll(
    arg_func: PGFunction,
    arg_collation: Oid,
    arg_arg1: Datum,
    arg_arg2: Datum,
    arg_arg3: Datum,
    arg_arg4: Datum,
    arg_arg5: Datum,
    arg_arg6: Datum,
    arg_arg7: Datum,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DirectFunctionCall7Coll(
                arg_func: PGFunction,
                arg_collation: Oid,
                arg_arg1: Datum,
                arg_arg2: Datum,
                arg_arg3: Datum,
                arg_arg4: Datum,
                arg_arg5: Datum,
                arg_arg6: Datum,
                arg_arg7: Datum,
            ) -> Datum;
        }
        DirectFunctionCall7Coll(
            arg_func,
            arg_collation,
            arg_arg1,
            arg_arg2,
            arg_arg3,
            arg_arg4,
            arg_arg5,
            arg_arg6,
            arg_arg7,
        )
    })
}
pub unsafe fn DirectFunctionCall8Coll(
    arg_func: PGFunction,
    arg_collation: Oid,
    arg_arg1: Datum,
    arg_arg2: Datum,
    arg_arg3: Datum,
    arg_arg4: Datum,
    arg_arg5: Datum,
    arg_arg6: Datum,
    arg_arg7: Datum,
    arg_arg8: Datum,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DirectFunctionCall8Coll(
                arg_func: PGFunction,
                arg_collation: Oid,
                arg_arg1: Datum,
                arg_arg2: Datum,
                arg_arg3: Datum,
                arg_arg4: Datum,
                arg_arg5: Datum,
                arg_arg6: Datum,
                arg_arg7: Datum,
                arg_arg8: Datum,
            ) -> Datum;
        }
        DirectFunctionCall8Coll(
            arg_func,
            arg_collation,
            arg_arg1,
            arg_arg2,
            arg_arg3,
            arg_arg4,
            arg_arg5,
            arg_arg6,
            arg_arg7,
            arg_arg8,
        )
    })
}
pub unsafe fn DirectFunctionCall9Coll(
    arg_func: PGFunction,
    arg_collation: Oid,
    arg_arg1: Datum,
    arg_arg2: Datum,
    arg_arg3: Datum,
    arg_arg4: Datum,
    arg_arg5: Datum,
    arg_arg6: Datum,
    arg_arg7: Datum,
    arg_arg8: Datum,
    arg_arg9: Datum,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DirectFunctionCall9Coll(
                arg_func: PGFunction,
                arg_collation: Oid,
                arg_arg1: Datum,
                arg_arg2: Datum,
                arg_arg3: Datum,
                arg_arg4: Datum,
                arg_arg5: Datum,
                arg_arg6: Datum,
                arg_arg7: Datum,
                arg_arg8: Datum,
                arg_arg9: Datum,
            ) -> Datum;
        }
        DirectFunctionCall9Coll(
            arg_func,
            arg_collation,
            arg_arg1,
            arg_arg2,
            arg_arg3,
            arg_arg4,
            arg_arg5,
            arg_arg6,
            arg_arg7,
            arg_arg8,
            arg_arg9,
        )
    })
}
pub unsafe fn CallerFInfoFunctionCall1(
    arg_func: PGFunction,
    arg_flinfo: *mut FmgrInfo,
    arg_collation: Oid,
    arg_arg1: Datum,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CallerFInfoFunctionCall1(
                arg_func: PGFunction,
                arg_flinfo: *mut FmgrInfo,
                arg_collation: Oid,
                arg_arg1: Datum,
            ) -> Datum;
        }
        CallerFInfoFunctionCall1(arg_func, arg_flinfo, arg_collation, arg_arg1)
    })
}
pub unsafe fn CallerFInfoFunctionCall2(
    arg_func: PGFunction,
    arg_flinfo: *mut FmgrInfo,
    arg_collation: Oid,
    arg_arg1: Datum,
    arg_arg2: Datum,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CallerFInfoFunctionCall2(
                arg_func: PGFunction,
                arg_flinfo: *mut FmgrInfo,
                arg_collation: Oid,
                arg_arg1: Datum,
                arg_arg2: Datum,
            ) -> Datum;
        }
        CallerFInfoFunctionCall2(arg_func, arg_flinfo, arg_collation, arg_arg1, arg_arg2)
    })
}
pub unsafe fn FunctionCall0Coll(arg_flinfo: *mut FmgrInfo, arg_collation: Oid) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FunctionCall0Coll(arg_flinfo: *mut FmgrInfo, arg_collation: Oid) -> Datum;
        }
        FunctionCall0Coll(arg_flinfo, arg_collation)
    })
}
pub unsafe fn FunctionCall1Coll(
    arg_flinfo: *mut FmgrInfo,
    arg_collation: Oid,
    arg_arg1: Datum,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FunctionCall1Coll(
                arg_flinfo: *mut FmgrInfo,
                arg_collation: Oid,
                arg_arg1: Datum,
            ) -> Datum;
        }
        FunctionCall1Coll(arg_flinfo, arg_collation, arg_arg1)
    })
}
pub unsafe fn FunctionCall2Coll(
    arg_flinfo: *mut FmgrInfo,
    arg_collation: Oid,
    arg_arg1: Datum,
    arg_arg2: Datum,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FunctionCall2Coll(
                arg_flinfo: *mut FmgrInfo,
                arg_collation: Oid,
                arg_arg1: Datum,
                arg_arg2: Datum,
            ) -> Datum;
        }
        FunctionCall2Coll(arg_flinfo, arg_collation, arg_arg1, arg_arg2)
    })
}
pub unsafe fn FunctionCall3Coll(
    arg_flinfo: *mut FmgrInfo,
    arg_collation: Oid,
    arg_arg1: Datum,
    arg_arg2: Datum,
    arg_arg3: Datum,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FunctionCall3Coll(
                arg_flinfo: *mut FmgrInfo,
                arg_collation: Oid,
                arg_arg1: Datum,
                arg_arg2: Datum,
                arg_arg3: Datum,
            ) -> Datum;
        }
        FunctionCall3Coll(arg_flinfo, arg_collation, arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn FunctionCall4Coll(
    arg_flinfo: *mut FmgrInfo,
    arg_collation: Oid,
    arg_arg1: Datum,
    arg_arg2: Datum,
    arg_arg3: Datum,
    arg_arg4: Datum,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FunctionCall4Coll(
                arg_flinfo: *mut FmgrInfo,
                arg_collation: Oid,
                arg_arg1: Datum,
                arg_arg2: Datum,
                arg_arg3: Datum,
                arg_arg4: Datum,
            ) -> Datum;
        }
        FunctionCall4Coll(arg_flinfo, arg_collation, arg_arg1, arg_arg2, arg_arg3, arg_arg4)
    })
}
pub unsafe fn FunctionCall5Coll(
    arg_flinfo: *mut FmgrInfo,
    arg_collation: Oid,
    arg_arg1: Datum,
    arg_arg2: Datum,
    arg_arg3: Datum,
    arg_arg4: Datum,
    arg_arg5: Datum,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FunctionCall5Coll(
                arg_flinfo: *mut FmgrInfo,
                arg_collation: Oid,
                arg_arg1: Datum,
                arg_arg2: Datum,
                arg_arg3: Datum,
                arg_arg4: Datum,
                arg_arg5: Datum,
            ) -> Datum;
        }
        FunctionCall5Coll(
            arg_flinfo,
            arg_collation,
            arg_arg1,
            arg_arg2,
            arg_arg3,
            arg_arg4,
            arg_arg5,
        )
    })
}
pub unsafe fn FunctionCall6Coll(
    arg_flinfo: *mut FmgrInfo,
    arg_collation: Oid,
    arg_arg1: Datum,
    arg_arg2: Datum,
    arg_arg3: Datum,
    arg_arg4: Datum,
    arg_arg5: Datum,
    arg_arg6: Datum,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FunctionCall6Coll(
                arg_flinfo: *mut FmgrInfo,
                arg_collation: Oid,
                arg_arg1: Datum,
                arg_arg2: Datum,
                arg_arg3: Datum,
                arg_arg4: Datum,
                arg_arg5: Datum,
                arg_arg6: Datum,
            ) -> Datum;
        }
        FunctionCall6Coll(
            arg_flinfo,
            arg_collation,
            arg_arg1,
            arg_arg2,
            arg_arg3,
            arg_arg4,
            arg_arg5,
            arg_arg6,
        )
    })
}
pub unsafe fn FunctionCall7Coll(
    arg_flinfo: *mut FmgrInfo,
    arg_collation: Oid,
    arg_arg1: Datum,
    arg_arg2: Datum,
    arg_arg3: Datum,
    arg_arg4: Datum,
    arg_arg5: Datum,
    arg_arg6: Datum,
    arg_arg7: Datum,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FunctionCall7Coll(
                arg_flinfo: *mut FmgrInfo,
                arg_collation: Oid,
                arg_arg1: Datum,
                arg_arg2: Datum,
                arg_arg3: Datum,
                arg_arg4: Datum,
                arg_arg5: Datum,
                arg_arg6: Datum,
                arg_arg7: Datum,
            ) -> Datum;
        }
        FunctionCall7Coll(
            arg_flinfo,
            arg_collation,
            arg_arg1,
            arg_arg2,
            arg_arg3,
            arg_arg4,
            arg_arg5,
            arg_arg6,
            arg_arg7,
        )
    })
}
pub unsafe fn FunctionCall8Coll(
    arg_flinfo: *mut FmgrInfo,
    arg_collation: Oid,
    arg_arg1: Datum,
    arg_arg2: Datum,
    arg_arg3: Datum,
    arg_arg4: Datum,
    arg_arg5: Datum,
    arg_arg6: Datum,
    arg_arg7: Datum,
    arg_arg8: Datum,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FunctionCall8Coll(
                arg_flinfo: *mut FmgrInfo,
                arg_collation: Oid,
                arg_arg1: Datum,
                arg_arg2: Datum,
                arg_arg3: Datum,
                arg_arg4: Datum,
                arg_arg5: Datum,
                arg_arg6: Datum,
                arg_arg7: Datum,
                arg_arg8: Datum,
            ) -> Datum;
        }
        FunctionCall8Coll(
            arg_flinfo,
            arg_collation,
            arg_arg1,
            arg_arg2,
            arg_arg3,
            arg_arg4,
            arg_arg5,
            arg_arg6,
            arg_arg7,
            arg_arg8,
        )
    })
}
pub unsafe fn FunctionCall9Coll(
    arg_flinfo: *mut FmgrInfo,
    arg_collation: Oid,
    arg_arg1: Datum,
    arg_arg2: Datum,
    arg_arg3: Datum,
    arg_arg4: Datum,
    arg_arg5: Datum,
    arg_arg6: Datum,
    arg_arg7: Datum,
    arg_arg8: Datum,
    arg_arg9: Datum,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FunctionCall9Coll(
                arg_flinfo: *mut FmgrInfo,
                arg_collation: Oid,
                arg_arg1: Datum,
                arg_arg2: Datum,
                arg_arg3: Datum,
                arg_arg4: Datum,
                arg_arg5: Datum,
                arg_arg6: Datum,
                arg_arg7: Datum,
                arg_arg8: Datum,
                arg_arg9: Datum,
            ) -> Datum;
        }
        FunctionCall9Coll(
            arg_flinfo,
            arg_collation,
            arg_arg1,
            arg_arg2,
            arg_arg3,
            arg_arg4,
            arg_arg5,
            arg_arg6,
            arg_arg7,
            arg_arg8,
            arg_arg9,
        )
    })
}
pub unsafe fn OidFunctionCall0Coll(arg_functionId: Oid, arg_collation: Oid) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn OidFunctionCall0Coll(arg_functionId: Oid, arg_collation: Oid) -> Datum;
        }
        OidFunctionCall0Coll(arg_functionId, arg_collation)
    })
}
pub unsafe fn OidFunctionCall1Coll(
    arg_functionId: Oid,
    arg_collation: Oid,
    arg_arg1: Datum,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn OidFunctionCall1Coll(
                arg_functionId: Oid,
                arg_collation: Oid,
                arg_arg1: Datum,
            ) -> Datum;
        }
        OidFunctionCall1Coll(arg_functionId, arg_collation, arg_arg1)
    })
}
pub unsafe fn OidFunctionCall2Coll(
    arg_functionId: Oid,
    arg_collation: Oid,
    arg_arg1: Datum,
    arg_arg2: Datum,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn OidFunctionCall2Coll(
                arg_functionId: Oid,
                arg_collation: Oid,
                arg_arg1: Datum,
                arg_arg2: Datum,
            ) -> Datum;
        }
        OidFunctionCall2Coll(arg_functionId, arg_collation, arg_arg1, arg_arg2)
    })
}
pub unsafe fn OidFunctionCall3Coll(
    arg_functionId: Oid,
    arg_collation: Oid,
    arg_arg1: Datum,
    arg_arg2: Datum,
    arg_arg3: Datum,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn OidFunctionCall3Coll(
                arg_functionId: Oid,
                arg_collation: Oid,
                arg_arg1: Datum,
                arg_arg2: Datum,
                arg_arg3: Datum,
            ) -> Datum;
        }
        OidFunctionCall3Coll(arg_functionId, arg_collation, arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn OidFunctionCall4Coll(
    arg_functionId: Oid,
    arg_collation: Oid,
    arg_arg1: Datum,
    arg_arg2: Datum,
    arg_arg3: Datum,
    arg_arg4: Datum,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn OidFunctionCall4Coll(
                arg_functionId: Oid,
                arg_collation: Oid,
                arg_arg1: Datum,
                arg_arg2: Datum,
                arg_arg3: Datum,
                arg_arg4: Datum,
            ) -> Datum;
        }
        OidFunctionCall4Coll(arg_functionId, arg_collation, arg_arg1, arg_arg2, arg_arg3, arg_arg4)
    })
}
pub unsafe fn OidFunctionCall5Coll(
    arg_functionId: Oid,
    arg_collation: Oid,
    arg_arg1: Datum,
    arg_arg2: Datum,
    arg_arg3: Datum,
    arg_arg4: Datum,
    arg_arg5: Datum,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn OidFunctionCall5Coll(
                arg_functionId: Oid,
                arg_collation: Oid,
                arg_arg1: Datum,
                arg_arg2: Datum,
                arg_arg3: Datum,
                arg_arg4: Datum,
                arg_arg5: Datum,
            ) -> Datum;
        }
        OidFunctionCall5Coll(
            arg_functionId,
            arg_collation,
            arg_arg1,
            arg_arg2,
            arg_arg3,
            arg_arg4,
            arg_arg5,
        )
    })
}
pub unsafe fn OidFunctionCall6Coll(
    arg_functionId: Oid,
    arg_collation: Oid,
    arg_arg1: Datum,
    arg_arg2: Datum,
    arg_arg3: Datum,
    arg_arg4: Datum,
    arg_arg5: Datum,
    arg_arg6: Datum,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn OidFunctionCall6Coll(
                arg_functionId: Oid,
                arg_collation: Oid,
                arg_arg1: Datum,
                arg_arg2: Datum,
                arg_arg3: Datum,
                arg_arg4: Datum,
                arg_arg5: Datum,
                arg_arg6: Datum,
            ) -> Datum;
        }
        OidFunctionCall6Coll(
            arg_functionId,
            arg_collation,
            arg_arg1,
            arg_arg2,
            arg_arg3,
            arg_arg4,
            arg_arg5,
            arg_arg6,
        )
    })
}
pub unsafe fn OidFunctionCall7Coll(
    arg_functionId: Oid,
    arg_collation: Oid,
    arg_arg1: Datum,
    arg_arg2: Datum,
    arg_arg3: Datum,
    arg_arg4: Datum,
    arg_arg5: Datum,
    arg_arg6: Datum,
    arg_arg7: Datum,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn OidFunctionCall7Coll(
                arg_functionId: Oid,
                arg_collation: Oid,
                arg_arg1: Datum,
                arg_arg2: Datum,
                arg_arg3: Datum,
                arg_arg4: Datum,
                arg_arg5: Datum,
                arg_arg6: Datum,
                arg_arg7: Datum,
            ) -> Datum;
        }
        OidFunctionCall7Coll(
            arg_functionId,
            arg_collation,
            arg_arg1,
            arg_arg2,
            arg_arg3,
            arg_arg4,
            arg_arg5,
            arg_arg6,
            arg_arg7,
        )
    })
}
pub unsafe fn OidFunctionCall8Coll(
    arg_functionId: Oid,
    arg_collation: Oid,
    arg_arg1: Datum,
    arg_arg2: Datum,
    arg_arg3: Datum,
    arg_arg4: Datum,
    arg_arg5: Datum,
    arg_arg6: Datum,
    arg_arg7: Datum,
    arg_arg8: Datum,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn OidFunctionCall8Coll(
                arg_functionId: Oid,
                arg_collation: Oid,
                arg_arg1: Datum,
                arg_arg2: Datum,
                arg_arg3: Datum,
                arg_arg4: Datum,
                arg_arg5: Datum,
                arg_arg6: Datum,
                arg_arg7: Datum,
                arg_arg8: Datum,
            ) -> Datum;
        }
        OidFunctionCall8Coll(
            arg_functionId,
            arg_collation,
            arg_arg1,
            arg_arg2,
            arg_arg3,
            arg_arg4,
            arg_arg5,
            arg_arg6,
            arg_arg7,
            arg_arg8,
        )
    })
}
pub unsafe fn OidFunctionCall9Coll(
    arg_functionId: Oid,
    arg_collation: Oid,
    arg_arg1: Datum,
    arg_arg2: Datum,
    arg_arg3: Datum,
    arg_arg4: Datum,
    arg_arg5: Datum,
    arg_arg6: Datum,
    arg_arg7: Datum,
    arg_arg8: Datum,
    arg_arg9: Datum,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn OidFunctionCall9Coll(
                arg_functionId: Oid,
                arg_collation: Oid,
                arg_arg1: Datum,
                arg_arg2: Datum,
                arg_arg3: Datum,
                arg_arg4: Datum,
                arg_arg5: Datum,
                arg_arg6: Datum,
                arg_arg7: Datum,
                arg_arg8: Datum,
                arg_arg9: Datum,
            ) -> Datum;
        }
        OidFunctionCall9Coll(
            arg_functionId,
            arg_collation,
            arg_arg1,
            arg_arg2,
            arg_arg3,
            arg_arg4,
            arg_arg5,
            arg_arg6,
            arg_arg7,
            arg_arg8,
            arg_arg9,
        )
    })
}
pub unsafe fn InputFunctionCall(
    arg_flinfo: *mut FmgrInfo,
    arg_str_: *mut ::std::os::raw::c_char,
    arg_typioparam: Oid,
    arg_typmod: int32,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InputFunctionCall(
                arg_flinfo: *mut FmgrInfo,
                arg_str_: *mut ::std::os::raw::c_char,
                arg_typioparam: Oid,
                arg_typmod: int32,
            ) -> Datum;
        }
        InputFunctionCall(arg_flinfo, arg_str_, arg_typioparam, arg_typmod)
    })
}
pub unsafe fn OidInputFunctionCall(
    arg_functionId: Oid,
    arg_str_: *mut ::std::os::raw::c_char,
    arg_typioparam: Oid,
    arg_typmod: int32,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn OidInputFunctionCall(
                arg_functionId: Oid,
                arg_str_: *mut ::std::os::raw::c_char,
                arg_typioparam: Oid,
                arg_typmod: int32,
            ) -> Datum;
        }
        OidInputFunctionCall(arg_functionId, arg_str_, arg_typioparam, arg_typmod)
    })
}
pub unsafe fn OutputFunctionCall(
    arg_flinfo: *mut FmgrInfo,
    arg_val: Datum,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn OutputFunctionCall(
                arg_flinfo: *mut FmgrInfo,
                arg_val: Datum,
            ) -> *mut ::std::os::raw::c_char;
        }
        OutputFunctionCall(arg_flinfo, arg_val)
    })
}
pub unsafe fn OidOutputFunctionCall(
    arg_functionId: Oid,
    arg_val: Datum,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn OidOutputFunctionCall(
                arg_functionId: Oid,
                arg_val: Datum,
            ) -> *mut ::std::os::raw::c_char;
        }
        OidOutputFunctionCall(arg_functionId, arg_val)
    })
}
pub unsafe fn ReceiveFunctionCall(
    arg_flinfo: *mut FmgrInfo,
    arg_buf: fmStringInfo,
    arg_typioparam: Oid,
    arg_typmod: int32,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReceiveFunctionCall(
                arg_flinfo: *mut FmgrInfo,
                arg_buf: fmStringInfo,
                arg_typioparam: Oid,
                arg_typmod: int32,
            ) -> Datum;
        }
        ReceiveFunctionCall(arg_flinfo, arg_buf, arg_typioparam, arg_typmod)
    })
}
pub unsafe fn OidReceiveFunctionCall(
    arg_functionId: Oid,
    arg_buf: fmStringInfo,
    arg_typioparam: Oid,
    arg_typmod: int32,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn OidReceiveFunctionCall(
                arg_functionId: Oid,
                arg_buf: fmStringInfo,
                arg_typioparam: Oid,
                arg_typmod: int32,
            ) -> Datum;
        }
        OidReceiveFunctionCall(arg_functionId, arg_buf, arg_typioparam, arg_typmod)
    })
}
pub unsafe fn SendFunctionCall(arg_flinfo: *mut FmgrInfo, arg_val: Datum) -> *mut bytea {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SendFunctionCall(arg_flinfo: *mut FmgrInfo, arg_val: Datum) -> *mut bytea;
        }
        SendFunctionCall(arg_flinfo, arg_val)
    })
}
pub unsafe fn OidSendFunctionCall(arg_functionId: Oid, arg_val: Datum) -> *mut bytea {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn OidSendFunctionCall(arg_functionId: Oid, arg_val: Datum) -> *mut bytea;
        }
        OidSendFunctionCall(arg_functionId, arg_val)
    })
}
pub unsafe fn fetch_finfo_record(
    arg_filehandle: *mut ::std::os::raw::c_void,
    arg_funcname: *const ::std::os::raw::c_char,
) -> *const Pg_finfo_record {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fetch_finfo_record(
                arg_filehandle: *mut ::std::os::raw::c_void,
                arg_funcname: *const ::std::os::raw::c_char,
            ) -> *const Pg_finfo_record;
        }
        fetch_finfo_record(arg_filehandle, arg_funcname)
    })
}
pub unsafe fn clear_external_function_hash(arg_filehandle: *mut ::std::os::raw::c_void) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn clear_external_function_hash(arg_filehandle: *mut ::std::os::raw::c_void);
        }
        clear_external_function_hash(arg_filehandle)
    })
}
pub unsafe fn fmgr_internal_function(arg_proname: *const ::std::os::raw::c_char) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fmgr_internal_function(arg_proname: *const ::std::os::raw::c_char) -> Oid;
        }
        fmgr_internal_function(arg_proname)
    })
}
pub unsafe fn get_fn_expr_rettype(arg_flinfo: *mut FmgrInfo) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_fn_expr_rettype(arg_flinfo: *mut FmgrInfo) -> Oid;
        }
        get_fn_expr_rettype(arg_flinfo)
    })
}
pub unsafe fn get_fn_expr_argtype(
    arg_flinfo: *mut FmgrInfo,
    arg_argnum: ::std::os::raw::c_int,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_fn_expr_argtype(
                arg_flinfo: *mut FmgrInfo,
                arg_argnum: ::std::os::raw::c_int,
            ) -> Oid;
        }
        get_fn_expr_argtype(arg_flinfo, arg_argnum)
    })
}
pub unsafe fn get_call_expr_argtype(arg_expr: fmNodePtr, arg_argnum: ::std::os::raw::c_int) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_call_expr_argtype(arg_expr: fmNodePtr, arg_argnum: ::std::os::raw::c_int)
                -> Oid;
        }
        get_call_expr_argtype(arg_expr, arg_argnum)
    })
}
pub unsafe fn get_fn_expr_arg_stable(
    arg_flinfo: *mut FmgrInfo,
    arg_argnum: ::std::os::raw::c_int,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_fn_expr_arg_stable(
                arg_flinfo: *mut FmgrInfo,
                arg_argnum: ::std::os::raw::c_int,
            ) -> bool;
        }
        get_fn_expr_arg_stable(arg_flinfo, arg_argnum)
    })
}
pub unsafe fn get_call_expr_arg_stable(
    arg_expr: fmNodePtr,
    arg_argnum: ::std::os::raw::c_int,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_call_expr_arg_stable(
                arg_expr: fmNodePtr,
                arg_argnum: ::std::os::raw::c_int,
            ) -> bool;
        }
        get_call_expr_arg_stable(arg_expr, arg_argnum)
    })
}
pub unsafe fn get_fn_expr_variadic(arg_flinfo: *mut FmgrInfo) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_fn_expr_variadic(arg_flinfo: *mut FmgrInfo) -> bool;
        }
        get_fn_expr_variadic(arg_flinfo)
    })
}
pub unsafe fn get_fn_opclass_options(arg_flinfo: *mut FmgrInfo) -> *mut bytea {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_fn_opclass_options(arg_flinfo: *mut FmgrInfo) -> *mut bytea;
        }
        get_fn_opclass_options(arg_flinfo)
    })
}
pub unsafe fn has_fn_opclass_options(arg_flinfo: *mut FmgrInfo) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_fn_opclass_options(arg_flinfo: *mut FmgrInfo) -> bool;
        }
        has_fn_opclass_options(arg_flinfo)
    })
}
pub unsafe fn set_fn_opclass_options(arg_flinfo: *mut FmgrInfo, arg_options: *mut bytea) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn set_fn_opclass_options(arg_flinfo: *mut FmgrInfo, arg_options: *mut bytea);
        }
        set_fn_opclass_options(arg_flinfo, arg_options)
    })
}
pub unsafe fn CheckFunctionValidatorAccess(arg_validatorOid: Oid, arg_functionOid: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CheckFunctionValidatorAccess(arg_validatorOid: Oid, arg_functionOid: Oid) -> bool;
        }
        CheckFunctionValidatorAccess(arg_validatorOid, arg_functionOid)
    })
}
extern "C" {
    pub static mut Dynamic_library_path: *mut ::std::os::raw::c_char;
}
pub unsafe fn load_external_function(
    arg_filename: *const ::std::os::raw::c_char,
    arg_funcname: *const ::std::os::raw::c_char,
    arg_signalNotFound: bool,
    arg_filehandle: *mut *mut ::std::os::raw::c_void,
) -> PGFunction {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn load_external_function(
                arg_filename: *const ::std::os::raw::c_char,
                arg_funcname: *const ::std::os::raw::c_char,
                arg_signalNotFound: bool,
                arg_filehandle: *mut *mut ::std::os::raw::c_void,
            ) -> PGFunction;
        }
        load_external_function(arg_filename, arg_funcname, arg_signalNotFound, arg_filehandle)
    })
}
pub unsafe fn lookup_external_function(
    arg_filehandle: *mut ::std::os::raw::c_void,
    arg_funcname: *const ::std::os::raw::c_char,
) -> PGFunction {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lookup_external_function(
                arg_filehandle: *mut ::std::os::raw::c_void,
                arg_funcname: *const ::std::os::raw::c_char,
            ) -> PGFunction;
        }
        lookup_external_function(arg_filehandle, arg_funcname)
    })
}
pub unsafe fn load_file(arg_filename: *const ::std::os::raw::c_char, arg_restricted: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn load_file(arg_filename: *const ::std::os::raw::c_char, arg_restricted: bool);
        }
        load_file(arg_filename, arg_restricted)
    })
}
pub unsafe fn find_rendezvous_variable(
    arg_varName: *const ::std::os::raw::c_char,
) -> *mut *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn find_rendezvous_variable(
                arg_varName: *const ::std::os::raw::c_char,
            ) -> *mut *mut ::std::os::raw::c_void;
        }
        find_rendezvous_variable(arg_varName)
    })
}
pub unsafe fn EstimateLibraryStateSpace() -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EstimateLibraryStateSpace() -> Size;
        }
        EstimateLibraryStateSpace()
    })
}
pub unsafe fn SerializeLibraryState(
    arg_maxsize: Size,
    arg_start_address: *mut ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SerializeLibraryState(
                arg_maxsize: Size,
                arg_start_address: *mut ::std::os::raw::c_char,
            );
        }
        SerializeLibraryState(arg_maxsize, arg_start_address)
    })
}
pub unsafe fn RestoreLibraryState(arg_start_address: *mut ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RestoreLibraryState(arg_start_address: *mut ::std::os::raw::c_char);
        }
        RestoreLibraryState(arg_start_address)
    })
}
pub unsafe fn AggCheckCallContext(
    arg_fcinfo: FunctionCallInfo,
    arg_aggcontext: *mut MemoryContext,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AggCheckCallContext(
                arg_fcinfo: FunctionCallInfo,
                arg_aggcontext: *mut MemoryContext,
            ) -> ::std::os::raw::c_int;
        }
        AggCheckCallContext(arg_fcinfo, arg_aggcontext)
    })
}
pub unsafe fn AggGetAggref(arg_fcinfo: FunctionCallInfo) -> fmAggrefPtr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AggGetAggref(arg_fcinfo: FunctionCallInfo) -> fmAggrefPtr;
        }
        AggGetAggref(arg_fcinfo)
    })
}
pub unsafe fn AggGetTempMemoryContext(arg_fcinfo: FunctionCallInfo) -> MemoryContext {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AggGetTempMemoryContext(arg_fcinfo: FunctionCallInfo) -> MemoryContext;
        }
        AggGetTempMemoryContext(arg_fcinfo)
    })
}
pub unsafe fn AggStateIsShared(arg_fcinfo: FunctionCallInfo) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AggStateIsShared(arg_fcinfo: FunctionCallInfo) -> bool;
        }
        AggStateIsShared(arg_fcinfo)
    })
}
pub unsafe fn AggRegisterCallback(
    arg_fcinfo: FunctionCallInfo,
    arg_func: fmExprContextCallbackFunction,
    arg_arg: Datum,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AggRegisterCallback(
                arg_fcinfo: FunctionCallInfo,
                arg_func: fmExprContextCallbackFunction,
                arg_arg: Datum,
            );
        }
        AggRegisterCallback(arg_fcinfo, arg_func, arg_arg)
    })
}
pub const FmgrHookEventType_FHET_START: FmgrHookEventType = 0;
pub const FmgrHookEventType_FHET_END: FmgrHookEventType = 1;
pub const FmgrHookEventType_FHET_ABORT: FmgrHookEventType = 2;
pub type FmgrHookEventType = ::std::os::raw::c_uint;
pub type needs_fmgr_hook_type = ::std::option::Option<unsafe extern "C" fn(fn_oid: Oid) -> bool>;
pub type fmgr_hook_type = ::std::option::Option<
    unsafe extern "C" fn(event: FmgrHookEventType, flinfo: *mut FmgrInfo, arg: *mut Datum),
>;
extern "C" {
    pub static mut needs_fmgr_hook: needs_fmgr_hook_type;
}
extern "C" {
    pub static mut fmgr_hook: fmgr_hook_type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StringInfoData {
    pub data: *mut ::std::os::raw::c_char,
    pub len: ::std::os::raw::c_int,
    pub maxlen: ::std::os::raw::c_int,
    pub cursor: ::std::os::raw::c_int,
}
impl Default for StringInfoData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type StringInfo = *mut StringInfoData;
pub unsafe fn makeStringInfo() -> StringInfo {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeStringInfo() -> StringInfo;
        }
        makeStringInfo()
    })
}
pub unsafe fn initStringInfo(arg_str_: StringInfo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn initStringInfo(arg_str_: StringInfo);
        }
        initStringInfo(arg_str_)
    })
}
pub unsafe fn resetStringInfo(arg_str_: StringInfo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn resetStringInfo(arg_str_: StringInfo);
        }
        resetStringInfo(arg_str_)
    })
}
pub unsafe fn appendStringInfo(arg_str_: StringInfo, arg_fmt: *const ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn appendStringInfo(arg_str_: StringInfo, arg_fmt: *const ::std::os::raw::c_char);
        }
        appendStringInfo(arg_str_, arg_fmt)
    })
}
pub unsafe fn appendStringInfoString(arg_str_: StringInfo, arg_s: *const ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn appendStringInfoString(arg_str_: StringInfo, arg_s: *const ::std::os::raw::c_char);
        }
        appendStringInfoString(arg_str_, arg_s)
    })
}
pub unsafe fn appendStringInfoChar(arg_str_: StringInfo, arg_ch: ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn appendStringInfoChar(arg_str_: StringInfo, arg_ch: ::std::os::raw::c_char);
        }
        appendStringInfoChar(arg_str_, arg_ch)
    })
}
pub unsafe fn appendStringInfoSpaces(arg_str_: StringInfo, arg_count: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn appendStringInfoSpaces(arg_str_: StringInfo, arg_count: ::std::os::raw::c_int);
        }
        appendStringInfoSpaces(arg_str_, arg_count)
    })
}
pub unsafe fn appendBinaryStringInfo(
    arg_str_: StringInfo,
    arg_data: *const ::std::os::raw::c_char,
    arg_datalen: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn appendBinaryStringInfo(
                arg_str_: StringInfo,
                arg_data: *const ::std::os::raw::c_char,
                arg_datalen: ::std::os::raw::c_int,
            );
        }
        appendBinaryStringInfo(arg_str_, arg_data, arg_datalen)
    })
}
pub unsafe fn appendBinaryStringInfoNT(
    arg_str_: StringInfo,
    arg_data: *const ::std::os::raw::c_char,
    arg_datalen: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn appendBinaryStringInfoNT(
                arg_str_: StringInfo,
                arg_data: *const ::std::os::raw::c_char,
                arg_datalen: ::std::os::raw::c_int,
            );
        }
        appendBinaryStringInfoNT(arg_str_, arg_data, arg_datalen)
    })
}
pub unsafe fn enlargeStringInfo(arg_str_: StringInfo, arg_needed: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn enlargeStringInfo(arg_str_: StringInfo, arg_needed: ::std::os::raw::c_int);
        }
        enlargeStringInfo(arg_str_, arg_needed)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pairingheap_node {
    pub first_child: *mut pairingheap_node,
    pub next_sibling: *mut pairingheap_node,
    pub prev_or_parent: *mut pairingheap_node,
}
impl Default for pairingheap_node {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pairingheap_comparator = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const pairingheap_node,
        b: *const pairingheap_node,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pairingheap {
    pub ph_compare: pairingheap_comparator,
    pub ph_arg: *mut ::std::os::raw::c_void,
    pub ph_root: *mut pairingheap_node,
}
impl Default for pairingheap {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn pairingheap_allocate(
    arg_compare: pairingheap_comparator,
    arg_arg: *mut ::std::os::raw::c_void,
) -> *mut pairingheap {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pairingheap_allocate(
                arg_compare: pairingheap_comparator,
                arg_arg: *mut ::std::os::raw::c_void,
            ) -> *mut pairingheap;
        }
        pairingheap_allocate(arg_compare, arg_arg)
    })
}
pub unsafe fn pairingheap_free(arg_heap: *mut pairingheap) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pairingheap_free(arg_heap: *mut pairingheap);
        }
        pairingheap_free(arg_heap)
    })
}
pub unsafe fn pairingheap_add(arg_heap: *mut pairingheap, arg_node: *mut pairingheap_node) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pairingheap_add(arg_heap: *mut pairingheap, arg_node: *mut pairingheap_node);
        }
        pairingheap_add(arg_heap, arg_node)
    })
}
pub unsafe fn pairingheap_first(arg_heap: *mut pairingheap) -> *mut pairingheap_node {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pairingheap_first(arg_heap: *mut pairingheap) -> *mut pairingheap_node;
        }
        pairingheap_first(arg_heap)
    })
}
pub unsafe fn pairingheap_remove_first(arg_heap: *mut pairingheap) -> *mut pairingheap_node {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pairingheap_remove_first(arg_heap: *mut pairingheap) -> *mut pairingheap_node;
        }
        pairingheap_remove_first(arg_heap)
    })
}
pub unsafe fn pairingheap_remove(arg_heap: *mut pairingheap, arg_node: *mut pairingheap_node) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pairingheap_remove(arg_heap: *mut pairingheap, arg_node: *mut pairingheap_node);
        }
        pairingheap_remove(arg_heap, arg_node)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParamExternData {
    pub value: Datum,
    pub isnull: bool,
    pub pflags: uint16,
    pub ptype: Oid,
}
impl Default for ParamExternData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ParamListInfo = *mut ParamListInfoData;
pub type ParamFetchHook = ::std::option::Option<
    unsafe extern "C" fn(
        params: ParamListInfo,
        paramid: ::std::os::raw::c_int,
        speculative: bool,
        workspace: *mut ParamExternData,
    ) -> *mut ParamExternData,
>;
pub type ParamCompileHook = ::std::option::Option<
    unsafe extern "C" fn(
        params: ParamListInfo,
        param: *mut Param,
        state: *mut ExprState,
        resv: *mut Datum,
        resnull: *mut bool,
    ),
>;
pub type ParserSetupHook = ::std::option::Option<
    unsafe extern "C" fn(pstate: *mut ParseState, arg: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug)]
pub struct ParamListInfoData {
    pub paramFetch: ParamFetchHook,
    pub paramFetchArg: *mut ::std::os::raw::c_void,
    pub paramCompile: ParamCompileHook,
    pub paramCompileArg: *mut ::std::os::raw::c_void,
    pub parserSetup: ParserSetupHook,
    pub parserSetupArg: *mut ::std::os::raw::c_void,
    pub paramValuesStr: *mut ::std::os::raw::c_char,
    pub numParams: ::std::os::raw::c_int,
    pub params: __IncompleteArrayField<ParamExternData>,
}
impl Default for ParamListInfoData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParamExecData {
    pub execPlan: *mut ::std::os::raw::c_void,
    pub value: Datum,
    pub isnull: bool,
}
impl Default for ParamExecData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParamsErrorCbData {
    pub portalName: *const ::std::os::raw::c_char,
    pub params: ParamListInfo,
}
impl Default for ParamsErrorCbData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn makeParamList(arg_numParams: ::std::os::raw::c_int) -> ParamListInfo {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeParamList(arg_numParams: ::std::os::raw::c_int) -> ParamListInfo;
        }
        makeParamList(arg_numParams)
    })
}
pub unsafe fn copyParamList(arg_from: ParamListInfo) -> ParamListInfo {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn copyParamList(arg_from: ParamListInfo) -> ParamListInfo;
        }
        copyParamList(arg_from)
    })
}
pub unsafe fn EstimateParamListSpace(arg_paramLI: ParamListInfo) -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EstimateParamListSpace(arg_paramLI: ParamListInfo) -> Size;
        }
        EstimateParamListSpace(arg_paramLI)
    })
}
pub unsafe fn SerializeParamList(
    arg_paramLI: ParamListInfo,
    arg_start_address: *mut *mut ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SerializeParamList(
                arg_paramLI: ParamListInfo,
                arg_start_address: *mut *mut ::std::os::raw::c_char,
            );
        }
        SerializeParamList(arg_paramLI, arg_start_address)
    })
}
pub unsafe fn RestoreParamList(
    arg_start_address: *mut *mut ::std::os::raw::c_char,
) -> ParamListInfo {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RestoreParamList(
                arg_start_address: *mut *mut ::std::os::raw::c_char,
            ) -> ParamListInfo;
        }
        RestoreParamList(arg_start_address)
    })
}
pub unsafe fn BuildParamLogString(
    arg_params: ParamListInfo,
    arg_paramTextValues: *mut *mut ::std::os::raw::c_char,
    arg_valueLen: ::std::os::raw::c_int,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BuildParamLogString(
                arg_params: ParamListInfo,
                arg_paramTextValues: *mut *mut ::std::os::raw::c_char,
                arg_valueLen: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_char;
        }
        BuildParamLogString(arg_params, arg_paramTextValues, arg_valueLen)
    })
}
pub unsafe fn ParamsErrorCallback(arg_arg: *mut ::std::os::raw::c_void) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ParamsErrorCallback(arg_arg: *mut ::std::os::raw::c_void);
        }
        ParamsErrorCallback(arg_arg)
    })
}
pub const ScanDirection_BackwardScanDirection: ScanDirection = -1;
pub const ScanDirection_NoMovementScanDirection: ScanDirection = 0;
pub const ScanDirection_ForwardScanDirection: ScanDirection = 1;
pub type ScanDirection = ::std::os::raw::c_int;
pub type StrategyNumber = uint16;
pub const LockClauseStrength_LCS_NONE: LockClauseStrength = 0;
pub const LockClauseStrength_LCS_FORKEYSHARE: LockClauseStrength = 1;
pub const LockClauseStrength_LCS_FORSHARE: LockClauseStrength = 2;
pub const LockClauseStrength_LCS_FORNOKEYUPDATE: LockClauseStrength = 3;
pub const LockClauseStrength_LCS_FORUPDATE: LockClauseStrength = 4;
pub type LockClauseStrength = ::std::os::raw::c_uint;
pub const LockWaitPolicy_LockWaitBlock: LockWaitPolicy = 0;
pub const LockWaitPolicy_LockWaitSkip: LockWaitPolicy = 1;
pub const LockWaitPolicy_LockWaitError: LockWaitPolicy = 2;
pub type LockWaitPolicy = ::std::os::raw::c_uint;
pub const LockTupleMode_LockTupleKeyShare: LockTupleMode = 0;
pub const LockTupleMode_LockTupleShare: LockTupleMode = 1;
pub const LockTupleMode_LockTupleNoKeyExclusive: LockTupleMode = 2;
pub const LockTupleMode_LockTupleExclusive: LockTupleMode = 3;
pub type LockTupleMode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Alias {
    pub type_: NodeTag,
    pub aliasname: *mut ::std::os::raw::c_char,
    pub colnames: *mut List,
}
impl Default for Alias {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const OnCommitAction_ONCOMMIT_NOOP: OnCommitAction = 0;
pub const OnCommitAction_ONCOMMIT_PRESERVE_ROWS: OnCommitAction = 1;
pub const OnCommitAction_ONCOMMIT_DELETE_ROWS: OnCommitAction = 2;
pub const OnCommitAction_ONCOMMIT_DROP: OnCommitAction = 3;
pub type OnCommitAction = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeVar {
    pub type_: NodeTag,
    pub catalogname: *mut ::std::os::raw::c_char,
    pub schemaname: *mut ::std::os::raw::c_char,
    pub relname: *mut ::std::os::raw::c_char,
    pub inh: bool,
    pub relpersistence: ::std::os::raw::c_char,
    pub alias: *mut Alias,
    pub location: ::std::os::raw::c_int,
}
impl Default for RangeVar {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TableFunc {
    pub type_: NodeTag,
    pub ns_uris: *mut List,
    pub ns_names: *mut List,
    pub docexpr: *mut Node,
    pub rowexpr: *mut Node,
    pub colnames: *mut List,
    pub coltypes: *mut List,
    pub coltypmods: *mut List,
    pub colcollations: *mut List,
    pub colexprs: *mut List,
    pub coldefexprs: *mut List,
    pub notnulls: *mut Bitmapset,
    pub ordinalitycol: ::std::os::raw::c_int,
    pub location: ::std::os::raw::c_int,
}
impl Default for TableFunc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IntoClause {
    pub type_: NodeTag,
    pub rel: *mut RangeVar,
    pub colNames: *mut List,
    pub accessMethod: *mut ::std::os::raw::c_char,
    pub options: *mut List,
    pub onCommit: OnCommitAction,
    pub tableSpaceName: *mut ::std::os::raw::c_char,
    pub viewQuery: *mut Node,
    pub skipData: bool,
}
impl Default for IntoClause {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Expr {
    pub type_: NodeTag,
}
impl Default for Expr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Var {
    pub xpr: Expr,
    pub varno: Index,
    pub varattno: AttrNumber,
    pub vartype: Oid,
    pub vartypmod: int32,
    pub varcollid: Oid,
    pub varlevelsup: Index,
    pub varnosyn: Index,
    pub varattnosyn: AttrNumber,
    pub location: ::std::os::raw::c_int,
}
impl Default for Var {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Const {
    pub xpr: Expr,
    pub consttype: Oid,
    pub consttypmod: int32,
    pub constcollid: Oid,
    pub constlen: ::std::os::raw::c_int,
    pub constvalue: Datum,
    pub constisnull: bool,
    pub constbyval: bool,
    pub location: ::std::os::raw::c_int,
}
impl Default for Const {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ParamKind_PARAM_EXTERN: ParamKind = 0;
pub const ParamKind_PARAM_EXEC: ParamKind = 1;
pub const ParamKind_PARAM_SUBLINK: ParamKind = 2;
pub const ParamKind_PARAM_MULTIEXPR: ParamKind = 3;
pub type ParamKind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Param {
    pub xpr: Expr,
    pub paramkind: ParamKind,
    pub paramid: ::std::os::raw::c_int,
    pub paramtype: Oid,
    pub paramtypmod: int32,
    pub paramcollid: Oid,
    pub location: ::std::os::raw::c_int,
}
impl Default for Param {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Aggref {
    pub xpr: Expr,
    pub aggfnoid: Oid,
    pub aggtype: Oid,
    pub aggcollid: Oid,
    pub inputcollid: Oid,
    pub aggtranstype: Oid,
    pub aggargtypes: *mut List,
    pub aggdirectargs: *mut List,
    pub args: *mut List,
    pub aggorder: *mut List,
    pub aggdistinct: *mut List,
    pub aggfilter: *mut Expr,
    pub aggstar: bool,
    pub aggvariadic: bool,
    pub aggkind: ::std::os::raw::c_char,
    pub agglevelsup: Index,
    pub aggsplit: AggSplit,
    pub location: ::std::os::raw::c_int,
}
impl Default for Aggref {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GroupingFunc {
    pub xpr: Expr,
    pub args: *mut List,
    pub refs: *mut List,
    pub cols: *mut List,
    pub agglevelsup: Index,
    pub location: ::std::os::raw::c_int,
}
impl Default for GroupingFunc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowFunc {
    pub xpr: Expr,
    pub winfnoid: Oid,
    pub wintype: Oid,
    pub wincollid: Oid,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub aggfilter: *mut Expr,
    pub winref: Index,
    pub winstar: bool,
    pub winagg: bool,
    pub location: ::std::os::raw::c_int,
}
impl Default for WindowFunc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubscriptingRef {
    pub xpr: Expr,
    pub refcontainertype: Oid,
    pub refelemtype: Oid,
    pub reftypmod: int32,
    pub refcollid: Oid,
    pub refupperindexpr: *mut List,
    pub reflowerindexpr: *mut List,
    pub refexpr: *mut Expr,
    pub refassgnexpr: *mut Expr,
}
impl Default for SubscriptingRef {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const CoercionContext_COERCION_IMPLICIT: CoercionContext = 0;
pub const CoercionContext_COERCION_ASSIGNMENT: CoercionContext = 1;
pub const CoercionContext_COERCION_EXPLICIT: CoercionContext = 2;
pub type CoercionContext = ::std::os::raw::c_uint;
pub const CoercionForm_COERCE_EXPLICIT_CALL: CoercionForm = 0;
pub const CoercionForm_COERCE_EXPLICIT_CAST: CoercionForm = 1;
pub const CoercionForm_COERCE_IMPLICIT_CAST: CoercionForm = 2;
pub type CoercionForm = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuncExpr {
    pub xpr: Expr,
    pub funcid: Oid,
    pub funcresulttype: Oid,
    pub funcretset: bool,
    pub funcvariadic: bool,
    pub funcformat: CoercionForm,
    pub funccollid: Oid,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl Default for FuncExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NamedArgExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub name: *mut ::std::os::raw::c_char,
    pub argnumber: ::std::os::raw::c_int,
    pub location: ::std::os::raw::c_int,
}
impl Default for NamedArgExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpExpr {
    pub xpr: Expr,
    pub opno: Oid,
    pub opfuncid: Oid,
    pub opresulttype: Oid,
    pub opretset: bool,
    pub opcollid: Oid,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl Default for OpExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type DistinctExpr = OpExpr;
pub type NullIfExpr = OpExpr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScalarArrayOpExpr {
    pub xpr: Expr,
    pub opno: Oid,
    pub opfuncid: Oid,
    pub useOr: bool,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl Default for ScalarArrayOpExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const BoolExprType_AND_EXPR: BoolExprType = 0;
pub const BoolExprType_OR_EXPR: BoolExprType = 1;
pub const BoolExprType_NOT_EXPR: BoolExprType = 2;
pub type BoolExprType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BoolExpr {
    pub xpr: Expr,
    pub boolop: BoolExprType,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl Default for BoolExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const SubLinkType_EXISTS_SUBLINK: SubLinkType = 0;
pub const SubLinkType_ALL_SUBLINK: SubLinkType = 1;
pub const SubLinkType_ANY_SUBLINK: SubLinkType = 2;
pub const SubLinkType_ROWCOMPARE_SUBLINK: SubLinkType = 3;
pub const SubLinkType_EXPR_SUBLINK: SubLinkType = 4;
pub const SubLinkType_MULTIEXPR_SUBLINK: SubLinkType = 5;
pub const SubLinkType_ARRAY_SUBLINK: SubLinkType = 6;
pub const SubLinkType_CTE_SUBLINK: SubLinkType = 7;
pub type SubLinkType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubLink {
    pub xpr: Expr,
    pub subLinkType: SubLinkType,
    pub subLinkId: ::std::os::raw::c_int,
    pub testexpr: *mut Node,
    pub operName: *mut List,
    pub subselect: *mut Node,
    pub location: ::std::os::raw::c_int,
}
impl Default for SubLink {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubPlan {
    pub xpr: Expr,
    pub subLinkType: SubLinkType,
    pub testexpr: *mut Node,
    pub paramIds: *mut List,
    pub plan_id: ::std::os::raw::c_int,
    pub plan_name: *mut ::std::os::raw::c_char,
    pub firstColType: Oid,
    pub firstColTypmod: int32,
    pub firstColCollation: Oid,
    pub useHashTable: bool,
    pub unknownEqFalse: bool,
    pub parallel_safe: bool,
    pub setParam: *mut List,
    pub parParam: *mut List,
    pub args: *mut List,
    pub startup_cost: Cost,
    pub per_call_cost: Cost,
}
impl Default for SubPlan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlternativeSubPlan {
    pub xpr: Expr,
    pub subplans: *mut List,
}
impl Default for AlternativeSubPlan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FieldSelect {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub fieldnum: AttrNumber,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
}
impl Default for FieldSelect {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FieldStore {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub newvals: *mut List,
    pub fieldnums: *mut List,
    pub resulttype: Oid,
}
impl Default for FieldStore {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RelabelType {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
    pub relabelformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
impl Default for RelabelType {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CoerceViaIO {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub resultcollid: Oid,
    pub coerceformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
impl Default for CoerceViaIO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayCoerceExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub elemexpr: *mut Expr,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
    pub coerceformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
impl Default for ArrayCoerceExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConvertRowtypeExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub convertformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
impl Default for ConvertRowtypeExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CollateExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub collOid: Oid,
    pub location: ::std::os::raw::c_int,
}
impl Default for CollateExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CaseExpr {
    pub xpr: Expr,
    pub casetype: Oid,
    pub casecollid: Oid,
    pub arg: *mut Expr,
    pub args: *mut List,
    pub defresult: *mut Expr,
    pub location: ::std::os::raw::c_int,
}
impl Default for CaseExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CaseWhen {
    pub xpr: Expr,
    pub expr: *mut Expr,
    pub result: *mut Expr,
    pub location: ::std::os::raw::c_int,
}
impl Default for CaseWhen {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CaseTestExpr {
    pub xpr: Expr,
    pub typeId: Oid,
    pub typeMod: int32,
    pub collation: Oid,
}
impl Default for CaseTestExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayExpr {
    pub xpr: Expr,
    pub array_typeid: Oid,
    pub array_collid: Oid,
    pub element_typeid: Oid,
    pub elements: *mut List,
    pub multidims: bool,
    pub location: ::std::os::raw::c_int,
}
impl Default for ArrayExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RowExpr {
    pub xpr: Expr,
    pub args: *mut List,
    pub row_typeid: Oid,
    pub row_format: CoercionForm,
    pub colnames: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl Default for RowExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const RowCompareType_ROWCOMPARE_LT: RowCompareType = 1;
pub const RowCompareType_ROWCOMPARE_LE: RowCompareType = 2;
pub const RowCompareType_ROWCOMPARE_EQ: RowCompareType = 3;
pub const RowCompareType_ROWCOMPARE_GE: RowCompareType = 4;
pub const RowCompareType_ROWCOMPARE_GT: RowCompareType = 5;
pub const RowCompareType_ROWCOMPARE_NE: RowCompareType = 6;
pub type RowCompareType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RowCompareExpr {
    pub xpr: Expr,
    pub rctype: RowCompareType,
    pub opnos: *mut List,
    pub opfamilies: *mut List,
    pub inputcollids: *mut List,
    pub largs: *mut List,
    pub rargs: *mut List,
}
impl Default for RowCompareExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CoalesceExpr {
    pub xpr: Expr,
    pub coalescetype: Oid,
    pub coalescecollid: Oid,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl Default for CoalesceExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const MinMaxOp_IS_GREATEST: MinMaxOp = 0;
pub const MinMaxOp_IS_LEAST: MinMaxOp = 1;
pub type MinMaxOp = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MinMaxExpr {
    pub xpr: Expr,
    pub minmaxtype: Oid,
    pub minmaxcollid: Oid,
    pub inputcollid: Oid,
    pub op: MinMaxOp,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl Default for MinMaxExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const SQLValueFunctionOp_SVFOP_CURRENT_DATE: SQLValueFunctionOp = 0;
pub const SQLValueFunctionOp_SVFOP_CURRENT_TIME: SQLValueFunctionOp = 1;
pub const SQLValueFunctionOp_SVFOP_CURRENT_TIME_N: SQLValueFunctionOp = 2;
pub const SQLValueFunctionOp_SVFOP_CURRENT_TIMESTAMP: SQLValueFunctionOp = 3;
pub const SQLValueFunctionOp_SVFOP_CURRENT_TIMESTAMP_N: SQLValueFunctionOp = 4;
pub const SQLValueFunctionOp_SVFOP_LOCALTIME: SQLValueFunctionOp = 5;
pub const SQLValueFunctionOp_SVFOP_LOCALTIME_N: SQLValueFunctionOp = 6;
pub const SQLValueFunctionOp_SVFOP_LOCALTIMESTAMP: SQLValueFunctionOp = 7;
pub const SQLValueFunctionOp_SVFOP_LOCALTIMESTAMP_N: SQLValueFunctionOp = 8;
pub const SQLValueFunctionOp_SVFOP_CURRENT_ROLE: SQLValueFunctionOp = 9;
pub const SQLValueFunctionOp_SVFOP_CURRENT_USER: SQLValueFunctionOp = 10;
pub const SQLValueFunctionOp_SVFOP_USER: SQLValueFunctionOp = 11;
pub const SQLValueFunctionOp_SVFOP_SESSION_USER: SQLValueFunctionOp = 12;
pub const SQLValueFunctionOp_SVFOP_CURRENT_CATALOG: SQLValueFunctionOp = 13;
pub const SQLValueFunctionOp_SVFOP_CURRENT_SCHEMA: SQLValueFunctionOp = 14;
pub type SQLValueFunctionOp = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SQLValueFunction {
    pub xpr: Expr,
    pub op: SQLValueFunctionOp,
    pub type_: Oid,
    pub typmod: int32,
    pub location: ::std::os::raw::c_int,
}
impl Default for SQLValueFunction {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const XmlExprOp_IS_XMLCONCAT: XmlExprOp = 0;
pub const XmlExprOp_IS_XMLELEMENT: XmlExprOp = 1;
pub const XmlExprOp_IS_XMLFOREST: XmlExprOp = 2;
pub const XmlExprOp_IS_XMLPARSE: XmlExprOp = 3;
pub const XmlExprOp_IS_XMLPI: XmlExprOp = 4;
pub const XmlExprOp_IS_XMLROOT: XmlExprOp = 5;
pub const XmlExprOp_IS_XMLSERIALIZE: XmlExprOp = 6;
pub const XmlExprOp_IS_DOCUMENT: XmlExprOp = 7;
pub type XmlExprOp = ::std::os::raw::c_uint;
pub const XmlOptionType_XMLOPTION_DOCUMENT: XmlOptionType = 0;
pub const XmlOptionType_XMLOPTION_CONTENT: XmlOptionType = 1;
pub type XmlOptionType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XmlExpr {
    pub xpr: Expr,
    pub op: XmlExprOp,
    pub name: *mut ::std::os::raw::c_char,
    pub named_args: *mut List,
    pub arg_names: *mut List,
    pub args: *mut List,
    pub xmloption: XmlOptionType,
    pub type_: Oid,
    pub typmod: int32,
    pub location: ::std::os::raw::c_int,
}
impl Default for XmlExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const NullTestType_IS_NULL: NullTestType = 0;
pub const NullTestType_IS_NOT_NULL: NullTestType = 1;
pub type NullTestType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NullTest {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub nulltesttype: NullTestType,
    pub argisrow: bool,
    pub location: ::std::os::raw::c_int,
}
impl Default for NullTest {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const BoolTestType_IS_TRUE: BoolTestType = 0;
pub const BoolTestType_IS_NOT_TRUE: BoolTestType = 1;
pub const BoolTestType_IS_FALSE: BoolTestType = 2;
pub const BoolTestType_IS_NOT_FALSE: BoolTestType = 3;
pub const BoolTestType_IS_UNKNOWN: BoolTestType = 4;
pub const BoolTestType_IS_NOT_UNKNOWN: BoolTestType = 5;
pub type BoolTestType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BooleanTest {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub booltesttype: BoolTestType,
    pub location: ::std::os::raw::c_int,
}
impl Default for BooleanTest {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CoerceToDomain {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
    pub coercionformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
impl Default for CoerceToDomain {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CoerceToDomainValue {
    pub xpr: Expr,
    pub typeId: Oid,
    pub typeMod: int32,
    pub collation: Oid,
    pub location: ::std::os::raw::c_int,
}
impl Default for CoerceToDomainValue {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SetToDefault {
    pub xpr: Expr,
    pub typeId: Oid,
    pub typeMod: int32,
    pub collation: Oid,
    pub location: ::std::os::raw::c_int,
}
impl Default for SetToDefault {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CurrentOfExpr {
    pub xpr: Expr,
    pub cvarno: Index,
    pub cursor_name: *mut ::std::os::raw::c_char,
    pub cursor_param: ::std::os::raw::c_int,
}
impl Default for CurrentOfExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NextValueExpr {
    pub xpr: Expr,
    pub seqid: Oid,
    pub typeId: Oid,
}
impl Default for NextValueExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InferenceElem {
    pub xpr: Expr,
    pub expr: *mut Node,
    pub infercollid: Oid,
    pub inferopclass: Oid,
}
impl Default for InferenceElem {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TargetEntry {
    pub xpr: Expr,
    pub expr: *mut Expr,
    pub resno: AttrNumber,
    pub resname: *mut ::std::os::raw::c_char,
    pub ressortgroupref: Index,
    pub resorigtbl: Oid,
    pub resorigcol: AttrNumber,
    pub resjunk: bool,
}
impl Default for TargetEntry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeTblRef {
    pub type_: NodeTag,
    pub rtindex: ::std::os::raw::c_int,
}
impl Default for RangeTblRef {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JoinExpr {
    pub type_: NodeTag,
    pub jointype: JoinType,
    pub isNatural: bool,
    pub larg: *mut Node,
    pub rarg: *mut Node,
    pub usingClause: *mut List,
    pub quals: *mut Node,
    pub alias: *mut Alias,
    pub rtindex: ::std::os::raw::c_int,
}
impl Default for JoinExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FromExpr {
    pub type_: NodeTag,
    pub fromlist: *mut List,
    pub quals: *mut Node,
}
impl Default for FromExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OnConflictExpr {
    pub type_: NodeTag,
    pub action: OnConflictAction,
    pub arbiterElems: *mut List,
    pub arbiterWhere: *mut Node,
    pub constraint: Oid,
    pub onConflictSet: *mut List,
    pub onConflictWhere: *mut Node,
    pub exclRelIndex: ::std::os::raw::c_int,
    pub exclRelTlist: *mut List,
}
impl Default for OnConflictExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PlannedStmt {
    pub type_: NodeTag,
    pub commandType: CmdType,
    pub queryId: uint64,
    pub hasReturning: bool,
    pub hasModifyingCTE: bool,
    pub canSetTag: bool,
    pub transientPlan: bool,
    pub dependsOnRole: bool,
    pub parallelModeNeeded: bool,
    pub jitFlags: ::std::os::raw::c_int,
    pub planTree: *mut Plan,
    pub rtable: *mut List,
    pub resultRelations: *mut List,
    pub rootResultRelations: *mut List,
    pub appendRelations: *mut List,
    pub subplans: *mut List,
    pub rewindPlanIDs: *mut Bitmapset,
    pub rowMarks: *mut List,
    pub relationOids: *mut List,
    pub invalItems: *mut List,
    pub paramExecTypes: *mut List,
    pub utilityStmt: *mut Node,
    pub stmt_location: ::std::os::raw::c_int,
    pub stmt_len: ::std::os::raw::c_int,
}
impl Default for PlannedStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Plan {
    pub type_: NodeTag,
    pub startup_cost: Cost,
    pub total_cost: Cost,
    pub plan_rows: f64,
    pub plan_width: ::std::os::raw::c_int,
    pub parallel_aware: bool,
    pub parallel_safe: bool,
    pub plan_node_id: ::std::os::raw::c_int,
    pub targetlist: *mut List,
    pub qual: *mut List,
    pub lefttree: *mut Plan,
    pub righttree: *mut Plan,
    pub initPlan: *mut List,
    pub extParam: *mut Bitmapset,
    pub allParam: *mut Bitmapset,
}
impl Default for Plan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Result {
    pub plan: Plan,
    pub resconstantqual: *mut Node,
}
impl Default for Result {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProjectSet {
    pub plan: Plan,
}
impl Default for ProjectSet {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ModifyTable {
    pub plan: Plan,
    pub operation: CmdType,
    pub canSetTag: bool,
    pub nominalRelation: Index,
    pub rootRelation: Index,
    pub partColsUpdated: bool,
    pub resultRelations: *mut List,
    pub resultRelIndex: ::std::os::raw::c_int,
    pub rootResultRelIndex: ::std::os::raw::c_int,
    pub plans: *mut List,
    pub withCheckOptionLists: *mut List,
    pub returningLists: *mut List,
    pub fdwPrivLists: *mut List,
    pub fdwDirectModifyPlans: *mut Bitmapset,
    pub rowMarks: *mut List,
    pub epqParam: ::std::os::raw::c_int,
    pub onConflictAction: OnConflictAction,
    pub arbiterIndexes: *mut List,
    pub onConflictSet: *mut List,
    pub onConflictWhere: *mut Node,
    pub exclRelRTI: Index,
    pub exclRelTlist: *mut List,
}
impl Default for ModifyTable {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Append {
    pub plan: Plan,
    pub apprelids: *mut Bitmapset,
    pub appendplans: *mut List,
    pub first_partial_plan: ::std::os::raw::c_int,
    pub part_prune_info: *mut PartitionPruneInfo,
}
impl Default for Append {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeAppend {
    pub plan: Plan,
    pub apprelids: *mut Bitmapset,
    pub mergeplans: *mut List,
    pub numCols: ::std::os::raw::c_int,
    pub sortColIdx: *mut AttrNumber,
    pub sortOperators: *mut Oid,
    pub collations: *mut Oid,
    pub nullsFirst: *mut bool,
    pub part_prune_info: *mut PartitionPruneInfo,
}
impl Default for MergeAppend {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RecursiveUnion {
    pub plan: Plan,
    pub wtParam: ::std::os::raw::c_int,
    pub numCols: ::std::os::raw::c_int,
    pub dupColIdx: *mut AttrNumber,
    pub dupOperators: *mut Oid,
    pub dupCollations: *mut Oid,
    pub numGroups: ::std::os::raw::c_long,
}
impl Default for RecursiveUnion {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapAnd {
    pub plan: Plan,
    pub bitmapplans: *mut List,
}
impl Default for BitmapAnd {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapOr {
    pub plan: Plan,
    pub isshared: bool,
    pub bitmapplans: *mut List,
}
impl Default for BitmapOr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Scan {
    pub plan: Plan,
    pub scanrelid: Index,
}
impl Default for Scan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SeqScan = Scan;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SampleScan {
    pub scan: Scan,
    pub tablesample: *mut TableSampleClause,
}
impl Default for SampleScan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexScan {
    pub scan: Scan,
    pub indexid: Oid,
    pub indexqual: *mut List,
    pub indexqualorig: *mut List,
    pub indexorderby: *mut List,
    pub indexorderbyorig: *mut List,
    pub indexorderbyops: *mut List,
    pub indexorderdir: ScanDirection,
}
impl Default for IndexScan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexOnlyScan {
    pub scan: Scan,
    pub indexid: Oid,
    pub indexqual: *mut List,
    pub indexorderby: *mut List,
    pub indextlist: *mut List,
    pub indexorderdir: ScanDirection,
}
impl Default for IndexOnlyScan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapIndexScan {
    pub scan: Scan,
    pub indexid: Oid,
    pub isshared: bool,
    pub indexqual: *mut List,
    pub indexqualorig: *mut List,
}
impl Default for BitmapIndexScan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapHeapScan {
    pub scan: Scan,
    pub bitmapqualorig: *mut List,
}
impl Default for BitmapHeapScan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TidScan {
    pub scan: Scan,
    pub tidquals: *mut List,
}
impl Default for TidScan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubqueryScan {
    pub scan: Scan,
    pub subplan: *mut Plan,
}
impl Default for SubqueryScan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FunctionScan {
    pub scan: Scan,
    pub functions: *mut List,
    pub funcordinality: bool,
}
impl Default for FunctionScan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ValuesScan {
    pub scan: Scan,
    pub values_lists: *mut List,
}
impl Default for ValuesScan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TableFuncScan {
    pub scan: Scan,
    pub tablefunc: *mut TableFunc,
}
impl Default for TableFuncScan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CteScan {
    pub scan: Scan,
    pub ctePlanId: ::std::os::raw::c_int,
    pub cteParam: ::std::os::raw::c_int,
}
impl Default for CteScan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NamedTuplestoreScan {
    pub scan: Scan,
    pub enrname: *mut ::std::os::raw::c_char,
}
impl Default for NamedTuplestoreScan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WorkTableScan {
    pub scan: Scan,
    pub wtParam: ::std::os::raw::c_int,
}
impl Default for WorkTableScan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForeignScan {
    pub scan: Scan,
    pub operation: CmdType,
    pub fs_server: Oid,
    pub fdw_exprs: *mut List,
    pub fdw_private: *mut List,
    pub fdw_scan_tlist: *mut List,
    pub fdw_recheck_quals: *mut List,
    pub fs_relids: *mut Bitmapset,
    pub fsSystemCol: bool,
}
impl Default for ForeignScan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CustomScan {
    pub scan: Scan,
    pub flags: uint32,
    pub custom_plans: *mut List,
    pub custom_exprs: *mut List,
    pub custom_private: *mut List,
    pub custom_scan_tlist: *mut List,
    pub custom_relids: *mut Bitmapset,
    pub methods: *const CustomScanMethods,
}
impl Default for CustomScan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Join {
    pub plan: Plan,
    pub jointype: JoinType,
    pub inner_unique: bool,
    pub joinqual: *mut List,
}
impl Default for Join {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NestLoop {
    pub join: Join,
    pub nestParams: *mut List,
}
impl Default for NestLoop {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NestLoopParam {
    pub type_: NodeTag,
    pub paramno: ::std::os::raw::c_int,
    pub paramval: *mut Var,
}
impl Default for NestLoopParam {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeJoin {
    pub join: Join,
    pub skip_mark_restore: bool,
    pub mergeclauses: *mut List,
    pub mergeFamilies: *mut Oid,
    pub mergeCollations: *mut Oid,
    pub mergeStrategies: *mut ::std::os::raw::c_int,
    pub mergeNullsFirst: *mut bool,
}
impl Default for MergeJoin {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HashJoin {
    pub join: Join,
    pub hashclauses: *mut List,
    pub hashoperators: *mut List,
    pub hashcollations: *mut List,
    pub hashkeys: *mut List,
}
impl Default for HashJoin {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Material {
    pub plan: Plan,
}
impl Default for Material {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sort {
    pub plan: Plan,
    pub numCols: ::std::os::raw::c_int,
    pub sortColIdx: *mut AttrNumber,
    pub sortOperators: *mut Oid,
    pub collations: *mut Oid,
    pub nullsFirst: *mut bool,
}
impl Default for Sort {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IncrementalSort {
    pub sort: Sort,
    pub nPresortedCols: ::std::os::raw::c_int,
}
impl Default for IncrementalSort {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Group {
    pub plan: Plan,
    pub numCols: ::std::os::raw::c_int,
    pub grpColIdx: *mut AttrNumber,
    pub grpOperators: *mut Oid,
    pub grpCollations: *mut Oid,
}
impl Default for Group {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Agg {
    pub plan: Plan,
    pub aggstrategy: AggStrategy,
    pub aggsplit: AggSplit,
    pub numCols: ::std::os::raw::c_int,
    pub grpColIdx: *mut AttrNumber,
    pub grpOperators: *mut Oid,
    pub grpCollations: *mut Oid,
    pub numGroups: ::std::os::raw::c_long,
    pub transitionSpace: uint64,
    pub aggParams: *mut Bitmapset,
    pub groupingSets: *mut List,
    pub chain: *mut List,
}
impl Default for Agg {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowAgg {
    pub plan: Plan,
    pub winref: Index,
    pub partNumCols: ::std::os::raw::c_int,
    pub partColIdx: *mut AttrNumber,
    pub partOperators: *mut Oid,
    pub partCollations: *mut Oid,
    pub ordNumCols: ::std::os::raw::c_int,
    pub ordColIdx: *mut AttrNumber,
    pub ordOperators: *mut Oid,
    pub ordCollations: *mut Oid,
    pub frameOptions: ::std::os::raw::c_int,
    pub startOffset: *mut Node,
    pub endOffset: *mut Node,
    pub startInRangeFunc: Oid,
    pub endInRangeFunc: Oid,
    pub inRangeColl: Oid,
    pub inRangeAsc: bool,
    pub inRangeNullsFirst: bool,
}
impl Default for WindowAgg {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Unique {
    pub plan: Plan,
    pub numCols: ::std::os::raw::c_int,
    pub uniqColIdx: *mut AttrNumber,
    pub uniqOperators: *mut Oid,
    pub uniqCollations: *mut Oid,
}
impl Default for Unique {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Gather {
    pub plan: Plan,
    pub num_workers: ::std::os::raw::c_int,
    pub rescan_param: ::std::os::raw::c_int,
    pub single_copy: bool,
    pub invisible: bool,
    pub initParam: *mut Bitmapset,
}
impl Default for Gather {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GatherMerge {
    pub plan: Plan,
    pub num_workers: ::std::os::raw::c_int,
    pub rescan_param: ::std::os::raw::c_int,
    pub numCols: ::std::os::raw::c_int,
    pub sortColIdx: *mut AttrNumber,
    pub sortOperators: *mut Oid,
    pub collations: *mut Oid,
    pub nullsFirst: *mut bool,
    pub initParam: *mut Bitmapset,
}
impl Default for GatherMerge {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Hash {
    pub plan: Plan,
    pub hashkeys: *mut List,
    pub skewTable: Oid,
    pub skewColumn: AttrNumber,
    pub skewInherit: bool,
    pub rows_total: f64,
}
impl Default for Hash {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SetOp {
    pub plan: Plan,
    pub cmd: SetOpCmd,
    pub strategy: SetOpStrategy,
    pub numCols: ::std::os::raw::c_int,
    pub dupColIdx: *mut AttrNumber,
    pub dupOperators: *mut Oid,
    pub dupCollations: *mut Oid,
    pub flagColIdx: AttrNumber,
    pub firstFlag: ::std::os::raw::c_int,
    pub numGroups: ::std::os::raw::c_long,
}
impl Default for SetOp {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LockRows {
    pub plan: Plan,
    pub rowMarks: *mut List,
    pub epqParam: ::std::os::raw::c_int,
}
impl Default for LockRows {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Limit {
    pub plan: Plan,
    pub limitOffset: *mut Node,
    pub limitCount: *mut Node,
    pub limitOption: LimitOption,
    pub uniqNumCols: ::std::os::raw::c_int,
    pub uniqColIdx: *mut AttrNumber,
    pub uniqOperators: *mut Oid,
    pub uniqCollations: *mut Oid,
}
impl Default for Limit {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const RowMarkType_ROW_MARK_EXCLUSIVE: RowMarkType = 0;
pub const RowMarkType_ROW_MARK_NOKEYEXCLUSIVE: RowMarkType = 1;
pub const RowMarkType_ROW_MARK_SHARE: RowMarkType = 2;
pub const RowMarkType_ROW_MARK_KEYSHARE: RowMarkType = 3;
pub const RowMarkType_ROW_MARK_REFERENCE: RowMarkType = 4;
pub const RowMarkType_ROW_MARK_COPY: RowMarkType = 5;
pub type RowMarkType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PlanRowMark {
    pub type_: NodeTag,
    pub rti: Index,
    pub prti: Index,
    pub rowmarkId: Index,
    pub markType: RowMarkType,
    pub allMarkTypes: ::std::os::raw::c_int,
    pub strength: LockClauseStrength,
    pub waitPolicy: LockWaitPolicy,
    pub isParent: bool,
}
impl Default for PlanRowMark {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionPruneInfo {
    pub type_: NodeTag,
    pub prune_infos: *mut List,
    pub other_subplans: *mut Bitmapset,
}
impl Default for PartitionPruneInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionedRelPruneInfo {
    pub type_: NodeTag,
    pub rtindex: Index,
    pub present_parts: *mut Bitmapset,
    pub nparts: ::std::os::raw::c_int,
    pub subplan_map: *mut ::std::os::raw::c_int,
    pub subpart_map: *mut ::std::os::raw::c_int,
    pub relid_map: *mut Oid,
    pub initial_pruning_steps: *mut List,
    pub exec_pruning_steps: *mut List,
    pub execparamids: *mut Bitmapset,
}
impl Default for PartitionedRelPruneInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionPruneStep {
    pub type_: NodeTag,
    pub step_id: ::std::os::raw::c_int,
}
impl Default for PartitionPruneStep {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionPruneStepOp {
    pub step: PartitionPruneStep,
    pub opstrategy: StrategyNumber,
    pub exprs: *mut List,
    pub cmpfns: *mut List,
    pub nullkeys: *mut Bitmapset,
}
impl Default for PartitionPruneStepOp {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const PartitionPruneCombineOp_PARTPRUNE_COMBINE_UNION: PartitionPruneCombineOp = 0;
pub const PartitionPruneCombineOp_PARTPRUNE_COMBINE_INTERSECT: PartitionPruneCombineOp = 1;
pub type PartitionPruneCombineOp = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionPruneStepCombine {
    pub step: PartitionPruneStep,
    pub combineOp: PartitionPruneCombineOp,
    pub source_stepids: *mut List,
}
impl Default for PartitionPruneStepCombine {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PlanInvalItem {
    pub type_: NodeTag,
    pub cacheId: ::std::os::raw::c_int,
    pub hashValue: uint32,
}
impl Default for PlanInvalItem {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pg_atomic_flag {
    pub value: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pg_atomic_uint32 {
    pub value: uint32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pg_atomic_uint64 {
    pub value: uint64,
}
extern "C" {
    pub static mut dynamic_shared_memory_type: ::std::os::raw::c_int;
}
pub type dsm_handle = uint32;
pub const dsm_op_DSM_OP_CREATE: dsm_op = 0;
pub const dsm_op_DSM_OP_ATTACH: dsm_op = 1;
pub const dsm_op_DSM_OP_DETACH: dsm_op = 2;
pub const dsm_op_DSM_OP_DESTROY: dsm_op = 3;
pub type dsm_op = ::std::os::raw::c_uint;
pub unsafe fn dsm_impl_op(
    arg_op: dsm_op,
    arg_handle: dsm_handle,
    arg_request_size: Size,
    arg_impl_private: *mut *mut ::std::os::raw::c_void,
    arg_mapped_address: *mut *mut ::std::os::raw::c_void,
    arg_mapped_size: *mut Size,
    arg_elevel: ::std::os::raw::c_int,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsm_impl_op(
                arg_op: dsm_op,
                arg_handle: dsm_handle,
                arg_request_size: Size,
                arg_impl_private: *mut *mut ::std::os::raw::c_void,
                arg_mapped_address: *mut *mut ::std::os::raw::c_void,
                arg_mapped_size: *mut Size,
                arg_elevel: ::std::os::raw::c_int,
            ) -> bool;
        }
        dsm_impl_op(
            arg_op,
            arg_handle,
            arg_request_size,
            arg_impl_private,
            arg_mapped_address,
            arg_mapped_size,
            arg_elevel,
        )
    })
}
pub unsafe fn dsm_impl_pin_segment(
    arg_handle: dsm_handle,
    arg_impl_private: *mut ::std::os::raw::c_void,
    arg_impl_private_pm_handle: *mut *mut ::std::os::raw::c_void,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsm_impl_pin_segment(
                arg_handle: dsm_handle,
                arg_impl_private: *mut ::std::os::raw::c_void,
                arg_impl_private_pm_handle: *mut *mut ::std::os::raw::c_void,
            );
        }
        dsm_impl_pin_segment(arg_handle, arg_impl_private, arg_impl_private_pm_handle)
    })
}
pub unsafe fn dsm_impl_unpin_segment(
    arg_handle: dsm_handle,
    arg_impl_private: *mut *mut ::std::os::raw::c_void,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsm_impl_unpin_segment(
                arg_handle: dsm_handle,
                arg_impl_private: *mut *mut ::std::os::raw::c_void,
            );
        }
        dsm_impl_unpin_segment(arg_handle, arg_impl_private)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsm_segment {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PGShmemHeader {
    _unused: [u8; 0],
}
pub unsafe fn dsm_cleanup_using_control_segment(arg_old_control_handle: dsm_handle) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsm_cleanup_using_control_segment(arg_old_control_handle: dsm_handle);
        }
        dsm_cleanup_using_control_segment(arg_old_control_handle)
    })
}
pub unsafe fn dsm_postmaster_startup(arg_arg1: *mut PGShmemHeader) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsm_postmaster_startup(arg_arg1: *mut PGShmemHeader);
        }
        dsm_postmaster_startup(arg_arg1)
    })
}
pub unsafe fn dsm_backend_shutdown() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsm_backend_shutdown();
        }
        dsm_backend_shutdown()
    })
}
pub unsafe fn dsm_detach_all() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsm_detach_all();
        }
        dsm_detach_all()
    })
}
pub unsafe fn dsm_create(arg_size: Size, arg_flags: ::std::os::raw::c_int) -> *mut dsm_segment {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsm_create(arg_size: Size, arg_flags: ::std::os::raw::c_int) -> *mut dsm_segment;
        }
        dsm_create(arg_size, arg_flags)
    })
}
pub unsafe fn dsm_attach(arg_h: dsm_handle) -> *mut dsm_segment {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsm_attach(arg_h: dsm_handle) -> *mut dsm_segment;
        }
        dsm_attach(arg_h)
    })
}
pub unsafe fn dsm_detach(arg_seg: *mut dsm_segment) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsm_detach(arg_seg: *mut dsm_segment);
        }
        dsm_detach(arg_seg)
    })
}
pub unsafe fn dsm_pin_mapping(arg_seg: *mut dsm_segment) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsm_pin_mapping(arg_seg: *mut dsm_segment);
        }
        dsm_pin_mapping(arg_seg)
    })
}
pub unsafe fn dsm_unpin_mapping(arg_seg: *mut dsm_segment) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsm_unpin_mapping(arg_seg: *mut dsm_segment);
        }
        dsm_unpin_mapping(arg_seg)
    })
}
pub unsafe fn dsm_pin_segment(arg_seg: *mut dsm_segment) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsm_pin_segment(arg_seg: *mut dsm_segment);
        }
        dsm_pin_segment(arg_seg)
    })
}
pub unsafe fn dsm_unpin_segment(arg_h: dsm_handle) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsm_unpin_segment(arg_h: dsm_handle);
        }
        dsm_unpin_segment(arg_h)
    })
}
pub unsafe fn dsm_find_mapping(arg_h: dsm_handle) -> *mut dsm_segment {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsm_find_mapping(arg_h: dsm_handle) -> *mut dsm_segment;
        }
        dsm_find_mapping(arg_h)
    })
}
pub unsafe fn dsm_segment_address(arg_seg: *mut dsm_segment) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsm_segment_address(arg_seg: *mut dsm_segment) -> *mut ::std::os::raw::c_void;
        }
        dsm_segment_address(arg_seg)
    })
}
pub unsafe fn dsm_segment_map_length(arg_seg: *mut dsm_segment) -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsm_segment_map_length(arg_seg: *mut dsm_segment) -> Size;
        }
        dsm_segment_map_length(arg_seg)
    })
}
pub unsafe fn dsm_segment_handle(arg_seg: *mut dsm_segment) -> dsm_handle {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsm_segment_handle(arg_seg: *mut dsm_segment) -> dsm_handle;
        }
        dsm_segment_handle(arg_seg)
    })
}
pub type on_dsm_detach_callback =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut dsm_segment, arg: Datum)>;
pub unsafe fn on_dsm_detach(
    arg_seg: *mut dsm_segment,
    arg_function: on_dsm_detach_callback,
    arg_arg: Datum,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn on_dsm_detach(
                arg_seg: *mut dsm_segment,
                arg_function: on_dsm_detach_callback,
                arg_arg: Datum,
            );
        }
        on_dsm_detach(arg_seg, arg_function, arg_arg)
    })
}
pub unsafe fn cancel_on_dsm_detach(
    arg_seg: *mut dsm_segment,
    arg_function: on_dsm_detach_callback,
    arg_arg: Datum,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cancel_on_dsm_detach(
                arg_seg: *mut dsm_segment,
                arg_function: on_dsm_detach_callback,
                arg_arg: Datum,
            );
        }
        cancel_on_dsm_detach(arg_seg, arg_function, arg_arg)
    })
}
pub unsafe fn reset_on_dsm_detach() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn reset_on_dsm_detach();
        }
        reset_on_dsm_detach()
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsa_area {
    _unused: [u8; 0],
}
pub type dsa_pointer = uint64;
pub type dsa_pointer_atomic = pg_atomic_uint64;
pub type dsa_handle = dsm_handle;
pub unsafe fn dsa_create(arg_tranche_id: ::std::os::raw::c_int) -> *mut dsa_area {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsa_create(arg_tranche_id: ::std::os::raw::c_int) -> *mut dsa_area;
        }
        dsa_create(arg_tranche_id)
    })
}
pub unsafe fn dsa_create_in_place(
    arg_place: *mut ::std::os::raw::c_void,
    arg_size: usize,
    arg_tranche_id: ::std::os::raw::c_int,
    arg_segment: *mut dsm_segment,
) -> *mut dsa_area {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsa_create_in_place(
                arg_place: *mut ::std::os::raw::c_void,
                arg_size: usize,
                arg_tranche_id: ::std::os::raw::c_int,
                arg_segment: *mut dsm_segment,
            ) -> *mut dsa_area;
        }
        dsa_create_in_place(arg_place, arg_size, arg_tranche_id, arg_segment)
    })
}
pub unsafe fn dsa_attach(arg_handle: dsa_handle) -> *mut dsa_area {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsa_attach(arg_handle: dsa_handle) -> *mut dsa_area;
        }
        dsa_attach(arg_handle)
    })
}
pub unsafe fn dsa_attach_in_place(
    arg_place: *mut ::std::os::raw::c_void,
    arg_segment: *mut dsm_segment,
) -> *mut dsa_area {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsa_attach_in_place(
                arg_place: *mut ::std::os::raw::c_void,
                arg_segment: *mut dsm_segment,
            ) -> *mut dsa_area;
        }
        dsa_attach_in_place(arg_place, arg_segment)
    })
}
pub unsafe fn dsa_release_in_place(arg_place: *mut ::std::os::raw::c_void) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsa_release_in_place(arg_place: *mut ::std::os::raw::c_void);
        }
        dsa_release_in_place(arg_place)
    })
}
pub unsafe fn dsa_on_dsm_detach_release_in_place(arg_arg1: *mut dsm_segment, arg_arg2: Datum) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsa_on_dsm_detach_release_in_place(arg_arg1: *mut dsm_segment, arg_arg2: Datum);
        }
        dsa_on_dsm_detach_release_in_place(arg_arg1, arg_arg2)
    })
}
pub unsafe fn dsa_on_shmem_exit_release_in_place(arg_arg1: ::std::os::raw::c_int, arg_arg2: Datum) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsa_on_shmem_exit_release_in_place(arg_arg1: ::std::os::raw::c_int, arg_arg2: Datum);
        }
        dsa_on_shmem_exit_release_in_place(arg_arg1, arg_arg2)
    })
}
pub unsafe fn dsa_pin_mapping(arg_area: *mut dsa_area) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsa_pin_mapping(arg_area: *mut dsa_area);
        }
        dsa_pin_mapping(arg_area)
    })
}
pub unsafe fn dsa_detach(arg_area: *mut dsa_area) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsa_detach(arg_area: *mut dsa_area);
        }
        dsa_detach(arg_area)
    })
}
pub unsafe fn dsa_pin(arg_area: *mut dsa_area) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsa_pin(arg_area: *mut dsa_area);
        }
        dsa_pin(arg_area)
    })
}
pub unsafe fn dsa_unpin(arg_area: *mut dsa_area) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsa_unpin(arg_area: *mut dsa_area);
        }
        dsa_unpin(arg_area)
    })
}
pub unsafe fn dsa_set_size_limit(arg_area: *mut dsa_area, arg_limit: usize) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsa_set_size_limit(arg_area: *mut dsa_area, arg_limit: usize);
        }
        dsa_set_size_limit(arg_area, arg_limit)
    })
}
pub unsafe fn dsa_minimum_size() -> usize {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsa_minimum_size() -> usize;
        }
        dsa_minimum_size()
    })
}
pub unsafe fn dsa_get_handle(arg_area: *mut dsa_area) -> dsa_handle {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsa_get_handle(arg_area: *mut dsa_area) -> dsa_handle;
        }
        dsa_get_handle(arg_area)
    })
}
pub unsafe fn dsa_allocate_extended(
    arg_area: *mut dsa_area,
    arg_size: usize,
    arg_flags: ::std::os::raw::c_int,
) -> dsa_pointer {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsa_allocate_extended(
                arg_area: *mut dsa_area,
                arg_size: usize,
                arg_flags: ::std::os::raw::c_int,
            ) -> dsa_pointer;
        }
        dsa_allocate_extended(arg_area, arg_size, arg_flags)
    })
}
pub unsafe fn dsa_free(arg_area: *mut dsa_area, arg_dp: dsa_pointer) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsa_free(arg_area: *mut dsa_area, arg_dp: dsa_pointer);
        }
        dsa_free(arg_area, arg_dp)
    })
}
pub unsafe fn dsa_get_address(
    arg_area: *mut dsa_area,
    arg_dp: dsa_pointer,
) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsa_get_address(
                arg_area: *mut dsa_area,
                arg_dp: dsa_pointer,
            ) -> *mut ::std::os::raw::c_void;
        }
        dsa_get_address(arg_area, arg_dp)
    })
}
pub unsafe fn dsa_trim(arg_area: *mut dsa_area) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsa_trim(arg_area: *mut dsa_area);
        }
        dsa_trim(arg_area)
    })
}
pub unsafe fn dsa_dump(arg_area: *mut dsa_area) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsa_dump(arg_area: *mut dsa_area);
        }
        dsa_dump(arg_area)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TIDBitmap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TBMIterator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TBMSharedIterator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct TBMIterateResult {
    pub blockno: BlockNumber,
    pub ntuples: ::std::os::raw::c_int,
    pub recheck: bool,
    pub offsets: __IncompleteArrayField<OffsetNumber>,
}
pub unsafe fn tbm_create(
    arg_maxbytes: ::std::os::raw::c_long,
    arg_dsa: *mut dsa_area,
) -> *mut TIDBitmap {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tbm_create(
                arg_maxbytes: ::std::os::raw::c_long,
                arg_dsa: *mut dsa_area,
            ) -> *mut TIDBitmap;
        }
        tbm_create(arg_maxbytes, arg_dsa)
    })
}
pub unsafe fn tbm_free(arg_tbm: *mut TIDBitmap) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tbm_free(arg_tbm: *mut TIDBitmap);
        }
        tbm_free(arg_tbm)
    })
}
pub unsafe fn tbm_free_shared_area(arg_dsa: *mut dsa_area, arg_dp: dsa_pointer) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tbm_free_shared_area(arg_dsa: *mut dsa_area, arg_dp: dsa_pointer);
        }
        tbm_free_shared_area(arg_dsa, arg_dp)
    })
}
pub unsafe fn tbm_add_tuples(
    arg_tbm: *mut TIDBitmap,
    arg_tids: ItemPointer,
    arg_ntids: ::std::os::raw::c_int,
    arg_recheck: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tbm_add_tuples(
                arg_tbm: *mut TIDBitmap,
                arg_tids: ItemPointer,
                arg_ntids: ::std::os::raw::c_int,
                arg_recheck: bool,
            );
        }
        tbm_add_tuples(arg_tbm, arg_tids, arg_ntids, arg_recheck)
    })
}
pub unsafe fn tbm_add_page(arg_tbm: *mut TIDBitmap, arg_pageno: BlockNumber) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tbm_add_page(arg_tbm: *mut TIDBitmap, arg_pageno: BlockNumber);
        }
        tbm_add_page(arg_tbm, arg_pageno)
    })
}
pub unsafe fn tbm_union(arg_a: *mut TIDBitmap, arg_b: *const TIDBitmap) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tbm_union(arg_a: *mut TIDBitmap, arg_b: *const TIDBitmap);
        }
        tbm_union(arg_a, arg_b)
    })
}
pub unsafe fn tbm_intersect(arg_a: *mut TIDBitmap, arg_b: *const TIDBitmap) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tbm_intersect(arg_a: *mut TIDBitmap, arg_b: *const TIDBitmap);
        }
        tbm_intersect(arg_a, arg_b)
    })
}
pub unsafe fn tbm_is_empty(arg_tbm: *const TIDBitmap) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tbm_is_empty(arg_tbm: *const TIDBitmap) -> bool;
        }
        tbm_is_empty(arg_tbm)
    })
}
pub unsafe fn tbm_begin_iterate(arg_tbm: *mut TIDBitmap) -> *mut TBMIterator {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tbm_begin_iterate(arg_tbm: *mut TIDBitmap) -> *mut TBMIterator;
        }
        tbm_begin_iterate(arg_tbm)
    })
}
pub unsafe fn tbm_prepare_shared_iterate(arg_tbm: *mut TIDBitmap) -> dsa_pointer {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tbm_prepare_shared_iterate(arg_tbm: *mut TIDBitmap) -> dsa_pointer;
        }
        tbm_prepare_shared_iterate(arg_tbm)
    })
}
pub unsafe fn tbm_iterate(arg_iterator: *mut TBMIterator) -> *mut TBMIterateResult {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tbm_iterate(arg_iterator: *mut TBMIterator) -> *mut TBMIterateResult;
        }
        tbm_iterate(arg_iterator)
    })
}
pub unsafe fn tbm_shared_iterate(arg_iterator: *mut TBMSharedIterator) -> *mut TBMIterateResult {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tbm_shared_iterate(arg_iterator: *mut TBMSharedIterator) -> *mut TBMIterateResult;
        }
        tbm_shared_iterate(arg_iterator)
    })
}
pub unsafe fn tbm_end_iterate(arg_iterator: *mut TBMIterator) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tbm_end_iterate(arg_iterator: *mut TBMIterator);
        }
        tbm_end_iterate(arg_iterator)
    })
}
pub unsafe fn tbm_end_shared_iterate(arg_iterator: *mut TBMSharedIterator) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tbm_end_shared_iterate(arg_iterator: *mut TBMSharedIterator);
        }
        tbm_end_shared_iterate(arg_iterator)
    })
}
pub unsafe fn tbm_attach_shared_iterate(
    arg_dsa: *mut dsa_area,
    arg_dp: dsa_pointer,
) -> *mut TBMSharedIterator {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tbm_attach_shared_iterate(
                arg_dsa: *mut dsa_area,
                arg_dp: dsa_pointer,
            ) -> *mut TBMSharedIterator;
        }
        tbm_attach_shared_iterate(arg_dsa, arg_dp)
    })
}
pub unsafe fn tbm_calculate_entries(arg_maxbytes: f64) -> ::std::os::raw::c_long {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tbm_calculate_entries(arg_maxbytes: f64) -> ::std::os::raw::c_long;
        }
        tbm_calculate_entries(arg_maxbytes)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionBoundInfoData {
    _unused: [u8; 0],
}
pub type PartitionBoundInfo = *mut PartitionBoundInfoData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionKeyData {
    _unused: [u8; 0],
}
pub type PartitionKey = *mut PartitionKeyData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionDescData {
    _unused: [u8; 0],
}
pub type PartitionDesc = *mut PartitionDescData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionDirectoryData {
    _unused: [u8; 0],
}
pub type PartitionDirectory = *mut PartitionDirectoryData;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct proclist_node {
    pub next: ::std::os::raw::c_int,
    pub prev: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct proclist_head {
    pub head: ::std::os::raw::c_int,
    pub tail: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct proclist_mutable_iter {
    pub cur: ::std::os::raw::c_int,
    pub next: ::std::os::raw::c_int,
}
pub type slock_t = ::std::os::raw::c_int;
extern "C" {
    pub static mut dummy_spinlock: slock_t;
}
pub unsafe fn s_lock(
    arg_lock: *mut slock_t,
    arg_file: *const ::std::os::raw::c_char,
    arg_line: ::std::os::raw::c_int,
    arg_func: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn s_lock(
                arg_lock: *mut slock_t,
                arg_file: *const ::std::os::raw::c_char,
                arg_line: ::std::os::raw::c_int,
                arg_func: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        s_lock(arg_lock, arg_file, arg_line, arg_func)
    })
}
pub unsafe fn set_spins_per_delay(arg_shared_spins_per_delay: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn set_spins_per_delay(arg_shared_spins_per_delay: ::std::os::raw::c_int);
        }
        set_spins_per_delay(arg_shared_spins_per_delay)
    })
}
pub unsafe fn update_spins_per_delay(
    arg_shared_spins_per_delay: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn update_spins_per_delay(
                arg_shared_spins_per_delay: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        update_spins_per_delay(arg_shared_spins_per_delay)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SpinDelayStatus {
    pub spins: ::std::os::raw::c_int,
    pub delays: ::std::os::raw::c_int,
    pub cur_delay: ::std::os::raw::c_int,
    pub file: *const ::std::os::raw::c_char,
    pub line: ::std::os::raw::c_int,
    pub func: *const ::std::os::raw::c_char,
}
impl Default for SpinDelayStatus {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn perform_spin_delay(arg_status: *mut SpinDelayStatus) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn perform_spin_delay(arg_status: *mut SpinDelayStatus);
        }
        perform_spin_delay(arg_status)
    })
}
pub unsafe fn finish_spin_delay(arg_status: *mut SpinDelayStatus) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn finish_spin_delay(arg_status: *mut SpinDelayStatus);
        }
        finish_spin_delay(arg_status)
    })
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ConditionVariable {
    pub mutex: slock_t,
    pub wakeup: proclist_head,
}
pub unsafe fn ConditionVariableInit(arg_cv: *mut ConditionVariable) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ConditionVariableInit(arg_cv: *mut ConditionVariable);
        }
        ConditionVariableInit(arg_cv)
    })
}
pub unsafe fn ConditionVariableSleep(arg_cv: *mut ConditionVariable, arg_wait_event_info: uint32) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ConditionVariableSleep(arg_cv: *mut ConditionVariable, arg_wait_event_info: uint32);
        }
        ConditionVariableSleep(arg_cv, arg_wait_event_info)
    })
}
pub unsafe fn ConditionVariableTimedSleep(
    arg_cv: *mut ConditionVariable,
    arg_timeout: ::std::os::raw::c_long,
    arg_wait_event_info: uint32,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ConditionVariableTimedSleep(
                arg_cv: *mut ConditionVariable,
                arg_timeout: ::std::os::raw::c_long,
                arg_wait_event_info: uint32,
            ) -> bool;
        }
        ConditionVariableTimedSleep(arg_cv, arg_timeout, arg_wait_event_info)
    })
}
pub unsafe fn ConditionVariableCancelSleep() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ConditionVariableCancelSleep();
        }
        ConditionVariableCancelSleep()
    })
}
pub unsafe fn ConditionVariablePrepareToSleep(arg_cv: *mut ConditionVariable) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ConditionVariablePrepareToSleep(arg_cv: *mut ConditionVariable);
        }
        ConditionVariablePrepareToSleep(arg_cv)
    })
}
pub unsafe fn ConditionVariableSignal(arg_cv: *mut ConditionVariable) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ConditionVariableSignal(arg_cv: *mut ConditionVariable);
        }
        ConditionVariableSignal(arg_cv)
    })
}
pub unsafe fn ConditionVariableBroadcast(arg_cv: *mut ConditionVariable) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ConditionVariableBroadcast(arg_cv: *mut ConditionVariable);
        }
        ConditionVariableBroadcast(arg_cv)
    })
}
pub type HashValueFunc = ::std::option::Option<
    unsafe extern "C" fn(key: *const ::std::os::raw::c_void, keysize: Size) -> uint32,
>;
pub type HashCompareFunc = ::std::option::Option<
    unsafe extern "C" fn(
        key1: *const ::std::os::raw::c_void,
        key2: *const ::std::os::raw::c_void,
        keysize: Size,
    ) -> ::std::os::raw::c_int,
>;
pub type HashCopyFunc = ::std::option::Option<
    unsafe extern "C" fn(
        dest: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        keysize: Size,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type HashAllocFunc =
    ::std::option::Option<unsafe extern "C" fn(request: Size) -> *mut ::std::os::raw::c_void>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HASHELEMENT {
    pub link: *mut HASHELEMENT,
    pub hashvalue: uint32,
}
impl Default for HASHELEMENT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HASHHDR {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTAB {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HASHCTL {
    pub num_partitions: ::std::os::raw::c_long,
    pub ssize: ::std::os::raw::c_long,
    pub dsize: ::std::os::raw::c_long,
    pub max_dsize: ::std::os::raw::c_long,
    pub ffactor: ::std::os::raw::c_long,
    pub keysize: Size,
    pub entrysize: Size,
    pub hash: HashValueFunc,
    pub match_: HashCompareFunc,
    pub keycopy: HashCopyFunc,
    pub alloc: HashAllocFunc,
    pub hcxt: MemoryContext,
    pub hctl: *mut HASHHDR,
}
impl Default for HASHCTL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const HASHACTION_HASH_FIND: HASHACTION = 0;
pub const HASHACTION_HASH_ENTER: HASHACTION = 1;
pub const HASHACTION_HASH_REMOVE: HASHACTION = 2;
pub const HASHACTION_HASH_ENTER_NULL: HASHACTION = 3;
pub type HASHACTION = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HASH_SEQ_STATUS {
    pub hashp: *mut HTAB,
    pub curBucket: uint32,
    pub curEntry: *mut HASHELEMENT,
}
impl Default for HASH_SEQ_STATUS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn hash_create(
    arg_tabname: *const ::std::os::raw::c_char,
    arg_nelem: ::std::os::raw::c_long,
    arg_info: *mut HASHCTL,
    arg_flags: ::std::os::raw::c_int,
) -> *mut HTAB {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hash_create(
                arg_tabname: *const ::std::os::raw::c_char,
                arg_nelem: ::std::os::raw::c_long,
                arg_info: *mut HASHCTL,
                arg_flags: ::std::os::raw::c_int,
            ) -> *mut HTAB;
        }
        hash_create(arg_tabname, arg_nelem, arg_info, arg_flags)
    })
}
pub unsafe fn hash_destroy(arg_hashp: *mut HTAB) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hash_destroy(arg_hashp: *mut HTAB);
        }
        hash_destroy(arg_hashp)
    })
}
pub unsafe fn hash_stats(arg_where_: *const ::std::os::raw::c_char, arg_hashp: *mut HTAB) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hash_stats(arg_where_: *const ::std::os::raw::c_char, arg_hashp: *mut HTAB);
        }
        hash_stats(arg_where_, arg_hashp)
    })
}
pub unsafe fn hash_search(
    arg_hashp: *mut HTAB,
    arg_keyPtr: *const ::std::os::raw::c_void,
    arg_action: HASHACTION,
    arg_foundPtr: *mut bool,
) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hash_search(
                arg_hashp: *mut HTAB,
                arg_keyPtr: *const ::std::os::raw::c_void,
                arg_action: HASHACTION,
                arg_foundPtr: *mut bool,
            ) -> *mut ::std::os::raw::c_void;
        }
        hash_search(arg_hashp, arg_keyPtr, arg_action, arg_foundPtr)
    })
}
pub unsafe fn get_hash_value(
    arg_hashp: *mut HTAB,
    arg_keyPtr: *const ::std::os::raw::c_void,
) -> uint32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_hash_value(
                arg_hashp: *mut HTAB,
                arg_keyPtr: *const ::std::os::raw::c_void,
            ) -> uint32;
        }
        get_hash_value(arg_hashp, arg_keyPtr)
    })
}
pub unsafe fn hash_search_with_hash_value(
    arg_hashp: *mut HTAB,
    arg_keyPtr: *const ::std::os::raw::c_void,
    arg_hashvalue: uint32,
    arg_action: HASHACTION,
    arg_foundPtr: *mut bool,
) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hash_search_with_hash_value(
                arg_hashp: *mut HTAB,
                arg_keyPtr: *const ::std::os::raw::c_void,
                arg_hashvalue: uint32,
                arg_action: HASHACTION,
                arg_foundPtr: *mut bool,
            ) -> *mut ::std::os::raw::c_void;
        }
        hash_search_with_hash_value(arg_hashp, arg_keyPtr, arg_hashvalue, arg_action, arg_foundPtr)
    })
}
pub unsafe fn hash_update_hash_key(
    arg_hashp: *mut HTAB,
    arg_existingEntry: *mut ::std::os::raw::c_void,
    arg_newKeyPtr: *const ::std::os::raw::c_void,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hash_update_hash_key(
                arg_hashp: *mut HTAB,
                arg_existingEntry: *mut ::std::os::raw::c_void,
                arg_newKeyPtr: *const ::std::os::raw::c_void,
            ) -> bool;
        }
        hash_update_hash_key(arg_hashp, arg_existingEntry, arg_newKeyPtr)
    })
}
pub unsafe fn hash_get_num_entries(arg_hashp: *mut HTAB) -> ::std::os::raw::c_long {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hash_get_num_entries(arg_hashp: *mut HTAB) -> ::std::os::raw::c_long;
        }
        hash_get_num_entries(arg_hashp)
    })
}
pub unsafe fn hash_seq_init(arg_status: *mut HASH_SEQ_STATUS, arg_hashp: *mut HTAB) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hash_seq_init(arg_status: *mut HASH_SEQ_STATUS, arg_hashp: *mut HTAB);
        }
        hash_seq_init(arg_status, arg_hashp)
    })
}
pub unsafe fn hash_seq_search(arg_status: *mut HASH_SEQ_STATUS) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hash_seq_search(arg_status: *mut HASH_SEQ_STATUS) -> *mut ::std::os::raw::c_void;
        }
        hash_seq_search(arg_status)
    })
}
pub unsafe fn hash_seq_term(arg_status: *mut HASH_SEQ_STATUS) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hash_seq_term(arg_status: *mut HASH_SEQ_STATUS);
        }
        hash_seq_term(arg_status)
    })
}
pub unsafe fn hash_freeze(arg_hashp: *mut HTAB) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hash_freeze(arg_hashp: *mut HTAB);
        }
        hash_freeze(arg_hashp)
    })
}
pub unsafe fn hash_estimate_size(
    arg_num_entries: ::std::os::raw::c_long,
    arg_entrysize: Size,
) -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hash_estimate_size(
                arg_num_entries: ::std::os::raw::c_long,
                arg_entrysize: Size,
            ) -> Size;
        }
        hash_estimate_size(arg_num_entries, arg_entrysize)
    })
}
pub unsafe fn hash_select_dirsize(
    arg_num_entries: ::std::os::raw::c_long,
) -> ::std::os::raw::c_long {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hash_select_dirsize(
                arg_num_entries: ::std::os::raw::c_long,
            ) -> ::std::os::raw::c_long;
        }
        hash_select_dirsize(arg_num_entries)
    })
}
pub unsafe fn hash_get_shared_size(
    arg_info: *mut HASHCTL,
    arg_flags: ::std::os::raw::c_int,
) -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hash_get_shared_size(
                arg_info: *mut HASHCTL,
                arg_flags: ::std::os::raw::c_int,
            ) -> Size;
        }
        hash_get_shared_size(arg_info, arg_flags)
    })
}
pub unsafe fn AtEOXact_HashTables(arg_isCommit: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AtEOXact_HashTables(arg_isCommit: bool);
        }
        AtEOXact_HashTables(arg_isCommit)
    })
}
pub unsafe fn AtEOSubXact_HashTables(arg_isCommit: bool, arg_nestDepth: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AtEOSubXact_HashTables(arg_isCommit: bool, arg_nestDepth: ::std::os::raw::c_int);
        }
        AtEOSubXact_HashTables(arg_isCommit, arg_nestDepth)
    })
}
pub const EphemeralNameRelationType_ENR_NAMED_TUPLESTORE: EphemeralNameRelationType = 0;
pub type EphemeralNameRelationType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EphemeralNamedRelationMetadataData {
    pub name: *mut ::std::os::raw::c_char,
    pub reliddesc: Oid,
    pub tupdesc: TupleDesc,
    pub enrtype: EphemeralNameRelationType,
    pub enrtuples: f64,
}
impl Default for EphemeralNamedRelationMetadataData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type EphemeralNamedRelationMetadata = *mut EphemeralNamedRelationMetadataData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EphemeralNamedRelationData {
    pub md: EphemeralNamedRelationMetadataData,
    pub reldata: *mut ::std::os::raw::c_void,
}
impl Default for EphemeralNamedRelationData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type EphemeralNamedRelation = *mut EphemeralNamedRelationData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueryEnvironment {
    _unused: [u8; 0],
}
pub unsafe fn create_queryEnv() -> *mut QueryEnvironment {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_queryEnv() -> *mut QueryEnvironment;
        }
        create_queryEnv()
    })
}
pub unsafe fn get_visible_ENR_metadata(
    arg_queryEnv: *mut QueryEnvironment,
    arg_refname: *const ::std::os::raw::c_char,
) -> EphemeralNamedRelationMetadata {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_visible_ENR_metadata(
                arg_queryEnv: *mut QueryEnvironment,
                arg_refname: *const ::std::os::raw::c_char,
            ) -> EphemeralNamedRelationMetadata;
        }
        get_visible_ENR_metadata(arg_queryEnv, arg_refname)
    })
}
pub unsafe fn register_ENR(arg_queryEnv: *mut QueryEnvironment, arg_enr: EphemeralNamedRelation) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn register_ENR(arg_queryEnv: *mut QueryEnvironment, arg_enr: EphemeralNamedRelation);
        }
        register_ENR(arg_queryEnv, arg_enr)
    })
}
pub unsafe fn unregister_ENR(
    arg_queryEnv: *mut QueryEnvironment,
    arg_name: *const ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn unregister_ENR(
                arg_queryEnv: *mut QueryEnvironment,
                arg_name: *const ::std::os::raw::c_char,
            );
        }
        unregister_ENR(arg_queryEnv, arg_name)
    })
}
pub unsafe fn get_ENR(
    arg_queryEnv: *mut QueryEnvironment,
    arg_name: *const ::std::os::raw::c_char,
) -> EphemeralNamedRelation {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_ENR(
                arg_queryEnv: *mut QueryEnvironment,
                arg_name: *const ::std::os::raw::c_char,
            ) -> EphemeralNamedRelation;
        }
        get_ENR(arg_queryEnv, arg_name)
    })
}
pub unsafe fn ENRMetadataGetTupDesc(arg_enrmd: EphemeralNamedRelationMetadata) -> TupleDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ENRMetadataGetTupDesc(arg_enrmd: EphemeralNamedRelationMetadata) -> TupleDesc;
        }
        ENRMetadataGetTupDesc(arg_enrmd)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Trigger {
    pub tgoid: Oid,
    pub tgname: *mut ::std::os::raw::c_char,
    pub tgfoid: Oid,
    pub tgtype: int16,
    pub tgenabled: ::std::os::raw::c_char,
    pub tgisinternal: bool,
    pub tgisclone: bool,
    pub tgconstrrelid: Oid,
    pub tgconstrindid: Oid,
    pub tgconstraint: Oid,
    pub tgdeferrable: bool,
    pub tginitdeferred: bool,
    pub tgnargs: int16,
    pub tgnattr: int16,
    pub tgattr: *mut int16,
    pub tgargs: *mut *mut ::std::os::raw::c_char,
    pub tgqual: *mut ::std::os::raw::c_char,
    pub tgoldtable: *mut ::std::os::raw::c_char,
    pub tgnewtable: *mut ::std::os::raw::c_char,
}
impl Default for Trigger {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TriggerDesc {
    pub triggers: *mut Trigger,
    pub numtriggers: ::std::os::raw::c_int,
    pub trig_insert_before_row: bool,
    pub trig_insert_after_row: bool,
    pub trig_insert_instead_row: bool,
    pub trig_insert_before_statement: bool,
    pub trig_insert_after_statement: bool,
    pub trig_update_before_row: bool,
    pub trig_update_after_row: bool,
    pub trig_update_instead_row: bool,
    pub trig_update_before_statement: bool,
    pub trig_update_after_statement: bool,
    pub trig_delete_before_row: bool,
    pub trig_delete_after_row: bool,
    pub trig_delete_instead_row: bool,
    pub trig_delete_before_statement: bool,
    pub trig_delete_after_statement: bool,
    pub trig_truncate_before_statement: bool,
    pub trig_truncate_after_statement: bool,
    pub trig_insert_new_table: bool,
    pub trig_update_old_table: bool,
    pub trig_update_new_table: bool,
    pub trig_delete_old_table: bool,
}
impl Default for TriggerDesc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dirent {
    pub d_ino: __uint64_t,
    pub d_seekoff: __uint64_t,
    pub d_reclen: __uint16_t,
    pub d_namlen: __uint16_t,
    pub d_type: __uint8_t,
    pub d_name: [::std::os::raw::c_char; 1024usize],
}
impl Default for dirent {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _telldir {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DIR {
    pub __dd_fd: ::std::os::raw::c_int,
    pub __dd_loc: ::std::os::raw::c_long,
    pub __dd_size: ::std::os::raw::c_long,
    pub __dd_buf: *mut ::std::os::raw::c_char,
    pub __dd_len: ::std::os::raw::c_int,
    pub __dd_seek: ::std::os::raw::c_long,
    pub __padding: ::std::os::raw::c_long,
    pub __dd_flags: ::std::os::raw::c_int,
    pub __dd_lock: __darwin_pthread_mutex_t,
    pub __dd_td: *mut _telldir,
}
impl Default for DIR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn closedir(arg_arg1: *mut DIR) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn closedir(arg_arg1: *mut DIR) -> ::std::os::raw::c_int;
        }
        closedir(arg_arg1)
    })
}
pub unsafe fn opendir(arg_arg1: *const ::std::os::raw::c_char) -> *mut DIR {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn opendir(arg_arg1: *const ::std::os::raw::c_char) -> *mut DIR;
        }
        opendir(arg_arg1)
    })
}
pub unsafe fn readdir(arg_arg1: *mut DIR) -> *mut dirent {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn readdir(arg_arg1: *mut DIR) -> *mut dirent;
        }
        readdir(arg_arg1)
    })
}
pub unsafe fn readdir_r(
    arg_arg1: *mut DIR,
    arg_arg2: *mut dirent,
    arg_arg3: *mut *mut dirent,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn readdir_r(
                arg_arg1: *mut DIR,
                arg_arg2: *mut dirent,
                arg_arg3: *mut *mut dirent,
            ) -> ::std::os::raw::c_int;
        }
        readdir_r(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn rewinddir(arg_arg1: *mut DIR) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn rewinddir(arg_arg1: *mut DIR);
        }
        rewinddir(arg_arg1)
    })
}
pub unsafe fn seekdir(arg_arg1: *mut DIR, arg_arg2: ::std::os::raw::c_long) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn seekdir(arg_arg1: *mut DIR, arg_arg2: ::std::os::raw::c_long);
        }
        seekdir(arg_arg1, arg_arg2)
    })
}
pub unsafe fn telldir(arg_arg1: *mut DIR) -> ::std::os::raw::c_long {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn telldir(arg_arg1: *mut DIR) -> ::std::os::raw::c_long;
        }
        telldir(arg_arg1)
    })
}
pub unsafe fn fdopendir(arg_arg1: ::std::os::raw::c_int) -> *mut DIR {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fdopendir(arg_arg1: ::std::os::raw::c_int) -> *mut DIR;
        }
        fdopendir(arg_arg1)
    })
}
pub unsafe fn alphasort(
    arg_arg1: *mut *const dirent,
    arg_arg2: *mut *const dirent,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn alphasort(
                arg_arg1: *mut *const dirent,
                arg_arg2: *mut *const dirent,
            ) -> ::std::os::raw::c_int;
        }
        alphasort(arg_arg1, arg_arg2)
    })
}
pub unsafe fn dirfd(arg_dirp: *mut DIR) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dirfd(arg_dirp: *mut DIR) -> ::std::os::raw::c_int;
        }
        dirfd(arg_dirp)
    })
}
pub unsafe fn scandir(
    arg_arg1: *const ::std::os::raw::c_char,
    arg_arg2: *mut *mut *mut dirent,
    arg_arg3: ::std::option::Option<
        unsafe extern "C" fn(arg1: *const dirent) -> ::std::os::raw::c_int,
    >,
    arg_arg4: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut *const dirent,
            arg2: *mut *const dirent,
        ) -> ::std::os::raw::c_int,
    >,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn scandir(
                arg_arg1: *const ::std::os::raw::c_char,
                arg_arg2: *mut *mut *mut dirent,
                arg_arg3: ::std::option::Option<
                    unsafe extern "C" fn(arg1: *const dirent) -> ::std::os::raw::c_int,
                >,
                arg_arg4: ::std::option::Option<
                    unsafe extern "C" fn(
                        arg1: *mut *const dirent,
                        arg2: *mut *const dirent,
                    ) -> ::std::os::raw::c_int,
                >,
            ) -> ::std::os::raw::c_int;
        }
        scandir(arg_arg1, arg_arg2, arg_arg3, arg_arg4)
    })
}
pub unsafe fn scandir_b(
    arg_arg1: *const ::std::os::raw::c_char,
    arg_arg2: *mut *mut *mut dirent,
    arg_arg3: *mut ::std::os::raw::c_void,
    arg_arg4: *mut ::std::os::raw::c_void,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn scandir_b(
                arg_arg1: *const ::std::os::raw::c_char,
                arg_arg2: *mut *mut *mut dirent,
                arg_arg3: *mut ::std::os::raw::c_void,
                arg_arg4: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int;
        }
        scandir_b(arg_arg1, arg_arg2, arg_arg3, arg_arg4)
    })
}
pub unsafe fn getdirentries(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: *mut ::std::os::raw::c_char,
    arg_arg3: ::std::os::raw::c_int,
    arg_arg4: *mut ::std::os::raw::c_long,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getdirentries(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: *mut ::std::os::raw::c_char,
                arg_arg3: ::std::os::raw::c_int,
                arg_arg4: *mut ::std::os::raw::c_long,
            ) -> ::std::os::raw::c_int;
        }
        getdirentries(arg_arg1, arg_arg2, arg_arg3, arg_arg4)
    })
}
pub unsafe fn __opendir2(
    arg_arg1: *const ::std::os::raw::c_char,
    arg_arg2: ::std::os::raw::c_int,
) -> *mut DIR {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn __opendir2(
                arg_arg1: *const ::std::os::raw::c_char,
                arg_arg2: ::std::os::raw::c_int,
            ) -> *mut DIR;
        }
        __opendir2(arg_arg1, arg_arg2)
    })
}
pub type File = ::std::os::raw::c_int;
extern "C" {
    pub static mut max_files_per_process: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut data_sync_retry: bool;
}
extern "C" {
    pub static mut max_safe_fds: ::std::os::raw::c_int;
}
pub unsafe fn PathNameOpenFile(
    arg_fileName: *const ::std::os::raw::c_char,
    arg_fileFlags: ::std::os::raw::c_int,
) -> File {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PathNameOpenFile(
                arg_fileName: *const ::std::os::raw::c_char,
                arg_fileFlags: ::std::os::raw::c_int,
            ) -> File;
        }
        PathNameOpenFile(arg_fileName, arg_fileFlags)
    })
}
pub unsafe fn PathNameOpenFilePerm(
    arg_fileName: *const ::std::os::raw::c_char,
    arg_fileFlags: ::std::os::raw::c_int,
    arg_fileMode: mode_t,
) -> File {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PathNameOpenFilePerm(
                arg_fileName: *const ::std::os::raw::c_char,
                arg_fileFlags: ::std::os::raw::c_int,
                arg_fileMode: mode_t,
            ) -> File;
        }
        PathNameOpenFilePerm(arg_fileName, arg_fileFlags, arg_fileMode)
    })
}
pub unsafe fn OpenTemporaryFile(arg_interXact: bool) -> File {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn OpenTemporaryFile(arg_interXact: bool) -> File;
        }
        OpenTemporaryFile(arg_interXact)
    })
}
pub unsafe fn FileClose(arg_file: File) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FileClose(arg_file: File);
        }
        FileClose(arg_file)
    })
}
pub unsafe fn FilePrefetch(
    arg_file: File,
    arg_offset: off_t,
    arg_amount: ::std::os::raw::c_int,
    arg_wait_event_info: uint32,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FilePrefetch(
                arg_file: File,
                arg_offset: off_t,
                arg_amount: ::std::os::raw::c_int,
                arg_wait_event_info: uint32,
            ) -> ::std::os::raw::c_int;
        }
        FilePrefetch(arg_file, arg_offset, arg_amount, arg_wait_event_info)
    })
}
pub unsafe fn FileRead(
    arg_file: File,
    arg_buffer: *mut ::std::os::raw::c_char,
    arg_amount: ::std::os::raw::c_int,
    arg_offset: off_t,
    arg_wait_event_info: uint32,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FileRead(
                arg_file: File,
                arg_buffer: *mut ::std::os::raw::c_char,
                arg_amount: ::std::os::raw::c_int,
                arg_offset: off_t,
                arg_wait_event_info: uint32,
            ) -> ::std::os::raw::c_int;
        }
        FileRead(arg_file, arg_buffer, arg_amount, arg_offset, arg_wait_event_info)
    })
}
pub unsafe fn FileWrite(
    arg_file: File,
    arg_buffer: *mut ::std::os::raw::c_char,
    arg_amount: ::std::os::raw::c_int,
    arg_offset: off_t,
    arg_wait_event_info: uint32,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FileWrite(
                arg_file: File,
                arg_buffer: *mut ::std::os::raw::c_char,
                arg_amount: ::std::os::raw::c_int,
                arg_offset: off_t,
                arg_wait_event_info: uint32,
            ) -> ::std::os::raw::c_int;
        }
        FileWrite(arg_file, arg_buffer, arg_amount, arg_offset, arg_wait_event_info)
    })
}
pub unsafe fn FileSync(arg_file: File, arg_wait_event_info: uint32) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FileSync(arg_file: File, arg_wait_event_info: uint32) -> ::std::os::raw::c_int;
        }
        FileSync(arg_file, arg_wait_event_info)
    })
}
pub unsafe fn FileSize(arg_file: File) -> off_t {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FileSize(arg_file: File) -> off_t;
        }
        FileSize(arg_file)
    })
}
pub unsafe fn FileTruncate(
    arg_file: File,
    arg_offset: off_t,
    arg_wait_event_info: uint32,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FileTruncate(
                arg_file: File,
                arg_offset: off_t,
                arg_wait_event_info: uint32,
            ) -> ::std::os::raw::c_int;
        }
        FileTruncate(arg_file, arg_offset, arg_wait_event_info)
    })
}
pub unsafe fn FileWriteback(
    arg_file: File,
    arg_offset: off_t,
    arg_nbytes: off_t,
    arg_wait_event_info: uint32,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FileWriteback(
                arg_file: File,
                arg_offset: off_t,
                arg_nbytes: off_t,
                arg_wait_event_info: uint32,
            );
        }
        FileWriteback(arg_file, arg_offset, arg_nbytes, arg_wait_event_info)
    })
}
pub unsafe fn FilePathName(arg_file: File) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FilePathName(arg_file: File) -> *mut ::std::os::raw::c_char;
        }
        FilePathName(arg_file)
    })
}
pub unsafe fn FileGetRawDesc(arg_file: File) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FileGetRawDesc(arg_file: File) -> ::std::os::raw::c_int;
        }
        FileGetRawDesc(arg_file)
    })
}
pub unsafe fn FileGetRawFlags(arg_file: File) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FileGetRawFlags(arg_file: File) -> ::std::os::raw::c_int;
        }
        FileGetRawFlags(arg_file)
    })
}
pub unsafe fn FileGetRawMode(arg_file: File) -> mode_t {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FileGetRawMode(arg_file: File) -> mode_t;
        }
        FileGetRawMode(arg_file)
    })
}
pub unsafe fn PathNameCreateTemporaryFile(
    arg_name: *const ::std::os::raw::c_char,
    arg_error_on_failure: bool,
) -> File {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PathNameCreateTemporaryFile(
                arg_name: *const ::std::os::raw::c_char,
                arg_error_on_failure: bool,
            ) -> File;
        }
        PathNameCreateTemporaryFile(arg_name, arg_error_on_failure)
    })
}
pub unsafe fn PathNameOpenTemporaryFile(arg_name: *const ::std::os::raw::c_char) -> File {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PathNameOpenTemporaryFile(arg_name: *const ::std::os::raw::c_char) -> File;
        }
        PathNameOpenTemporaryFile(arg_name)
    })
}
pub unsafe fn PathNameDeleteTemporaryFile(
    arg_name: *const ::std::os::raw::c_char,
    arg_error_on_failure: bool,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PathNameDeleteTemporaryFile(
                arg_name: *const ::std::os::raw::c_char,
                arg_error_on_failure: bool,
            ) -> bool;
        }
        PathNameDeleteTemporaryFile(arg_name, arg_error_on_failure)
    })
}
pub unsafe fn PathNameCreateTemporaryDir(
    arg_base: *const ::std::os::raw::c_char,
    arg_name: *const ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PathNameCreateTemporaryDir(
                arg_base: *const ::std::os::raw::c_char,
                arg_name: *const ::std::os::raw::c_char,
            );
        }
        PathNameCreateTemporaryDir(arg_base, arg_name)
    })
}
pub unsafe fn PathNameDeleteTemporaryDir(arg_name: *const ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PathNameDeleteTemporaryDir(arg_name: *const ::std::os::raw::c_char);
        }
        PathNameDeleteTemporaryDir(arg_name)
    })
}
pub unsafe fn TempTablespacePath(arg_path: *mut ::std::os::raw::c_char, arg_tablespace: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TempTablespacePath(arg_path: *mut ::std::os::raw::c_char, arg_tablespace: Oid);
        }
        TempTablespacePath(arg_path, arg_tablespace)
    })
}
pub unsafe fn AllocateFile(
    arg_name: *const ::std::os::raw::c_char,
    arg_mode: *const ::std::os::raw::c_char,
) -> *mut FILE {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AllocateFile(
                arg_name: *const ::std::os::raw::c_char,
                arg_mode: *const ::std::os::raw::c_char,
            ) -> *mut FILE;
        }
        AllocateFile(arg_name, arg_mode)
    })
}
pub unsafe fn FreeFile(arg_file: *mut FILE) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FreeFile(arg_file: *mut FILE) -> ::std::os::raw::c_int;
        }
        FreeFile(arg_file)
    })
}
pub unsafe fn OpenPipeStream(
    arg_command: *const ::std::os::raw::c_char,
    arg_mode: *const ::std::os::raw::c_char,
) -> *mut FILE {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn OpenPipeStream(
                arg_command: *const ::std::os::raw::c_char,
                arg_mode: *const ::std::os::raw::c_char,
            ) -> *mut FILE;
        }
        OpenPipeStream(arg_command, arg_mode)
    })
}
pub unsafe fn ClosePipeStream(arg_file: *mut FILE) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ClosePipeStream(arg_file: *mut FILE) -> ::std::os::raw::c_int;
        }
        ClosePipeStream(arg_file)
    })
}
pub unsafe fn AllocateDir(arg_dirname: *const ::std::os::raw::c_char) -> *mut DIR {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AllocateDir(arg_dirname: *const ::std::os::raw::c_char) -> *mut DIR;
        }
        AllocateDir(arg_dirname)
    })
}
pub unsafe fn ReadDir(
    arg_dir: *mut DIR,
    arg_dirname: *const ::std::os::raw::c_char,
) -> *mut dirent {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReadDir(
                arg_dir: *mut DIR,
                arg_dirname: *const ::std::os::raw::c_char,
            ) -> *mut dirent;
        }
        ReadDir(arg_dir, arg_dirname)
    })
}
pub unsafe fn ReadDirExtended(
    arg_dir: *mut DIR,
    arg_dirname: *const ::std::os::raw::c_char,
    arg_elevel: ::std::os::raw::c_int,
) -> *mut dirent {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReadDirExtended(
                arg_dir: *mut DIR,
                arg_dirname: *const ::std::os::raw::c_char,
                arg_elevel: ::std::os::raw::c_int,
            ) -> *mut dirent;
        }
        ReadDirExtended(arg_dir, arg_dirname, arg_elevel)
    })
}
pub unsafe fn FreeDir(arg_dir: *mut DIR) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FreeDir(arg_dir: *mut DIR) -> ::std::os::raw::c_int;
        }
        FreeDir(arg_dir)
    })
}
pub unsafe fn OpenTransientFile(
    arg_fileName: *const ::std::os::raw::c_char,
    arg_fileFlags: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn OpenTransientFile(
                arg_fileName: *const ::std::os::raw::c_char,
                arg_fileFlags: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        OpenTransientFile(arg_fileName, arg_fileFlags)
    })
}
pub unsafe fn OpenTransientFilePerm(
    arg_fileName: *const ::std::os::raw::c_char,
    arg_fileFlags: ::std::os::raw::c_int,
    arg_fileMode: mode_t,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn OpenTransientFilePerm(
                arg_fileName: *const ::std::os::raw::c_char,
                arg_fileFlags: ::std::os::raw::c_int,
                arg_fileMode: mode_t,
            ) -> ::std::os::raw::c_int;
        }
        OpenTransientFilePerm(arg_fileName, arg_fileFlags, arg_fileMode)
    })
}
pub unsafe fn CloseTransientFile(arg_fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CloseTransientFile(arg_fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        CloseTransientFile(arg_fd)
    })
}
pub unsafe fn BasicOpenFile(
    arg_fileName: *const ::std::os::raw::c_char,
    arg_fileFlags: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BasicOpenFile(
                arg_fileName: *const ::std::os::raw::c_char,
                arg_fileFlags: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        BasicOpenFile(arg_fileName, arg_fileFlags)
    })
}
pub unsafe fn BasicOpenFilePerm(
    arg_fileName: *const ::std::os::raw::c_char,
    arg_fileFlags: ::std::os::raw::c_int,
    arg_fileMode: mode_t,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BasicOpenFilePerm(
                arg_fileName: *const ::std::os::raw::c_char,
                arg_fileFlags: ::std::os::raw::c_int,
                arg_fileMode: mode_t,
            ) -> ::std::os::raw::c_int;
        }
        BasicOpenFilePerm(arg_fileName, arg_fileFlags, arg_fileMode)
    })
}
pub unsafe fn AcquireExternalFD() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AcquireExternalFD() -> bool;
        }
        AcquireExternalFD()
    })
}
pub unsafe fn ReserveExternalFD() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReserveExternalFD();
        }
        ReserveExternalFD()
    })
}
pub unsafe fn ReleaseExternalFD() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReleaseExternalFD();
        }
        ReleaseExternalFD()
    })
}
pub unsafe fn MakePGDirectory(
    arg_directoryName: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MakePGDirectory(
                arg_directoryName: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        MakePGDirectory(arg_directoryName)
    })
}
pub unsafe fn InitFileAccess() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitFileAccess();
        }
        InitFileAccess()
    })
}
pub unsafe fn set_max_safe_fds() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn set_max_safe_fds();
        }
        set_max_safe_fds()
    })
}
pub unsafe fn closeAllVfds() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn closeAllVfds();
        }
        closeAllVfds()
    })
}
pub unsafe fn SetTempTablespaces(arg_tableSpaces: *mut Oid, arg_numSpaces: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SetTempTablespaces(arg_tableSpaces: *mut Oid, arg_numSpaces: ::std::os::raw::c_int);
        }
        SetTempTablespaces(arg_tableSpaces, arg_numSpaces)
    })
}
pub unsafe fn TempTablespacesAreSet() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TempTablespacesAreSet() -> bool;
        }
        TempTablespacesAreSet()
    })
}
pub unsafe fn GetTempTablespaces(
    arg_tableSpaces: *mut Oid,
    arg_numSpaces: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetTempTablespaces(
                arg_tableSpaces: *mut Oid,
                arg_numSpaces: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        GetTempTablespaces(arg_tableSpaces, arg_numSpaces)
    })
}
pub unsafe fn GetNextTempTableSpace() -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetNextTempTableSpace() -> Oid;
        }
        GetNextTempTableSpace()
    })
}
pub unsafe fn AtEOXact_Files(arg_isCommit: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AtEOXact_Files(arg_isCommit: bool);
        }
        AtEOXact_Files(arg_isCommit)
    })
}
pub unsafe fn AtEOSubXact_Files(
    arg_isCommit: bool,
    arg_mySubid: SubTransactionId,
    arg_parentSubid: SubTransactionId,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AtEOSubXact_Files(
                arg_isCommit: bool,
                arg_mySubid: SubTransactionId,
                arg_parentSubid: SubTransactionId,
            );
        }
        AtEOSubXact_Files(arg_isCommit, arg_mySubid, arg_parentSubid)
    })
}
pub unsafe fn RemovePgTempFiles() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RemovePgTempFiles();
        }
        RemovePgTempFiles()
    })
}
pub unsafe fn RemovePgTempFilesInDir(
    arg_tmpdirname: *const ::std::os::raw::c_char,
    arg_missing_ok: bool,
    arg_unlink_all: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RemovePgTempFilesInDir(
                arg_tmpdirname: *const ::std::os::raw::c_char,
                arg_missing_ok: bool,
                arg_unlink_all: bool,
            );
        }
        RemovePgTempFilesInDir(arg_tmpdirname, arg_missing_ok, arg_unlink_all)
    })
}
pub unsafe fn looks_like_temp_rel_name(arg_name: *const ::std::os::raw::c_char) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn looks_like_temp_rel_name(arg_name: *const ::std::os::raw::c_char) -> bool;
        }
        looks_like_temp_rel_name(arg_name)
    })
}
pub unsafe fn pg_fsync(arg_fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_fsync(arg_fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        pg_fsync(arg_fd)
    })
}
pub unsafe fn pg_fsync_no_writethrough(arg_fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_fsync_no_writethrough(arg_fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        pg_fsync_no_writethrough(arg_fd)
    })
}
pub unsafe fn pg_fsync_writethrough(arg_fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_fsync_writethrough(arg_fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        pg_fsync_writethrough(arg_fd)
    })
}
pub unsafe fn pg_fdatasync(arg_fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_fdatasync(arg_fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        pg_fdatasync(arg_fd)
    })
}
pub unsafe fn pg_flush_data(arg_fd: ::std::os::raw::c_int, arg_offset: off_t, arg_amount: off_t) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_flush_data(arg_fd: ::std::os::raw::c_int, arg_offset: off_t, arg_amount: off_t);
        }
        pg_flush_data(arg_fd, arg_offset, arg_amount)
    })
}
pub unsafe fn fsync_fname(arg_fname: *const ::std::os::raw::c_char, arg_isdir: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fsync_fname(arg_fname: *const ::std::os::raw::c_char, arg_isdir: bool);
        }
        fsync_fname(arg_fname, arg_isdir)
    })
}
pub unsafe fn fsync_fname_ext(
    arg_fname: *const ::std::os::raw::c_char,
    arg_isdir: bool,
    arg_ignore_perm: bool,
    arg_elevel: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fsync_fname_ext(
                arg_fname: *const ::std::os::raw::c_char,
                arg_isdir: bool,
                arg_ignore_perm: bool,
                arg_elevel: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        fsync_fname_ext(arg_fname, arg_isdir, arg_ignore_perm, arg_elevel)
    })
}
pub unsafe fn durable_rename(
    arg_oldfile: *const ::std::os::raw::c_char,
    arg_newfile: *const ::std::os::raw::c_char,
    arg_loglevel: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn durable_rename(
                arg_oldfile: *const ::std::os::raw::c_char,
                arg_newfile: *const ::std::os::raw::c_char,
                arg_loglevel: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        durable_rename(arg_oldfile, arg_newfile, arg_loglevel)
    })
}
pub unsafe fn durable_unlink(
    arg_fname: *const ::std::os::raw::c_char,
    arg_loglevel: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn durable_unlink(
                arg_fname: *const ::std::os::raw::c_char,
                arg_loglevel: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        durable_unlink(arg_fname, arg_loglevel)
    })
}
pub unsafe fn durable_rename_excl(
    arg_oldfile: *const ::std::os::raw::c_char,
    arg_newfile: *const ::std::os::raw::c_char,
    arg_loglevel: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn durable_rename_excl(
                arg_oldfile: *const ::std::os::raw::c_char,
                arg_newfile: *const ::std::os::raw::c_char,
                arg_loglevel: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        durable_rename_excl(arg_oldfile, arg_newfile, arg_loglevel)
    })
}
pub unsafe fn SyncDataDirectory() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SyncDataDirectory();
        }
        SyncDataDirectory()
    })
}
pub unsafe fn data_sync_elevel(arg_elevel: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn data_sync_elevel(arg_elevel: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        data_sync_elevel(arg_elevel)
    })
}
pub unsafe fn SpinlockSemas() -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SpinlockSemas() -> ::std::os::raw::c_int;
        }
        SpinlockSemas()
    })
}
pub unsafe fn SpinlockSemaSize() -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SpinlockSemaSize() -> Size;
        }
        SpinlockSemaSize()
    })
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SharedFileSet {
    pub creator_pid: pid_t,
    pub number: uint32,
    pub mutex: slock_t,
    pub refcnt: ::std::os::raw::c_int,
    pub ntablespaces: ::std::os::raw::c_int,
    pub tablespaces: [Oid; 8usize],
}
pub unsafe fn SharedFileSetInit(arg_fileset: *mut SharedFileSet, arg_seg: *mut dsm_segment) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SharedFileSetInit(arg_fileset: *mut SharedFileSet, arg_seg: *mut dsm_segment);
        }
        SharedFileSetInit(arg_fileset, arg_seg)
    })
}
pub unsafe fn SharedFileSetAttach(arg_fileset: *mut SharedFileSet, arg_seg: *mut dsm_segment) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SharedFileSetAttach(arg_fileset: *mut SharedFileSet, arg_seg: *mut dsm_segment);
        }
        SharedFileSetAttach(arg_fileset, arg_seg)
    })
}
pub unsafe fn SharedFileSetCreate(
    arg_fileset: *mut SharedFileSet,
    arg_name: *const ::std::os::raw::c_char,
) -> File {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SharedFileSetCreate(
                arg_fileset: *mut SharedFileSet,
                arg_name: *const ::std::os::raw::c_char,
            ) -> File;
        }
        SharedFileSetCreate(arg_fileset, arg_name)
    })
}
pub unsafe fn SharedFileSetOpen(
    arg_fileset: *mut SharedFileSet,
    arg_name: *const ::std::os::raw::c_char,
) -> File {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SharedFileSetOpen(
                arg_fileset: *mut SharedFileSet,
                arg_name: *const ::std::os::raw::c_char,
            ) -> File;
        }
        SharedFileSetOpen(arg_fileset, arg_name)
    })
}
pub unsafe fn SharedFileSetDelete(
    arg_fileset: *mut SharedFileSet,
    arg_name: *const ::std::os::raw::c_char,
    arg_error_on_failure: bool,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SharedFileSetDelete(
                arg_fileset: *mut SharedFileSet,
                arg_name: *const ::std::os::raw::c_char,
                arg_error_on_failure: bool,
            ) -> bool;
        }
        SharedFileSetDelete(arg_fileset, arg_name, arg_error_on_failure)
    })
}
pub unsafe fn SharedFileSetDeleteAll(arg_fileset: *mut SharedFileSet) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SharedFileSetDeleteAll(arg_fileset: *mut SharedFileSet);
        }
        SharedFileSetDeleteAll(arg_fileset)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SharedTuplestore {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SharedTuplestoreAccessor {
    _unused: [u8; 0],
}
pub unsafe fn sts_estimate(arg_participants: ::std::os::raw::c_int) -> usize {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sts_estimate(arg_participants: ::std::os::raw::c_int) -> usize;
        }
        sts_estimate(arg_participants)
    })
}
pub unsafe fn sts_initialize(
    arg_sts: *mut SharedTuplestore,
    arg_participants: ::std::os::raw::c_int,
    arg_my_participant_number: ::std::os::raw::c_int,
    arg_meta_data_size: usize,
    arg_flags: ::std::os::raw::c_int,
    arg_fileset: *mut SharedFileSet,
    arg_name: *const ::std::os::raw::c_char,
) -> *mut SharedTuplestoreAccessor {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sts_initialize(
                arg_sts: *mut SharedTuplestore,
                arg_participants: ::std::os::raw::c_int,
                arg_my_participant_number: ::std::os::raw::c_int,
                arg_meta_data_size: usize,
                arg_flags: ::std::os::raw::c_int,
                arg_fileset: *mut SharedFileSet,
                arg_name: *const ::std::os::raw::c_char,
            ) -> *mut SharedTuplestoreAccessor;
        }
        sts_initialize(
            arg_sts,
            arg_participants,
            arg_my_participant_number,
            arg_meta_data_size,
            arg_flags,
            arg_fileset,
            arg_name,
        )
    })
}
pub unsafe fn sts_attach(
    arg_sts: *mut SharedTuplestore,
    arg_my_participant_number: ::std::os::raw::c_int,
    arg_fileset: *mut SharedFileSet,
) -> *mut SharedTuplestoreAccessor {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sts_attach(
                arg_sts: *mut SharedTuplestore,
                arg_my_participant_number: ::std::os::raw::c_int,
                arg_fileset: *mut SharedFileSet,
            ) -> *mut SharedTuplestoreAccessor;
        }
        sts_attach(arg_sts, arg_my_participant_number, arg_fileset)
    })
}
pub unsafe fn sts_end_write(arg_accessor: *mut SharedTuplestoreAccessor) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sts_end_write(arg_accessor: *mut SharedTuplestoreAccessor);
        }
        sts_end_write(arg_accessor)
    })
}
pub unsafe fn sts_reinitialize(arg_accessor: *mut SharedTuplestoreAccessor) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sts_reinitialize(arg_accessor: *mut SharedTuplestoreAccessor);
        }
        sts_reinitialize(arg_accessor)
    })
}
pub unsafe fn sts_begin_parallel_scan(arg_accessor: *mut SharedTuplestoreAccessor) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sts_begin_parallel_scan(arg_accessor: *mut SharedTuplestoreAccessor);
        }
        sts_begin_parallel_scan(arg_accessor)
    })
}
pub unsafe fn sts_end_parallel_scan(arg_accessor: *mut SharedTuplestoreAccessor) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sts_end_parallel_scan(arg_accessor: *mut SharedTuplestoreAccessor);
        }
        sts_end_parallel_scan(arg_accessor)
    })
}
pub unsafe fn sts_puttuple(
    arg_accessor: *mut SharedTuplestoreAccessor,
    arg_meta_data: *mut ::std::os::raw::c_void,
    arg_tuple: MinimalTuple,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sts_puttuple(
                arg_accessor: *mut SharedTuplestoreAccessor,
                arg_meta_data: *mut ::std::os::raw::c_void,
                arg_tuple: MinimalTuple,
            );
        }
        sts_puttuple(arg_accessor, arg_meta_data, arg_tuple)
    })
}
pub unsafe fn sts_parallel_scan_next(
    arg_accessor: *mut SharedTuplestoreAccessor,
    arg_meta_data: *mut ::std::os::raw::c_void,
) -> MinimalTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sts_parallel_scan_next(
                arg_accessor: *mut SharedTuplestoreAccessor,
                arg_meta_data: *mut ::std::os::raw::c_void,
            ) -> MinimalTuple;
        }
        sts_parallel_scan_next(arg_accessor, arg_meta_data)
    })
}
pub type Timestamp = int64;
pub type TimestampTz = int64;
pub type TimeOffset = int64;
pub type fsec_t = int32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Interval {
    pub time: TimeOffset,
    pub day: int32,
    pub month: int32,
}
pub const SnapshotType_SNAPSHOT_MVCC: SnapshotType = 0;
pub const SnapshotType_SNAPSHOT_SELF: SnapshotType = 1;
pub const SnapshotType_SNAPSHOT_ANY: SnapshotType = 2;
pub const SnapshotType_SNAPSHOT_TOAST: SnapshotType = 3;
pub const SnapshotType_SNAPSHOT_DIRTY: SnapshotType = 4;
pub const SnapshotType_SNAPSHOT_HISTORIC_MVCC: SnapshotType = 5;
pub const SnapshotType_SNAPSHOT_NON_VACUUMABLE: SnapshotType = 6;
pub type SnapshotType = ::std::os::raw::c_uint;
pub type Snapshot = *mut SnapshotData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SnapshotData {
    pub snapshot_type: SnapshotType,
    pub xmin: TransactionId,
    pub xmax: TransactionId,
    pub xip: *mut TransactionId,
    pub xcnt: uint32,
    pub subxip: *mut TransactionId,
    pub subxcnt: int32,
    pub suboverflowed: bool,
    pub takenDuringRecovery: bool,
    pub copied: bool,
    pub curcid: CommandId,
    pub speculativeToken: uint32,
    pub active_count: uint32,
    pub regd_count: uint32,
    pub ph_node: pairingheap_node,
    pub whenTaken: TimestampTz,
    pub lsn: XLogRecPtr,
}
impl Default for SnapshotData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Relation = *mut RelationData;
pub type RelationPtr = *mut Relation;
pub unsafe fn RelationIdGetRelation(arg_relationId: Oid) -> Relation {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationIdGetRelation(arg_relationId: Oid) -> Relation;
        }
        RelationIdGetRelation(arg_relationId)
    })
}
pub unsafe fn RelationClose(arg_relation: Relation) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationClose(arg_relation: Relation);
        }
        RelationClose(arg_relation)
    })
}
pub unsafe fn RelationGetFKeyList(arg_relation: Relation) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationGetFKeyList(arg_relation: Relation) -> *mut List;
        }
        RelationGetFKeyList(arg_relation)
    })
}
pub unsafe fn RelationGetIndexList(arg_relation: Relation) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationGetIndexList(arg_relation: Relation) -> *mut List;
        }
        RelationGetIndexList(arg_relation)
    })
}
pub unsafe fn RelationGetStatExtList(arg_relation: Relation) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationGetStatExtList(arg_relation: Relation) -> *mut List;
        }
        RelationGetStatExtList(arg_relation)
    })
}
pub unsafe fn RelationGetPrimaryKeyIndex(arg_relation: Relation) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationGetPrimaryKeyIndex(arg_relation: Relation) -> Oid;
        }
        RelationGetPrimaryKeyIndex(arg_relation)
    })
}
pub unsafe fn RelationGetReplicaIndex(arg_relation: Relation) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationGetReplicaIndex(arg_relation: Relation) -> Oid;
        }
        RelationGetReplicaIndex(arg_relation)
    })
}
pub unsafe fn RelationGetIndexExpressions(arg_relation: Relation) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationGetIndexExpressions(arg_relation: Relation) -> *mut List;
        }
        RelationGetIndexExpressions(arg_relation)
    })
}
pub unsafe fn RelationGetDummyIndexExpressions(arg_relation: Relation) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationGetDummyIndexExpressions(arg_relation: Relation) -> *mut List;
        }
        RelationGetDummyIndexExpressions(arg_relation)
    })
}
pub unsafe fn RelationGetIndexPredicate(arg_relation: Relation) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationGetIndexPredicate(arg_relation: Relation) -> *mut List;
        }
        RelationGetIndexPredicate(arg_relation)
    })
}
pub unsafe fn RelationGetIndexRawAttOptions(arg_relation: Relation) -> *mut Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationGetIndexRawAttOptions(arg_relation: Relation) -> *mut Datum;
        }
        RelationGetIndexRawAttOptions(arg_relation)
    })
}
pub unsafe fn RelationGetIndexAttOptions(
    arg_relation: Relation,
    arg_copy: bool,
) -> *mut *mut bytea {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationGetIndexAttOptions(
                arg_relation: Relation,
                arg_copy: bool,
            ) -> *mut *mut bytea;
        }
        RelationGetIndexAttOptions(arg_relation, arg_copy)
    })
}
pub const IndexAttrBitmapKind_INDEX_ATTR_BITMAP_ALL: IndexAttrBitmapKind = 0;
pub const IndexAttrBitmapKind_INDEX_ATTR_BITMAP_KEY: IndexAttrBitmapKind = 1;
pub const IndexAttrBitmapKind_INDEX_ATTR_BITMAP_PRIMARY_KEY: IndexAttrBitmapKind = 2;
pub const IndexAttrBitmapKind_INDEX_ATTR_BITMAP_IDENTITY_KEY: IndexAttrBitmapKind = 3;
pub type IndexAttrBitmapKind = ::std::os::raw::c_uint;
pub unsafe fn RelationGetIndexAttrBitmap(
    arg_relation: Relation,
    arg_attrKind: IndexAttrBitmapKind,
) -> *mut Bitmapset {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationGetIndexAttrBitmap(
                arg_relation: Relation,
                arg_attrKind: IndexAttrBitmapKind,
            ) -> *mut Bitmapset;
        }
        RelationGetIndexAttrBitmap(arg_relation, arg_attrKind)
    })
}
pub unsafe fn RelationGetExclusionInfo(
    arg_indexRelation: Relation,
    arg_operators: *mut *mut Oid,
    arg_procs: *mut *mut Oid,
    arg_strategies: *mut *mut uint16,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationGetExclusionInfo(
                arg_indexRelation: Relation,
                arg_operators: *mut *mut Oid,
                arg_procs: *mut *mut Oid,
                arg_strategies: *mut *mut uint16,
            );
        }
        RelationGetExclusionInfo(arg_indexRelation, arg_operators, arg_procs, arg_strategies)
    })
}
pub unsafe fn RelationInitIndexAccessInfo(arg_relation: Relation) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationInitIndexAccessInfo(arg_relation: Relation);
        }
        RelationInitIndexAccessInfo(arg_relation)
    })
}
pub unsafe fn GetRelationPublicationActions(arg_relation: Relation) -> *mut PublicationActions {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetRelationPublicationActions(arg_relation: Relation) -> *mut PublicationActions;
        }
        GetRelationPublicationActions(arg_relation)
    })
}
pub unsafe fn RelationInitTableAccessMethod(arg_relation: Relation) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationInitTableAccessMethod(arg_relation: Relation);
        }
        RelationInitTableAccessMethod(arg_relation)
    })
}
pub unsafe fn errtable(arg_rel: Relation) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn errtable(arg_rel: Relation) -> ::std::os::raw::c_int;
        }
        errtable(arg_rel)
    })
}
pub unsafe fn errtablecol(
    arg_rel: Relation,
    arg_attnum: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn errtablecol(
                arg_rel: Relation,
                arg_attnum: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        errtablecol(arg_rel, arg_attnum)
    })
}
pub unsafe fn errtablecolname(
    arg_rel: Relation,
    arg_colname: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn errtablecolname(
                arg_rel: Relation,
                arg_colname: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        errtablecolname(arg_rel, arg_colname)
    })
}
pub unsafe fn errtableconstraint(
    arg_rel: Relation,
    arg_conname: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn errtableconstraint(
                arg_rel: Relation,
                arg_conname: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        errtableconstraint(arg_rel, arg_conname)
    })
}
pub unsafe fn RelationCacheInitialize() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationCacheInitialize();
        }
        RelationCacheInitialize()
    })
}
pub unsafe fn RelationCacheInitializePhase2() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationCacheInitializePhase2();
        }
        RelationCacheInitializePhase2()
    })
}
pub unsafe fn RelationCacheInitializePhase3() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationCacheInitializePhase3();
        }
        RelationCacheInitializePhase3()
    })
}
pub unsafe fn RelationBuildLocalRelation(
    arg_relname: *const ::std::os::raw::c_char,
    arg_relnamespace: Oid,
    arg_tupDesc: TupleDesc,
    arg_relid: Oid,
    arg_accessmtd: Oid,
    arg_relfilenode: Oid,
    arg_reltablespace: Oid,
    arg_shared_relation: bool,
    arg_mapped_relation: bool,
    arg_relpersistence: ::std::os::raw::c_char,
    arg_relkind: ::std::os::raw::c_char,
) -> Relation {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationBuildLocalRelation(
                arg_relname: *const ::std::os::raw::c_char,
                arg_relnamespace: Oid,
                arg_tupDesc: TupleDesc,
                arg_relid: Oid,
                arg_accessmtd: Oid,
                arg_relfilenode: Oid,
                arg_reltablespace: Oid,
                arg_shared_relation: bool,
                arg_mapped_relation: bool,
                arg_relpersistence: ::std::os::raw::c_char,
                arg_relkind: ::std::os::raw::c_char,
            ) -> Relation;
        }
        RelationBuildLocalRelation(
            arg_relname,
            arg_relnamespace,
            arg_tupDesc,
            arg_relid,
            arg_accessmtd,
            arg_relfilenode,
            arg_reltablespace,
            arg_shared_relation,
            arg_mapped_relation,
            arg_relpersistence,
            arg_relkind,
        )
    })
}
pub unsafe fn RelationSetNewRelfilenode(
    arg_relation: Relation,
    arg_persistence: ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationSetNewRelfilenode(
                arg_relation: Relation,
                arg_persistence: ::std::os::raw::c_char,
            );
        }
        RelationSetNewRelfilenode(arg_relation, arg_persistence)
    })
}
pub unsafe fn RelationAssumeNewRelfilenode(arg_relation: Relation) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationAssumeNewRelfilenode(arg_relation: Relation);
        }
        RelationAssumeNewRelfilenode(arg_relation)
    })
}
pub unsafe fn RelationForgetRelation(arg_rid: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationForgetRelation(arg_rid: Oid);
        }
        RelationForgetRelation(arg_rid)
    })
}
pub unsafe fn RelationCacheInvalidateEntry(arg_relationId: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationCacheInvalidateEntry(arg_relationId: Oid);
        }
        RelationCacheInvalidateEntry(arg_relationId)
    })
}
pub unsafe fn RelationCacheInvalidate(arg_debug_discard: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationCacheInvalidate(arg_debug_discard: bool);
        }
        RelationCacheInvalidate(arg_debug_discard)
    })
}
pub unsafe fn RelationCloseSmgrByOid(arg_relationId: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationCloseSmgrByOid(arg_relationId: Oid);
        }
        RelationCloseSmgrByOid(arg_relationId)
    })
}
pub unsafe fn AssertPendingSyncs_RelationCache() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AssertPendingSyncs_RelationCache();
        }
        AssertPendingSyncs_RelationCache()
    })
}
pub unsafe fn AtEOXact_RelationCache(arg_isCommit: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AtEOXact_RelationCache(arg_isCommit: bool);
        }
        AtEOXact_RelationCache(arg_isCommit)
    })
}
pub unsafe fn AtEOSubXact_RelationCache(
    arg_isCommit: bool,
    arg_mySubid: SubTransactionId,
    arg_parentSubid: SubTransactionId,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AtEOSubXact_RelationCache(
                arg_isCommit: bool,
                arg_mySubid: SubTransactionId,
                arg_parentSubid: SubTransactionId,
            );
        }
        AtEOSubXact_RelationCache(arg_isCommit, arg_mySubid, arg_parentSubid)
    })
}
pub unsafe fn RelationIdIsInInitFile(arg_relationId: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationIdIsInInitFile(arg_relationId: Oid) -> bool;
        }
        RelationIdIsInInitFile(arg_relationId)
    })
}
pub unsafe fn RelationCacheInitFilePreInvalidate() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationCacheInitFilePreInvalidate();
        }
        RelationCacheInitFilePreInvalidate()
    })
}
pub unsafe fn RelationCacheInitFilePostInvalidate() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationCacheInitFilePostInvalidate();
        }
        RelationCacheInitFilePostInvalidate()
    })
}
pub unsafe fn RelationCacheInitFileRemove() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationCacheInitFileRemove();
        }
        RelationCacheInitFileRemove()
    })
}
extern "C" {
    pub static mut criticalRelcachesBuilt: bool;
}
extern "C" {
    pub static mut criticalSharedRelcachesBuilt: bool;
}
pub type SortSupport = *mut SortSupportData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SortSupportData {
    pub ssup_cxt: MemoryContext,
    pub ssup_collation: Oid,
    pub ssup_reverse: bool,
    pub ssup_nulls_first: bool,
    pub ssup_attno: AttrNumber,
    pub ssup_extra: *mut ::std::os::raw::c_void,
    pub comparator: ::std::option::Option<
        unsafe extern "C" fn(x: Datum, y: Datum, ssup: SortSupport) -> ::std::os::raw::c_int,
    >,
    pub abbreviate: bool,
    pub abbrev_converter:
        ::std::option::Option<unsafe extern "C" fn(original: Datum, ssup: SortSupport) -> Datum>,
    pub abbrev_abort: ::std::option::Option<
        unsafe extern "C" fn(memtupcount: ::std::os::raw::c_int, ssup: SortSupport) -> bool,
    >,
    pub abbrev_full_comparator: ::std::option::Option<
        unsafe extern "C" fn(x: Datum, y: Datum, ssup: SortSupport) -> ::std::os::raw::c_int,
    >,
}
impl Default for SortSupportData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn PrepareSortSupportComparisonShim(arg_cmpFunc: Oid, arg_ssup: SortSupport) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PrepareSortSupportComparisonShim(arg_cmpFunc: Oid, arg_ssup: SortSupport);
        }
        PrepareSortSupportComparisonShim(arg_cmpFunc, arg_ssup)
    })
}
pub unsafe fn PrepareSortSupportFromOrderingOp(arg_orderingOp: Oid, arg_ssup: SortSupport) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PrepareSortSupportFromOrderingOp(arg_orderingOp: Oid, arg_ssup: SortSupport);
        }
        PrepareSortSupportFromOrderingOp(arg_orderingOp, arg_ssup)
    })
}
pub unsafe fn PrepareSortSupportFromIndexRel(
    arg_indexRel: Relation,
    arg_strategy: int16,
    arg_ssup: SortSupport,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PrepareSortSupportFromIndexRel(
                arg_indexRel: Relation,
                arg_strategy: int16,
                arg_ssup: SortSupport,
            );
        }
        PrepareSortSupportFromIndexRel(arg_indexRel, arg_strategy, arg_ssup)
    })
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IndexTupleData {
    pub t_tid: ItemPointerData,
    pub t_info: ::std::os::raw::c_ushort,
}
pub type IndexTuple = *mut IndexTupleData;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IndexAttributeBitMapData {
    pub bits: [bits8; 4usize],
}
pub type IndexAttributeBitMap = *mut IndexAttributeBitMapData;
pub unsafe fn index_form_tuple(
    arg_tupleDescriptor: TupleDesc,
    arg_values: *mut Datum,
    arg_isnull: *mut bool,
) -> IndexTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_form_tuple(
                arg_tupleDescriptor: TupleDesc,
                arg_values: *mut Datum,
                arg_isnull: *mut bool,
            ) -> IndexTuple;
        }
        index_form_tuple(arg_tupleDescriptor, arg_values, arg_isnull)
    })
}
pub unsafe fn nocache_index_getattr(
    arg_tup: IndexTuple,
    arg_attnum: ::std::os::raw::c_int,
    arg_tupleDesc: TupleDesc,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn nocache_index_getattr(
                arg_tup: IndexTuple,
                arg_attnum: ::std::os::raw::c_int,
                arg_tupleDesc: TupleDesc,
            ) -> Datum;
        }
        nocache_index_getattr(arg_tup, arg_attnum, arg_tupleDesc)
    })
}
pub unsafe fn index_deform_tuple(
    arg_tup: IndexTuple,
    arg_tupleDescriptor: TupleDesc,
    arg_values: *mut Datum,
    arg_isnull: *mut bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_deform_tuple(
                arg_tup: IndexTuple,
                arg_tupleDescriptor: TupleDesc,
                arg_values: *mut Datum,
                arg_isnull: *mut bool,
            );
        }
        index_deform_tuple(arg_tup, arg_tupleDescriptor, arg_values, arg_isnull)
    })
}
pub unsafe fn CopyIndexTuple(arg_source: IndexTuple) -> IndexTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CopyIndexTuple(arg_source: IndexTuple) -> IndexTuple;
        }
        CopyIndexTuple(arg_source)
    })
}
pub unsafe fn index_truncate_tuple(
    arg_sourceDescriptor: TupleDesc,
    arg_source: IndexTuple,
    arg_leavenatts: ::std::os::raw::c_int,
) -> IndexTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_truncate_tuple(
                arg_sourceDescriptor: TupleDesc,
                arg_source: IndexTuple,
                arg_leavenatts: ::std::os::raw::c_int,
            ) -> IndexTuple;
        }
        index_truncate_tuple(arg_sourceDescriptor, arg_source, arg_leavenatts)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Tuplesortstate {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sharedsort {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SortCoordinateData {
    pub isWorker: bool,
    pub nParticipants: ::std::os::raw::c_int,
    pub sharedsort: *mut Sharedsort,
}
impl Default for SortCoordinateData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SortCoordinate = *mut SortCoordinateData;
pub const TuplesortMethod_SORT_TYPE_STILL_IN_PROGRESS: TuplesortMethod = 0;
pub const TuplesortMethod_SORT_TYPE_TOP_N_HEAPSORT: TuplesortMethod = 1;
pub const TuplesortMethod_SORT_TYPE_QUICKSORT: TuplesortMethod = 2;
pub const TuplesortMethod_SORT_TYPE_EXTERNAL_SORT: TuplesortMethod = 4;
pub const TuplesortMethod_SORT_TYPE_EXTERNAL_MERGE: TuplesortMethod = 8;
pub type TuplesortMethod = ::std::os::raw::c_uint;
pub const TuplesortSpaceType_SORT_SPACE_TYPE_DISK: TuplesortSpaceType = 0;
pub const TuplesortSpaceType_SORT_SPACE_TYPE_MEMORY: TuplesortSpaceType = 1;
pub type TuplesortSpaceType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TuplesortInstrumentation {
    pub sortMethod: TuplesortMethod,
    pub spaceType: TuplesortSpaceType,
    pub spaceUsed: int64,
}
impl Default for TuplesortInstrumentation {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn tuplesort_begin_heap(
    arg_tupDesc: TupleDesc,
    arg_nkeys: ::std::os::raw::c_int,
    arg_attNums: *mut AttrNumber,
    arg_sortOperators: *mut Oid,
    arg_sortCollations: *mut Oid,
    arg_nullsFirstFlags: *mut bool,
    arg_workMem: ::std::os::raw::c_int,
    arg_coordinate: SortCoordinate,
    arg_randomAccess: bool,
) -> *mut Tuplesortstate {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplesort_begin_heap(
                arg_tupDesc: TupleDesc,
                arg_nkeys: ::std::os::raw::c_int,
                arg_attNums: *mut AttrNumber,
                arg_sortOperators: *mut Oid,
                arg_sortCollations: *mut Oid,
                arg_nullsFirstFlags: *mut bool,
                arg_workMem: ::std::os::raw::c_int,
                arg_coordinate: SortCoordinate,
                arg_randomAccess: bool,
            ) -> *mut Tuplesortstate;
        }
        tuplesort_begin_heap(
            arg_tupDesc,
            arg_nkeys,
            arg_attNums,
            arg_sortOperators,
            arg_sortCollations,
            arg_nullsFirstFlags,
            arg_workMem,
            arg_coordinate,
            arg_randomAccess,
        )
    })
}
pub unsafe fn tuplesort_begin_cluster(
    arg_tupDesc: TupleDesc,
    arg_indexRel: Relation,
    arg_workMem: ::std::os::raw::c_int,
    arg_coordinate: SortCoordinate,
    arg_randomAccess: bool,
) -> *mut Tuplesortstate {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplesort_begin_cluster(
                arg_tupDesc: TupleDesc,
                arg_indexRel: Relation,
                arg_workMem: ::std::os::raw::c_int,
                arg_coordinate: SortCoordinate,
                arg_randomAccess: bool,
            ) -> *mut Tuplesortstate;
        }
        tuplesort_begin_cluster(
            arg_tupDesc,
            arg_indexRel,
            arg_workMem,
            arg_coordinate,
            arg_randomAccess,
        )
    })
}
pub unsafe fn tuplesort_begin_index_btree(
    arg_heapRel: Relation,
    arg_indexRel: Relation,
    arg_enforceUnique: bool,
    arg_workMem: ::std::os::raw::c_int,
    arg_coordinate: SortCoordinate,
    arg_randomAccess: bool,
) -> *mut Tuplesortstate {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplesort_begin_index_btree(
                arg_heapRel: Relation,
                arg_indexRel: Relation,
                arg_enforceUnique: bool,
                arg_workMem: ::std::os::raw::c_int,
                arg_coordinate: SortCoordinate,
                arg_randomAccess: bool,
            ) -> *mut Tuplesortstate;
        }
        tuplesort_begin_index_btree(
            arg_heapRel,
            arg_indexRel,
            arg_enforceUnique,
            arg_workMem,
            arg_coordinate,
            arg_randomAccess,
        )
    })
}
pub unsafe fn tuplesort_begin_index_hash(
    arg_heapRel: Relation,
    arg_indexRel: Relation,
    arg_high_mask: uint32,
    arg_low_mask: uint32,
    arg_max_buckets: uint32,
    arg_workMem: ::std::os::raw::c_int,
    arg_coordinate: SortCoordinate,
    arg_randomAccess: bool,
) -> *mut Tuplesortstate {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplesort_begin_index_hash(
                arg_heapRel: Relation,
                arg_indexRel: Relation,
                arg_high_mask: uint32,
                arg_low_mask: uint32,
                arg_max_buckets: uint32,
                arg_workMem: ::std::os::raw::c_int,
                arg_coordinate: SortCoordinate,
                arg_randomAccess: bool,
            ) -> *mut Tuplesortstate;
        }
        tuplesort_begin_index_hash(
            arg_heapRel,
            arg_indexRel,
            arg_high_mask,
            arg_low_mask,
            arg_max_buckets,
            arg_workMem,
            arg_coordinate,
            arg_randomAccess,
        )
    })
}
pub unsafe fn tuplesort_begin_datum(
    arg_datumType: Oid,
    arg_sortOperator: Oid,
    arg_sortCollation: Oid,
    arg_nullsFirstFlag: bool,
    arg_workMem: ::std::os::raw::c_int,
    arg_coordinate: SortCoordinate,
    arg_randomAccess: bool,
) -> *mut Tuplesortstate {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplesort_begin_datum(
                arg_datumType: Oid,
                arg_sortOperator: Oid,
                arg_sortCollation: Oid,
                arg_nullsFirstFlag: bool,
                arg_workMem: ::std::os::raw::c_int,
                arg_coordinate: SortCoordinate,
                arg_randomAccess: bool,
            ) -> *mut Tuplesortstate;
        }
        tuplesort_begin_datum(
            arg_datumType,
            arg_sortOperator,
            arg_sortCollation,
            arg_nullsFirstFlag,
            arg_workMem,
            arg_coordinate,
            arg_randomAccess,
        )
    })
}
pub unsafe fn tuplesort_set_bound(arg_state: *mut Tuplesortstate, arg_bound: int64) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplesort_set_bound(arg_state: *mut Tuplesortstate, arg_bound: int64);
        }
        tuplesort_set_bound(arg_state, arg_bound)
    })
}
pub unsafe fn tuplesort_used_bound(arg_state: *mut Tuplesortstate) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplesort_used_bound(arg_state: *mut Tuplesortstate) -> bool;
        }
        tuplesort_used_bound(arg_state)
    })
}
pub unsafe fn tuplesort_puttupleslot(
    arg_state: *mut Tuplesortstate,
    arg_slot: *mut TupleTableSlot,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplesort_puttupleslot(
                arg_state: *mut Tuplesortstate,
                arg_slot: *mut TupleTableSlot,
            );
        }
        tuplesort_puttupleslot(arg_state, arg_slot)
    })
}
pub unsafe fn tuplesort_putheaptuple(arg_state: *mut Tuplesortstate, arg_tup: HeapTuple) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplesort_putheaptuple(arg_state: *mut Tuplesortstate, arg_tup: HeapTuple);
        }
        tuplesort_putheaptuple(arg_state, arg_tup)
    })
}
pub unsafe fn tuplesort_putindextuplevalues(
    arg_state: *mut Tuplesortstate,
    arg_rel: Relation,
    arg_self_: ItemPointer,
    arg_values: *mut Datum,
    arg_isnull: *mut bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplesort_putindextuplevalues(
                arg_state: *mut Tuplesortstate,
                arg_rel: Relation,
                arg_self_: ItemPointer,
                arg_values: *mut Datum,
                arg_isnull: *mut bool,
            );
        }
        tuplesort_putindextuplevalues(arg_state, arg_rel, arg_self_, arg_values, arg_isnull)
    })
}
pub unsafe fn tuplesort_putdatum(arg_state: *mut Tuplesortstate, arg_val: Datum, arg_isNull: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplesort_putdatum(arg_state: *mut Tuplesortstate, arg_val: Datum, arg_isNull: bool);
        }
        tuplesort_putdatum(arg_state, arg_val, arg_isNull)
    })
}
pub unsafe fn tuplesort_performsort(arg_state: *mut Tuplesortstate) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplesort_performsort(arg_state: *mut Tuplesortstate);
        }
        tuplesort_performsort(arg_state)
    })
}
pub unsafe fn tuplesort_gettupleslot(
    arg_state: *mut Tuplesortstate,
    arg_forward: bool,
    arg_copy: bool,
    arg_slot: *mut TupleTableSlot,
    arg_abbrev: *mut Datum,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplesort_gettupleslot(
                arg_state: *mut Tuplesortstate,
                arg_forward: bool,
                arg_copy: bool,
                arg_slot: *mut TupleTableSlot,
                arg_abbrev: *mut Datum,
            ) -> bool;
        }
        tuplesort_gettupleslot(arg_state, arg_forward, arg_copy, arg_slot, arg_abbrev)
    })
}
pub unsafe fn tuplesort_getheaptuple(
    arg_state: *mut Tuplesortstate,
    arg_forward: bool,
) -> HeapTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplesort_getheaptuple(
                arg_state: *mut Tuplesortstate,
                arg_forward: bool,
            ) -> HeapTuple;
        }
        tuplesort_getheaptuple(arg_state, arg_forward)
    })
}
pub unsafe fn tuplesort_getindextuple(
    arg_state: *mut Tuplesortstate,
    arg_forward: bool,
) -> IndexTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplesort_getindextuple(
                arg_state: *mut Tuplesortstate,
                arg_forward: bool,
            ) -> IndexTuple;
        }
        tuplesort_getindextuple(arg_state, arg_forward)
    })
}
pub unsafe fn tuplesort_getdatum(
    arg_state: *mut Tuplesortstate,
    arg_forward: bool,
    arg_val: *mut Datum,
    arg_isNull: *mut bool,
    arg_abbrev: *mut Datum,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplesort_getdatum(
                arg_state: *mut Tuplesortstate,
                arg_forward: bool,
                arg_val: *mut Datum,
                arg_isNull: *mut bool,
                arg_abbrev: *mut Datum,
            ) -> bool;
        }
        tuplesort_getdatum(arg_state, arg_forward, arg_val, arg_isNull, arg_abbrev)
    })
}
pub unsafe fn tuplesort_skiptuples(
    arg_state: *mut Tuplesortstate,
    arg_ntuples: int64,
    arg_forward: bool,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplesort_skiptuples(
                arg_state: *mut Tuplesortstate,
                arg_ntuples: int64,
                arg_forward: bool,
            ) -> bool;
        }
        tuplesort_skiptuples(arg_state, arg_ntuples, arg_forward)
    })
}
pub unsafe fn tuplesort_end(arg_state: *mut Tuplesortstate) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplesort_end(arg_state: *mut Tuplesortstate);
        }
        tuplesort_end(arg_state)
    })
}
pub unsafe fn tuplesort_reset(arg_state: *mut Tuplesortstate) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplesort_reset(arg_state: *mut Tuplesortstate);
        }
        tuplesort_reset(arg_state)
    })
}
pub unsafe fn tuplesort_get_stats(
    arg_state: *mut Tuplesortstate,
    arg_stats: *mut TuplesortInstrumentation,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplesort_get_stats(
                arg_state: *mut Tuplesortstate,
                arg_stats: *mut TuplesortInstrumentation,
            );
        }
        tuplesort_get_stats(arg_state, arg_stats)
    })
}
pub unsafe fn tuplesort_method_name(arg_m: TuplesortMethod) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplesort_method_name(arg_m: TuplesortMethod) -> *const ::std::os::raw::c_char;
        }
        tuplesort_method_name(arg_m)
    })
}
pub unsafe fn tuplesort_space_type_name(
    arg_t: TuplesortSpaceType,
) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplesort_space_type_name(
                arg_t: TuplesortSpaceType,
            ) -> *const ::std::os::raw::c_char;
        }
        tuplesort_space_type_name(arg_t)
    })
}
pub unsafe fn tuplesort_merge_order(arg_allowedMem: int64) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplesort_merge_order(arg_allowedMem: int64) -> ::std::os::raw::c_int;
        }
        tuplesort_merge_order(arg_allowedMem)
    })
}
pub unsafe fn tuplesort_estimate_shared(arg_nworkers: ::std::os::raw::c_int) -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplesort_estimate_shared(arg_nworkers: ::std::os::raw::c_int) -> Size;
        }
        tuplesort_estimate_shared(arg_nworkers)
    })
}
pub unsafe fn tuplesort_initialize_shared(
    arg_shared: *mut Sharedsort,
    arg_nWorkers: ::std::os::raw::c_int,
    arg_seg: *mut dsm_segment,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplesort_initialize_shared(
                arg_shared: *mut Sharedsort,
                arg_nWorkers: ::std::os::raw::c_int,
                arg_seg: *mut dsm_segment,
            );
        }
        tuplesort_initialize_shared(arg_shared, arg_nWorkers, arg_seg)
    })
}
pub unsafe fn tuplesort_attach_shared(arg_shared: *mut Sharedsort, arg_seg: *mut dsm_segment) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplesort_attach_shared(arg_shared: *mut Sharedsort, arg_seg: *mut dsm_segment);
        }
        tuplesort_attach_shared(arg_shared, arg_seg)
    })
}
pub unsafe fn tuplesort_rescan(arg_state: *mut Tuplesortstate) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplesort_rescan(arg_state: *mut Tuplesortstate);
        }
        tuplesort_rescan(arg_state)
    })
}
pub unsafe fn tuplesort_markpos(arg_state: *mut Tuplesortstate) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplesort_markpos(arg_state: *mut Tuplesortstate);
        }
        tuplesort_markpos(arg_state)
    })
}
pub unsafe fn tuplesort_restorepos(arg_state: *mut Tuplesortstate) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplesort_restorepos(arg_state: *mut Tuplesortstate);
        }
        tuplesort_restorepos(arg_state)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Tuplestorestate {
    _unused: [u8; 0],
}
pub unsafe fn tuplestore_begin_heap(
    arg_randomAccess: bool,
    arg_interXact: bool,
    arg_maxKBytes: ::std::os::raw::c_int,
) -> *mut Tuplestorestate {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplestore_begin_heap(
                arg_randomAccess: bool,
                arg_interXact: bool,
                arg_maxKBytes: ::std::os::raw::c_int,
            ) -> *mut Tuplestorestate;
        }
        tuplestore_begin_heap(arg_randomAccess, arg_interXact, arg_maxKBytes)
    })
}
pub unsafe fn tuplestore_set_eflags(
    arg_state: *mut Tuplestorestate,
    arg_eflags: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplestore_set_eflags(
                arg_state: *mut Tuplestorestate,
                arg_eflags: ::std::os::raw::c_int,
            );
        }
        tuplestore_set_eflags(arg_state, arg_eflags)
    })
}
pub unsafe fn tuplestore_puttupleslot(
    arg_state: *mut Tuplestorestate,
    arg_slot: *mut TupleTableSlot,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplestore_puttupleslot(
                arg_state: *mut Tuplestorestate,
                arg_slot: *mut TupleTableSlot,
            );
        }
        tuplestore_puttupleslot(arg_state, arg_slot)
    })
}
pub unsafe fn tuplestore_puttuple(arg_state: *mut Tuplestorestate, arg_tuple: HeapTuple) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplestore_puttuple(arg_state: *mut Tuplestorestate, arg_tuple: HeapTuple);
        }
        tuplestore_puttuple(arg_state, arg_tuple)
    })
}
pub unsafe fn tuplestore_putvalues(
    arg_state: *mut Tuplestorestate,
    arg_tdesc: TupleDesc,
    arg_values: *mut Datum,
    arg_isnull: *mut bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplestore_putvalues(
                arg_state: *mut Tuplestorestate,
                arg_tdesc: TupleDesc,
                arg_values: *mut Datum,
                arg_isnull: *mut bool,
            );
        }
        tuplestore_putvalues(arg_state, arg_tdesc, arg_values, arg_isnull)
    })
}
pub unsafe fn tuplestore_alloc_read_pointer(
    arg_state: *mut Tuplestorestate,
    arg_eflags: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplestore_alloc_read_pointer(
                arg_state: *mut Tuplestorestate,
                arg_eflags: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        tuplestore_alloc_read_pointer(arg_state, arg_eflags)
    })
}
pub unsafe fn tuplestore_select_read_pointer(
    arg_state: *mut Tuplestorestate,
    arg_ptr: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplestore_select_read_pointer(
                arg_state: *mut Tuplestorestate,
                arg_ptr: ::std::os::raw::c_int,
            );
        }
        tuplestore_select_read_pointer(arg_state, arg_ptr)
    })
}
pub unsafe fn tuplestore_copy_read_pointer(
    arg_state: *mut Tuplestorestate,
    arg_srcptr: ::std::os::raw::c_int,
    arg_destptr: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplestore_copy_read_pointer(
                arg_state: *mut Tuplestorestate,
                arg_srcptr: ::std::os::raw::c_int,
                arg_destptr: ::std::os::raw::c_int,
            );
        }
        tuplestore_copy_read_pointer(arg_state, arg_srcptr, arg_destptr)
    })
}
pub unsafe fn tuplestore_trim(arg_state: *mut Tuplestorestate) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplestore_trim(arg_state: *mut Tuplestorestate);
        }
        tuplestore_trim(arg_state)
    })
}
pub unsafe fn tuplestore_in_memory(arg_state: *mut Tuplestorestate) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplestore_in_memory(arg_state: *mut Tuplestorestate) -> bool;
        }
        tuplestore_in_memory(arg_state)
    })
}
pub unsafe fn tuplestore_gettupleslot(
    arg_state: *mut Tuplestorestate,
    arg_forward: bool,
    arg_copy: bool,
    arg_slot: *mut TupleTableSlot,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplestore_gettupleslot(
                arg_state: *mut Tuplestorestate,
                arg_forward: bool,
                arg_copy: bool,
                arg_slot: *mut TupleTableSlot,
            ) -> bool;
        }
        tuplestore_gettupleslot(arg_state, arg_forward, arg_copy, arg_slot)
    })
}
pub unsafe fn tuplestore_advance(arg_state: *mut Tuplestorestate, arg_forward: bool) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplestore_advance(arg_state: *mut Tuplestorestate, arg_forward: bool) -> bool;
        }
        tuplestore_advance(arg_state, arg_forward)
    })
}
pub unsafe fn tuplestore_skiptuples(
    arg_state: *mut Tuplestorestate,
    arg_ntuples: int64,
    arg_forward: bool,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplestore_skiptuples(
                arg_state: *mut Tuplestorestate,
                arg_ntuples: int64,
                arg_forward: bool,
            ) -> bool;
        }
        tuplestore_skiptuples(arg_state, arg_ntuples, arg_forward)
    })
}
pub unsafe fn tuplestore_tuple_count(arg_state: *mut Tuplestorestate) -> int64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplestore_tuple_count(arg_state: *mut Tuplestorestate) -> int64;
        }
        tuplestore_tuple_count(arg_state)
    })
}
pub unsafe fn tuplestore_ateof(arg_state: *mut Tuplestorestate) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplestore_ateof(arg_state: *mut Tuplestorestate) -> bool;
        }
        tuplestore_ateof(arg_state)
    })
}
pub unsafe fn tuplestore_rescan(arg_state: *mut Tuplestorestate) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplestore_rescan(arg_state: *mut Tuplestorestate);
        }
        tuplestore_rescan(arg_state)
    })
}
pub unsafe fn tuplestore_clear(arg_state: *mut Tuplestorestate) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplestore_clear(arg_state: *mut Tuplestorestate);
        }
        tuplestore_clear(arg_state)
    })
}
pub unsafe fn tuplestore_end(arg_state: *mut Tuplestorestate) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplestore_end(arg_state: *mut Tuplestorestate);
        }
        tuplestore_end(arg_state)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionRoutingInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParallelHashJoinState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprEvalStep {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CopyMultiInsertBuffer {
    _unused: [u8; 0],
}
pub type ExprStateEvalFunc = ::std::option::Option<
    unsafe extern "C" fn(
        expression: *mut ExprState,
        econtext: *mut ExprContext,
        isNull: *mut bool,
    ) -> Datum,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprState {
    pub tag: NodeTag,
    pub flags: uint8,
    pub resnull: bool,
    pub resvalue: Datum,
    pub resultslot: *mut TupleTableSlot,
    pub steps: *mut ExprEvalStep,
    pub evalfunc: ExprStateEvalFunc,
    pub expr: *mut Expr,
    pub evalfunc_private: *mut ::std::os::raw::c_void,
    pub steps_len: ::std::os::raw::c_int,
    pub steps_alloc: ::std::os::raw::c_int,
    pub parent: *mut PlanState,
    pub ext_params: ParamListInfo,
    pub innermost_caseval: *mut Datum,
    pub innermost_casenull: *mut bool,
    pub innermost_domainval: *mut Datum,
    pub innermost_domainnull: *mut bool,
}
impl Default for ExprState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexInfo {
    pub type_: NodeTag,
    pub ii_NumIndexAttrs: ::std::os::raw::c_int,
    pub ii_NumIndexKeyAttrs: ::std::os::raw::c_int,
    pub ii_IndexAttrNumbers: [AttrNumber; 32usize],
    pub ii_Expressions: *mut List,
    pub ii_ExpressionsState: *mut List,
    pub ii_Predicate: *mut List,
    pub ii_PredicateState: *mut ExprState,
    pub ii_ExclusionOps: *mut Oid,
    pub ii_ExclusionProcs: *mut Oid,
    pub ii_ExclusionStrats: *mut uint16,
    pub ii_UniqueOps: *mut Oid,
    pub ii_UniqueProcs: *mut Oid,
    pub ii_UniqueStrats: *mut uint16,
    pub ii_OpclassOptions: *mut Datum,
    pub ii_Unique: bool,
    pub ii_ReadyForInserts: bool,
    pub ii_Concurrent: bool,
    pub ii_BrokenHotChain: bool,
    pub ii_ParallelWorkers: ::std::os::raw::c_int,
    pub ii_Am: Oid,
    pub ii_AmCache: *mut ::std::os::raw::c_void,
    pub ii_Context: MemoryContext,
}
impl Default for IndexInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ExprContextCallbackFunction = ::std::option::Option<unsafe extern "C" fn(arg: Datum)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprContext_CB {
    pub next: *mut ExprContext_CB,
    pub function: ExprContextCallbackFunction,
    pub arg: Datum,
}
impl Default for ExprContext_CB {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExprContext {
    pub type_: NodeTag,
    pub ecxt_scantuple: *mut TupleTableSlot,
    pub ecxt_innertuple: *mut TupleTableSlot,
    pub ecxt_outertuple: *mut TupleTableSlot,
    pub ecxt_per_query_memory: MemoryContext,
    pub ecxt_per_tuple_memory: MemoryContext,
    pub ecxt_param_exec_vals: *mut ParamExecData,
    pub ecxt_param_list_info: ParamListInfo,
    pub ecxt_aggvalues: *mut Datum,
    pub ecxt_aggnulls: *mut bool,
    pub caseValue_datum: Datum,
    pub caseValue_isNull: bool,
    pub domainValue_datum: Datum,
    pub domainValue_isNull: bool,
    pub ecxt_estate: *mut EState,
    pub ecxt_callbacks: *mut ExprContext_CB,
}
impl Default for ExprContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ExprDoneCond_ExprSingleResult: ExprDoneCond = 0;
pub const ExprDoneCond_ExprMultipleResult: ExprDoneCond = 1;
pub const ExprDoneCond_ExprEndResult: ExprDoneCond = 2;
pub type ExprDoneCond = ::std::os::raw::c_uint;
pub const SetFunctionReturnMode_SFRM_ValuePerCall: SetFunctionReturnMode = 1;
pub const SetFunctionReturnMode_SFRM_Materialize: SetFunctionReturnMode = 2;
pub const SetFunctionReturnMode_SFRM_Materialize_Random: SetFunctionReturnMode = 4;
pub const SetFunctionReturnMode_SFRM_Materialize_Preferred: SetFunctionReturnMode = 8;
pub type SetFunctionReturnMode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReturnSetInfo {
    pub type_: NodeTag,
    pub econtext: *mut ExprContext,
    pub expectedDesc: TupleDesc,
    pub allowedModes: ::std::os::raw::c_int,
    pub returnMode: SetFunctionReturnMode,
    pub isDone: ExprDoneCond,
    pub setResult: *mut Tuplestorestate,
    pub setDesc: TupleDesc,
}
impl Default for ReturnSetInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProjectionInfo {
    pub type_: NodeTag,
    pub pi_state: ExprState,
    pub pi_exprContext: *mut ExprContext,
}
impl Default for ProjectionInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JunkFilter {
    pub type_: NodeTag,
    pub jf_targetList: *mut List,
    pub jf_cleanTupType: TupleDesc,
    pub jf_cleanMap: *mut AttrNumber,
    pub jf_resultSlot: *mut TupleTableSlot,
    pub jf_junkAttNo: AttrNumber,
}
impl Default for JunkFilter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OnConflictSetState {
    pub type_: NodeTag,
    pub oc_Existing: *mut TupleTableSlot,
    pub oc_ProjSlot: *mut TupleTableSlot,
    pub oc_ProjInfo: *mut ProjectionInfo,
    pub oc_WhereClause: *mut ExprState,
}
impl Default for OnConflictSetState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResultRelInfo {
    pub type_: NodeTag,
    pub ri_RangeTableIndex: Index,
    pub ri_RelationDesc: Relation,
    pub ri_NumIndices: ::std::os::raw::c_int,
    pub ri_IndexRelationDescs: RelationPtr,
    pub ri_IndexRelationInfo: *mut *mut IndexInfo,
    pub ri_TrigDesc: *mut TriggerDesc,
    pub ri_TrigFunctions: *mut FmgrInfo,
    pub ri_TrigWhenExprs: *mut *mut ExprState,
    pub ri_TrigInstrument: *mut Instrumentation,
    pub ri_ReturningSlot: *mut TupleTableSlot,
    pub ri_TrigOldSlot: *mut TupleTableSlot,
    pub ri_TrigNewSlot: *mut TupleTableSlot,
    pub ri_FdwRoutine: *mut FdwRoutine,
    pub ri_FdwState: *mut ::std::os::raw::c_void,
    pub ri_usesFdwDirectModify: bool,
    pub ri_WithCheckOptions: *mut List,
    pub ri_WithCheckOptionExprs: *mut List,
    pub ri_ConstraintExprs: *mut *mut ExprState,
    pub ri_GeneratedExprs: *mut *mut ExprState,
    pub ri_NumGeneratedNeeded: ::std::os::raw::c_int,
    pub ri_junkFilter: *mut JunkFilter,
    pub ri_returningList: *mut List,
    pub ri_projectReturning: *mut ProjectionInfo,
    pub ri_onConflictArbiterIndexes: *mut List,
    pub ri_onConflict: *mut OnConflictSetState,
    pub ri_PartitionCheck: *mut List,
    pub ri_PartitionCheckExpr: *mut ExprState,
    pub ri_RootResultRelInfo: *mut ResultRelInfo,
    pub ri_PartitionInfo: *mut PartitionRoutingInfo,
    pub ri_CopyMultiInsertBuffer: *mut CopyMultiInsertBuffer,
}
impl Default for ResultRelInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EState {
    pub type_: NodeTag,
    pub es_direction: ScanDirection,
    pub es_snapshot: Snapshot,
    pub es_crosscheck_snapshot: Snapshot,
    pub es_range_table: *mut List,
    pub es_range_table_size: Index,
    pub es_relations: *mut Relation,
    pub es_rowmarks: *mut *mut ExecRowMark,
    pub es_plannedstmt: *mut PlannedStmt,
    pub es_sourceText: *const ::std::os::raw::c_char,
    pub es_junkFilter: *mut JunkFilter,
    pub es_output_cid: CommandId,
    pub es_result_relations: *mut ResultRelInfo,
    pub es_num_result_relations: ::std::os::raw::c_int,
    pub es_result_relation_info: *mut ResultRelInfo,
    pub es_root_result_relations: *mut ResultRelInfo,
    pub es_num_root_result_relations: ::std::os::raw::c_int,
    pub es_partition_directory: PartitionDirectory,
    pub es_tuple_routing_result_relations: *mut List,
    pub es_trig_target_relations: *mut List,
    pub es_param_list_info: ParamListInfo,
    pub es_param_exec_vals: *mut ParamExecData,
    pub es_queryEnv: *mut QueryEnvironment,
    pub es_query_cxt: MemoryContext,
    pub es_tupleTable: *mut List,
    pub es_processed: uint64,
    pub es_top_eflags: ::std::os::raw::c_int,
    pub es_instrument: ::std::os::raw::c_int,
    pub es_finished: bool,
    pub es_exprcontexts: *mut List,
    pub es_subplanstates: *mut List,
    pub es_auxmodifytables: *mut List,
    pub es_per_tuple_exprcontext: *mut ExprContext,
    pub es_epq_active: *mut EPQState,
    pub es_use_parallel_mode: bool,
    pub es_query_dsa: *mut dsa_area,
    pub es_jit_flags: ::std::os::raw::c_int,
    pub es_jit: *mut JitContext,
    pub es_jit_worker_instr: *mut JitInstrumentation,
}
impl Default for EState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExecRowMark {
    pub relation: Relation,
    pub relid: Oid,
    pub rti: Index,
    pub prti: Index,
    pub rowmarkId: Index,
    pub markType: RowMarkType,
    pub strength: LockClauseStrength,
    pub waitPolicy: LockWaitPolicy,
    pub ermActive: bool,
    pub curCtid: ItemPointerData,
    pub ermExtra: *mut ::std::os::raw::c_void,
}
impl Default for ExecRowMark {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExecAuxRowMark {
    pub rowmark: *mut ExecRowMark,
    pub ctidAttNo: AttrNumber,
    pub toidAttNo: AttrNumber,
    pub wholeAttNo: AttrNumber,
}
impl Default for ExecAuxRowMark {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TupleHashEntry = *mut TupleHashEntryData;
pub type TupleHashTable = *mut TupleHashTableData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TupleHashEntryData {
    pub firstTuple: MinimalTuple,
    pub additional: *mut ::std::os::raw::c_void,
    pub status: uint32,
    pub hash: uint32,
}
impl Default for TupleHashEntryData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static pg_leftmost_one_pos: [uint8; 256usize];
}
extern "C" {
    pub static pg_rightmost_one_pos: [uint8; 256usize];
}
extern "C" {
    pub static pg_number_of_ones: [uint8; 256usize];
}
extern "C" {
    pub static mut pg_popcount32:
        ::std::option::Option<unsafe extern "C" fn(word: uint32) -> ::std::os::raw::c_int>;
}
extern "C" {
    pub static mut pg_popcount64:
        ::std::option::Option<unsafe extern "C" fn(word: uint64) -> ::std::os::raw::c_int>;
}
pub unsafe fn pg_popcount(
    arg_buf: *const ::std::os::raw::c_char,
    arg_bytes: ::std::os::raw::c_int,
) -> uint64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_popcount(
                arg_buf: *const ::std::os::raw::c_char,
                arg_bytes: ::std::os::raw::c_int,
            ) -> uint64;
        }
        pg_popcount(arg_buf, arg_bytes)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tuplehash_hash {
    pub size: uint64,
    pub members: uint32,
    pub sizemask: uint32,
    pub grow_threshold: uint32,
    pub data: *mut TupleHashEntryData,
    pub ctx: MemoryContext,
    pub private_data: *mut ::std::os::raw::c_void,
}
impl Default for tuplehash_hash {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const tuplehash_status_tuplehash_SH_EMPTY: tuplehash_status = 0;
pub const tuplehash_status_tuplehash_SH_IN_USE: tuplehash_status = 1;
pub type tuplehash_status = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tuplehash_iterator {
    pub cur: uint32,
    pub end: uint32,
    pub done: bool,
}
pub unsafe fn tuplehash_create(
    arg_ctx: MemoryContext,
    arg_nelements: uint32,
    arg_private_data: *mut ::std::os::raw::c_void,
) -> *mut tuplehash_hash {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplehash_create(
                arg_ctx: MemoryContext,
                arg_nelements: uint32,
                arg_private_data: *mut ::std::os::raw::c_void,
            ) -> *mut tuplehash_hash;
        }
        tuplehash_create(arg_ctx, arg_nelements, arg_private_data)
    })
}
pub unsafe fn tuplehash_destroy(arg_tb: *mut tuplehash_hash) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplehash_destroy(arg_tb: *mut tuplehash_hash);
        }
        tuplehash_destroy(arg_tb)
    })
}
pub unsafe fn tuplehash_reset(arg_tb: *mut tuplehash_hash) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplehash_reset(arg_tb: *mut tuplehash_hash);
        }
        tuplehash_reset(arg_tb)
    })
}
pub unsafe fn tuplehash_grow(arg_tb: *mut tuplehash_hash, arg_newsize: uint64) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplehash_grow(arg_tb: *mut tuplehash_hash, arg_newsize: uint64);
        }
        tuplehash_grow(arg_tb, arg_newsize)
    })
}
pub unsafe fn tuplehash_insert(
    arg_tb: *mut tuplehash_hash,
    arg_key: MinimalTuple,
    arg_found: *mut bool,
) -> *mut TupleHashEntryData {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplehash_insert(
                arg_tb: *mut tuplehash_hash,
                arg_key: MinimalTuple,
                arg_found: *mut bool,
            ) -> *mut TupleHashEntryData;
        }
        tuplehash_insert(arg_tb, arg_key, arg_found)
    })
}
pub unsafe fn tuplehash_insert_hash(
    arg_tb: *mut tuplehash_hash,
    arg_key: MinimalTuple,
    arg_hash: uint32,
    arg_found: *mut bool,
) -> *mut TupleHashEntryData {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplehash_insert_hash(
                arg_tb: *mut tuplehash_hash,
                arg_key: MinimalTuple,
                arg_hash: uint32,
                arg_found: *mut bool,
            ) -> *mut TupleHashEntryData;
        }
        tuplehash_insert_hash(arg_tb, arg_key, arg_hash, arg_found)
    })
}
pub unsafe fn tuplehash_lookup(
    arg_tb: *mut tuplehash_hash,
    arg_key: MinimalTuple,
) -> *mut TupleHashEntryData {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplehash_lookup(
                arg_tb: *mut tuplehash_hash,
                arg_key: MinimalTuple,
            ) -> *mut TupleHashEntryData;
        }
        tuplehash_lookup(arg_tb, arg_key)
    })
}
pub unsafe fn tuplehash_lookup_hash(
    arg_tb: *mut tuplehash_hash,
    arg_key: MinimalTuple,
    arg_hash: uint32,
) -> *mut TupleHashEntryData {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplehash_lookup_hash(
                arg_tb: *mut tuplehash_hash,
                arg_key: MinimalTuple,
                arg_hash: uint32,
            ) -> *mut TupleHashEntryData;
        }
        tuplehash_lookup_hash(arg_tb, arg_key, arg_hash)
    })
}
pub unsafe fn tuplehash_delete(arg_tb: *mut tuplehash_hash, arg_key: MinimalTuple) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplehash_delete(arg_tb: *mut tuplehash_hash, arg_key: MinimalTuple) -> bool;
        }
        tuplehash_delete(arg_tb, arg_key)
    })
}
pub unsafe fn tuplehash_start_iterate(
    arg_tb: *mut tuplehash_hash,
    arg_iter: *mut tuplehash_iterator,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplehash_start_iterate(
                arg_tb: *mut tuplehash_hash,
                arg_iter: *mut tuplehash_iterator,
            );
        }
        tuplehash_start_iterate(arg_tb, arg_iter)
    })
}
pub unsafe fn tuplehash_start_iterate_at(
    arg_tb: *mut tuplehash_hash,
    arg_iter: *mut tuplehash_iterator,
    arg_at: uint32,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplehash_start_iterate_at(
                arg_tb: *mut tuplehash_hash,
                arg_iter: *mut tuplehash_iterator,
                arg_at: uint32,
            );
        }
        tuplehash_start_iterate_at(arg_tb, arg_iter, arg_at)
    })
}
pub unsafe fn tuplehash_iterate(
    arg_tb: *mut tuplehash_hash,
    arg_iter: *mut tuplehash_iterator,
) -> *mut TupleHashEntryData {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplehash_iterate(
                arg_tb: *mut tuplehash_hash,
                arg_iter: *mut tuplehash_iterator,
            ) -> *mut TupleHashEntryData;
        }
        tuplehash_iterate(arg_tb, arg_iter)
    })
}
pub unsafe fn tuplehash_stat(arg_tb: *mut tuplehash_hash) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tuplehash_stat(arg_tb: *mut tuplehash_hash);
        }
        tuplehash_stat(arg_tb)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TupleHashTableData {
    pub hashtab: *mut tuplehash_hash,
    pub numCols: ::std::os::raw::c_int,
    pub keyColIdx: *mut AttrNumber,
    pub tab_hash_funcs: *mut FmgrInfo,
    pub tab_eq_func: *mut ExprState,
    pub tab_collations: *mut Oid,
    pub tablecxt: MemoryContext,
    pub tempcxt: MemoryContext,
    pub entrysize: Size,
    pub tableslot: *mut TupleTableSlot,
    pub inputslot: *mut TupleTableSlot,
    pub in_hash_funcs: *mut FmgrInfo,
    pub cur_eq_func: *mut ExprState,
    pub hash_iv: uint32,
    pub exprcontext: *mut ExprContext,
}
impl Default for TupleHashTableData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TupleHashIterator = tuplehash_iterator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggrefExprState {
    pub type_: NodeTag,
    pub aggref: *mut Aggref,
    pub aggno: ::std::os::raw::c_int,
}
impl Default for AggrefExprState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowFuncExprState {
    pub type_: NodeTag,
    pub wfunc: *mut WindowFunc,
    pub args: *mut List,
    pub aggfilter: *mut ExprState,
    pub wfuncno: ::std::os::raw::c_int,
}
impl Default for WindowFuncExprState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SetExprState {
    pub type_: NodeTag,
    pub expr: *mut Expr,
    pub args: *mut List,
    pub elidedFuncState: *mut ExprState,
    pub func: FmgrInfo,
    pub funcResultStore: *mut Tuplestorestate,
    pub funcResultSlot: *mut TupleTableSlot,
    pub funcResultDesc: TupleDesc,
    pub funcReturnsTuple: bool,
    pub funcReturnsSet: bool,
    pub setArgsValid: bool,
    pub shutdown_reg: bool,
    pub fcinfo: FunctionCallInfo,
}
impl Default for SetExprState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubPlanState {
    pub type_: NodeTag,
    pub subplan: *mut SubPlan,
    pub planstate: *mut PlanState,
    pub parent: *mut PlanState,
    pub testexpr: *mut ExprState,
    pub args: *mut List,
    pub curTuple: HeapTuple,
    pub curArray: Datum,
    pub descRight: TupleDesc,
    pub projLeft: *mut ProjectionInfo,
    pub projRight: *mut ProjectionInfo,
    pub hashtable: TupleHashTable,
    pub hashnulls: TupleHashTable,
    pub havehashrows: bool,
    pub havenullrows: bool,
    pub hashtablecxt: MemoryContext,
    pub hashtempcxt: MemoryContext,
    pub innerecontext: *mut ExprContext,
    pub numCols: ::std::os::raw::c_int,
    pub keyColIdx: *mut AttrNumber,
    pub tab_eq_funcoids: *mut Oid,
    pub tab_collations: *mut Oid,
    pub tab_hash_funcs: *mut FmgrInfo,
    pub tab_eq_funcs: *mut FmgrInfo,
    pub lhs_hash_funcs: *mut FmgrInfo,
    pub cur_eq_funcs: *mut FmgrInfo,
    pub cur_eq_comp: *mut ExprState,
}
impl Default for SubPlanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlternativeSubPlanState {
    pub type_: NodeTag,
    pub subplan: *mut AlternativeSubPlan,
    pub subplans: *mut List,
    pub active: ::std::os::raw::c_int,
}
impl Default for AlternativeSubPlanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const DomainConstraintType_DOM_CONSTRAINT_NOTNULL: DomainConstraintType = 0;
pub const DomainConstraintType_DOM_CONSTRAINT_CHECK: DomainConstraintType = 1;
pub type DomainConstraintType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DomainConstraintState {
    pub type_: NodeTag,
    pub constrainttype: DomainConstraintType,
    pub name: *mut ::std::os::raw::c_char,
    pub check_expr: *mut Expr,
    pub check_exprstate: *mut ExprState,
}
impl Default for DomainConstraintState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ExecProcNodeMtd =
    ::std::option::Option<unsafe extern "C" fn(pstate: *mut PlanState) -> *mut TupleTableSlot>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PlanState {
    pub type_: NodeTag,
    pub plan: *mut Plan,
    pub state: *mut EState,
    pub ExecProcNode: ExecProcNodeMtd,
    pub ExecProcNodeReal: ExecProcNodeMtd,
    pub instrument: *mut Instrumentation,
    pub worker_instrument: *mut WorkerInstrumentation,
    pub worker_jit_instrument: *mut SharedJitInstrumentation,
    pub qual: *mut ExprState,
    pub lefttree: *mut PlanState,
    pub righttree: *mut PlanState,
    pub initPlan: *mut List,
    pub subPlan: *mut List,
    pub chgParam: *mut Bitmapset,
    pub ps_ResultTupleDesc: TupleDesc,
    pub ps_ResultTupleSlot: *mut TupleTableSlot,
    pub ps_ExprContext: *mut ExprContext,
    pub ps_ProjInfo: *mut ProjectionInfo,
    pub scandesc: TupleDesc,
    pub scanops: *const TupleTableSlotOps,
    pub outerops: *const TupleTableSlotOps,
    pub innerops: *const TupleTableSlotOps,
    pub resultops: *const TupleTableSlotOps,
    pub scanopsfixed: bool,
    pub outeropsfixed: bool,
    pub inneropsfixed: bool,
    pub resultopsfixed: bool,
    pub scanopsset: bool,
    pub outeropsset: bool,
    pub inneropsset: bool,
    pub resultopsset: bool,
}
impl Default for PlanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EPQState {
    pub parentestate: *mut EState,
    pub epqParam: ::std::os::raw::c_int,
    pub tuple_table: *mut List,
    pub relsubs_slot: *mut *mut TupleTableSlot,
    pub plan: *mut Plan,
    pub arowMarks: *mut List,
    pub origslot: *mut TupleTableSlot,
    pub recheckestate: *mut EState,
    pub relsubs_rowmark: *mut *mut ExecAuxRowMark,
    pub relsubs_done: *mut bool,
    pub recheckplanstate: *mut PlanState,
}
impl Default for EPQState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResultState {
    pub ps: PlanState,
    pub resconstantqual: *mut ExprState,
    pub rs_done: bool,
    pub rs_checkqual: bool,
}
impl Default for ResultState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProjectSetState {
    pub ps: PlanState,
    pub elems: *mut *mut Node,
    pub elemdone: *mut ExprDoneCond,
    pub nelems: ::std::os::raw::c_int,
    pub pending_srf_tuples: bool,
    pub argcontext: MemoryContext,
}
impl Default for ProjectSetState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ModifyTableState {
    pub ps: PlanState,
    pub operation: CmdType,
    pub canSetTag: bool,
    pub mt_done: bool,
    pub mt_plans: *mut *mut PlanState,
    pub mt_nplans: ::std::os::raw::c_int,
    pub mt_whichplan: ::std::os::raw::c_int,
    pub mt_scans: *mut *mut TupleTableSlot,
    pub resultRelInfo: *mut ResultRelInfo,
    pub rootResultRelInfo: *mut ResultRelInfo,
    pub mt_arowmarks: *mut *mut List,
    pub mt_epqstate: EPQState,
    pub fireBSTriggers: bool,
    pub mt_root_tuple_slot: *mut TupleTableSlot,
    pub mt_partition_tuple_routing: *mut PartitionTupleRouting,
    pub mt_transition_capture: *mut TransitionCaptureState,
    pub mt_oc_transition_capture: *mut TransitionCaptureState,
    pub mt_per_subplan_tupconv_maps: *mut *mut TupleConversionMap,
}
impl Default for ModifyTableState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParallelAppendState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionPruneState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AppendState {
    pub ps: PlanState,
    pub appendplans: *mut *mut PlanState,
    pub as_nplans: ::std::os::raw::c_int,
    pub as_whichplan: ::std::os::raw::c_int,
    pub as_first_partial_plan: ::std::os::raw::c_int,
    pub as_pstate: *mut ParallelAppendState,
    pub pstate_len: Size,
    pub as_prune_state: *mut PartitionPruneState,
    pub as_valid_subplans: *mut Bitmapset,
    pub choose_next_subplan:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut AppendState) -> bool>,
}
impl Default for AppendState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeAppendState {
    pub ps: PlanState,
    pub mergeplans: *mut *mut PlanState,
    pub ms_nplans: ::std::os::raw::c_int,
    pub ms_nkeys: ::std::os::raw::c_int,
    pub ms_sortkeys: SortSupport,
    pub ms_slots: *mut *mut TupleTableSlot,
    pub ms_heap: *mut binaryheap,
    pub ms_initialized: bool,
    pub ms_prune_state: *mut PartitionPruneState,
    pub ms_valid_subplans: *mut Bitmapset,
}
impl Default for MergeAppendState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RecursiveUnionState {
    pub ps: PlanState,
    pub recursing: bool,
    pub intermediate_empty: bool,
    pub working_table: *mut Tuplestorestate,
    pub intermediate_table: *mut Tuplestorestate,
    pub eqfuncoids: *mut Oid,
    pub hashfunctions: *mut FmgrInfo,
    pub tempContext: MemoryContext,
    pub hashtable: TupleHashTable,
    pub tableContext: MemoryContext,
}
impl Default for RecursiveUnionState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapAndState {
    pub ps: PlanState,
    pub bitmapplans: *mut *mut PlanState,
    pub nplans: ::std::os::raw::c_int,
}
impl Default for BitmapAndState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapOrState {
    pub ps: PlanState,
    pub bitmapplans: *mut *mut PlanState,
    pub nplans: ::std::os::raw::c_int,
}
impl Default for BitmapOrState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScanState {
    pub ps: PlanState,
    pub ss_currentRelation: Relation,
    pub ss_currentScanDesc: *mut TableScanDescData,
    pub ss_ScanTupleSlot: *mut TupleTableSlot,
}
impl Default for ScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SeqScanState {
    pub ss: ScanState,
    pub pscan_len: Size,
}
impl Default for SeqScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SampleScanState {
    pub ss: ScanState,
    pub args: *mut List,
    pub repeatable: *mut ExprState,
    pub tsmroutine: *mut TsmRoutine,
    pub tsm_state: *mut ::std::os::raw::c_void,
    pub use_bulkread: bool,
    pub use_pagemode: bool,
    pub begun: bool,
    pub seed: uint32,
    pub donetuples: int64,
    pub haveblock: bool,
    pub done: bool,
}
impl Default for SampleScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexRuntimeKeyInfo {
    pub scan_key: *mut ScanKeyData,
    pub key_expr: *mut ExprState,
    pub key_toastable: bool,
}
impl Default for IndexRuntimeKeyInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexArrayKeyInfo {
    pub scan_key: *mut ScanKeyData,
    pub array_expr: *mut ExprState,
    pub next_elem: ::std::os::raw::c_int,
    pub num_elems: ::std::os::raw::c_int,
    pub elem_values: *mut Datum,
    pub elem_nulls: *mut bool,
}
impl Default for IndexArrayKeyInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexScanState {
    pub ss: ScanState,
    pub indexqualorig: *mut ExprState,
    pub indexorderbyorig: *mut List,
    pub iss_ScanKeys: *mut ScanKeyData,
    pub iss_NumScanKeys: ::std::os::raw::c_int,
    pub iss_OrderByKeys: *mut ScanKeyData,
    pub iss_NumOrderByKeys: ::std::os::raw::c_int,
    pub iss_RuntimeKeys: *mut IndexRuntimeKeyInfo,
    pub iss_NumRuntimeKeys: ::std::os::raw::c_int,
    pub iss_RuntimeKeysReady: bool,
    pub iss_RuntimeContext: *mut ExprContext,
    pub iss_RelationDesc: Relation,
    pub iss_ScanDesc: *mut IndexScanDescData,
    pub iss_ReorderQueue: *mut pairingheap,
    pub iss_ReachedEnd: bool,
    pub iss_OrderByValues: *mut Datum,
    pub iss_OrderByNulls: *mut bool,
    pub iss_SortSupport: SortSupport,
    pub iss_OrderByTypByVals: *mut bool,
    pub iss_OrderByTypLens: *mut int16,
    pub iss_PscanLen: Size,
}
impl Default for IndexScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexOnlyScanState {
    pub ss: ScanState,
    pub indexqual: *mut ExprState,
    pub ioss_ScanKeys: *mut ScanKeyData,
    pub ioss_NumScanKeys: ::std::os::raw::c_int,
    pub ioss_OrderByKeys: *mut ScanKeyData,
    pub ioss_NumOrderByKeys: ::std::os::raw::c_int,
    pub ioss_RuntimeKeys: *mut IndexRuntimeKeyInfo,
    pub ioss_NumRuntimeKeys: ::std::os::raw::c_int,
    pub ioss_RuntimeKeysReady: bool,
    pub ioss_RuntimeContext: *mut ExprContext,
    pub ioss_RelationDesc: Relation,
    pub ioss_ScanDesc: *mut IndexScanDescData,
    pub ioss_TableSlot: *mut TupleTableSlot,
    pub ioss_VMBuffer: Buffer,
    pub ioss_PscanLen: Size,
}
impl Default for IndexOnlyScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapIndexScanState {
    pub ss: ScanState,
    pub biss_result: *mut TIDBitmap,
    pub biss_ScanKeys: *mut ScanKeyData,
    pub biss_NumScanKeys: ::std::os::raw::c_int,
    pub biss_RuntimeKeys: *mut IndexRuntimeKeyInfo,
    pub biss_NumRuntimeKeys: ::std::os::raw::c_int,
    pub biss_ArrayKeys: *mut IndexArrayKeyInfo,
    pub biss_NumArrayKeys: ::std::os::raw::c_int,
    pub biss_RuntimeKeysReady: bool,
    pub biss_RuntimeContext: *mut ExprContext,
    pub biss_RelationDesc: Relation,
    pub biss_ScanDesc: *mut IndexScanDescData,
}
impl Default for BitmapIndexScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const SharedBitmapState_BM_INITIAL: SharedBitmapState = 0;
pub const SharedBitmapState_BM_INPROGRESS: SharedBitmapState = 1;
pub const SharedBitmapState_BM_FINISHED: SharedBitmapState = 2;
pub type SharedBitmapState = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct ParallelBitmapHeapState {
    pub tbmiterator: dsa_pointer,
    pub prefetch_iterator: dsa_pointer,
    pub mutex: slock_t,
    pub prefetch_pages: ::std::os::raw::c_int,
    pub prefetch_target: ::std::os::raw::c_int,
    pub state: SharedBitmapState,
    pub cv: ConditionVariable,
    pub phs_snapshot_data: __IncompleteArrayField<::std::os::raw::c_char>,
}
impl Default for ParallelBitmapHeapState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapHeapScanState {
    pub ss: ScanState,
    pub bitmapqualorig: *mut ExprState,
    pub tbm: *mut TIDBitmap,
    pub tbmiterator: *mut TBMIterator,
    pub tbmres: *mut TBMIterateResult,
    pub can_skip_fetch: bool,
    pub return_empty_tuples: ::std::os::raw::c_int,
    pub vmbuffer: Buffer,
    pub pvmbuffer: Buffer,
    pub exact_pages: ::std::os::raw::c_long,
    pub lossy_pages: ::std::os::raw::c_long,
    pub prefetch_iterator: *mut TBMIterator,
    pub prefetch_pages: ::std::os::raw::c_int,
    pub prefetch_target: ::std::os::raw::c_int,
    pub prefetch_maximum: ::std::os::raw::c_int,
    pub pscan_len: Size,
    pub initialized: bool,
    pub shared_tbmiterator: *mut TBMSharedIterator,
    pub shared_prefetch_iterator: *mut TBMSharedIterator,
    pub pstate: *mut ParallelBitmapHeapState,
}
impl Default for BitmapHeapScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TidScanState {
    pub ss: ScanState,
    pub tss_tidexprs: *mut List,
    pub tss_isCurrentOf: bool,
    pub tss_NumTids: ::std::os::raw::c_int,
    pub tss_TidPtr: ::std::os::raw::c_int,
    pub tss_TidList: *mut ItemPointerData,
    pub tss_htup: HeapTupleData,
}
impl Default for TidScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubqueryScanState {
    pub ss: ScanState,
    pub subplan: *mut PlanState,
}
impl Default for SubqueryScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FunctionScanPerFuncState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FunctionScanState {
    pub ss: ScanState,
    pub eflags: ::std::os::raw::c_int,
    pub ordinality: bool,
    pub simple: bool,
    pub ordinal: int64,
    pub nfuncs: ::std::os::raw::c_int,
    pub funcstates: *mut FunctionScanPerFuncState,
    pub argcontext: MemoryContext,
}
impl Default for FunctionScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ValuesScanState {
    pub ss: ScanState,
    pub rowcontext: *mut ExprContext,
    pub exprlists: *mut *mut List,
    pub exprstatelists: *mut *mut List,
    pub array_len: ::std::os::raw::c_int,
    pub curr_idx: ::std::os::raw::c_int,
}
impl Default for ValuesScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TableFuncScanState {
    pub ss: ScanState,
    pub docexpr: *mut ExprState,
    pub rowexpr: *mut ExprState,
    pub colexprs: *mut List,
    pub coldefexprs: *mut List,
    pub ns_names: *mut List,
    pub ns_uris: *mut List,
    pub notnulls: *mut Bitmapset,
    pub opaque: *mut ::std::os::raw::c_void,
    pub routine: *mut TableFuncRoutine,
    pub in_functions: *mut FmgrInfo,
    pub typioparams: *mut Oid,
    pub ordinal: int64,
    pub perTableCxt: MemoryContext,
    pub tupstore: *mut Tuplestorestate,
}
impl Default for TableFuncScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CteScanState {
    pub ss: ScanState,
    pub eflags: ::std::os::raw::c_int,
    pub readptr: ::std::os::raw::c_int,
    pub cteplanstate: *mut PlanState,
    pub leader: *mut CteScanState,
    pub cte_table: *mut Tuplestorestate,
    pub eof_cte: bool,
}
impl Default for CteScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NamedTuplestoreScanState {
    pub ss: ScanState,
    pub readptr: ::std::os::raw::c_int,
    pub tupdesc: TupleDesc,
    pub relation: *mut Tuplestorestate,
}
impl Default for NamedTuplestoreScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WorkTableScanState {
    pub ss: ScanState,
    pub rustate: *mut RecursiveUnionState,
}
impl Default for WorkTableScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForeignScanState {
    pub ss: ScanState,
    pub fdw_recheck_quals: *mut ExprState,
    pub pscan_len: Size,
    pub fdwroutine: *mut FdwRoutine,
    pub fdw_state: *mut ::std::os::raw::c_void,
}
impl Default for ForeignScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CustomScanState {
    pub ss: ScanState,
    pub flags: uint32,
    pub custom_ps: *mut List,
    pub pscan_len: Size,
    pub methods: *const CustomExecMethods,
}
impl Default for CustomScanState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JoinState {
    pub ps: PlanState,
    pub jointype: JoinType,
    pub single_match: bool,
    pub joinqual: *mut ExprState,
}
impl Default for JoinState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NestLoopState {
    pub js: JoinState,
    pub nl_NeedNewOuter: bool,
    pub nl_MatchedOuter: bool,
    pub nl_NullInnerTupleSlot: *mut TupleTableSlot,
}
impl Default for NestLoopState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeJoinClauseData {
    _unused: [u8; 0],
}
pub type MergeJoinClause = *mut MergeJoinClauseData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeJoinState {
    pub js: JoinState,
    pub mj_NumClauses: ::std::os::raw::c_int,
    pub mj_Clauses: MergeJoinClause,
    pub mj_JoinState: ::std::os::raw::c_int,
    pub mj_SkipMarkRestore: bool,
    pub mj_ExtraMarks: bool,
    pub mj_ConstFalseJoin: bool,
    pub mj_FillOuter: bool,
    pub mj_FillInner: bool,
    pub mj_MatchedOuter: bool,
    pub mj_MatchedInner: bool,
    pub mj_OuterTupleSlot: *mut TupleTableSlot,
    pub mj_InnerTupleSlot: *mut TupleTableSlot,
    pub mj_MarkedTupleSlot: *mut TupleTableSlot,
    pub mj_NullOuterTupleSlot: *mut TupleTableSlot,
    pub mj_NullInnerTupleSlot: *mut TupleTableSlot,
    pub mj_OuterEContext: *mut ExprContext,
    pub mj_InnerEContext: *mut ExprContext,
}
impl Default for MergeJoinState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HashJoinTupleData {
    _unused: [u8; 0],
}
pub type HashJoinTuple = *mut HashJoinTupleData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HashJoinTableData {
    _unused: [u8; 0],
}
pub type HashJoinTable = *mut HashJoinTableData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HashJoinState {
    pub js: JoinState,
    pub hashclauses: *mut ExprState,
    pub hj_OuterHashKeys: *mut List,
    pub hj_HashOperators: *mut List,
    pub hj_Collations: *mut List,
    pub hj_HashTable: HashJoinTable,
    pub hj_CurHashValue: uint32,
    pub hj_CurBucketNo: ::std::os::raw::c_int,
    pub hj_CurSkewBucketNo: ::std::os::raw::c_int,
    pub hj_CurTuple: HashJoinTuple,
    pub hj_OuterTupleSlot: *mut TupleTableSlot,
    pub hj_HashTupleSlot: *mut TupleTableSlot,
    pub hj_NullOuterTupleSlot: *mut TupleTableSlot,
    pub hj_NullInnerTupleSlot: *mut TupleTableSlot,
    pub hj_FirstOuterTupleSlot: *mut TupleTableSlot,
    pub hj_JoinState: ::std::os::raw::c_int,
    pub hj_MatchedOuter: bool,
    pub hj_OuterNotEmpty: bool,
}
impl Default for HashJoinState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MaterialState {
    pub ss: ScanState,
    pub eflags: ::std::os::raw::c_int,
    pub eof_underlying: bool,
    pub tuplestorestate: *mut Tuplestorestate,
}
impl Default for MaterialState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PresortedKeyData {
    pub flinfo: FmgrInfo,
    pub fcinfo: FunctionCallInfo,
    pub attno: OffsetNumber,
}
impl Default for PresortedKeyData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct SharedSortInfo {
    pub num_workers: ::std::os::raw::c_int,
    pub sinstrument: __IncompleteArrayField<TuplesortInstrumentation>,
}
impl Default for SharedSortInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SortState {
    pub ss: ScanState,
    pub randomAccess: bool,
    pub bounded: bool,
    pub bound: int64,
    pub sort_Done: bool,
    pub bounded_Done: bool,
    pub bound_Done: int64,
    pub tuplesortstate: *mut ::std::os::raw::c_void,
    pub am_worker: bool,
    pub shared_info: *mut SharedSortInfo,
}
impl Default for SortState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IncrementalSortGroupInfo {
    pub groupCount: int64,
    pub maxDiskSpaceUsed: int64,
    pub totalDiskSpaceUsed: int64,
    pub maxMemorySpaceUsed: int64,
    pub totalMemorySpaceUsed: int64,
    pub sortMethods: bits32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IncrementalSortInfo {
    pub fullsortGroupInfo: IncrementalSortGroupInfo,
    pub prefixsortGroupInfo: IncrementalSortGroupInfo,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct SharedIncrementalSortInfo {
    pub num_workers: ::std::os::raw::c_int,
    pub sinfo: __IncompleteArrayField<IncrementalSortInfo>,
}
pub const IncrementalSortExecutionStatus_INCSORT_LOADFULLSORT: IncrementalSortExecutionStatus = 0;
pub const IncrementalSortExecutionStatus_INCSORT_LOADPREFIXSORT: IncrementalSortExecutionStatus = 1;
pub const IncrementalSortExecutionStatus_INCSORT_READFULLSORT: IncrementalSortExecutionStatus = 2;
pub const IncrementalSortExecutionStatus_INCSORT_READPREFIXSORT: IncrementalSortExecutionStatus = 3;
pub type IncrementalSortExecutionStatus = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IncrementalSortState {
    pub ss: ScanState,
    pub bounded: bool,
    pub bound: int64,
    pub outerNodeDone: bool,
    pub bound_Done: int64,
    pub execution_status: IncrementalSortExecutionStatus,
    pub n_fullsort_remaining: int64,
    pub fullsort_state: *mut Tuplesortstate,
    pub prefixsort_state: *mut Tuplesortstate,
    pub presorted_keys: *mut PresortedKeyData,
    pub incsort_info: IncrementalSortInfo,
    pub group_pivot: *mut TupleTableSlot,
    pub transfer_tuple: *mut TupleTableSlot,
    pub am_worker: bool,
    pub shared_info: *mut SharedIncrementalSortInfo,
}
impl Default for IncrementalSortState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GroupState {
    pub ss: ScanState,
    pub eqfunction: *mut ExprState,
    pub grp_done: bool,
}
impl Default for GroupState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AggregateInstrumentation {
    pub hash_mem_peak: Size,
    pub hash_disk_used: uint64,
    pub hash_batches_used: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct SharedAggInfo {
    pub num_workers: ::std::os::raw::c_int,
    pub sinstrument: __IncompleteArrayField<AggregateInstrumentation>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggStatePerAggData {
    _unused: [u8; 0],
}
pub type AggStatePerAgg = *mut AggStatePerAggData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggStatePerTransData {
    _unused: [u8; 0],
}
pub type AggStatePerTrans = *mut AggStatePerTransData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggStatePerGroupData {
    _unused: [u8; 0],
}
pub type AggStatePerGroup = *mut AggStatePerGroupData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggStatePerPhaseData {
    _unused: [u8; 0],
}
pub type AggStatePerPhase = *mut AggStatePerPhaseData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggStatePerHashData {
    _unused: [u8; 0],
}
pub type AggStatePerHash = *mut AggStatePerHashData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggState {
    pub ss: ScanState,
    pub aggs: *mut List,
    pub numaggs: ::std::os::raw::c_int,
    pub numtrans: ::std::os::raw::c_int,
    pub aggstrategy: AggStrategy,
    pub aggsplit: AggSplit,
    pub phase: AggStatePerPhase,
    pub numphases: ::std::os::raw::c_int,
    pub current_phase: ::std::os::raw::c_int,
    pub peragg: AggStatePerAgg,
    pub pertrans: AggStatePerTrans,
    pub hashcontext: *mut ExprContext,
    pub aggcontexts: *mut *mut ExprContext,
    pub tmpcontext: *mut ExprContext,
    pub curaggcontext: *mut ExprContext,
    pub curperagg: AggStatePerAgg,
    pub curpertrans: AggStatePerTrans,
    pub input_done: bool,
    pub agg_done: bool,
    pub projected_set: ::std::os::raw::c_int,
    pub current_set: ::std::os::raw::c_int,
    pub grouped_cols: *mut Bitmapset,
    pub all_grouped_cols: *mut List,
    pub colnos_needed: *mut Bitmapset,
    pub max_colno_needed: ::std::os::raw::c_int,
    pub all_cols_needed: bool,
    pub maxsets: ::std::os::raw::c_int,
    pub phases: AggStatePerPhase,
    pub sort_in: *mut Tuplesortstate,
    pub sort_out: *mut Tuplesortstate,
    pub sort_slot: *mut TupleTableSlot,
    pub pergroups: *mut AggStatePerGroup,
    pub grp_firstTuple: HeapTuple,
    pub table_filled: bool,
    pub num_hashes: ::std::os::raw::c_int,
    pub hash_metacxt: MemoryContext,
    pub hash_tapeinfo: *mut HashTapeInfo,
    pub hash_spills: *mut HashAggSpill,
    pub hash_spill_rslot: *mut TupleTableSlot,
    pub hash_spill_wslot: *mut TupleTableSlot,
    pub hash_batches: *mut List,
    pub hash_ever_spilled: bool,
    pub hash_spill_mode: bool,
    pub hash_mem_limit: Size,
    pub hash_ngroups_limit: uint64,
    pub hash_planned_partitions: ::std::os::raw::c_int,
    pub hashentrysize: f64,
    pub hash_mem_peak: Size,
    pub hash_ngroups_current: uint64,
    pub hash_disk_used: uint64,
    pub hash_batches_used: ::std::os::raw::c_int,
    pub perhash: AggStatePerHash,
    pub hash_pergroup: *mut AggStatePerGroup,
    pub all_pergroups: *mut AggStatePerGroup,
    pub combinedproj: *mut ProjectionInfo,
    pub shared_info: *mut SharedAggInfo,
}
impl Default for AggState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowStatePerFuncData {
    _unused: [u8; 0],
}
pub type WindowStatePerFunc = *mut WindowStatePerFuncData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowStatePerAggData {
    _unused: [u8; 0],
}
pub type WindowStatePerAgg = *mut WindowStatePerAggData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowAggState {
    pub ss: ScanState,
    pub funcs: *mut List,
    pub numfuncs: ::std::os::raw::c_int,
    pub numaggs: ::std::os::raw::c_int,
    pub perfunc: WindowStatePerFunc,
    pub peragg: WindowStatePerAgg,
    pub partEqfunction: *mut ExprState,
    pub ordEqfunction: *mut ExprState,
    pub buffer: *mut Tuplestorestate,
    pub current_ptr: ::std::os::raw::c_int,
    pub framehead_ptr: ::std::os::raw::c_int,
    pub frametail_ptr: ::std::os::raw::c_int,
    pub grouptail_ptr: ::std::os::raw::c_int,
    pub spooled_rows: int64,
    pub currentpos: int64,
    pub frameheadpos: int64,
    pub frametailpos: int64,
    pub agg_winobj: *mut WindowObjectData,
    pub aggregatedbase: int64,
    pub aggregatedupto: int64,
    pub frameOptions: ::std::os::raw::c_int,
    pub startOffset: *mut ExprState,
    pub endOffset: *mut ExprState,
    pub startOffsetValue: Datum,
    pub endOffsetValue: Datum,
    pub startInRangeFunc: FmgrInfo,
    pub endInRangeFunc: FmgrInfo,
    pub inRangeColl: Oid,
    pub inRangeAsc: bool,
    pub inRangeNullsFirst: bool,
    pub currentgroup: int64,
    pub frameheadgroup: int64,
    pub frametailgroup: int64,
    pub groupheadpos: int64,
    pub grouptailpos: int64,
    pub partcontext: MemoryContext,
    pub aggcontext: MemoryContext,
    pub curaggcontext: MemoryContext,
    pub tmpcontext: *mut ExprContext,
    pub all_first: bool,
    pub all_done: bool,
    pub partition_spooled: bool,
    pub more_partitions: bool,
    pub framehead_valid: bool,
    pub frametail_valid: bool,
    pub grouptail_valid: bool,
    pub first_part_slot: *mut TupleTableSlot,
    pub framehead_slot: *mut TupleTableSlot,
    pub frametail_slot: *mut TupleTableSlot,
    pub agg_row_slot: *mut TupleTableSlot,
    pub temp_slot_1: *mut TupleTableSlot,
    pub temp_slot_2: *mut TupleTableSlot,
}
impl Default for WindowAggState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UniqueState {
    pub ps: PlanState,
    pub eqfunction: *mut ExprState,
}
impl Default for UniqueState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GatherState {
    pub ps: PlanState,
    pub initialized: bool,
    pub need_to_scan_locally: bool,
    pub tuples_needed: int64,
    pub funnel_slot: *mut TupleTableSlot,
    pub pei: *mut ParallelExecutorInfo,
    pub nworkers_launched: ::std::os::raw::c_int,
    pub nreaders: ::std::os::raw::c_int,
    pub nextreader: ::std::os::raw::c_int,
    pub reader: *mut *mut TupleQueueReader,
}
impl Default for GatherState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GMReaderTupleBuffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GatherMergeState {
    pub ps: PlanState,
    pub initialized: bool,
    pub gm_initialized: bool,
    pub need_to_scan_locally: bool,
    pub tuples_needed: int64,
    pub tupDesc: TupleDesc,
    pub gm_nkeys: ::std::os::raw::c_int,
    pub gm_sortkeys: SortSupport,
    pub pei: *mut ParallelExecutorInfo,
    pub nworkers_launched: ::std::os::raw::c_int,
    pub nreaders: ::std::os::raw::c_int,
    pub gm_slots: *mut *mut TupleTableSlot,
    pub reader: *mut *mut TupleQueueReader,
    pub gm_tuple_buffers: *mut GMReaderTupleBuffer,
    pub gm_heap: *mut binaryheap,
}
impl Default for GatherMergeState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HashInstrumentation {
    pub nbuckets: ::std::os::raw::c_int,
    pub nbuckets_original: ::std::os::raw::c_int,
    pub nbatch: ::std::os::raw::c_int,
    pub nbatch_original: ::std::os::raw::c_int,
    pub space_peak: Size,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct SharedHashInfo {
    pub num_workers: ::std::os::raw::c_int,
    pub hinstrument: __IncompleteArrayField<HashInstrumentation>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HashState {
    pub ps: PlanState,
    pub hashtable: HashJoinTable,
    pub hashkeys: *mut List,
    pub shared_info: *mut SharedHashInfo,
    pub hinstrument: *mut HashInstrumentation,
    pub parallel_state: *mut ParallelHashJoinState,
}
impl Default for HashState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SetOpStatePerGroupData {
    _unused: [u8; 0],
}
pub type SetOpStatePerGroup = *mut SetOpStatePerGroupData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SetOpState {
    pub ps: PlanState,
    pub eqfunction: *mut ExprState,
    pub eqfuncoids: *mut Oid,
    pub hashfunctions: *mut FmgrInfo,
    pub setop_done: bool,
    pub numOutput: ::std::os::raw::c_long,
    pub pergroup: SetOpStatePerGroup,
    pub grp_firstTuple: HeapTuple,
    pub hashtable: TupleHashTable,
    pub tableContext: MemoryContext,
    pub table_filled: bool,
    pub hashiter: TupleHashIterator,
}
impl Default for SetOpState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LockRowsState {
    pub ps: PlanState,
    pub lr_arowMarks: *mut List,
    pub lr_epqstate: EPQState,
}
impl Default for LockRowsState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const LimitStateCond_LIMIT_INITIAL: LimitStateCond = 0;
pub const LimitStateCond_LIMIT_RESCAN: LimitStateCond = 1;
pub const LimitStateCond_LIMIT_EMPTY: LimitStateCond = 2;
pub const LimitStateCond_LIMIT_INWINDOW: LimitStateCond = 3;
pub const LimitStateCond_LIMIT_WINDOWEND_TIES: LimitStateCond = 4;
pub const LimitStateCond_LIMIT_SUBPLANEOF: LimitStateCond = 5;
pub const LimitStateCond_LIMIT_WINDOWEND: LimitStateCond = 6;
pub const LimitStateCond_LIMIT_WINDOWSTART: LimitStateCond = 7;
pub type LimitStateCond = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LimitState {
    pub ps: PlanState,
    pub limitOffset: *mut ExprState,
    pub limitCount: *mut ExprState,
    pub limitOption: LimitOption,
    pub offset: int64,
    pub count: int64,
    pub noCount: bool,
    pub lstate: LimitStateCond,
    pub position: int64,
    pub subSlot: *mut TupleTableSlot,
    pub eqfunction: *mut ExprState,
    pub last_slot: *mut TupleTableSlot,
}
impl Default for LimitState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const CommandTag_CMDTAG_UNKNOWN: CommandTag = 0;
pub const CommandTag_CMDTAG_ALTER_ACCESS_METHOD: CommandTag = 1;
pub const CommandTag_CMDTAG_ALTER_AGGREGATE: CommandTag = 2;
pub const CommandTag_CMDTAG_ALTER_CAST: CommandTag = 3;
pub const CommandTag_CMDTAG_ALTER_COLLATION: CommandTag = 4;
pub const CommandTag_CMDTAG_ALTER_CONSTRAINT: CommandTag = 5;
pub const CommandTag_CMDTAG_ALTER_CONVERSION: CommandTag = 6;
pub const CommandTag_CMDTAG_ALTER_DATABASE: CommandTag = 7;
pub const CommandTag_CMDTAG_ALTER_DEFAULT_PRIVILEGES: CommandTag = 8;
pub const CommandTag_CMDTAG_ALTER_DOMAIN: CommandTag = 9;
pub const CommandTag_CMDTAG_ALTER_EVENT_TRIGGER: CommandTag = 10;
pub const CommandTag_CMDTAG_ALTER_EXTENSION: CommandTag = 11;
pub const CommandTag_CMDTAG_ALTER_FOREIGN_DATA_WRAPPER: CommandTag = 12;
pub const CommandTag_CMDTAG_ALTER_FOREIGN_TABLE: CommandTag = 13;
pub const CommandTag_CMDTAG_ALTER_FUNCTION: CommandTag = 14;
pub const CommandTag_CMDTAG_ALTER_INDEX: CommandTag = 15;
pub const CommandTag_CMDTAG_ALTER_LANGUAGE: CommandTag = 16;
pub const CommandTag_CMDTAG_ALTER_LARGE_OBJECT: CommandTag = 17;
pub const CommandTag_CMDTAG_ALTER_MATERIALIZED_VIEW: CommandTag = 18;
pub const CommandTag_CMDTAG_ALTER_OPERATOR: CommandTag = 19;
pub const CommandTag_CMDTAG_ALTER_OPERATOR_CLASS: CommandTag = 20;
pub const CommandTag_CMDTAG_ALTER_OPERATOR_FAMILY: CommandTag = 21;
pub const CommandTag_CMDTAG_ALTER_POLICY: CommandTag = 22;
pub const CommandTag_CMDTAG_ALTER_PROCEDURE: CommandTag = 23;
pub const CommandTag_CMDTAG_ALTER_PUBLICATION: CommandTag = 24;
pub const CommandTag_CMDTAG_ALTER_ROLE: CommandTag = 25;
pub const CommandTag_CMDTAG_ALTER_ROUTINE: CommandTag = 26;
pub const CommandTag_CMDTAG_ALTER_RULE: CommandTag = 27;
pub const CommandTag_CMDTAG_ALTER_SCHEMA: CommandTag = 28;
pub const CommandTag_CMDTAG_ALTER_SEQUENCE: CommandTag = 29;
pub const CommandTag_CMDTAG_ALTER_SERVER: CommandTag = 30;
pub const CommandTag_CMDTAG_ALTER_STATISTICS: CommandTag = 31;
pub const CommandTag_CMDTAG_ALTER_SUBSCRIPTION: CommandTag = 32;
pub const CommandTag_CMDTAG_ALTER_SYSTEM: CommandTag = 33;
pub const CommandTag_CMDTAG_ALTER_TABLE: CommandTag = 34;
pub const CommandTag_CMDTAG_ALTER_TABLESPACE: CommandTag = 35;
pub const CommandTag_CMDTAG_ALTER_TEXT_SEARCH_CONFIGURATION: CommandTag = 36;
pub const CommandTag_CMDTAG_ALTER_TEXT_SEARCH_DICTIONARY: CommandTag = 37;
pub const CommandTag_CMDTAG_ALTER_TEXT_SEARCH_PARSER: CommandTag = 38;
pub const CommandTag_CMDTAG_ALTER_TEXT_SEARCH_TEMPLATE: CommandTag = 39;
pub const CommandTag_CMDTAG_ALTER_TRANSFORM: CommandTag = 40;
pub const CommandTag_CMDTAG_ALTER_TRIGGER: CommandTag = 41;
pub const CommandTag_CMDTAG_ALTER_TYPE: CommandTag = 42;
pub const CommandTag_CMDTAG_ALTER_USER_MAPPING: CommandTag = 43;
pub const CommandTag_CMDTAG_ALTER_VIEW: CommandTag = 44;
pub const CommandTag_CMDTAG_ANALYZE: CommandTag = 45;
pub const CommandTag_CMDTAG_BEGIN: CommandTag = 46;
pub const CommandTag_CMDTAG_CALL: CommandTag = 47;
pub const CommandTag_CMDTAG_CHECKPOINT: CommandTag = 48;
pub const CommandTag_CMDTAG_CLOSE: CommandTag = 49;
pub const CommandTag_CMDTAG_CLOSE_CURSOR: CommandTag = 50;
pub const CommandTag_CMDTAG_CLOSE_CURSOR_ALL: CommandTag = 51;
pub const CommandTag_CMDTAG_CLUSTER: CommandTag = 52;
pub const CommandTag_CMDTAG_COMMENT: CommandTag = 53;
pub const CommandTag_CMDTAG_COMMIT: CommandTag = 54;
pub const CommandTag_CMDTAG_COMMIT_PREPARED: CommandTag = 55;
pub const CommandTag_CMDTAG_COPY: CommandTag = 56;
pub const CommandTag_CMDTAG_COPY_FROM: CommandTag = 57;
pub const CommandTag_CMDTAG_CREATE_ACCESS_METHOD: CommandTag = 58;
pub const CommandTag_CMDTAG_CREATE_AGGREGATE: CommandTag = 59;
pub const CommandTag_CMDTAG_CREATE_CAST: CommandTag = 60;
pub const CommandTag_CMDTAG_CREATE_COLLATION: CommandTag = 61;
pub const CommandTag_CMDTAG_CREATE_CONSTRAINT: CommandTag = 62;
pub const CommandTag_CMDTAG_CREATE_CONVERSION: CommandTag = 63;
pub const CommandTag_CMDTAG_CREATE_DATABASE: CommandTag = 64;
pub const CommandTag_CMDTAG_CREATE_DOMAIN: CommandTag = 65;
pub const CommandTag_CMDTAG_CREATE_EVENT_TRIGGER: CommandTag = 66;
pub const CommandTag_CMDTAG_CREATE_EXTENSION: CommandTag = 67;
pub const CommandTag_CMDTAG_CREATE_FOREIGN_DATA_WRAPPER: CommandTag = 68;
pub const CommandTag_CMDTAG_CREATE_FOREIGN_TABLE: CommandTag = 69;
pub const CommandTag_CMDTAG_CREATE_FUNCTION: CommandTag = 70;
pub const CommandTag_CMDTAG_CREATE_INDEX: CommandTag = 71;
pub const CommandTag_CMDTAG_CREATE_LANGUAGE: CommandTag = 72;
pub const CommandTag_CMDTAG_CREATE_MATERIALIZED_VIEW: CommandTag = 73;
pub const CommandTag_CMDTAG_CREATE_OPERATOR: CommandTag = 74;
pub const CommandTag_CMDTAG_CREATE_OPERATOR_CLASS: CommandTag = 75;
pub const CommandTag_CMDTAG_CREATE_OPERATOR_FAMILY: CommandTag = 76;
pub const CommandTag_CMDTAG_CREATE_POLICY: CommandTag = 77;
pub const CommandTag_CMDTAG_CREATE_PROCEDURE: CommandTag = 78;
pub const CommandTag_CMDTAG_CREATE_PUBLICATION: CommandTag = 79;
pub const CommandTag_CMDTAG_CREATE_ROLE: CommandTag = 80;
pub const CommandTag_CMDTAG_CREATE_ROUTINE: CommandTag = 81;
pub const CommandTag_CMDTAG_CREATE_RULE: CommandTag = 82;
pub const CommandTag_CMDTAG_CREATE_SCHEMA: CommandTag = 83;
pub const CommandTag_CMDTAG_CREATE_SEQUENCE: CommandTag = 84;
pub const CommandTag_CMDTAG_CREATE_SERVER: CommandTag = 85;
pub const CommandTag_CMDTAG_CREATE_STATISTICS: CommandTag = 86;
pub const CommandTag_CMDTAG_CREATE_SUBSCRIPTION: CommandTag = 87;
pub const CommandTag_CMDTAG_CREATE_TABLE: CommandTag = 88;
pub const CommandTag_CMDTAG_CREATE_TABLE_AS: CommandTag = 89;
pub const CommandTag_CMDTAG_CREATE_TABLESPACE: CommandTag = 90;
pub const CommandTag_CMDTAG_CREATE_TEXT_SEARCH_CONFIGURATION: CommandTag = 91;
pub const CommandTag_CMDTAG_CREATE_TEXT_SEARCH_DICTIONARY: CommandTag = 92;
pub const CommandTag_CMDTAG_CREATE_TEXT_SEARCH_PARSER: CommandTag = 93;
pub const CommandTag_CMDTAG_CREATE_TEXT_SEARCH_TEMPLATE: CommandTag = 94;
pub const CommandTag_CMDTAG_CREATE_TRANSFORM: CommandTag = 95;
pub const CommandTag_CMDTAG_CREATE_TRIGGER: CommandTag = 96;
pub const CommandTag_CMDTAG_CREATE_TYPE: CommandTag = 97;
pub const CommandTag_CMDTAG_CREATE_USER_MAPPING: CommandTag = 98;
pub const CommandTag_CMDTAG_CREATE_VIEW: CommandTag = 99;
pub const CommandTag_CMDTAG_DEALLOCATE: CommandTag = 100;
pub const CommandTag_CMDTAG_DEALLOCATE_ALL: CommandTag = 101;
pub const CommandTag_CMDTAG_DECLARE_CURSOR: CommandTag = 102;
pub const CommandTag_CMDTAG_DELETE: CommandTag = 103;
pub const CommandTag_CMDTAG_DISCARD: CommandTag = 104;
pub const CommandTag_CMDTAG_DISCARD_ALL: CommandTag = 105;
pub const CommandTag_CMDTAG_DISCARD_PLANS: CommandTag = 106;
pub const CommandTag_CMDTAG_DISCARD_SEQUENCES: CommandTag = 107;
pub const CommandTag_CMDTAG_DISCARD_TEMP: CommandTag = 108;
pub const CommandTag_CMDTAG_DO: CommandTag = 109;
pub const CommandTag_CMDTAG_DROP_ACCESS_METHOD: CommandTag = 110;
pub const CommandTag_CMDTAG_DROP_AGGREGATE: CommandTag = 111;
pub const CommandTag_CMDTAG_DROP_CAST: CommandTag = 112;
pub const CommandTag_CMDTAG_DROP_COLLATION: CommandTag = 113;
pub const CommandTag_CMDTAG_DROP_CONSTRAINT: CommandTag = 114;
pub const CommandTag_CMDTAG_DROP_CONVERSION: CommandTag = 115;
pub const CommandTag_CMDTAG_DROP_DATABASE: CommandTag = 116;
pub const CommandTag_CMDTAG_DROP_DOMAIN: CommandTag = 117;
pub const CommandTag_CMDTAG_DROP_EVENT_TRIGGER: CommandTag = 118;
pub const CommandTag_CMDTAG_DROP_EXTENSION: CommandTag = 119;
pub const CommandTag_CMDTAG_DROP_FOREIGN_DATA_WRAPPER: CommandTag = 120;
pub const CommandTag_CMDTAG_DROP_FOREIGN_TABLE: CommandTag = 121;
pub const CommandTag_CMDTAG_DROP_FUNCTION: CommandTag = 122;
pub const CommandTag_CMDTAG_DROP_INDEX: CommandTag = 123;
pub const CommandTag_CMDTAG_DROP_LANGUAGE: CommandTag = 124;
pub const CommandTag_CMDTAG_DROP_MATERIALIZED_VIEW: CommandTag = 125;
pub const CommandTag_CMDTAG_DROP_OPERATOR: CommandTag = 126;
pub const CommandTag_CMDTAG_DROP_OPERATOR_CLASS: CommandTag = 127;
pub const CommandTag_CMDTAG_DROP_OPERATOR_FAMILY: CommandTag = 128;
pub const CommandTag_CMDTAG_DROP_OWNED: CommandTag = 129;
pub const CommandTag_CMDTAG_DROP_POLICY: CommandTag = 130;
pub const CommandTag_CMDTAG_DROP_PROCEDURE: CommandTag = 131;
pub const CommandTag_CMDTAG_DROP_PUBLICATION: CommandTag = 132;
pub const CommandTag_CMDTAG_DROP_ROLE: CommandTag = 133;
pub const CommandTag_CMDTAG_DROP_ROUTINE: CommandTag = 134;
pub const CommandTag_CMDTAG_DROP_RULE: CommandTag = 135;
pub const CommandTag_CMDTAG_DROP_SCHEMA: CommandTag = 136;
pub const CommandTag_CMDTAG_DROP_SEQUENCE: CommandTag = 137;
pub const CommandTag_CMDTAG_DROP_SERVER: CommandTag = 138;
pub const CommandTag_CMDTAG_DROP_STATISTICS: CommandTag = 139;
pub const CommandTag_CMDTAG_DROP_SUBSCRIPTION: CommandTag = 140;
pub const CommandTag_CMDTAG_DROP_TABLE: CommandTag = 141;
pub const CommandTag_CMDTAG_DROP_TABLESPACE: CommandTag = 142;
pub const CommandTag_CMDTAG_DROP_TEXT_SEARCH_CONFIGURATION: CommandTag = 143;
pub const CommandTag_CMDTAG_DROP_TEXT_SEARCH_DICTIONARY: CommandTag = 144;
pub const CommandTag_CMDTAG_DROP_TEXT_SEARCH_PARSER: CommandTag = 145;
pub const CommandTag_CMDTAG_DROP_TEXT_SEARCH_TEMPLATE: CommandTag = 146;
pub const CommandTag_CMDTAG_DROP_TRANSFORM: CommandTag = 147;
pub const CommandTag_CMDTAG_DROP_TRIGGER: CommandTag = 148;
pub const CommandTag_CMDTAG_DROP_TYPE: CommandTag = 149;
pub const CommandTag_CMDTAG_DROP_USER_MAPPING: CommandTag = 150;
pub const CommandTag_CMDTAG_DROP_VIEW: CommandTag = 151;
pub const CommandTag_CMDTAG_EXECUTE: CommandTag = 152;
pub const CommandTag_CMDTAG_EXPLAIN: CommandTag = 153;
pub const CommandTag_CMDTAG_FETCH: CommandTag = 154;
pub const CommandTag_CMDTAG_GRANT: CommandTag = 155;
pub const CommandTag_CMDTAG_GRANT_ROLE: CommandTag = 156;
pub const CommandTag_CMDTAG_IMPORT_FOREIGN_SCHEMA: CommandTag = 157;
pub const CommandTag_CMDTAG_INSERT: CommandTag = 158;
pub const CommandTag_CMDTAG_LISTEN: CommandTag = 159;
pub const CommandTag_CMDTAG_LOAD: CommandTag = 160;
pub const CommandTag_CMDTAG_LOCK_TABLE: CommandTag = 161;
pub const CommandTag_CMDTAG_MOVE: CommandTag = 162;
pub const CommandTag_CMDTAG_NOTIFY: CommandTag = 163;
pub const CommandTag_CMDTAG_PREPARE: CommandTag = 164;
pub const CommandTag_CMDTAG_PREPARE_TRANSACTION: CommandTag = 165;
pub const CommandTag_CMDTAG_REASSIGN_OWNED: CommandTag = 166;
pub const CommandTag_CMDTAG_REFRESH_MATERIALIZED_VIEW: CommandTag = 167;
pub const CommandTag_CMDTAG_REINDEX: CommandTag = 168;
pub const CommandTag_CMDTAG_RELEASE: CommandTag = 169;
pub const CommandTag_CMDTAG_RESET: CommandTag = 170;
pub const CommandTag_CMDTAG_REVOKE: CommandTag = 171;
pub const CommandTag_CMDTAG_REVOKE_ROLE: CommandTag = 172;
pub const CommandTag_CMDTAG_ROLLBACK: CommandTag = 173;
pub const CommandTag_CMDTAG_ROLLBACK_PREPARED: CommandTag = 174;
pub const CommandTag_CMDTAG_SAVEPOINT: CommandTag = 175;
pub const CommandTag_CMDTAG_SECURITY_LABEL: CommandTag = 176;
pub const CommandTag_CMDTAG_SELECT: CommandTag = 177;
pub const CommandTag_CMDTAG_SELECT_FOR_KEY_SHARE: CommandTag = 178;
pub const CommandTag_CMDTAG_SELECT_FOR_NO_KEY_UPDATE: CommandTag = 179;
pub const CommandTag_CMDTAG_SELECT_FOR_SHARE: CommandTag = 180;
pub const CommandTag_CMDTAG_SELECT_FOR_UPDATE: CommandTag = 181;
pub const CommandTag_CMDTAG_SELECT_INTO: CommandTag = 182;
pub const CommandTag_CMDTAG_SET: CommandTag = 183;
pub const CommandTag_CMDTAG_SET_CONSTRAINTS: CommandTag = 184;
pub const CommandTag_CMDTAG_SHOW: CommandTag = 185;
pub const CommandTag_CMDTAG_START_TRANSACTION: CommandTag = 186;
pub const CommandTag_CMDTAG_TRUNCATE_TABLE: CommandTag = 187;
pub const CommandTag_CMDTAG_UNLISTEN: CommandTag = 188;
pub const CommandTag_CMDTAG_UPDATE: CommandTag = 189;
pub const CommandTag_CMDTAG_VACUUM: CommandTag = 190;
pub const CommandTag_COMMAND_TAG_NEXTTAG: CommandTag = 191;
pub type CommandTag = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueryCompletion {
    pub commandTag: CommandTag,
    pub nprocessed: uint64,
}
impl Default for QueryCompletion {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn InitializeQueryCompletion(arg_qc: *mut QueryCompletion) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitializeQueryCompletion(arg_qc: *mut QueryCompletion);
        }
        InitializeQueryCompletion(arg_qc)
    })
}
pub unsafe fn GetCommandTagName(arg_commandTag: CommandTag) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetCommandTagName(arg_commandTag: CommandTag) -> *const ::std::os::raw::c_char;
        }
        GetCommandTagName(arg_commandTag)
    })
}
pub unsafe fn command_tag_display_rowcount(arg_commandTag: CommandTag) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn command_tag_display_rowcount(arg_commandTag: CommandTag) -> bool;
        }
        command_tag_display_rowcount(arg_commandTag)
    })
}
pub unsafe fn command_tag_event_trigger_ok(arg_commandTag: CommandTag) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn command_tag_event_trigger_ok(arg_commandTag: CommandTag) -> bool;
        }
        command_tag_event_trigger_ok(arg_commandTag)
    })
}
pub unsafe fn command_tag_table_rewrite_ok(arg_commandTag: CommandTag) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn command_tag_table_rewrite_ok(arg_commandTag: CommandTag) -> bool;
        }
        command_tag_table_rewrite_ok(arg_commandTag)
    })
}
pub unsafe fn GetCommandTagEnum(arg_tagname: *const ::std::os::raw::c_char) -> CommandTag {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetCommandTagEnum(arg_tagname: *const ::std::os::raw::c_char) -> CommandTag;
        }
        GetCommandTagEnum(arg_tagname)
    })
}
pub const CommandDest_DestNone: CommandDest = 0;
pub const CommandDest_DestDebug: CommandDest = 1;
pub const CommandDest_DestRemote: CommandDest = 2;
pub const CommandDest_DestRemoteExecute: CommandDest = 3;
pub const CommandDest_DestRemoteSimple: CommandDest = 4;
pub const CommandDest_DestSPI: CommandDest = 5;
pub const CommandDest_DestTuplestore: CommandDest = 6;
pub const CommandDest_DestIntoRel: CommandDest = 7;
pub const CommandDest_DestCopyOut: CommandDest = 8;
pub const CommandDest_DestSQLFunction: CommandDest = 9;
pub const CommandDest_DestTransientRel: CommandDest = 10;
pub const CommandDest_DestTupleQueue: CommandDest = 11;
pub type CommandDest = ::std::os::raw::c_uint;
pub type DestReceiver = _DestReceiver;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DestReceiver {
    pub receiveSlot: ::std::option::Option<
        unsafe extern "C" fn(slot: *mut TupleTableSlot, self_: *mut DestReceiver) -> bool,
    >,
    pub rStartup: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut DestReceiver,
            operation: ::std::os::raw::c_int,
            typeinfo: TupleDesc,
        ),
    >,
    pub rShutdown: ::std::option::Option<unsafe extern "C" fn(self_: *mut DestReceiver)>,
    pub rDestroy: ::std::option::Option<unsafe extern "C" fn(self_: *mut DestReceiver)>,
    pub mydest: CommandDest,
}
impl Default for _DestReceiver {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut None_Receiver: *mut DestReceiver;
}
pub unsafe fn BeginCommand(arg_commandTag: CommandTag, arg_dest: CommandDest) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BeginCommand(arg_commandTag: CommandTag, arg_dest: CommandDest);
        }
        BeginCommand(arg_commandTag, arg_dest)
    })
}
pub unsafe fn CreateDestReceiver(arg_dest: CommandDest) -> *mut DestReceiver {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateDestReceiver(arg_dest: CommandDest) -> *mut DestReceiver;
        }
        CreateDestReceiver(arg_dest)
    })
}
pub unsafe fn EndCommand(
    arg_qc: *const QueryCompletion,
    arg_dest: CommandDest,
    arg_force_undecorated_output: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EndCommand(
                arg_qc: *const QueryCompletion,
                arg_dest: CommandDest,
                arg_force_undecorated_output: bool,
            );
        }
        EndCommand(arg_qc, arg_dest, arg_force_undecorated_output)
    })
}
pub unsafe fn EndReplicationCommand(arg_commandTag: *const ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EndReplicationCommand(arg_commandTag: *const ::std::os::raw::c_char);
        }
        EndReplicationCommand(arg_commandTag)
    })
}
pub unsafe fn NullCommand(arg_dest: CommandDest) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn NullCommand(arg_dest: CommandDest);
        }
        NullCommand(arg_dest)
    })
}
pub unsafe fn ReadyForQuery(arg_dest: CommandDest) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReadyForQuery(arg_dest: CommandDest);
        }
        ReadyForQuery(arg_dest)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueryDesc {
    pub operation: CmdType,
    pub plannedstmt: *mut PlannedStmt,
    pub sourceText: *const ::std::os::raw::c_char,
    pub snapshot: Snapshot,
    pub crosscheck_snapshot: Snapshot,
    pub dest: *mut DestReceiver,
    pub params: ParamListInfo,
    pub queryEnv: *mut QueryEnvironment,
    pub instrument_options: ::std::os::raw::c_int,
    pub tupDesc: TupleDesc,
    pub estate: *mut EState,
    pub planstate: *mut PlanState,
    pub already_executed: bool,
    pub totaltime: *mut Instrumentation,
}
impl Default for QueryDesc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn CreateQueryDesc(
    arg_plannedstmt: *mut PlannedStmt,
    arg_sourceText: *const ::std::os::raw::c_char,
    arg_snapshot: Snapshot,
    arg_crosscheck_snapshot: Snapshot,
    arg_dest: *mut DestReceiver,
    arg_params: ParamListInfo,
    arg_queryEnv: *mut QueryEnvironment,
    arg_instrument_options: ::std::os::raw::c_int,
) -> *mut QueryDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateQueryDesc(
                arg_plannedstmt: *mut PlannedStmt,
                arg_sourceText: *const ::std::os::raw::c_char,
                arg_snapshot: Snapshot,
                arg_crosscheck_snapshot: Snapshot,
                arg_dest: *mut DestReceiver,
                arg_params: ParamListInfo,
                arg_queryEnv: *mut QueryEnvironment,
                arg_instrument_options: ::std::os::raw::c_int,
            ) -> *mut QueryDesc;
        }
        CreateQueryDesc(
            arg_plannedstmt,
            arg_sourceText,
            arg_snapshot,
            arg_crosscheck_snapshot,
            arg_dest,
            arg_params,
            arg_queryEnv,
            arg_instrument_options,
        )
    })
}
pub unsafe fn FreeQueryDesc(arg_qdesc: *mut QueryDesc) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FreeQueryDesc(arg_qdesc: *mut QueryDesc);
        }
        FreeQueryDesc(arg_qdesc)
    })
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Value {
    pub type_: NodeTag,
    pub val: Value_ValUnion,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Value_ValUnion {
    pub ival: ::std::os::raw::c_int,
    pub str_: *mut ::std::os::raw::c_char,
}
impl Default for Value_ValUnion {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for Value {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn makeInteger(arg_i: ::std::os::raw::c_int) -> *mut Value {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeInteger(arg_i: ::std::os::raw::c_int) -> *mut Value;
        }
        makeInteger(arg_i)
    })
}
pub unsafe fn makeFloat(arg_numericStr: *mut ::std::os::raw::c_char) -> *mut Value {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeFloat(arg_numericStr: *mut ::std::os::raw::c_char) -> *mut Value;
        }
        makeFloat(arg_numericStr)
    })
}
pub unsafe fn makeString(arg_str_: *mut ::std::os::raw::c_char) -> *mut Value {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeString(arg_str_: *mut ::std::os::raw::c_char) -> *mut Value;
        }
        makeString(arg_str_)
    })
}
pub unsafe fn makeBitString(arg_str_: *mut ::std::os::raw::c_char) -> *mut Value {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeBitString(arg_str_: *mut ::std::os::raw::c_char) -> *mut Value;
        }
        makeBitString(arg_str_)
    })
}
pub const OverridingKind_OVERRIDING_NOT_SET: OverridingKind = 0;
pub const OverridingKind_OVERRIDING_USER_VALUE: OverridingKind = 1;
pub const OverridingKind_OVERRIDING_SYSTEM_VALUE: OverridingKind = 2;
pub type OverridingKind = ::std::os::raw::c_uint;
pub const QuerySource_QSRC_ORIGINAL: QuerySource = 0;
pub const QuerySource_QSRC_PARSER: QuerySource = 1;
pub const QuerySource_QSRC_INSTEAD_RULE: QuerySource = 2;
pub const QuerySource_QSRC_QUAL_INSTEAD_RULE: QuerySource = 3;
pub const QuerySource_QSRC_NON_INSTEAD_RULE: QuerySource = 4;
pub type QuerySource = ::std::os::raw::c_uint;
pub const SortByDir_SORTBY_DEFAULT: SortByDir = 0;
pub const SortByDir_SORTBY_ASC: SortByDir = 1;
pub const SortByDir_SORTBY_DESC: SortByDir = 2;
pub const SortByDir_SORTBY_USING: SortByDir = 3;
pub type SortByDir = ::std::os::raw::c_uint;
pub const SortByNulls_SORTBY_NULLS_DEFAULT: SortByNulls = 0;
pub const SortByNulls_SORTBY_NULLS_FIRST: SortByNulls = 1;
pub const SortByNulls_SORTBY_NULLS_LAST: SortByNulls = 2;
pub type SortByNulls = ::std::os::raw::c_uint;
pub type AclMode = uint32;
#[doc = "\tQuery Tree"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Query {
    pub type_: NodeTag,
    pub commandType: CmdType,
    pub querySource: QuerySource,
    pub queryId: uint64,
    pub canSetTag: bool,
    pub utilityStmt: *mut Node,
    pub resultRelation: ::std::os::raw::c_int,
    pub hasAggs: bool,
    pub hasWindowFuncs: bool,
    pub hasTargetSRFs: bool,
    pub hasSubLinks: bool,
    pub hasDistinctOn: bool,
    pub hasRecursive: bool,
    pub hasModifyingCTE: bool,
    pub hasForUpdate: bool,
    pub hasRowSecurity: bool,
    pub cteList: *mut List,
    pub rtable: *mut List,
    pub jointree: *mut FromExpr,
    pub targetList: *mut List,
    pub override_: OverridingKind,
    pub onConflict: *mut OnConflictExpr,
    pub returningList: *mut List,
    pub groupClause: *mut List,
    pub groupingSets: *mut List,
    pub havingQual: *mut Node,
    pub windowClause: *mut List,
    pub distinctClause: *mut List,
    pub sortClause: *mut List,
    pub limitOffset: *mut Node,
    pub limitCount: *mut Node,
    pub limitOption: LimitOption,
    pub rowMarks: *mut List,
    pub setOperations: *mut Node,
    pub constraintDeps: *mut List,
    pub withCheckOptions: *mut List,
    pub stmt_location: ::std::os::raw::c_int,
    pub stmt_len: ::std::os::raw::c_int,
}
impl Default for Query {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\tSupporting data structures for Parse Trees"]
#[doc = ""]
#[doc = "\tMost of these node types appear in raw parsetrees output by the grammar,"]
#[doc = "\tand get transformed to something else by the analyzer.  A few of them"]
#[doc = "\tare used as-is in transformed querytrees."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TypeName {
    pub type_: NodeTag,
    pub names: *mut List,
    pub typeOid: Oid,
    pub setof: bool,
    pub pct_type: bool,
    pub typmods: *mut List,
    pub typemod: int32,
    pub arrayBounds: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl Default for TypeName {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ColumnRef {
    pub type_: NodeTag,
    pub fields: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl Default for ColumnRef {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParamRef {
    pub type_: NodeTag,
    pub number: ::std::os::raw::c_int,
    pub location: ::std::os::raw::c_int,
}
impl Default for ParamRef {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const A_Expr_Kind_AEXPR_OP: A_Expr_Kind = 0;
pub const A_Expr_Kind_AEXPR_OP_ANY: A_Expr_Kind = 1;
pub const A_Expr_Kind_AEXPR_OP_ALL: A_Expr_Kind = 2;
pub const A_Expr_Kind_AEXPR_DISTINCT: A_Expr_Kind = 3;
pub const A_Expr_Kind_AEXPR_NOT_DISTINCT: A_Expr_Kind = 4;
pub const A_Expr_Kind_AEXPR_NULLIF: A_Expr_Kind = 5;
pub const A_Expr_Kind_AEXPR_OF: A_Expr_Kind = 6;
pub const A_Expr_Kind_AEXPR_IN: A_Expr_Kind = 7;
pub const A_Expr_Kind_AEXPR_LIKE: A_Expr_Kind = 8;
pub const A_Expr_Kind_AEXPR_ILIKE: A_Expr_Kind = 9;
pub const A_Expr_Kind_AEXPR_SIMILAR: A_Expr_Kind = 10;
pub const A_Expr_Kind_AEXPR_BETWEEN: A_Expr_Kind = 11;
pub const A_Expr_Kind_AEXPR_NOT_BETWEEN: A_Expr_Kind = 12;
pub const A_Expr_Kind_AEXPR_BETWEEN_SYM: A_Expr_Kind = 13;
pub const A_Expr_Kind_AEXPR_NOT_BETWEEN_SYM: A_Expr_Kind = 14;
pub const A_Expr_Kind_AEXPR_PAREN: A_Expr_Kind = 15;
pub type A_Expr_Kind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct A_Expr {
    pub type_: NodeTag,
    pub kind: A_Expr_Kind,
    pub name: *mut List,
    pub lexpr: *mut Node,
    pub rexpr: *mut Node,
    pub location: ::std::os::raw::c_int,
}
impl Default for A_Expr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct A_Const {
    pub type_: NodeTag,
    pub val: Value,
    pub location: ::std::os::raw::c_int,
}
impl Default for A_Const {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TypeCast {
    pub type_: NodeTag,
    pub arg: *mut Node,
    pub typeName: *mut TypeName,
    pub location: ::std::os::raw::c_int,
}
impl Default for TypeCast {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CollateClause {
    pub type_: NodeTag,
    pub arg: *mut Node,
    pub collname: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl Default for CollateClause {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const RoleSpecType_ROLESPEC_CSTRING: RoleSpecType = 0;
pub const RoleSpecType_ROLESPEC_CURRENT_USER: RoleSpecType = 1;
pub const RoleSpecType_ROLESPEC_SESSION_USER: RoleSpecType = 2;
pub const RoleSpecType_ROLESPEC_PUBLIC: RoleSpecType = 3;
pub type RoleSpecType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RoleSpec {
    pub type_: NodeTag,
    pub roletype: RoleSpecType,
    pub rolename: *mut ::std::os::raw::c_char,
    pub location: ::std::os::raw::c_int,
}
impl Default for RoleSpec {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuncCall {
    pub type_: NodeTag,
    pub funcname: *mut List,
    pub args: *mut List,
    pub agg_order: *mut List,
    pub agg_filter: *mut Node,
    pub agg_within_group: bool,
    pub agg_star: bool,
    pub agg_distinct: bool,
    pub func_variadic: bool,
    pub over: *mut WindowDef,
    pub location: ::std::os::raw::c_int,
}
impl Default for FuncCall {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct A_Star {
    pub type_: NodeTag,
}
impl Default for A_Star {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct A_Indices {
    pub type_: NodeTag,
    pub is_slice: bool,
    pub lidx: *mut Node,
    pub uidx: *mut Node,
}
impl Default for A_Indices {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct A_Indirection {
    pub type_: NodeTag,
    pub arg: *mut Node,
    pub indirection: *mut List,
}
impl Default for A_Indirection {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct A_ArrayExpr {
    pub type_: NodeTag,
    pub elements: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl Default for A_ArrayExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResTarget {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub indirection: *mut List,
    pub val: *mut Node,
    pub location: ::std::os::raw::c_int,
}
impl Default for ResTarget {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MultiAssignRef {
    pub type_: NodeTag,
    pub source: *mut Node,
    pub colno: ::std::os::raw::c_int,
    pub ncolumns: ::std::os::raw::c_int,
}
impl Default for MultiAssignRef {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SortBy {
    pub type_: NodeTag,
    pub node: *mut Node,
    pub sortby_dir: SortByDir,
    pub sortby_nulls: SortByNulls,
    pub useOp: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl Default for SortBy {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowDef {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub refname: *mut ::std::os::raw::c_char,
    pub partitionClause: *mut List,
    pub orderClause: *mut List,
    pub frameOptions: ::std::os::raw::c_int,
    pub startOffset: *mut Node,
    pub endOffset: *mut Node,
    pub location: ::std::os::raw::c_int,
}
impl Default for WindowDef {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeSubselect {
    pub type_: NodeTag,
    pub lateral: bool,
    pub subquery: *mut Node,
    pub alias: *mut Alias,
}
impl Default for RangeSubselect {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeFunction {
    pub type_: NodeTag,
    pub lateral: bool,
    pub ordinality: bool,
    pub is_rowsfrom: bool,
    pub functions: *mut List,
    pub alias: *mut Alias,
    pub coldeflist: *mut List,
}
impl Default for RangeFunction {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeTableFunc {
    pub type_: NodeTag,
    pub lateral: bool,
    pub docexpr: *mut Node,
    pub rowexpr: *mut Node,
    pub namespaces: *mut List,
    pub columns: *mut List,
    pub alias: *mut Alias,
    pub location: ::std::os::raw::c_int,
}
impl Default for RangeTableFunc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeTableFuncCol {
    pub type_: NodeTag,
    pub colname: *mut ::std::os::raw::c_char,
    pub typeName: *mut TypeName,
    pub for_ordinality: bool,
    pub is_not_null: bool,
    pub colexpr: *mut Node,
    pub coldefexpr: *mut Node,
    pub location: ::std::os::raw::c_int,
}
impl Default for RangeTableFuncCol {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeTableSample {
    pub type_: NodeTag,
    pub relation: *mut Node,
    pub method: *mut List,
    pub args: *mut List,
    pub repeatable: *mut Node,
    pub location: ::std::os::raw::c_int,
}
impl Default for RangeTableSample {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ColumnDef {
    pub type_: NodeTag,
    pub colname: *mut ::std::os::raw::c_char,
    pub typeName: *mut TypeName,
    pub inhcount: ::std::os::raw::c_int,
    pub is_local: bool,
    pub is_not_null: bool,
    pub is_from_type: bool,
    pub storage: ::std::os::raw::c_char,
    pub raw_default: *mut Node,
    pub cooked_default: *mut Node,
    pub identity: ::std::os::raw::c_char,
    pub identitySequence: *mut RangeVar,
    pub generated: ::std::os::raw::c_char,
    pub collClause: *mut CollateClause,
    pub collOid: Oid,
    pub constraints: *mut List,
    pub fdwoptions: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl Default for ColumnDef {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TableLikeClause {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub options: bits32,
    pub relationOid: Oid,
}
impl Default for TableLikeClause {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const TableLikeOption_CREATE_TABLE_LIKE_COMMENTS: TableLikeOption = 1;
pub const TableLikeOption_CREATE_TABLE_LIKE_CONSTRAINTS: TableLikeOption = 2;
pub const TableLikeOption_CREATE_TABLE_LIKE_DEFAULTS: TableLikeOption = 4;
pub const TableLikeOption_CREATE_TABLE_LIKE_GENERATED: TableLikeOption = 8;
pub const TableLikeOption_CREATE_TABLE_LIKE_IDENTITY: TableLikeOption = 16;
pub const TableLikeOption_CREATE_TABLE_LIKE_INDEXES: TableLikeOption = 32;
pub const TableLikeOption_CREATE_TABLE_LIKE_STATISTICS: TableLikeOption = 64;
pub const TableLikeOption_CREATE_TABLE_LIKE_STORAGE: TableLikeOption = 128;
pub const TableLikeOption_CREATE_TABLE_LIKE_ALL: TableLikeOption = 2147483647;
pub type TableLikeOption = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexElem {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub expr: *mut Node,
    pub indexcolname: *mut ::std::os::raw::c_char,
    pub collation: *mut List,
    pub opclass: *mut List,
    pub opclassopts: *mut List,
    pub ordering: SortByDir,
    pub nulls_ordering: SortByNulls,
}
impl Default for IndexElem {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const DefElemAction_DEFELEM_UNSPEC: DefElemAction = 0;
pub const DefElemAction_DEFELEM_SET: DefElemAction = 1;
pub const DefElemAction_DEFELEM_ADD: DefElemAction = 2;
pub const DefElemAction_DEFELEM_DROP: DefElemAction = 3;
pub type DefElemAction = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DefElem {
    pub type_: NodeTag,
    pub defnamespace: *mut ::std::os::raw::c_char,
    pub defname: *mut ::std::os::raw::c_char,
    pub arg: *mut Node,
    pub defaction: DefElemAction,
    pub location: ::std::os::raw::c_int,
}
impl Default for DefElem {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LockingClause {
    pub type_: NodeTag,
    pub lockedRels: *mut List,
    pub strength: LockClauseStrength,
    pub waitPolicy: LockWaitPolicy,
}
impl Default for LockingClause {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XmlSerialize {
    pub type_: NodeTag,
    pub xmloption: XmlOptionType,
    pub expr: *mut Node,
    pub typeName: *mut TypeName,
    pub location: ::std::os::raw::c_int,
}
impl Default for XmlSerialize {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionElem {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub expr: *mut Node,
    pub collation: *mut List,
    pub opclass: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl Default for PartitionElem {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionSpec {
    pub type_: NodeTag,
    pub strategy: *mut ::std::os::raw::c_char,
    pub partParams: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl Default for PartitionSpec {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionBoundSpec {
    pub type_: NodeTag,
    pub strategy: ::std::os::raw::c_char,
    pub is_default: bool,
    pub modulus: ::std::os::raw::c_int,
    pub remainder: ::std::os::raw::c_int,
    pub listdatums: *mut List,
    pub lowerdatums: *mut List,
    pub upperdatums: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl Default for PartitionBoundSpec {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const PartitionRangeDatumKind_PARTITION_RANGE_DATUM_MINVALUE: PartitionRangeDatumKind = -1;
pub const PartitionRangeDatumKind_PARTITION_RANGE_DATUM_VALUE: PartitionRangeDatumKind = 0;
pub const PartitionRangeDatumKind_PARTITION_RANGE_DATUM_MAXVALUE: PartitionRangeDatumKind = 1;
pub type PartitionRangeDatumKind = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionRangeDatum {
    pub type_: NodeTag,
    pub kind: PartitionRangeDatumKind,
    pub value: *mut Node,
    pub location: ::std::os::raw::c_int,
}
impl Default for PartitionRangeDatum {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionCmd {
    pub type_: NodeTag,
    pub name: *mut RangeVar,
    pub bound: *mut PartitionBoundSpec,
}
impl Default for PartitionCmd {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const RTEKind_RTE_RELATION: RTEKind = 0;
pub const RTEKind_RTE_SUBQUERY: RTEKind = 1;
pub const RTEKind_RTE_JOIN: RTEKind = 2;
pub const RTEKind_RTE_FUNCTION: RTEKind = 3;
pub const RTEKind_RTE_TABLEFUNC: RTEKind = 4;
pub const RTEKind_RTE_VALUES: RTEKind = 5;
pub const RTEKind_RTE_CTE: RTEKind = 6;
pub const RTEKind_RTE_NAMEDTUPLESTORE: RTEKind = 7;
pub const RTEKind_RTE_RESULT: RTEKind = 8;
pub type RTEKind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeTblEntry {
    pub type_: NodeTag,
    pub rtekind: RTEKind,
    pub relid: Oid,
    pub relkind: ::std::os::raw::c_char,
    pub rellockmode: ::std::os::raw::c_int,
    pub tablesample: *mut TableSampleClause,
    pub subquery: *mut Query,
    pub security_barrier: bool,
    pub jointype: JoinType,
    pub joinmergedcols: ::std::os::raw::c_int,
    pub joinaliasvars: *mut List,
    pub joinleftcols: *mut List,
    pub joinrightcols: *mut List,
    pub functions: *mut List,
    pub funcordinality: bool,
    pub tablefunc: *mut TableFunc,
    pub values_lists: *mut List,
    pub ctename: *mut ::std::os::raw::c_char,
    pub ctelevelsup: Index,
    pub self_reference: bool,
    pub coltypes: *mut List,
    pub coltypmods: *mut List,
    pub colcollations: *mut List,
    pub enrname: *mut ::std::os::raw::c_char,
    pub enrtuples: f64,
    pub alias: *mut Alias,
    pub eref: *mut Alias,
    pub lateral: bool,
    pub inh: bool,
    pub inFromCl: bool,
    pub requiredPerms: AclMode,
    pub checkAsUser: Oid,
    pub selectedCols: *mut Bitmapset,
    pub insertedCols: *mut Bitmapset,
    pub updatedCols: *mut Bitmapset,
    pub extraUpdatedCols: *mut Bitmapset,
    pub securityQuals: *mut List,
}
impl Default for RangeTblEntry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeTblFunction {
    pub type_: NodeTag,
    pub funcexpr: *mut Node,
    pub funccolcount: ::std::os::raw::c_int,
    pub funccolnames: *mut List,
    pub funccoltypes: *mut List,
    pub funccoltypmods: *mut List,
    pub funccolcollations: *mut List,
    pub funcparams: *mut Bitmapset,
}
impl Default for RangeTblFunction {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TableSampleClause {
    pub type_: NodeTag,
    pub tsmhandler: Oid,
    pub args: *mut List,
    pub repeatable: *mut Expr,
}
impl Default for TableSampleClause {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const WCOKind_WCO_VIEW_CHECK: WCOKind = 0;
pub const WCOKind_WCO_RLS_INSERT_CHECK: WCOKind = 1;
pub const WCOKind_WCO_RLS_UPDATE_CHECK: WCOKind = 2;
pub const WCOKind_WCO_RLS_CONFLICT_CHECK: WCOKind = 3;
pub type WCOKind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WithCheckOption {
    pub type_: NodeTag,
    pub kind: WCOKind,
    pub relname: *mut ::std::os::raw::c_char,
    pub polname: *mut ::std::os::raw::c_char,
    pub qual: *mut Node,
    pub cascaded: bool,
}
impl Default for WithCheckOption {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SortGroupClause {
    pub type_: NodeTag,
    pub tleSortGroupRef: Index,
    pub eqop: Oid,
    pub sortop: Oid,
    pub nulls_first: bool,
    pub hashable: bool,
}
impl Default for SortGroupClause {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const GroupingSetKind_GROUPING_SET_EMPTY: GroupingSetKind = 0;
pub const GroupingSetKind_GROUPING_SET_SIMPLE: GroupingSetKind = 1;
pub const GroupingSetKind_GROUPING_SET_ROLLUP: GroupingSetKind = 2;
pub const GroupingSetKind_GROUPING_SET_CUBE: GroupingSetKind = 3;
pub const GroupingSetKind_GROUPING_SET_SETS: GroupingSetKind = 4;
pub type GroupingSetKind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GroupingSet {
    pub type_: NodeTag,
    pub kind: GroupingSetKind,
    pub content: *mut List,
    pub location: ::std::os::raw::c_int,
}
impl Default for GroupingSet {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowClause {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub refname: *mut ::std::os::raw::c_char,
    pub partitionClause: *mut List,
    pub orderClause: *mut List,
    pub frameOptions: ::std::os::raw::c_int,
    pub startOffset: *mut Node,
    pub endOffset: *mut Node,
    pub startInRangeFunc: Oid,
    pub endInRangeFunc: Oid,
    pub inRangeColl: Oid,
    pub inRangeAsc: bool,
    pub inRangeNullsFirst: bool,
    pub winref: Index,
    pub copiedOrder: bool,
}
impl Default for WindowClause {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RowMarkClause {
    pub type_: NodeTag,
    pub rti: Index,
    pub strength: LockClauseStrength,
    pub waitPolicy: LockWaitPolicy,
    pub pushedDown: bool,
}
impl Default for RowMarkClause {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WithClause {
    pub type_: NodeTag,
    pub ctes: *mut List,
    pub recursive: bool,
    pub location: ::std::os::raw::c_int,
}
impl Default for WithClause {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InferClause {
    pub type_: NodeTag,
    pub indexElems: *mut List,
    pub whereClause: *mut Node,
    pub conname: *mut ::std::os::raw::c_char,
    pub location: ::std::os::raw::c_int,
}
impl Default for InferClause {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OnConflictClause {
    pub type_: NodeTag,
    pub action: OnConflictAction,
    pub infer: *mut InferClause,
    pub targetList: *mut List,
    pub whereClause: *mut Node,
    pub location: ::std::os::raw::c_int,
}
impl Default for OnConflictClause {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const CTEMaterialize_CTEMaterializeDefault: CTEMaterialize = 0;
pub const CTEMaterialize_CTEMaterializeAlways: CTEMaterialize = 1;
pub const CTEMaterialize_CTEMaterializeNever: CTEMaterialize = 2;
pub type CTEMaterialize = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CommonTableExpr {
    pub type_: NodeTag,
    pub ctename: *mut ::std::os::raw::c_char,
    pub aliascolnames: *mut List,
    pub ctematerialized: CTEMaterialize,
    pub ctequery: *mut Node,
    pub location: ::std::os::raw::c_int,
    pub cterecursive: bool,
    pub cterefcount: ::std::os::raw::c_int,
    pub ctecolnames: *mut List,
    pub ctecoltypes: *mut List,
    pub ctecoltypmods: *mut List,
    pub ctecolcollations: *mut List,
}
impl Default for CommonTableExpr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TriggerTransition {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub isNew: bool,
    pub isTable: bool,
}
impl Default for TriggerTransition {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\t\tRaw Grammar Output Statements"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RawStmt {
    pub type_: NodeTag,
    pub stmt: *mut Node,
    pub stmt_location: ::std::os::raw::c_int,
    pub stmt_len: ::std::os::raw::c_int,
}
impl Default for RawStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "\t\tOptimizable Statements"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InsertStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub cols: *mut List,
    pub selectStmt: *mut Node,
    pub onConflictClause: *mut OnConflictClause,
    pub returningList: *mut List,
    pub withClause: *mut WithClause,
    pub override_: OverridingKind,
}
impl Default for InsertStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeleteStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub usingClause: *mut List,
    pub whereClause: *mut Node,
    pub returningList: *mut List,
    pub withClause: *mut WithClause,
}
impl Default for DeleteStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UpdateStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub targetList: *mut List,
    pub whereClause: *mut Node,
    pub fromClause: *mut List,
    pub returningList: *mut List,
    pub withClause: *mut WithClause,
}
impl Default for UpdateStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const SetOperation_SETOP_NONE: SetOperation = 0;
pub const SetOperation_SETOP_UNION: SetOperation = 1;
pub const SetOperation_SETOP_INTERSECT: SetOperation = 2;
pub const SetOperation_SETOP_EXCEPT: SetOperation = 3;
pub type SetOperation = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SelectStmt {
    pub type_: NodeTag,
    pub distinctClause: *mut List,
    pub intoClause: *mut IntoClause,
    pub targetList: *mut List,
    pub fromClause: *mut List,
    pub whereClause: *mut Node,
    pub groupClause: *mut List,
    pub havingClause: *mut Node,
    pub windowClause: *mut List,
    pub valuesLists: *mut List,
    pub sortClause: *mut List,
    pub limitOffset: *mut Node,
    pub limitCount: *mut Node,
    pub limitOption: LimitOption,
    pub lockingClause: *mut List,
    pub withClause: *mut WithClause,
    pub op: SetOperation,
    pub all: bool,
    pub larg: *mut SelectStmt,
    pub rarg: *mut SelectStmt,
}
impl Default for SelectStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SetOperationStmt {
    pub type_: NodeTag,
    pub op: SetOperation,
    pub all: bool,
    pub larg: *mut Node,
    pub rarg: *mut Node,
    pub colTypes: *mut List,
    pub colTypmods: *mut List,
    pub colCollations: *mut List,
    pub groupClauses: *mut List,
}
impl Default for SetOperationStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ObjectType_OBJECT_ACCESS_METHOD: ObjectType = 0;
pub const ObjectType_OBJECT_AGGREGATE: ObjectType = 1;
pub const ObjectType_OBJECT_AMOP: ObjectType = 2;
pub const ObjectType_OBJECT_AMPROC: ObjectType = 3;
pub const ObjectType_OBJECT_ATTRIBUTE: ObjectType = 4;
pub const ObjectType_OBJECT_CAST: ObjectType = 5;
pub const ObjectType_OBJECT_COLUMN: ObjectType = 6;
pub const ObjectType_OBJECT_COLLATION: ObjectType = 7;
pub const ObjectType_OBJECT_CONVERSION: ObjectType = 8;
pub const ObjectType_OBJECT_DATABASE: ObjectType = 9;
pub const ObjectType_OBJECT_DEFAULT: ObjectType = 10;
pub const ObjectType_OBJECT_DEFACL: ObjectType = 11;
pub const ObjectType_OBJECT_DOMAIN: ObjectType = 12;
pub const ObjectType_OBJECT_DOMCONSTRAINT: ObjectType = 13;
pub const ObjectType_OBJECT_EVENT_TRIGGER: ObjectType = 14;
pub const ObjectType_OBJECT_EXTENSION: ObjectType = 15;
pub const ObjectType_OBJECT_FDW: ObjectType = 16;
pub const ObjectType_OBJECT_FOREIGN_SERVER: ObjectType = 17;
pub const ObjectType_OBJECT_FOREIGN_TABLE: ObjectType = 18;
pub const ObjectType_OBJECT_FUNCTION: ObjectType = 19;
pub const ObjectType_OBJECT_INDEX: ObjectType = 20;
pub const ObjectType_OBJECT_LANGUAGE: ObjectType = 21;
pub const ObjectType_OBJECT_LARGEOBJECT: ObjectType = 22;
pub const ObjectType_OBJECT_MATVIEW: ObjectType = 23;
pub const ObjectType_OBJECT_OPCLASS: ObjectType = 24;
pub const ObjectType_OBJECT_OPERATOR: ObjectType = 25;
pub const ObjectType_OBJECT_OPFAMILY: ObjectType = 26;
pub const ObjectType_OBJECT_POLICY: ObjectType = 27;
pub const ObjectType_OBJECT_PROCEDURE: ObjectType = 28;
pub const ObjectType_OBJECT_PUBLICATION: ObjectType = 29;
pub const ObjectType_OBJECT_PUBLICATION_REL: ObjectType = 30;
pub const ObjectType_OBJECT_ROLE: ObjectType = 31;
pub const ObjectType_OBJECT_ROUTINE: ObjectType = 32;
pub const ObjectType_OBJECT_RULE: ObjectType = 33;
pub const ObjectType_OBJECT_SCHEMA: ObjectType = 34;
pub const ObjectType_OBJECT_SEQUENCE: ObjectType = 35;
pub const ObjectType_OBJECT_SUBSCRIPTION: ObjectType = 36;
pub const ObjectType_OBJECT_STATISTIC_EXT: ObjectType = 37;
pub const ObjectType_OBJECT_TABCONSTRAINT: ObjectType = 38;
pub const ObjectType_OBJECT_TABLE: ObjectType = 39;
pub const ObjectType_OBJECT_TABLESPACE: ObjectType = 40;
pub const ObjectType_OBJECT_TRANSFORM: ObjectType = 41;
pub const ObjectType_OBJECT_TRIGGER: ObjectType = 42;
pub const ObjectType_OBJECT_TSCONFIGURATION: ObjectType = 43;
pub const ObjectType_OBJECT_TSDICTIONARY: ObjectType = 44;
pub const ObjectType_OBJECT_TSPARSER: ObjectType = 45;
pub const ObjectType_OBJECT_TSTEMPLATE: ObjectType = 46;
pub const ObjectType_OBJECT_TYPE: ObjectType = 47;
pub const ObjectType_OBJECT_USER_MAPPING: ObjectType = 48;
pub const ObjectType_OBJECT_VIEW: ObjectType = 49;
#[doc = "\t\tOther Statements (no optimizations required)"]
#[doc = ""]
#[doc = "\t\tThese are not touched by parser/analyze.c except to put them into"]
#[doc = "\t\tthe utilityStmt field of a Query.  This is eventually passed to"]
#[doc = "\t\tProcessUtility (by-passing rewriting and planning).  Some of the"]
#[doc = "\t\tstatements do need attention from parse analysis, and this is"]
#[doc = "\t\tdone by routines in parser/parse_utilcmd.c after ProcessUtility"]
#[doc = "\t\treceives the command for execution."]
#[doc = "\t\tDECLARE CURSOR, EXPLAIN, and CREATE TABLE AS are special cases:"]
#[doc = "\t\tthey contain optimizable statements, which get processed normally"]
#[doc = "\t\tby parser/analyze.c."]
pub type ObjectType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateSchemaStmt {
    pub type_: NodeTag,
    pub schemaname: *mut ::std::os::raw::c_char,
    pub authrole: *mut RoleSpec,
    pub schemaElts: *mut List,
    pub if_not_exists: bool,
}
impl Default for CreateSchemaStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const DropBehavior_DROP_RESTRICT: DropBehavior = 0;
pub const DropBehavior_DROP_CASCADE: DropBehavior = 1;
pub type DropBehavior = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterTableStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub cmds: *mut List,
    pub relkind: ObjectType,
    pub missing_ok: bool,
}
impl Default for AlterTableStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const AlterTableType_AT_AddColumn: AlterTableType = 0;
pub const AlterTableType_AT_AddColumnRecurse: AlterTableType = 1;
pub const AlterTableType_AT_AddColumnToView: AlterTableType = 2;
pub const AlterTableType_AT_ColumnDefault: AlterTableType = 3;
pub const AlterTableType_AT_CookedColumnDefault: AlterTableType = 4;
pub const AlterTableType_AT_DropNotNull: AlterTableType = 5;
pub const AlterTableType_AT_SetNotNull: AlterTableType = 6;
pub const AlterTableType_AT_DropExpression: AlterTableType = 7;
pub const AlterTableType_AT_CheckNotNull: AlterTableType = 8;
pub const AlterTableType_AT_SetStatistics: AlterTableType = 9;
pub const AlterTableType_AT_SetOptions: AlterTableType = 10;
pub const AlterTableType_AT_ResetOptions: AlterTableType = 11;
pub const AlterTableType_AT_SetStorage: AlterTableType = 12;
pub const AlterTableType_AT_DropColumn: AlterTableType = 13;
pub const AlterTableType_AT_DropColumnRecurse: AlterTableType = 14;
pub const AlterTableType_AT_AddIndex: AlterTableType = 15;
pub const AlterTableType_AT_ReAddIndex: AlterTableType = 16;
pub const AlterTableType_AT_AddConstraint: AlterTableType = 17;
pub const AlterTableType_AT_AddConstraintRecurse: AlterTableType = 18;
pub const AlterTableType_AT_ReAddConstraint: AlterTableType = 19;
pub const AlterTableType_AT_ReAddDomainConstraint: AlterTableType = 20;
pub const AlterTableType_AT_AlterConstraint: AlterTableType = 21;
pub const AlterTableType_AT_ValidateConstraint: AlterTableType = 22;
pub const AlterTableType_AT_ValidateConstraintRecurse: AlterTableType = 23;
pub const AlterTableType_AT_AddIndexConstraint: AlterTableType = 24;
pub const AlterTableType_AT_DropConstraint: AlterTableType = 25;
pub const AlterTableType_AT_DropConstraintRecurse: AlterTableType = 26;
pub const AlterTableType_AT_ReAddComment: AlterTableType = 27;
pub const AlterTableType_AT_AlterColumnType: AlterTableType = 28;
pub const AlterTableType_AT_AlterColumnGenericOptions: AlterTableType = 29;
pub const AlterTableType_AT_ChangeOwner: AlterTableType = 30;
pub const AlterTableType_AT_ClusterOn: AlterTableType = 31;
pub const AlterTableType_AT_DropCluster: AlterTableType = 32;
pub const AlterTableType_AT_SetLogged: AlterTableType = 33;
pub const AlterTableType_AT_SetUnLogged: AlterTableType = 34;
pub const AlterTableType_AT_DropOids: AlterTableType = 35;
pub const AlterTableType_AT_SetTableSpace: AlterTableType = 36;
pub const AlterTableType_AT_SetRelOptions: AlterTableType = 37;
pub const AlterTableType_AT_ResetRelOptions: AlterTableType = 38;
pub const AlterTableType_AT_ReplaceRelOptions: AlterTableType = 39;
pub const AlterTableType_AT_EnableTrig: AlterTableType = 40;
pub const AlterTableType_AT_EnableAlwaysTrig: AlterTableType = 41;
pub const AlterTableType_AT_EnableReplicaTrig: AlterTableType = 42;
pub const AlterTableType_AT_DisableTrig: AlterTableType = 43;
pub const AlterTableType_AT_EnableTrigAll: AlterTableType = 44;
pub const AlterTableType_AT_DisableTrigAll: AlterTableType = 45;
pub const AlterTableType_AT_EnableTrigUser: AlterTableType = 46;
pub const AlterTableType_AT_DisableTrigUser: AlterTableType = 47;
pub const AlterTableType_AT_EnableRule: AlterTableType = 48;
pub const AlterTableType_AT_EnableAlwaysRule: AlterTableType = 49;
pub const AlterTableType_AT_EnableReplicaRule: AlterTableType = 50;
pub const AlterTableType_AT_DisableRule: AlterTableType = 51;
pub const AlterTableType_AT_AddInherit: AlterTableType = 52;
pub const AlterTableType_AT_DropInherit: AlterTableType = 53;
pub const AlterTableType_AT_AddOf: AlterTableType = 54;
pub const AlterTableType_AT_DropOf: AlterTableType = 55;
pub const AlterTableType_AT_ReplicaIdentity: AlterTableType = 56;
pub const AlterTableType_AT_EnableRowSecurity: AlterTableType = 57;
pub const AlterTableType_AT_DisableRowSecurity: AlterTableType = 58;
pub const AlterTableType_AT_ForceRowSecurity: AlterTableType = 59;
pub const AlterTableType_AT_NoForceRowSecurity: AlterTableType = 60;
pub const AlterTableType_AT_GenericOptions: AlterTableType = 61;
pub const AlterTableType_AT_AttachPartition: AlterTableType = 62;
pub const AlterTableType_AT_DetachPartition: AlterTableType = 63;
pub const AlterTableType_AT_AddIdentity: AlterTableType = 64;
pub const AlterTableType_AT_SetIdentity: AlterTableType = 65;
pub const AlterTableType_AT_DropIdentity: AlterTableType = 66;
pub type AlterTableType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReplicaIdentityStmt {
    pub type_: NodeTag,
    pub identity_type: ::std::os::raw::c_char,
    pub name: *mut ::std::os::raw::c_char,
}
impl Default for ReplicaIdentityStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterTableCmd {
    pub type_: NodeTag,
    pub subtype: AlterTableType,
    pub name: *mut ::std::os::raw::c_char,
    pub num: int16,
    pub newowner: *mut RoleSpec,
    pub def: *mut Node,
    pub behavior: DropBehavior,
    pub missing_ok: bool,
}
impl Default for AlterTableCmd {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterCollationStmt {
    pub type_: NodeTag,
    pub collname: *mut List,
}
impl Default for AlterCollationStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterDomainStmt {
    pub type_: NodeTag,
    pub subtype: ::std::os::raw::c_char,
    pub typeName: *mut List,
    pub name: *mut ::std::os::raw::c_char,
    pub def: *mut Node,
    pub behavior: DropBehavior,
    pub missing_ok: bool,
}
impl Default for AlterDomainStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const GrantTargetType_ACL_TARGET_OBJECT: GrantTargetType = 0;
pub const GrantTargetType_ACL_TARGET_ALL_IN_SCHEMA: GrantTargetType = 1;
pub const GrantTargetType_ACL_TARGET_DEFAULTS: GrantTargetType = 2;
pub type GrantTargetType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrantStmt {
    pub type_: NodeTag,
    pub is_grant: bool,
    pub targtype: GrantTargetType,
    pub objtype: ObjectType,
    pub objects: *mut List,
    pub privileges: *mut List,
    pub grantees: *mut List,
    pub grant_option: bool,
    pub behavior: DropBehavior,
}
impl Default for GrantStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjectWithArgs {
    pub type_: NodeTag,
    pub objname: *mut List,
    pub objargs: *mut List,
    pub args_unspecified: bool,
}
impl Default for ObjectWithArgs {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AccessPriv {
    pub type_: NodeTag,
    pub priv_name: *mut ::std::os::raw::c_char,
    pub cols: *mut List,
}
impl Default for AccessPriv {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GrantRoleStmt {
    pub type_: NodeTag,
    pub granted_roles: *mut List,
    pub grantee_roles: *mut List,
    pub is_grant: bool,
    pub admin_opt: bool,
    pub grantor: *mut RoleSpec,
    pub behavior: DropBehavior,
}
impl Default for GrantRoleStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterDefaultPrivilegesStmt {
    pub type_: NodeTag,
    pub options: *mut List,
    pub action: *mut GrantStmt,
}
impl Default for AlterDefaultPrivilegesStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CopyStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub query: *mut Node,
    pub attlist: *mut List,
    pub is_from: bool,
    pub is_program: bool,
    pub filename: *mut ::std::os::raw::c_char,
    pub options: *mut List,
    pub whereClause: *mut Node,
}
impl Default for CopyStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const VariableSetKind_VAR_SET_VALUE: VariableSetKind = 0;
pub const VariableSetKind_VAR_SET_DEFAULT: VariableSetKind = 1;
pub const VariableSetKind_VAR_SET_CURRENT: VariableSetKind = 2;
pub const VariableSetKind_VAR_SET_MULTI: VariableSetKind = 3;
pub const VariableSetKind_VAR_RESET: VariableSetKind = 4;
pub const VariableSetKind_VAR_RESET_ALL: VariableSetKind = 5;
pub type VariableSetKind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VariableSetStmt {
    pub type_: NodeTag,
    pub kind: VariableSetKind,
    pub name: *mut ::std::os::raw::c_char,
    pub args: *mut List,
    pub is_local: bool,
}
impl Default for VariableSetStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VariableShowStmt {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
}
impl Default for VariableShowStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub tableElts: *mut List,
    pub inhRelations: *mut List,
    pub partbound: *mut PartitionBoundSpec,
    pub partspec: *mut PartitionSpec,
    pub ofTypename: *mut TypeName,
    pub constraints: *mut List,
    pub options: *mut List,
    pub oncommit: OnCommitAction,
    pub tablespacename: *mut ::std::os::raw::c_char,
    pub accessMethod: *mut ::std::os::raw::c_char,
    pub if_not_exists: bool,
}
impl Default for CreateStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ConstrType_CONSTR_NULL: ConstrType = 0;
pub const ConstrType_CONSTR_NOTNULL: ConstrType = 1;
pub const ConstrType_CONSTR_DEFAULT: ConstrType = 2;
pub const ConstrType_CONSTR_IDENTITY: ConstrType = 3;
pub const ConstrType_CONSTR_GENERATED: ConstrType = 4;
pub const ConstrType_CONSTR_CHECK: ConstrType = 5;
pub const ConstrType_CONSTR_PRIMARY: ConstrType = 6;
pub const ConstrType_CONSTR_UNIQUE: ConstrType = 7;
pub const ConstrType_CONSTR_EXCLUSION: ConstrType = 8;
pub const ConstrType_CONSTR_FOREIGN: ConstrType = 9;
pub const ConstrType_CONSTR_ATTR_DEFERRABLE: ConstrType = 10;
pub const ConstrType_CONSTR_ATTR_NOT_DEFERRABLE: ConstrType = 11;
pub const ConstrType_CONSTR_ATTR_DEFERRED: ConstrType = 12;
pub const ConstrType_CONSTR_ATTR_IMMEDIATE: ConstrType = 13;
pub type ConstrType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Constraint {
    pub type_: NodeTag,
    pub contype: ConstrType,
    pub conname: *mut ::std::os::raw::c_char,
    pub deferrable: bool,
    pub initdeferred: bool,
    pub location: ::std::os::raw::c_int,
    pub is_no_inherit: bool,
    pub raw_expr: *mut Node,
    pub cooked_expr: *mut ::std::os::raw::c_char,
    pub generated_when: ::std::os::raw::c_char,
    pub keys: *mut List,
    pub including: *mut List,
    pub exclusions: *mut List,
    pub options: *mut List,
    pub indexname: *mut ::std::os::raw::c_char,
    pub indexspace: *mut ::std::os::raw::c_char,
    pub reset_default_tblspc: bool,
    pub access_method: *mut ::std::os::raw::c_char,
    pub where_clause: *mut Node,
    pub pktable: *mut RangeVar,
    pub fk_attrs: *mut List,
    pub pk_attrs: *mut List,
    pub fk_matchtype: ::std::os::raw::c_char,
    pub fk_upd_action: ::std::os::raw::c_char,
    pub fk_del_action: ::std::os::raw::c_char,
    pub old_conpfeqop: *mut List,
    pub old_pktable_oid: Oid,
    pub skip_validation: bool,
    pub initially_valid: bool,
}
impl Default for Constraint {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateTableSpaceStmt {
    pub type_: NodeTag,
    pub tablespacename: *mut ::std::os::raw::c_char,
    pub owner: *mut RoleSpec,
    pub location: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl Default for CreateTableSpaceStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DropTableSpaceStmt {
    pub type_: NodeTag,
    pub tablespacename: *mut ::std::os::raw::c_char,
    pub missing_ok: bool,
}
impl Default for DropTableSpaceStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterTableSpaceOptionsStmt {
    pub type_: NodeTag,
    pub tablespacename: *mut ::std::os::raw::c_char,
    pub options: *mut List,
    pub isReset: bool,
}
impl Default for AlterTableSpaceOptionsStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterTableMoveAllStmt {
    pub type_: NodeTag,
    pub orig_tablespacename: *mut ::std::os::raw::c_char,
    pub objtype: ObjectType,
    pub roles: *mut List,
    pub new_tablespacename: *mut ::std::os::raw::c_char,
    pub nowait: bool,
}
impl Default for AlterTableMoveAllStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateExtensionStmt {
    pub type_: NodeTag,
    pub extname: *mut ::std::os::raw::c_char,
    pub if_not_exists: bool,
    pub options: *mut List,
}
impl Default for CreateExtensionStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterExtensionStmt {
    pub type_: NodeTag,
    pub extname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl Default for AlterExtensionStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterExtensionContentsStmt {
    pub type_: NodeTag,
    pub extname: *mut ::std::os::raw::c_char,
    pub action: ::std::os::raw::c_int,
    pub objtype: ObjectType,
    pub object: *mut Node,
}
impl Default for AlterExtensionContentsStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateFdwStmt {
    pub type_: NodeTag,
    pub fdwname: *mut ::std::os::raw::c_char,
    pub func_options: *mut List,
    pub options: *mut List,
}
impl Default for CreateFdwStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterFdwStmt {
    pub type_: NodeTag,
    pub fdwname: *mut ::std::os::raw::c_char,
    pub func_options: *mut List,
    pub options: *mut List,
}
impl Default for AlterFdwStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateForeignServerStmt {
    pub type_: NodeTag,
    pub servername: *mut ::std::os::raw::c_char,
    pub servertype: *mut ::std::os::raw::c_char,
    pub version: *mut ::std::os::raw::c_char,
    pub fdwname: *mut ::std::os::raw::c_char,
    pub if_not_exists: bool,
    pub options: *mut List,
}
impl Default for CreateForeignServerStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterForeignServerStmt {
    pub type_: NodeTag,
    pub servername: *mut ::std::os::raw::c_char,
    pub version: *mut ::std::os::raw::c_char,
    pub options: *mut List,
    pub has_version: bool,
}
impl Default for AlterForeignServerStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateForeignTableStmt {
    pub base: CreateStmt,
    pub servername: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl Default for CreateForeignTableStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateUserMappingStmt {
    pub type_: NodeTag,
    pub user: *mut RoleSpec,
    pub servername: *mut ::std::os::raw::c_char,
    pub if_not_exists: bool,
    pub options: *mut List,
}
impl Default for CreateUserMappingStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterUserMappingStmt {
    pub type_: NodeTag,
    pub user: *mut RoleSpec,
    pub servername: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl Default for AlterUserMappingStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DropUserMappingStmt {
    pub type_: NodeTag,
    pub user: *mut RoleSpec,
    pub servername: *mut ::std::os::raw::c_char,
    pub missing_ok: bool,
}
impl Default for DropUserMappingStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ImportForeignSchemaType_FDW_IMPORT_SCHEMA_ALL: ImportForeignSchemaType = 0;
pub const ImportForeignSchemaType_FDW_IMPORT_SCHEMA_LIMIT_TO: ImportForeignSchemaType = 1;
pub const ImportForeignSchemaType_FDW_IMPORT_SCHEMA_EXCEPT: ImportForeignSchemaType = 2;
pub type ImportForeignSchemaType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImportForeignSchemaStmt {
    pub type_: NodeTag,
    pub server_name: *mut ::std::os::raw::c_char,
    pub remote_schema: *mut ::std::os::raw::c_char,
    pub local_schema: *mut ::std::os::raw::c_char,
    pub list_type: ImportForeignSchemaType,
    pub table_list: *mut List,
    pub options: *mut List,
}
impl Default for ImportForeignSchemaStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreatePolicyStmt {
    pub type_: NodeTag,
    pub policy_name: *mut ::std::os::raw::c_char,
    pub table: *mut RangeVar,
    pub cmd_name: *mut ::std::os::raw::c_char,
    pub permissive: bool,
    pub roles: *mut List,
    pub qual: *mut Node,
    pub with_check: *mut Node,
}
impl Default for CreatePolicyStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterPolicyStmt {
    pub type_: NodeTag,
    pub policy_name: *mut ::std::os::raw::c_char,
    pub table: *mut RangeVar,
    pub roles: *mut List,
    pub qual: *mut Node,
    pub with_check: *mut Node,
}
impl Default for AlterPolicyStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateAmStmt {
    pub type_: NodeTag,
    pub amname: *mut ::std::os::raw::c_char,
    pub handler_name: *mut List,
    pub amtype: ::std::os::raw::c_char,
}
impl Default for CreateAmStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateTrigStmt {
    pub type_: NodeTag,
    pub trigname: *mut ::std::os::raw::c_char,
    pub relation: *mut RangeVar,
    pub funcname: *mut List,
    pub args: *mut List,
    pub row: bool,
    pub timing: int16,
    pub events: int16,
    pub columns: *mut List,
    pub whenClause: *mut Node,
    pub isconstraint: bool,
    pub transitionRels: *mut List,
    pub deferrable: bool,
    pub initdeferred: bool,
    pub constrrel: *mut RangeVar,
}
impl Default for CreateTrigStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateEventTrigStmt {
    pub type_: NodeTag,
    pub trigname: *mut ::std::os::raw::c_char,
    pub eventname: *mut ::std::os::raw::c_char,
    pub whenclause: *mut List,
    pub funcname: *mut List,
}
impl Default for CreateEventTrigStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterEventTrigStmt {
    pub type_: NodeTag,
    pub trigname: *mut ::std::os::raw::c_char,
    pub tgenabled: ::std::os::raw::c_char,
}
impl Default for AlterEventTrigStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreatePLangStmt {
    pub type_: NodeTag,
    pub replace: bool,
    pub plname: *mut ::std::os::raw::c_char,
    pub plhandler: *mut List,
    pub plinline: *mut List,
    pub plvalidator: *mut List,
    pub pltrusted: bool,
}
impl Default for CreatePLangStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const RoleStmtType_ROLESTMT_ROLE: RoleStmtType = 0;
pub const RoleStmtType_ROLESTMT_USER: RoleStmtType = 1;
pub const RoleStmtType_ROLESTMT_GROUP: RoleStmtType = 2;
pub type RoleStmtType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateRoleStmt {
    pub type_: NodeTag,
    pub stmt_type: RoleStmtType,
    pub role: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl Default for CreateRoleStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterRoleStmt {
    pub type_: NodeTag,
    pub role: *mut RoleSpec,
    pub options: *mut List,
    pub action: ::std::os::raw::c_int,
}
impl Default for AlterRoleStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterRoleSetStmt {
    pub type_: NodeTag,
    pub role: *mut RoleSpec,
    pub database: *mut ::std::os::raw::c_char,
    pub setstmt: *mut VariableSetStmt,
}
impl Default for AlterRoleSetStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DropRoleStmt {
    pub type_: NodeTag,
    pub roles: *mut List,
    pub missing_ok: bool,
}
impl Default for DropRoleStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateSeqStmt {
    pub type_: NodeTag,
    pub sequence: *mut RangeVar,
    pub options: *mut List,
    pub ownerId: Oid,
    pub for_identity: bool,
    pub if_not_exists: bool,
}
impl Default for CreateSeqStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterSeqStmt {
    pub type_: NodeTag,
    pub sequence: *mut RangeVar,
    pub options: *mut List,
    pub for_identity: bool,
    pub missing_ok: bool,
}
impl Default for AlterSeqStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DefineStmt {
    pub type_: NodeTag,
    pub kind: ObjectType,
    pub oldstyle: bool,
    pub defnames: *mut List,
    pub args: *mut List,
    pub definition: *mut List,
    pub if_not_exists: bool,
    pub replace: bool,
}
impl Default for DefineStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateDomainStmt {
    pub type_: NodeTag,
    pub domainname: *mut List,
    pub typeName: *mut TypeName,
    pub collClause: *mut CollateClause,
    pub constraints: *mut List,
}
impl Default for CreateDomainStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateOpClassStmt {
    pub type_: NodeTag,
    pub opclassname: *mut List,
    pub opfamilyname: *mut List,
    pub amname: *mut ::std::os::raw::c_char,
    pub datatype: *mut TypeName,
    pub items: *mut List,
    pub isDefault: bool,
}
impl Default for CreateOpClassStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateOpClassItem {
    pub type_: NodeTag,
    pub itemtype: ::std::os::raw::c_int,
    pub name: *mut ObjectWithArgs,
    pub number: ::std::os::raw::c_int,
    pub order_family: *mut List,
    pub class_args: *mut List,
    pub storedtype: *mut TypeName,
}
impl Default for CreateOpClassItem {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateOpFamilyStmt {
    pub type_: NodeTag,
    pub opfamilyname: *mut List,
    pub amname: *mut ::std::os::raw::c_char,
}
impl Default for CreateOpFamilyStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterOpFamilyStmt {
    pub type_: NodeTag,
    pub opfamilyname: *mut List,
    pub amname: *mut ::std::os::raw::c_char,
    pub isDrop: bool,
    pub items: *mut List,
}
impl Default for AlterOpFamilyStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DropStmt {
    pub type_: NodeTag,
    pub objects: *mut List,
    pub removeType: ObjectType,
    pub behavior: DropBehavior,
    pub missing_ok: bool,
    pub concurrent: bool,
}
impl Default for DropStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TruncateStmt {
    pub type_: NodeTag,
    pub relations: *mut List,
    pub restart_seqs: bool,
    pub behavior: DropBehavior,
}
impl Default for TruncateStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CommentStmt {
    pub type_: NodeTag,
    pub objtype: ObjectType,
    pub object: *mut Node,
    pub comment: *mut ::std::os::raw::c_char,
}
impl Default for CommentStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SecLabelStmt {
    pub type_: NodeTag,
    pub objtype: ObjectType,
    pub object: *mut Node,
    pub provider: *mut ::std::os::raw::c_char,
    pub label: *mut ::std::os::raw::c_char,
}
impl Default for SecLabelStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeclareCursorStmt {
    pub type_: NodeTag,
    pub portalname: *mut ::std::os::raw::c_char,
    pub options: ::std::os::raw::c_int,
    pub query: *mut Node,
}
impl Default for DeclareCursorStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ClosePortalStmt {
    pub type_: NodeTag,
    pub portalname: *mut ::std::os::raw::c_char,
}
impl Default for ClosePortalStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const FetchDirection_FETCH_FORWARD: FetchDirection = 0;
pub const FetchDirection_FETCH_BACKWARD: FetchDirection = 1;
pub const FetchDirection_FETCH_ABSOLUTE: FetchDirection = 2;
pub const FetchDirection_FETCH_RELATIVE: FetchDirection = 3;
pub type FetchDirection = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FetchStmt {
    pub type_: NodeTag,
    pub direction: FetchDirection,
    pub howMany: ::std::os::raw::c_long,
    pub portalname: *mut ::std::os::raw::c_char,
    pub ismove: bool,
}
impl Default for FetchStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexStmt {
    pub type_: NodeTag,
    pub idxname: *mut ::std::os::raw::c_char,
    pub relation: *mut RangeVar,
    pub accessMethod: *mut ::std::os::raw::c_char,
    pub tableSpace: *mut ::std::os::raw::c_char,
    pub indexParams: *mut List,
    pub indexIncludingParams: *mut List,
    pub options: *mut List,
    pub whereClause: *mut Node,
    pub excludeOpNames: *mut List,
    pub idxcomment: *mut ::std::os::raw::c_char,
    pub indexOid: Oid,
    pub oldNode: Oid,
    pub oldCreateSubid: SubTransactionId,
    pub oldFirstRelfilenodeSubid: SubTransactionId,
    pub unique: bool,
    pub primary: bool,
    pub isconstraint: bool,
    pub deferrable: bool,
    pub initdeferred: bool,
    pub transformed: bool,
    pub concurrent: bool,
    pub if_not_exists: bool,
    pub reset_default_tblspc: bool,
}
impl Default for IndexStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateStatsStmt {
    pub type_: NodeTag,
    pub defnames: *mut List,
    pub stat_types: *mut List,
    pub exprs: *mut List,
    pub relations: *mut List,
    pub stxcomment: *mut ::std::os::raw::c_char,
    pub if_not_exists: bool,
}
impl Default for CreateStatsStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterStatsStmt {
    pub type_: NodeTag,
    pub defnames: *mut List,
    pub stxstattarget: ::std::os::raw::c_int,
    pub missing_ok: bool,
}
impl Default for AlterStatsStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateFunctionStmt {
    pub type_: NodeTag,
    pub is_procedure: bool,
    pub replace: bool,
    pub funcname: *mut List,
    pub parameters: *mut List,
    pub returnType: *mut TypeName,
    pub options: *mut List,
}
impl Default for CreateFunctionStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const FunctionParameterMode_FUNC_PARAM_IN: FunctionParameterMode = 105;
pub const FunctionParameterMode_FUNC_PARAM_OUT: FunctionParameterMode = 111;
pub const FunctionParameterMode_FUNC_PARAM_INOUT: FunctionParameterMode = 98;
pub const FunctionParameterMode_FUNC_PARAM_VARIADIC: FunctionParameterMode = 118;
pub const FunctionParameterMode_FUNC_PARAM_TABLE: FunctionParameterMode = 116;
pub type FunctionParameterMode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FunctionParameter {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub argType: *mut TypeName,
    pub mode: FunctionParameterMode,
    pub defexpr: *mut Node,
}
impl Default for FunctionParameter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterFunctionStmt {
    pub type_: NodeTag,
    pub objtype: ObjectType,
    pub func: *mut ObjectWithArgs,
    pub actions: *mut List,
}
impl Default for AlterFunctionStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DoStmt {
    pub type_: NodeTag,
    pub args: *mut List,
}
impl Default for DoStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InlineCodeBlock {
    pub type_: NodeTag,
    pub source_text: *mut ::std::os::raw::c_char,
    pub langOid: Oid,
    pub langIsTrusted: bool,
    pub atomic: bool,
}
impl Default for InlineCodeBlock {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CallStmt {
    pub type_: NodeTag,
    pub funccall: *mut FuncCall,
    pub funcexpr: *mut FuncExpr,
}
impl Default for CallStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CallContext {
    pub type_: NodeTag,
    pub atomic: bool,
}
impl Default for CallContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RenameStmt {
    pub type_: NodeTag,
    pub renameType: ObjectType,
    pub relationType: ObjectType,
    pub relation: *mut RangeVar,
    pub object: *mut Node,
    pub subname: *mut ::std::os::raw::c_char,
    pub newname: *mut ::std::os::raw::c_char,
    pub behavior: DropBehavior,
    pub missing_ok: bool,
}
impl Default for RenameStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterObjectDependsStmt {
    pub type_: NodeTag,
    pub objectType: ObjectType,
    pub relation: *mut RangeVar,
    pub object: *mut Node,
    pub extname: *mut Value,
    pub remove: bool,
}
impl Default for AlterObjectDependsStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterObjectSchemaStmt {
    pub type_: NodeTag,
    pub objectType: ObjectType,
    pub relation: *mut RangeVar,
    pub object: *mut Node,
    pub newschema: *mut ::std::os::raw::c_char,
    pub missing_ok: bool,
}
impl Default for AlterObjectSchemaStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterOwnerStmt {
    pub type_: NodeTag,
    pub objectType: ObjectType,
    pub relation: *mut RangeVar,
    pub object: *mut Node,
    pub newowner: *mut RoleSpec,
}
impl Default for AlterOwnerStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterOperatorStmt {
    pub type_: NodeTag,
    pub opername: *mut ObjectWithArgs,
    pub options: *mut List,
}
impl Default for AlterOperatorStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterTypeStmt {
    pub type_: NodeTag,
    pub typeName: *mut List,
    pub options: *mut List,
}
impl Default for AlterTypeStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RuleStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub rulename: *mut ::std::os::raw::c_char,
    pub whereClause: *mut Node,
    pub event: CmdType,
    pub instead: bool,
    pub actions: *mut List,
    pub replace: bool,
}
impl Default for RuleStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotifyStmt {
    pub type_: NodeTag,
    pub conditionname: *mut ::std::os::raw::c_char,
    pub payload: *mut ::std::os::raw::c_char,
}
impl Default for NotifyStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ListenStmt {
    pub type_: NodeTag,
    pub conditionname: *mut ::std::os::raw::c_char,
}
impl Default for ListenStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UnlistenStmt {
    pub type_: NodeTag,
    pub conditionname: *mut ::std::os::raw::c_char,
}
impl Default for UnlistenStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const TransactionStmtKind_TRANS_STMT_BEGIN: TransactionStmtKind = 0;
pub const TransactionStmtKind_TRANS_STMT_START: TransactionStmtKind = 1;
pub const TransactionStmtKind_TRANS_STMT_COMMIT: TransactionStmtKind = 2;
pub const TransactionStmtKind_TRANS_STMT_ROLLBACK: TransactionStmtKind = 3;
pub const TransactionStmtKind_TRANS_STMT_SAVEPOINT: TransactionStmtKind = 4;
pub const TransactionStmtKind_TRANS_STMT_RELEASE: TransactionStmtKind = 5;
pub const TransactionStmtKind_TRANS_STMT_ROLLBACK_TO: TransactionStmtKind = 6;
pub const TransactionStmtKind_TRANS_STMT_PREPARE: TransactionStmtKind = 7;
pub const TransactionStmtKind_TRANS_STMT_COMMIT_PREPARED: TransactionStmtKind = 8;
pub const TransactionStmtKind_TRANS_STMT_ROLLBACK_PREPARED: TransactionStmtKind = 9;
pub type TransactionStmtKind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TransactionStmt {
    pub type_: NodeTag,
    pub kind: TransactionStmtKind,
    pub options: *mut List,
    pub savepoint_name: *mut ::std::os::raw::c_char,
    pub gid: *mut ::std::os::raw::c_char,
    pub chain: bool,
}
impl Default for TransactionStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CompositeTypeStmt {
    pub type_: NodeTag,
    pub typevar: *mut RangeVar,
    pub coldeflist: *mut List,
}
impl Default for CompositeTypeStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateEnumStmt {
    pub type_: NodeTag,
    pub typeName: *mut List,
    pub vals: *mut List,
}
impl Default for CreateEnumStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateRangeStmt {
    pub type_: NodeTag,
    pub typeName: *mut List,
    pub params: *mut List,
}
impl Default for CreateRangeStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterEnumStmt {
    pub type_: NodeTag,
    pub typeName: *mut List,
    pub oldVal: *mut ::std::os::raw::c_char,
    pub newVal: *mut ::std::os::raw::c_char,
    pub newValNeighbor: *mut ::std::os::raw::c_char,
    pub newValIsAfter: bool,
    pub skipIfNewValExists: bool,
}
impl Default for AlterEnumStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ViewCheckOption_NO_CHECK_OPTION: ViewCheckOption = 0;
pub const ViewCheckOption_LOCAL_CHECK_OPTION: ViewCheckOption = 1;
pub const ViewCheckOption_CASCADED_CHECK_OPTION: ViewCheckOption = 2;
pub type ViewCheckOption = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ViewStmt {
    pub type_: NodeTag,
    pub view: *mut RangeVar,
    pub aliases: *mut List,
    pub query: *mut Node,
    pub replace: bool,
    pub options: *mut List,
    pub withCheckOption: ViewCheckOption,
}
impl Default for ViewStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LoadStmt {
    pub type_: NodeTag,
    pub filename: *mut ::std::os::raw::c_char,
}
impl Default for LoadStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreatedbStmt {
    pub type_: NodeTag,
    pub dbname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl Default for CreatedbStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterDatabaseStmt {
    pub type_: NodeTag,
    pub dbname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl Default for AlterDatabaseStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterDatabaseSetStmt {
    pub type_: NodeTag,
    pub dbname: *mut ::std::os::raw::c_char,
    pub setstmt: *mut VariableSetStmt,
}
impl Default for AlterDatabaseSetStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DropdbStmt {
    pub type_: NodeTag,
    pub dbname: *mut ::std::os::raw::c_char,
    pub missing_ok: bool,
    pub options: *mut List,
}
impl Default for DropdbStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterSystemStmt {
    pub type_: NodeTag,
    pub setstmt: *mut VariableSetStmt,
}
impl Default for AlterSystemStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ClusterOption_CLUOPT_RECHECK: ClusterOption = 1;
pub const ClusterOption_CLUOPT_VERBOSE: ClusterOption = 2;
pub type ClusterOption = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ClusterStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub indexname: *mut ::std::os::raw::c_char,
    pub options: ::std::os::raw::c_int,
}
impl Default for ClusterStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VacuumStmt {
    pub type_: NodeTag,
    pub options: *mut List,
    pub rels: *mut List,
    pub is_vacuumcmd: bool,
}
impl Default for VacuumStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VacuumRelation {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub oid: Oid,
    pub va_cols: *mut List,
}
impl Default for VacuumRelation {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExplainStmt {
    pub type_: NodeTag,
    pub query: *mut Node,
    pub options: *mut List,
}
impl Default for ExplainStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateTableAsStmt {
    pub type_: NodeTag,
    pub query: *mut Node,
    pub into: *mut IntoClause,
    pub relkind: ObjectType,
    pub is_select_into: bool,
    pub if_not_exists: bool,
}
impl Default for CreateTableAsStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RefreshMatViewStmt {
    pub type_: NodeTag,
    pub concurrent: bool,
    pub skipData: bool,
    pub relation: *mut RangeVar,
}
impl Default for RefreshMatViewStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CheckPointStmt {
    pub type_: NodeTag,
}
impl Default for CheckPointStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const DiscardMode_DISCARD_ALL: DiscardMode = 0;
pub const DiscardMode_DISCARD_PLANS: DiscardMode = 1;
pub const DiscardMode_DISCARD_SEQUENCES: DiscardMode = 2;
pub const DiscardMode_DISCARD_TEMP: DiscardMode = 3;
pub type DiscardMode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DiscardStmt {
    pub type_: NodeTag,
    pub target: DiscardMode,
}
impl Default for DiscardStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LockStmt {
    pub type_: NodeTag,
    pub relations: *mut List,
    pub mode: ::std::os::raw::c_int,
    pub nowait: bool,
}
impl Default for LockStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConstraintsSetStmt {
    pub type_: NodeTag,
    pub constraints: *mut List,
    pub deferred: bool,
}
impl Default for ConstraintsSetStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ReindexObjectType_REINDEX_OBJECT_INDEX: ReindexObjectType = 0;
pub const ReindexObjectType_REINDEX_OBJECT_TABLE: ReindexObjectType = 1;
pub const ReindexObjectType_REINDEX_OBJECT_SCHEMA: ReindexObjectType = 2;
pub const ReindexObjectType_REINDEX_OBJECT_SYSTEM: ReindexObjectType = 3;
pub const ReindexObjectType_REINDEX_OBJECT_DATABASE: ReindexObjectType = 4;
pub type ReindexObjectType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReindexStmt {
    pub type_: NodeTag,
    pub kind: ReindexObjectType,
    pub relation: *mut RangeVar,
    pub name: *const ::std::os::raw::c_char,
    pub options: ::std::os::raw::c_int,
    pub concurrent: bool,
}
impl Default for ReindexStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateConversionStmt {
    pub type_: NodeTag,
    pub conversion_name: *mut List,
    pub for_encoding_name: *mut ::std::os::raw::c_char,
    pub to_encoding_name: *mut ::std::os::raw::c_char,
    pub func_name: *mut List,
    pub def: bool,
}
impl Default for CreateConversionStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateCastStmt {
    pub type_: NodeTag,
    pub sourcetype: *mut TypeName,
    pub targettype: *mut TypeName,
    pub func: *mut ObjectWithArgs,
    pub context: CoercionContext,
    pub inout: bool,
}
impl Default for CreateCastStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateTransformStmt {
    pub type_: NodeTag,
    pub replace: bool,
    pub type_name: *mut TypeName,
    pub lang: *mut ::std::os::raw::c_char,
    pub fromsql: *mut ObjectWithArgs,
    pub tosql: *mut ObjectWithArgs,
}
impl Default for CreateTransformStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PrepareStmt {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub argtypes: *mut List,
    pub query: *mut Node,
}
impl Default for PrepareStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExecuteStmt {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub params: *mut List,
}
impl Default for ExecuteStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeallocateStmt {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
}
impl Default for DeallocateStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DropOwnedStmt {
    pub type_: NodeTag,
    pub roles: *mut List,
    pub behavior: DropBehavior,
}
impl Default for DropOwnedStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReassignOwnedStmt {
    pub type_: NodeTag,
    pub roles: *mut List,
    pub newrole: *mut RoleSpec,
}
impl Default for ReassignOwnedStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterTSDictionaryStmt {
    pub type_: NodeTag,
    pub dictname: *mut List,
    pub options: *mut List,
}
impl Default for AlterTSDictionaryStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const AlterTSConfigType_ALTER_TSCONFIG_ADD_MAPPING: AlterTSConfigType = 0;
pub const AlterTSConfigType_ALTER_TSCONFIG_ALTER_MAPPING_FOR_TOKEN: AlterTSConfigType = 1;
pub const AlterTSConfigType_ALTER_TSCONFIG_REPLACE_DICT: AlterTSConfigType = 2;
pub const AlterTSConfigType_ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN: AlterTSConfigType = 3;
pub const AlterTSConfigType_ALTER_TSCONFIG_DROP_MAPPING: AlterTSConfigType = 4;
pub type AlterTSConfigType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterTSConfigurationStmt {
    pub type_: NodeTag,
    pub kind: AlterTSConfigType,
    pub cfgname: *mut List,
    pub tokentype: *mut List,
    pub dicts: *mut List,
    pub override_: bool,
    pub replace: bool,
    pub missing_ok: bool,
}
impl Default for AlterTSConfigurationStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreatePublicationStmt {
    pub type_: NodeTag,
    pub pubname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
    pub tables: *mut List,
    pub for_all_tables: bool,
}
impl Default for CreatePublicationStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterPublicationStmt {
    pub type_: NodeTag,
    pub pubname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
    pub tables: *mut List,
    pub for_all_tables: bool,
    pub tableAction: DefElemAction,
}
impl Default for AlterPublicationStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateSubscriptionStmt {
    pub type_: NodeTag,
    pub subname: *mut ::std::os::raw::c_char,
    pub conninfo: *mut ::std::os::raw::c_char,
    pub publication: *mut List,
    pub options: *mut List,
}
impl Default for CreateSubscriptionStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const AlterSubscriptionType_ALTER_SUBSCRIPTION_OPTIONS: AlterSubscriptionType = 0;
pub const AlterSubscriptionType_ALTER_SUBSCRIPTION_CONNECTION: AlterSubscriptionType = 1;
pub const AlterSubscriptionType_ALTER_SUBSCRIPTION_PUBLICATION: AlterSubscriptionType = 2;
pub const AlterSubscriptionType_ALTER_SUBSCRIPTION_REFRESH: AlterSubscriptionType = 3;
pub const AlterSubscriptionType_ALTER_SUBSCRIPTION_ENABLED: AlterSubscriptionType = 4;
pub type AlterSubscriptionType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterSubscriptionStmt {
    pub type_: NodeTag,
    pub kind: AlterSubscriptionType,
    pub subname: *mut ::std::os::raw::c_char,
    pub conninfo: *mut ::std::os::raw::c_char,
    pub publication: *mut List,
    pub options: *mut List,
}
impl Default for AlterSubscriptionStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DropSubscriptionStmt {
    pub type_: NodeTag,
    pub subname: *mut ::std::os::raw::c_char,
    pub missing_ok: bool,
    pub behavior: DropBehavior,
}
impl Default for DropSubscriptionStmt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MemoryContextCounters {
    pub nblocks: Size,
    pub freechunks: Size,
    pub totalspace: Size,
    pub freespace: Size,
}
pub type MemoryStatsPrintFunc = ::std::option::Option<
    unsafe extern "C" fn(
        context: MemoryContext,
        passthru: *mut ::std::os::raw::c_void,
        stats_string: *const ::std::os::raw::c_char,
    ),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MemoryContextMethods {
    pub alloc: ::std::option::Option<
        unsafe extern "C" fn(context: MemoryContext, size: Size) -> *mut ::std::os::raw::c_void,
    >,
    pub free_p: ::std::option::Option<
        unsafe extern "C" fn(context: MemoryContext, pointer: *mut ::std::os::raw::c_void),
    >,
    pub realloc: ::std::option::Option<
        unsafe extern "C" fn(
            context: MemoryContext,
            pointer: *mut ::std::os::raw::c_void,
            size: Size,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub reset: ::std::option::Option<unsafe extern "C" fn(context: MemoryContext)>,
    pub delete_context: ::std::option::Option<unsafe extern "C" fn(context: MemoryContext)>,
    pub get_chunk_space: ::std::option::Option<
        unsafe extern "C" fn(context: MemoryContext, pointer: *mut ::std::os::raw::c_void) -> Size,
    >,
    pub is_empty: ::std::option::Option<unsafe extern "C" fn(context: MemoryContext) -> bool>,
    pub stats: ::std::option::Option<
        unsafe extern "C" fn(
            context: MemoryContext,
            printfunc: MemoryStatsPrintFunc,
            passthru: *mut ::std::os::raw::c_void,
            totals: *mut MemoryContextCounters,
        ),
    >,
    pub check: ::std::option::Option<unsafe extern "C" fn(context: MemoryContext)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryContextData {
    pub type_: NodeTag,
    pub isReset: bool,
    pub allowInCritSection: bool,
    pub mem_allocated: Size,
    pub methods: *const MemoryContextMethods,
    pub parent: MemoryContext,
    pub firstchild: MemoryContext,
    pub prevchild: MemoryContext,
    pub nextchild: MemoryContext,
    pub name: *const ::std::os::raw::c_char,
    pub ident: *const ::std::os::raw::c_char,
    pub reset_cbs: *mut MemoryContextCallback,
}
impl Default for MemoryContextData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut TopMemoryContext: MemoryContext;
}
extern "C" {
    pub static mut ErrorContext: MemoryContext;
}
extern "C" {
    pub static mut PostmasterContext: MemoryContext;
}
extern "C" {
    pub static mut CacheMemoryContext: MemoryContext;
}
extern "C" {
    pub static mut MessageContext: MemoryContext;
}
extern "C" {
    pub static mut TopTransactionContext: MemoryContext;
}
extern "C" {
    pub static mut CurTransactionContext: MemoryContext;
}
extern "C" {
    pub static mut PortalContext: MemoryContext;
}
pub unsafe fn MemoryContextInit() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MemoryContextInit();
        }
        MemoryContextInit()
    })
}
pub unsafe fn MemoryContextReset(arg_context: MemoryContext) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MemoryContextReset(arg_context: MemoryContext);
        }
        MemoryContextReset(arg_context)
    })
}
pub unsafe fn MemoryContextDelete(arg_context: MemoryContext) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MemoryContextDelete(arg_context: MemoryContext);
        }
        MemoryContextDelete(arg_context)
    })
}
pub unsafe fn MemoryContextResetOnly(arg_context: MemoryContext) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MemoryContextResetOnly(arg_context: MemoryContext);
        }
        MemoryContextResetOnly(arg_context)
    })
}
pub unsafe fn MemoryContextResetChildren(arg_context: MemoryContext) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MemoryContextResetChildren(arg_context: MemoryContext);
        }
        MemoryContextResetChildren(arg_context)
    })
}
pub unsafe fn MemoryContextDeleteChildren(arg_context: MemoryContext) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MemoryContextDeleteChildren(arg_context: MemoryContext);
        }
        MemoryContextDeleteChildren(arg_context)
    })
}
pub unsafe fn MemoryContextSetIdentifier(
    arg_context: MemoryContext,
    arg_id: *const ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MemoryContextSetIdentifier(
                arg_context: MemoryContext,
                arg_id: *const ::std::os::raw::c_char,
            );
        }
        MemoryContextSetIdentifier(arg_context, arg_id)
    })
}
pub unsafe fn MemoryContextSetParent(arg_context: MemoryContext, arg_new_parent: MemoryContext) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MemoryContextSetParent(arg_context: MemoryContext, arg_new_parent: MemoryContext);
        }
        MemoryContextSetParent(arg_context, arg_new_parent)
    })
}
pub unsafe fn GetMemoryChunkSpace(arg_pointer: *mut ::std::os::raw::c_void) -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetMemoryChunkSpace(arg_pointer: *mut ::std::os::raw::c_void) -> Size;
        }
        GetMemoryChunkSpace(arg_pointer)
    })
}
pub unsafe fn MemoryContextGetParent(arg_context: MemoryContext) -> MemoryContext {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MemoryContextGetParent(arg_context: MemoryContext) -> MemoryContext;
        }
        MemoryContextGetParent(arg_context)
    })
}
pub unsafe fn MemoryContextIsEmpty(arg_context: MemoryContext) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MemoryContextIsEmpty(arg_context: MemoryContext) -> bool;
        }
        MemoryContextIsEmpty(arg_context)
    })
}
pub unsafe fn MemoryContextMemAllocated(arg_context: MemoryContext, arg_recurse: bool) -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MemoryContextMemAllocated(arg_context: MemoryContext, arg_recurse: bool) -> Size;
        }
        MemoryContextMemAllocated(arg_context, arg_recurse)
    })
}
pub unsafe fn MemoryContextStats(arg_context: MemoryContext) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MemoryContextStats(arg_context: MemoryContext);
        }
        MemoryContextStats(arg_context)
    })
}
pub unsafe fn MemoryContextStatsDetail(
    arg_context: MemoryContext,
    arg_max_children: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MemoryContextStatsDetail(
                arg_context: MemoryContext,
                arg_max_children: ::std::os::raw::c_int,
            );
        }
        MemoryContextStatsDetail(arg_context, arg_max_children)
    })
}
pub unsafe fn MemoryContextAllowInCriticalSection(arg_context: MemoryContext, arg_allow: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MemoryContextAllowInCriticalSection(arg_context: MemoryContext, arg_allow: bool);
        }
        MemoryContextAllowInCriticalSection(arg_context, arg_allow)
    })
}
pub unsafe fn MemoryContextCheck(arg_context: MemoryContext) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MemoryContextCheck(arg_context: MemoryContext);
        }
        MemoryContextCheck(arg_context)
    })
}
pub unsafe fn MemoryContextContains(
    arg_context: MemoryContext,
    arg_pointer: *mut ::std::os::raw::c_void,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MemoryContextContains(
                arg_context: MemoryContext,
                arg_pointer: *mut ::std::os::raw::c_void,
            ) -> bool;
        }
        MemoryContextContains(arg_context, arg_pointer)
    })
}
pub unsafe fn MemoryContextCreate(
    arg_node: MemoryContext,
    arg_tag: NodeTag,
    arg_methods: *const MemoryContextMethods,
    arg_parent: MemoryContext,
    arg_name: *const ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MemoryContextCreate(
                arg_node: MemoryContext,
                arg_tag: NodeTag,
                arg_methods: *const MemoryContextMethods,
                arg_parent: MemoryContext,
                arg_name: *const ::std::os::raw::c_char,
            );
        }
        MemoryContextCreate(arg_node, arg_tag, arg_methods, arg_parent, arg_name)
    })
}
pub unsafe fn AllocSetContextCreateInternal(
    arg_parent: MemoryContext,
    arg_name: *const ::std::os::raw::c_char,
    arg_minContextSize: Size,
    arg_initBlockSize: Size,
    arg_maxBlockSize: Size,
) -> MemoryContext {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AllocSetContextCreateInternal(
                arg_parent: MemoryContext,
                arg_name: *const ::std::os::raw::c_char,
                arg_minContextSize: Size,
                arg_initBlockSize: Size,
                arg_maxBlockSize: Size,
            ) -> MemoryContext;
        }
        AllocSetContextCreateInternal(
            arg_parent,
            arg_name,
            arg_minContextSize,
            arg_initBlockSize,
            arg_maxBlockSize,
        )
    })
}
pub unsafe fn SlabContextCreate(
    arg_parent: MemoryContext,
    arg_name: *const ::std::os::raw::c_char,
    arg_blockSize: Size,
    arg_chunkSize: Size,
) -> MemoryContext {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SlabContextCreate(
                arg_parent: MemoryContext,
                arg_name: *const ::std::os::raw::c_char,
                arg_blockSize: Size,
                arg_chunkSize: Size,
            ) -> MemoryContext;
        }
        SlabContextCreate(arg_parent, arg_name, arg_blockSize, arg_chunkSize)
    })
}
pub unsafe fn GenerationContextCreate(
    arg_parent: MemoryContext,
    arg_name: *const ::std::os::raw::c_char,
    arg_blockSize: Size,
) -> MemoryContext {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GenerationContextCreate(
                arg_parent: MemoryContext,
                arg_name: *const ::std::os::raw::c_char,
                arg_blockSize: Size,
            ) -> MemoryContext;
        }
        GenerationContextCreate(arg_parent, arg_name, arg_blockSize)
    })
}
pub type ExecutorStart_hook_type = ::std::option::Option<
    unsafe extern "C" fn(queryDesc: *mut QueryDesc, eflags: ::std::os::raw::c_int),
>;
extern "C" {
    pub static mut ExecutorStart_hook: ExecutorStart_hook_type;
}
pub type ExecutorRun_hook_type = ::std::option::Option<
    unsafe extern "C" fn(
        queryDesc: *mut QueryDesc,
        direction: ScanDirection,
        count: uint64,
        execute_once: bool,
    ),
>;
extern "C" {
    pub static mut ExecutorRun_hook: ExecutorRun_hook_type;
}
pub type ExecutorFinish_hook_type =
    ::std::option::Option<unsafe extern "C" fn(queryDesc: *mut QueryDesc)>;
extern "C" {
    pub static mut ExecutorFinish_hook: ExecutorFinish_hook_type;
}
pub type ExecutorEnd_hook_type =
    ::std::option::Option<unsafe extern "C" fn(queryDesc: *mut QueryDesc)>;
extern "C" {
    pub static mut ExecutorEnd_hook: ExecutorEnd_hook_type;
}
pub type ExecutorCheckPerms_hook_type =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut List, arg2: bool) -> bool>;
extern "C" {
    pub static mut ExecutorCheckPerms_hook: ExecutorCheckPerms_hook_type;
}
pub unsafe fn ExecReScan(arg_node: *mut PlanState) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecReScan(arg_node: *mut PlanState);
        }
        ExecReScan(arg_node)
    })
}
pub unsafe fn ExecMarkPos(arg_node: *mut PlanState) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecMarkPos(arg_node: *mut PlanState);
        }
        ExecMarkPos(arg_node)
    })
}
pub unsafe fn ExecRestrPos(arg_node: *mut PlanState) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecRestrPos(arg_node: *mut PlanState);
        }
        ExecRestrPos(arg_node)
    })
}
pub unsafe fn ExecSupportsMarkRestore(arg_pathnode: *mut Path) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecSupportsMarkRestore(arg_pathnode: *mut Path) -> bool;
        }
        ExecSupportsMarkRestore(arg_pathnode)
    })
}
pub unsafe fn ExecSupportsBackwardScan(arg_node: *mut Plan) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecSupportsBackwardScan(arg_node: *mut Plan) -> bool;
        }
        ExecSupportsBackwardScan(arg_node)
    })
}
pub unsafe fn ExecMaterializesOutput(arg_plantype: NodeTag) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecMaterializesOutput(arg_plantype: NodeTag) -> bool;
        }
        ExecMaterializesOutput(arg_plantype)
    })
}
pub unsafe fn execCurrentOf(
    arg_cexpr: *mut CurrentOfExpr,
    arg_econtext: *mut ExprContext,
    arg_table_oid: Oid,
    arg_current_tid: ItemPointer,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn execCurrentOf(
                arg_cexpr: *mut CurrentOfExpr,
                arg_econtext: *mut ExprContext,
                arg_table_oid: Oid,
                arg_current_tid: ItemPointer,
            ) -> bool;
        }
        execCurrentOf(arg_cexpr, arg_econtext, arg_table_oid, arg_current_tid)
    })
}
pub unsafe fn execTuplesMatchPrepare(
    arg_desc: TupleDesc,
    arg_numCols: ::std::os::raw::c_int,
    arg_keyColIdx: *const AttrNumber,
    arg_eqOperators: *const Oid,
    arg_collations: *const Oid,
    arg_parent: *mut PlanState,
) -> *mut ExprState {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn execTuplesMatchPrepare(
                arg_desc: TupleDesc,
                arg_numCols: ::std::os::raw::c_int,
                arg_keyColIdx: *const AttrNumber,
                arg_eqOperators: *const Oid,
                arg_collations: *const Oid,
                arg_parent: *mut PlanState,
            ) -> *mut ExprState;
        }
        execTuplesMatchPrepare(
            arg_desc,
            arg_numCols,
            arg_keyColIdx,
            arg_eqOperators,
            arg_collations,
            arg_parent,
        )
    })
}
pub unsafe fn execTuplesHashPrepare(
    arg_numCols: ::std::os::raw::c_int,
    arg_eqOperators: *const Oid,
    arg_eqFuncOids: *mut *mut Oid,
    arg_hashFunctions: *mut *mut FmgrInfo,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn execTuplesHashPrepare(
                arg_numCols: ::std::os::raw::c_int,
                arg_eqOperators: *const Oid,
                arg_eqFuncOids: *mut *mut Oid,
                arg_hashFunctions: *mut *mut FmgrInfo,
            );
        }
        execTuplesHashPrepare(arg_numCols, arg_eqOperators, arg_eqFuncOids, arg_hashFunctions)
    })
}
pub unsafe fn BuildTupleHashTable(
    arg_parent: *mut PlanState,
    arg_inputDesc: TupleDesc,
    arg_numCols: ::std::os::raw::c_int,
    arg_keyColIdx: *mut AttrNumber,
    arg_eqfuncoids: *const Oid,
    arg_hashfunctions: *mut FmgrInfo,
    arg_collations: *mut Oid,
    arg_nbuckets: ::std::os::raw::c_long,
    arg_additionalsize: Size,
    arg_tablecxt: MemoryContext,
    arg_tempcxt: MemoryContext,
    arg_use_variable_hash_iv: bool,
) -> TupleHashTable {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BuildTupleHashTable(
                arg_parent: *mut PlanState,
                arg_inputDesc: TupleDesc,
                arg_numCols: ::std::os::raw::c_int,
                arg_keyColIdx: *mut AttrNumber,
                arg_eqfuncoids: *const Oid,
                arg_hashfunctions: *mut FmgrInfo,
                arg_collations: *mut Oid,
                arg_nbuckets: ::std::os::raw::c_long,
                arg_additionalsize: Size,
                arg_tablecxt: MemoryContext,
                arg_tempcxt: MemoryContext,
                arg_use_variable_hash_iv: bool,
            ) -> TupleHashTable;
        }
        BuildTupleHashTable(
            arg_parent,
            arg_inputDesc,
            arg_numCols,
            arg_keyColIdx,
            arg_eqfuncoids,
            arg_hashfunctions,
            arg_collations,
            arg_nbuckets,
            arg_additionalsize,
            arg_tablecxt,
            arg_tempcxt,
            arg_use_variable_hash_iv,
        )
    })
}
pub unsafe fn BuildTupleHashTableExt(
    arg_parent: *mut PlanState,
    arg_inputDesc: TupleDesc,
    arg_numCols: ::std::os::raw::c_int,
    arg_keyColIdx: *mut AttrNumber,
    arg_eqfuncoids: *const Oid,
    arg_hashfunctions: *mut FmgrInfo,
    arg_collations: *mut Oid,
    arg_nbuckets: ::std::os::raw::c_long,
    arg_additionalsize: Size,
    arg_metacxt: MemoryContext,
    arg_tablecxt: MemoryContext,
    arg_tempcxt: MemoryContext,
    arg_use_variable_hash_iv: bool,
) -> TupleHashTable {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BuildTupleHashTableExt(
                arg_parent: *mut PlanState,
                arg_inputDesc: TupleDesc,
                arg_numCols: ::std::os::raw::c_int,
                arg_keyColIdx: *mut AttrNumber,
                arg_eqfuncoids: *const Oid,
                arg_hashfunctions: *mut FmgrInfo,
                arg_collations: *mut Oid,
                arg_nbuckets: ::std::os::raw::c_long,
                arg_additionalsize: Size,
                arg_metacxt: MemoryContext,
                arg_tablecxt: MemoryContext,
                arg_tempcxt: MemoryContext,
                arg_use_variable_hash_iv: bool,
            ) -> TupleHashTable;
        }
        BuildTupleHashTableExt(
            arg_parent,
            arg_inputDesc,
            arg_numCols,
            arg_keyColIdx,
            arg_eqfuncoids,
            arg_hashfunctions,
            arg_collations,
            arg_nbuckets,
            arg_additionalsize,
            arg_metacxt,
            arg_tablecxt,
            arg_tempcxt,
            arg_use_variable_hash_iv,
        )
    })
}
pub unsafe fn LookupTupleHashEntry(
    arg_hashtable: TupleHashTable,
    arg_slot: *mut TupleTableSlot,
    arg_isnew: *mut bool,
    arg_hash: *mut uint32,
) -> TupleHashEntry {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LookupTupleHashEntry(
                arg_hashtable: TupleHashTable,
                arg_slot: *mut TupleTableSlot,
                arg_isnew: *mut bool,
                arg_hash: *mut uint32,
            ) -> TupleHashEntry;
        }
        LookupTupleHashEntry(arg_hashtable, arg_slot, arg_isnew, arg_hash)
    })
}
pub unsafe fn TupleHashTableHash(
    arg_hashtable: TupleHashTable,
    arg_slot: *mut TupleTableSlot,
) -> uint32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TupleHashTableHash(
                arg_hashtable: TupleHashTable,
                arg_slot: *mut TupleTableSlot,
            ) -> uint32;
        }
        TupleHashTableHash(arg_hashtable, arg_slot)
    })
}
pub unsafe fn LookupTupleHashEntryHash(
    arg_hashtable: TupleHashTable,
    arg_slot: *mut TupleTableSlot,
    arg_isnew: *mut bool,
    arg_hash: uint32,
) -> TupleHashEntry {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LookupTupleHashEntryHash(
                arg_hashtable: TupleHashTable,
                arg_slot: *mut TupleTableSlot,
                arg_isnew: *mut bool,
                arg_hash: uint32,
            ) -> TupleHashEntry;
        }
        LookupTupleHashEntryHash(arg_hashtable, arg_slot, arg_isnew, arg_hash)
    })
}
pub unsafe fn FindTupleHashEntry(
    arg_hashtable: TupleHashTable,
    arg_slot: *mut TupleTableSlot,
    arg_eqcomp: *mut ExprState,
    arg_hashfunctions: *mut FmgrInfo,
) -> TupleHashEntry {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FindTupleHashEntry(
                arg_hashtable: TupleHashTable,
                arg_slot: *mut TupleTableSlot,
                arg_eqcomp: *mut ExprState,
                arg_hashfunctions: *mut FmgrInfo,
            ) -> TupleHashEntry;
        }
        FindTupleHashEntry(arg_hashtable, arg_slot, arg_eqcomp, arg_hashfunctions)
    })
}
pub unsafe fn ResetTupleHashTable(arg_hashtable: TupleHashTable) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ResetTupleHashTable(arg_hashtable: TupleHashTable);
        }
        ResetTupleHashTable(arg_hashtable)
    })
}
pub unsafe fn ExecInitJunkFilter(
    arg_targetList: *mut List,
    arg_slot: *mut TupleTableSlot,
) -> *mut JunkFilter {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecInitJunkFilter(
                arg_targetList: *mut List,
                arg_slot: *mut TupleTableSlot,
            ) -> *mut JunkFilter;
        }
        ExecInitJunkFilter(arg_targetList, arg_slot)
    })
}
pub unsafe fn ExecInitJunkFilterInsertion(
    arg_targetList: *mut List,
    arg_cleanTupType: TupleDesc,
    arg_slot: *mut TupleTableSlot,
) -> *mut JunkFilter {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecInitJunkFilterInsertion(
                arg_targetList: *mut List,
                arg_cleanTupType: TupleDesc,
                arg_slot: *mut TupleTableSlot,
            ) -> *mut JunkFilter;
        }
        ExecInitJunkFilterInsertion(arg_targetList, arg_cleanTupType, arg_slot)
    })
}
pub unsafe fn ExecInitJunkFilterConversion(
    arg_targetList: *mut List,
    arg_cleanTupType: TupleDesc,
    arg_slot: *mut TupleTableSlot,
) -> *mut JunkFilter {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecInitJunkFilterConversion(
                arg_targetList: *mut List,
                arg_cleanTupType: TupleDesc,
                arg_slot: *mut TupleTableSlot,
            ) -> *mut JunkFilter;
        }
        ExecInitJunkFilterConversion(arg_targetList, arg_cleanTupType, arg_slot)
    })
}
pub unsafe fn ExecFindJunkAttribute(
    arg_junkfilter: *mut JunkFilter,
    arg_attrName: *const ::std::os::raw::c_char,
) -> AttrNumber {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecFindJunkAttribute(
                arg_junkfilter: *mut JunkFilter,
                arg_attrName: *const ::std::os::raw::c_char,
            ) -> AttrNumber;
        }
        ExecFindJunkAttribute(arg_junkfilter, arg_attrName)
    })
}
pub unsafe fn ExecFindJunkAttributeInTlist(
    arg_targetlist: *mut List,
    arg_attrName: *const ::std::os::raw::c_char,
) -> AttrNumber {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecFindJunkAttributeInTlist(
                arg_targetlist: *mut List,
                arg_attrName: *const ::std::os::raw::c_char,
            ) -> AttrNumber;
        }
        ExecFindJunkAttributeInTlist(arg_targetlist, arg_attrName)
    })
}
pub unsafe fn ExecGetJunkAttribute(
    arg_slot: *mut TupleTableSlot,
    arg_attno: AttrNumber,
    arg_isNull: *mut bool,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecGetJunkAttribute(
                arg_slot: *mut TupleTableSlot,
                arg_attno: AttrNumber,
                arg_isNull: *mut bool,
            ) -> Datum;
        }
        ExecGetJunkAttribute(arg_slot, arg_attno, arg_isNull)
    })
}
pub unsafe fn ExecFilterJunk(
    arg_junkfilter: *mut JunkFilter,
    arg_slot: *mut TupleTableSlot,
) -> *mut TupleTableSlot {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecFilterJunk(
                arg_junkfilter: *mut JunkFilter,
                arg_slot: *mut TupleTableSlot,
            ) -> *mut TupleTableSlot;
        }
        ExecFilterJunk(arg_junkfilter, arg_slot)
    })
}
pub unsafe fn ExecutorStart(arg_queryDesc: *mut QueryDesc, arg_eflags: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecutorStart(arg_queryDesc: *mut QueryDesc, arg_eflags: ::std::os::raw::c_int);
        }
        ExecutorStart(arg_queryDesc, arg_eflags)
    })
}
pub unsafe fn standard_ExecutorStart(
    arg_queryDesc: *mut QueryDesc,
    arg_eflags: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn standard_ExecutorStart(
                arg_queryDesc: *mut QueryDesc,
                arg_eflags: ::std::os::raw::c_int,
            );
        }
        standard_ExecutorStart(arg_queryDesc, arg_eflags)
    })
}
pub unsafe fn ExecutorRun(
    arg_queryDesc: *mut QueryDesc,
    arg_direction: ScanDirection,
    arg_count: uint64,
    arg_execute_once: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecutorRun(
                arg_queryDesc: *mut QueryDesc,
                arg_direction: ScanDirection,
                arg_count: uint64,
                arg_execute_once: bool,
            );
        }
        ExecutorRun(arg_queryDesc, arg_direction, arg_count, arg_execute_once)
    })
}
pub unsafe fn standard_ExecutorRun(
    arg_queryDesc: *mut QueryDesc,
    arg_direction: ScanDirection,
    arg_count: uint64,
    arg_execute_once: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn standard_ExecutorRun(
                arg_queryDesc: *mut QueryDesc,
                arg_direction: ScanDirection,
                arg_count: uint64,
                arg_execute_once: bool,
            );
        }
        standard_ExecutorRun(arg_queryDesc, arg_direction, arg_count, arg_execute_once)
    })
}
pub unsafe fn ExecutorFinish(arg_queryDesc: *mut QueryDesc) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecutorFinish(arg_queryDesc: *mut QueryDesc);
        }
        ExecutorFinish(arg_queryDesc)
    })
}
pub unsafe fn standard_ExecutorFinish(arg_queryDesc: *mut QueryDesc) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn standard_ExecutorFinish(arg_queryDesc: *mut QueryDesc);
        }
        standard_ExecutorFinish(arg_queryDesc)
    })
}
pub unsafe fn ExecutorEnd(arg_queryDesc: *mut QueryDesc) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecutorEnd(arg_queryDesc: *mut QueryDesc);
        }
        ExecutorEnd(arg_queryDesc)
    })
}
pub unsafe fn standard_ExecutorEnd(arg_queryDesc: *mut QueryDesc) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn standard_ExecutorEnd(arg_queryDesc: *mut QueryDesc);
        }
        standard_ExecutorEnd(arg_queryDesc)
    })
}
pub unsafe fn ExecutorRewind(arg_queryDesc: *mut QueryDesc) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecutorRewind(arg_queryDesc: *mut QueryDesc);
        }
        ExecutorRewind(arg_queryDesc)
    })
}
pub unsafe fn ExecCheckRTPerms(arg_rangeTable: *mut List, arg_ereport_on_violation: bool) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecCheckRTPerms(arg_rangeTable: *mut List, arg_ereport_on_violation: bool) -> bool;
        }
        ExecCheckRTPerms(arg_rangeTable, arg_ereport_on_violation)
    })
}
pub unsafe fn CheckValidResultRel(arg_resultRelInfo: *mut ResultRelInfo, arg_operation: CmdType) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CheckValidResultRel(arg_resultRelInfo: *mut ResultRelInfo, arg_operation: CmdType);
        }
        CheckValidResultRel(arg_resultRelInfo, arg_operation)
    })
}
pub unsafe fn InitResultRelInfo(
    arg_resultRelInfo: *mut ResultRelInfo,
    arg_resultRelationDesc: Relation,
    arg_resultRelationIndex: Index,
    arg_partition_root_rri: *mut ResultRelInfo,
    arg_instrument_options: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitResultRelInfo(
                arg_resultRelInfo: *mut ResultRelInfo,
                arg_resultRelationDesc: Relation,
                arg_resultRelationIndex: Index,
                arg_partition_root_rri: *mut ResultRelInfo,
                arg_instrument_options: ::std::os::raw::c_int,
            );
        }
        InitResultRelInfo(
            arg_resultRelInfo,
            arg_resultRelationDesc,
            arg_resultRelationIndex,
            arg_partition_root_rri,
            arg_instrument_options,
        )
    })
}
pub unsafe fn ExecGetTriggerResultRel(
    arg_estate: *mut EState,
    arg_relid: Oid,
) -> *mut ResultRelInfo {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecGetTriggerResultRel(
                arg_estate: *mut EState,
                arg_relid: Oid,
            ) -> *mut ResultRelInfo;
        }
        ExecGetTriggerResultRel(arg_estate, arg_relid)
    })
}
pub unsafe fn ExecCleanUpTriggerState(arg_estate: *mut EState) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecCleanUpTriggerState(arg_estate: *mut EState);
        }
        ExecCleanUpTriggerState(arg_estate)
    })
}
pub unsafe fn ExecConstraints(
    arg_resultRelInfo: *mut ResultRelInfo,
    arg_slot: *mut TupleTableSlot,
    arg_estate: *mut EState,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecConstraints(
                arg_resultRelInfo: *mut ResultRelInfo,
                arg_slot: *mut TupleTableSlot,
                arg_estate: *mut EState,
            );
        }
        ExecConstraints(arg_resultRelInfo, arg_slot, arg_estate)
    })
}
pub unsafe fn ExecPartitionCheck(
    arg_resultRelInfo: *mut ResultRelInfo,
    arg_slot: *mut TupleTableSlot,
    arg_estate: *mut EState,
    arg_emitError: bool,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecPartitionCheck(
                arg_resultRelInfo: *mut ResultRelInfo,
                arg_slot: *mut TupleTableSlot,
                arg_estate: *mut EState,
                arg_emitError: bool,
            ) -> bool;
        }
        ExecPartitionCheck(arg_resultRelInfo, arg_slot, arg_estate, arg_emitError)
    })
}
pub unsafe fn ExecPartitionCheckEmitError(
    arg_resultRelInfo: *mut ResultRelInfo,
    arg_slot: *mut TupleTableSlot,
    arg_estate: *mut EState,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecPartitionCheckEmitError(
                arg_resultRelInfo: *mut ResultRelInfo,
                arg_slot: *mut TupleTableSlot,
                arg_estate: *mut EState,
            );
        }
        ExecPartitionCheckEmitError(arg_resultRelInfo, arg_slot, arg_estate)
    })
}
pub unsafe fn ExecWithCheckOptions(
    arg_kind: WCOKind,
    arg_resultRelInfo: *mut ResultRelInfo,
    arg_slot: *mut TupleTableSlot,
    arg_estate: *mut EState,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecWithCheckOptions(
                arg_kind: WCOKind,
                arg_resultRelInfo: *mut ResultRelInfo,
                arg_slot: *mut TupleTableSlot,
                arg_estate: *mut EState,
            );
        }
        ExecWithCheckOptions(arg_kind, arg_resultRelInfo, arg_slot, arg_estate)
    })
}
pub unsafe fn ExecUpdateLockMode(
    arg_estate: *mut EState,
    arg_relinfo: *mut ResultRelInfo,
) -> LockTupleMode {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecUpdateLockMode(
                arg_estate: *mut EState,
                arg_relinfo: *mut ResultRelInfo,
            ) -> LockTupleMode;
        }
        ExecUpdateLockMode(arg_estate, arg_relinfo)
    })
}
pub unsafe fn ExecFindRowMark(
    arg_estate: *mut EState,
    arg_rti: Index,
    arg_missing_ok: bool,
) -> *mut ExecRowMark {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecFindRowMark(
                arg_estate: *mut EState,
                arg_rti: Index,
                arg_missing_ok: bool,
            ) -> *mut ExecRowMark;
        }
        ExecFindRowMark(arg_estate, arg_rti, arg_missing_ok)
    })
}
pub unsafe fn ExecBuildAuxRowMark(
    arg_erm: *mut ExecRowMark,
    arg_targetlist: *mut List,
) -> *mut ExecAuxRowMark {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecBuildAuxRowMark(
                arg_erm: *mut ExecRowMark,
                arg_targetlist: *mut List,
            ) -> *mut ExecAuxRowMark;
        }
        ExecBuildAuxRowMark(arg_erm, arg_targetlist)
    })
}
pub unsafe fn EvalPlanQual(
    arg_epqstate: *mut EPQState,
    arg_relation: Relation,
    arg_rti: Index,
    arg_testslot: *mut TupleTableSlot,
) -> *mut TupleTableSlot {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EvalPlanQual(
                arg_epqstate: *mut EPQState,
                arg_relation: Relation,
                arg_rti: Index,
                arg_testslot: *mut TupleTableSlot,
            ) -> *mut TupleTableSlot;
        }
        EvalPlanQual(arg_epqstate, arg_relation, arg_rti, arg_testslot)
    })
}
pub unsafe fn EvalPlanQualInit(
    arg_epqstate: *mut EPQState,
    arg_parentestate: *mut EState,
    arg_subplan: *mut Plan,
    arg_auxrowmarks: *mut List,
    arg_epqParam: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EvalPlanQualInit(
                arg_epqstate: *mut EPQState,
                arg_parentestate: *mut EState,
                arg_subplan: *mut Plan,
                arg_auxrowmarks: *mut List,
                arg_epqParam: ::std::os::raw::c_int,
            );
        }
        EvalPlanQualInit(arg_epqstate, arg_parentestate, arg_subplan, arg_auxrowmarks, arg_epqParam)
    })
}
pub unsafe fn EvalPlanQualSetPlan(
    arg_epqstate: *mut EPQState,
    arg_subplan: *mut Plan,
    arg_auxrowmarks: *mut List,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EvalPlanQualSetPlan(
                arg_epqstate: *mut EPQState,
                arg_subplan: *mut Plan,
                arg_auxrowmarks: *mut List,
            );
        }
        EvalPlanQualSetPlan(arg_epqstate, arg_subplan, arg_auxrowmarks)
    })
}
pub unsafe fn EvalPlanQualSlot(
    arg_epqstate: *mut EPQState,
    arg_relation: Relation,
    arg_rti: Index,
) -> *mut TupleTableSlot {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EvalPlanQualSlot(
                arg_epqstate: *mut EPQState,
                arg_relation: Relation,
                arg_rti: Index,
            ) -> *mut TupleTableSlot;
        }
        EvalPlanQualSlot(arg_epqstate, arg_relation, arg_rti)
    })
}
pub unsafe fn EvalPlanQualFetchRowMark(
    arg_epqstate: *mut EPQState,
    arg_rti: Index,
    arg_slot: *mut TupleTableSlot,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EvalPlanQualFetchRowMark(
                arg_epqstate: *mut EPQState,
                arg_rti: Index,
                arg_slot: *mut TupleTableSlot,
            ) -> bool;
        }
        EvalPlanQualFetchRowMark(arg_epqstate, arg_rti, arg_slot)
    })
}
pub unsafe fn EvalPlanQualNext(arg_epqstate: *mut EPQState) -> *mut TupleTableSlot {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EvalPlanQualNext(arg_epqstate: *mut EPQState) -> *mut TupleTableSlot;
        }
        EvalPlanQualNext(arg_epqstate)
    })
}
pub unsafe fn EvalPlanQualBegin(arg_epqstate: *mut EPQState) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EvalPlanQualBegin(arg_epqstate: *mut EPQState);
        }
        EvalPlanQualBegin(arg_epqstate)
    })
}
pub unsafe fn EvalPlanQualEnd(arg_epqstate: *mut EPQState) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EvalPlanQualEnd(arg_epqstate: *mut EPQState);
        }
        EvalPlanQualEnd(arg_epqstate)
    })
}
pub unsafe fn ExecInitNode(
    arg_node: *mut Plan,
    arg_estate: *mut EState,
    arg_eflags: ::std::os::raw::c_int,
) -> *mut PlanState {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecInitNode(
                arg_node: *mut Plan,
                arg_estate: *mut EState,
                arg_eflags: ::std::os::raw::c_int,
            ) -> *mut PlanState;
        }
        ExecInitNode(arg_node, arg_estate, arg_eflags)
    })
}
pub unsafe fn ExecSetExecProcNode(arg_node: *mut PlanState, arg_function: ExecProcNodeMtd) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecSetExecProcNode(arg_node: *mut PlanState, arg_function: ExecProcNodeMtd);
        }
        ExecSetExecProcNode(arg_node, arg_function)
    })
}
pub unsafe fn MultiExecProcNode(arg_node: *mut PlanState) -> *mut Node {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MultiExecProcNode(arg_node: *mut PlanState) -> *mut Node;
        }
        MultiExecProcNode(arg_node)
    })
}
pub unsafe fn ExecEndNode(arg_node: *mut PlanState) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecEndNode(arg_node: *mut PlanState);
        }
        ExecEndNode(arg_node)
    })
}
pub unsafe fn ExecShutdownNode(arg_node: *mut PlanState) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecShutdownNode(arg_node: *mut PlanState) -> bool;
        }
        ExecShutdownNode(arg_node)
    })
}
pub unsafe fn ExecSetTupleBound(arg_tuples_needed: int64, arg_child_node: *mut PlanState) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecSetTupleBound(arg_tuples_needed: int64, arg_child_node: *mut PlanState);
        }
        ExecSetTupleBound(arg_tuples_needed, arg_child_node)
    })
}
pub unsafe fn ExecInitExpr(arg_node: *mut Expr, arg_parent: *mut PlanState) -> *mut ExprState {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecInitExpr(arg_node: *mut Expr, arg_parent: *mut PlanState) -> *mut ExprState;
        }
        ExecInitExpr(arg_node, arg_parent)
    })
}
pub unsafe fn ExecInitExprWithParams(
    arg_node: *mut Expr,
    arg_ext_params: ParamListInfo,
) -> *mut ExprState {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecInitExprWithParams(
                arg_node: *mut Expr,
                arg_ext_params: ParamListInfo,
            ) -> *mut ExprState;
        }
        ExecInitExprWithParams(arg_node, arg_ext_params)
    })
}
pub unsafe fn ExecInitQual(arg_qual: *mut List, arg_parent: *mut PlanState) -> *mut ExprState {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecInitQual(arg_qual: *mut List, arg_parent: *mut PlanState) -> *mut ExprState;
        }
        ExecInitQual(arg_qual, arg_parent)
    })
}
pub unsafe fn ExecInitCheck(arg_qual: *mut List, arg_parent: *mut PlanState) -> *mut ExprState {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecInitCheck(arg_qual: *mut List, arg_parent: *mut PlanState) -> *mut ExprState;
        }
        ExecInitCheck(arg_qual, arg_parent)
    })
}
pub unsafe fn ExecInitExprList(arg_nodes: *mut List, arg_parent: *mut PlanState) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecInitExprList(arg_nodes: *mut List, arg_parent: *mut PlanState) -> *mut List;
        }
        ExecInitExprList(arg_nodes, arg_parent)
    })
}
pub unsafe fn ExecBuildAggTrans(
    arg_aggstate: *mut AggState,
    arg_phase: *mut AggStatePerPhaseData,
    arg_doSort: bool,
    arg_doHash: bool,
    arg_nullcheck: bool,
) -> *mut ExprState {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecBuildAggTrans(
                arg_aggstate: *mut AggState,
                arg_phase: *mut AggStatePerPhaseData,
                arg_doSort: bool,
                arg_doHash: bool,
                arg_nullcheck: bool,
            ) -> *mut ExprState;
        }
        ExecBuildAggTrans(arg_aggstate, arg_phase, arg_doSort, arg_doHash, arg_nullcheck)
    })
}
pub unsafe fn ExecBuildGroupingEqual(
    arg_ldesc: TupleDesc,
    arg_rdesc: TupleDesc,
    arg_lops: *const TupleTableSlotOps,
    arg_rops: *const TupleTableSlotOps,
    arg_numCols: ::std::os::raw::c_int,
    arg_keyColIdx: *const AttrNumber,
    arg_eqfunctions: *const Oid,
    arg_collations: *const Oid,
    arg_parent: *mut PlanState,
) -> *mut ExprState {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecBuildGroupingEqual(
                arg_ldesc: TupleDesc,
                arg_rdesc: TupleDesc,
                arg_lops: *const TupleTableSlotOps,
                arg_rops: *const TupleTableSlotOps,
                arg_numCols: ::std::os::raw::c_int,
                arg_keyColIdx: *const AttrNumber,
                arg_eqfunctions: *const Oid,
                arg_collations: *const Oid,
                arg_parent: *mut PlanState,
            ) -> *mut ExprState;
        }
        ExecBuildGroupingEqual(
            arg_ldesc,
            arg_rdesc,
            arg_lops,
            arg_rops,
            arg_numCols,
            arg_keyColIdx,
            arg_eqfunctions,
            arg_collations,
            arg_parent,
        )
    })
}
pub unsafe fn ExecBuildProjectionInfo(
    arg_targetList: *mut List,
    arg_econtext: *mut ExprContext,
    arg_slot: *mut TupleTableSlot,
    arg_parent: *mut PlanState,
    arg_inputDesc: TupleDesc,
) -> *mut ProjectionInfo {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecBuildProjectionInfo(
                arg_targetList: *mut List,
                arg_econtext: *mut ExprContext,
                arg_slot: *mut TupleTableSlot,
                arg_parent: *mut PlanState,
                arg_inputDesc: TupleDesc,
            ) -> *mut ProjectionInfo;
        }
        ExecBuildProjectionInfo(arg_targetList, arg_econtext, arg_slot, arg_parent, arg_inputDesc)
    })
}
pub unsafe fn ExecBuildProjectionInfoExt(
    arg_targetList: *mut List,
    arg_econtext: *mut ExprContext,
    arg_slot: *mut TupleTableSlot,
    arg_assignJunkEntries: bool,
    arg_parent: *mut PlanState,
    arg_inputDesc: TupleDesc,
) -> *mut ProjectionInfo {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecBuildProjectionInfoExt(
                arg_targetList: *mut List,
                arg_econtext: *mut ExprContext,
                arg_slot: *mut TupleTableSlot,
                arg_assignJunkEntries: bool,
                arg_parent: *mut PlanState,
                arg_inputDesc: TupleDesc,
            ) -> *mut ProjectionInfo;
        }
        ExecBuildProjectionInfoExt(
            arg_targetList,
            arg_econtext,
            arg_slot,
            arg_assignJunkEntries,
            arg_parent,
            arg_inputDesc,
        )
    })
}
pub unsafe fn ExecPrepareExpr(arg_node: *mut Expr, arg_estate: *mut EState) -> *mut ExprState {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecPrepareExpr(arg_node: *mut Expr, arg_estate: *mut EState) -> *mut ExprState;
        }
        ExecPrepareExpr(arg_node, arg_estate)
    })
}
pub unsafe fn ExecPrepareQual(arg_qual: *mut List, arg_estate: *mut EState) -> *mut ExprState {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecPrepareQual(arg_qual: *mut List, arg_estate: *mut EState) -> *mut ExprState;
        }
        ExecPrepareQual(arg_qual, arg_estate)
    })
}
pub unsafe fn ExecPrepareCheck(arg_qual: *mut List, arg_estate: *mut EState) -> *mut ExprState {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecPrepareCheck(arg_qual: *mut List, arg_estate: *mut EState) -> *mut ExprState;
        }
        ExecPrepareCheck(arg_qual, arg_estate)
    })
}
pub unsafe fn ExecPrepareExprList(arg_nodes: *mut List, arg_estate: *mut EState) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecPrepareExprList(arg_nodes: *mut List, arg_estate: *mut EState) -> *mut List;
        }
        ExecPrepareExprList(arg_nodes, arg_estate)
    })
}
pub unsafe fn ExecCheck(arg_state: *mut ExprState, arg_context: *mut ExprContext) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecCheck(arg_state: *mut ExprState, arg_context: *mut ExprContext) -> bool;
        }
        ExecCheck(arg_state, arg_context)
    })
}
pub unsafe fn ExecInitTableFunctionResult(
    arg_expr: *mut Expr,
    arg_econtext: *mut ExprContext,
    arg_parent: *mut PlanState,
) -> *mut SetExprState {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecInitTableFunctionResult(
                arg_expr: *mut Expr,
                arg_econtext: *mut ExprContext,
                arg_parent: *mut PlanState,
            ) -> *mut SetExprState;
        }
        ExecInitTableFunctionResult(arg_expr, arg_econtext, arg_parent)
    })
}
pub unsafe fn ExecMakeTableFunctionResult(
    arg_setexpr: *mut SetExprState,
    arg_econtext: *mut ExprContext,
    arg_argContext: MemoryContext,
    arg_expectedDesc: TupleDesc,
    arg_randomAccess: bool,
) -> *mut Tuplestorestate {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecMakeTableFunctionResult(
                arg_setexpr: *mut SetExprState,
                arg_econtext: *mut ExprContext,
                arg_argContext: MemoryContext,
                arg_expectedDesc: TupleDesc,
                arg_randomAccess: bool,
            ) -> *mut Tuplestorestate;
        }
        ExecMakeTableFunctionResult(
            arg_setexpr,
            arg_econtext,
            arg_argContext,
            arg_expectedDesc,
            arg_randomAccess,
        )
    })
}
pub unsafe fn ExecInitFunctionResultSet(
    arg_expr: *mut Expr,
    arg_econtext: *mut ExprContext,
    arg_parent: *mut PlanState,
) -> *mut SetExprState {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecInitFunctionResultSet(
                arg_expr: *mut Expr,
                arg_econtext: *mut ExprContext,
                arg_parent: *mut PlanState,
            ) -> *mut SetExprState;
        }
        ExecInitFunctionResultSet(arg_expr, arg_econtext, arg_parent)
    })
}
pub unsafe fn ExecMakeFunctionResultSet(
    arg_fcache: *mut SetExprState,
    arg_econtext: *mut ExprContext,
    arg_argContext: MemoryContext,
    arg_isNull: *mut bool,
    arg_isDone: *mut ExprDoneCond,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecMakeFunctionResultSet(
                arg_fcache: *mut SetExprState,
                arg_econtext: *mut ExprContext,
                arg_argContext: MemoryContext,
                arg_isNull: *mut bool,
                arg_isDone: *mut ExprDoneCond,
            ) -> Datum;
        }
        ExecMakeFunctionResultSet(arg_fcache, arg_econtext, arg_argContext, arg_isNull, arg_isDone)
    })
}
pub type ExecScanAccessMtd =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ScanState) -> *mut TupleTableSlot>;
pub type ExecScanRecheckMtd = ::std::option::Option<
    unsafe extern "C" fn(node: *mut ScanState, slot: *mut TupleTableSlot) -> bool,
>;
pub unsafe fn ExecScan(
    arg_node: *mut ScanState,
    arg_accessMtd: ExecScanAccessMtd,
    arg_recheckMtd: ExecScanRecheckMtd,
) -> *mut TupleTableSlot {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecScan(
                arg_node: *mut ScanState,
                arg_accessMtd: ExecScanAccessMtd,
                arg_recheckMtd: ExecScanRecheckMtd,
            ) -> *mut TupleTableSlot;
        }
        ExecScan(arg_node, arg_accessMtd, arg_recheckMtd)
    })
}
pub unsafe fn ExecAssignScanProjectionInfo(arg_node: *mut ScanState) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecAssignScanProjectionInfo(arg_node: *mut ScanState);
        }
        ExecAssignScanProjectionInfo(arg_node)
    })
}
pub unsafe fn ExecAssignScanProjectionInfoWithVarno(arg_node: *mut ScanState, arg_varno: Index) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecAssignScanProjectionInfoWithVarno(arg_node: *mut ScanState, arg_varno: Index);
        }
        ExecAssignScanProjectionInfoWithVarno(arg_node, arg_varno)
    })
}
pub unsafe fn ExecScanReScan(arg_node: *mut ScanState) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecScanReScan(arg_node: *mut ScanState);
        }
        ExecScanReScan(arg_node)
    })
}
pub unsafe fn ExecInitResultTypeTL(arg_planstate: *mut PlanState) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecInitResultTypeTL(arg_planstate: *mut PlanState);
        }
        ExecInitResultTypeTL(arg_planstate)
    })
}
pub unsafe fn ExecInitResultSlot(
    arg_planstate: *mut PlanState,
    arg_tts_ops: *const TupleTableSlotOps,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecInitResultSlot(
                arg_planstate: *mut PlanState,
                arg_tts_ops: *const TupleTableSlotOps,
            );
        }
        ExecInitResultSlot(arg_planstate, arg_tts_ops)
    })
}
pub unsafe fn ExecInitResultTupleSlotTL(
    arg_planstate: *mut PlanState,
    arg_tts_ops: *const TupleTableSlotOps,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecInitResultTupleSlotTL(
                arg_planstate: *mut PlanState,
                arg_tts_ops: *const TupleTableSlotOps,
            );
        }
        ExecInitResultTupleSlotTL(arg_planstate, arg_tts_ops)
    })
}
pub unsafe fn ExecInitScanTupleSlot(
    arg_estate: *mut EState,
    arg_scanstate: *mut ScanState,
    arg_tupleDesc: TupleDesc,
    arg_tts_ops: *const TupleTableSlotOps,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecInitScanTupleSlot(
                arg_estate: *mut EState,
                arg_scanstate: *mut ScanState,
                arg_tupleDesc: TupleDesc,
                arg_tts_ops: *const TupleTableSlotOps,
            );
        }
        ExecInitScanTupleSlot(arg_estate, arg_scanstate, arg_tupleDesc, arg_tts_ops)
    })
}
pub unsafe fn ExecInitExtraTupleSlot(
    arg_estate: *mut EState,
    arg_tupledesc: TupleDesc,
    arg_tts_ops: *const TupleTableSlotOps,
) -> *mut TupleTableSlot {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecInitExtraTupleSlot(
                arg_estate: *mut EState,
                arg_tupledesc: TupleDesc,
                arg_tts_ops: *const TupleTableSlotOps,
            ) -> *mut TupleTableSlot;
        }
        ExecInitExtraTupleSlot(arg_estate, arg_tupledesc, arg_tts_ops)
    })
}
pub unsafe fn ExecInitNullTupleSlot(
    arg_estate: *mut EState,
    arg_tupType: TupleDesc,
    arg_tts_ops: *const TupleTableSlotOps,
) -> *mut TupleTableSlot {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecInitNullTupleSlot(
                arg_estate: *mut EState,
                arg_tupType: TupleDesc,
                arg_tts_ops: *const TupleTableSlotOps,
            ) -> *mut TupleTableSlot;
        }
        ExecInitNullTupleSlot(arg_estate, arg_tupType, arg_tts_ops)
    })
}
pub unsafe fn ExecTypeFromTL(arg_targetList: *mut List) -> TupleDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecTypeFromTL(arg_targetList: *mut List) -> TupleDesc;
        }
        ExecTypeFromTL(arg_targetList)
    })
}
pub unsafe fn ExecCleanTypeFromTL(arg_targetList: *mut List) -> TupleDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecCleanTypeFromTL(arg_targetList: *mut List) -> TupleDesc;
        }
        ExecCleanTypeFromTL(arg_targetList)
    })
}
pub unsafe fn ExecTypeFromExprList(arg_exprList: *mut List) -> TupleDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecTypeFromExprList(arg_exprList: *mut List) -> TupleDesc;
        }
        ExecTypeFromExprList(arg_exprList)
    })
}
pub unsafe fn ExecTypeSetColNames(arg_typeInfo: TupleDesc, arg_namesList: *mut List) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecTypeSetColNames(arg_typeInfo: TupleDesc, arg_namesList: *mut List);
        }
        ExecTypeSetColNames(arg_typeInfo, arg_namesList)
    })
}
pub unsafe fn UpdateChangedParamSet(arg_node: *mut PlanState, arg_newchg: *mut Bitmapset) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn UpdateChangedParamSet(arg_node: *mut PlanState, arg_newchg: *mut Bitmapset);
        }
        UpdateChangedParamSet(arg_node, arg_newchg)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TupOutputState {
    pub slot: *mut TupleTableSlot,
    pub dest: *mut DestReceiver,
}
impl Default for TupOutputState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn begin_tup_output_tupdesc(
    arg_dest: *mut DestReceiver,
    arg_tupdesc: TupleDesc,
    arg_tts_ops: *const TupleTableSlotOps,
) -> *mut TupOutputState {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn begin_tup_output_tupdesc(
                arg_dest: *mut DestReceiver,
                arg_tupdesc: TupleDesc,
                arg_tts_ops: *const TupleTableSlotOps,
            ) -> *mut TupOutputState;
        }
        begin_tup_output_tupdesc(arg_dest, arg_tupdesc, arg_tts_ops)
    })
}
pub unsafe fn do_tup_output(
    arg_tstate: *mut TupOutputState,
    arg_values: *mut Datum,
    arg_isnull: *mut bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn do_tup_output(
                arg_tstate: *mut TupOutputState,
                arg_values: *mut Datum,
                arg_isnull: *mut bool,
            );
        }
        do_tup_output(arg_tstate, arg_values, arg_isnull)
    })
}
pub unsafe fn do_text_output_multiline(
    arg_tstate: *mut TupOutputState,
    arg_txt: *const ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn do_text_output_multiline(
                arg_tstate: *mut TupOutputState,
                arg_txt: *const ::std::os::raw::c_char,
            );
        }
        do_text_output_multiline(arg_tstate, arg_txt)
    })
}
pub unsafe fn end_tup_output(arg_tstate: *mut TupOutputState) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn end_tup_output(arg_tstate: *mut TupOutputState);
        }
        end_tup_output(arg_tstate)
    })
}
pub unsafe fn CreateExecutorState() -> *mut EState {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateExecutorState() -> *mut EState;
        }
        CreateExecutorState()
    })
}
pub unsafe fn FreeExecutorState(arg_estate: *mut EState) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FreeExecutorState(arg_estate: *mut EState);
        }
        FreeExecutorState(arg_estate)
    })
}
pub unsafe fn CreateExprContext(arg_estate: *mut EState) -> *mut ExprContext {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateExprContext(arg_estate: *mut EState) -> *mut ExprContext;
        }
        CreateExprContext(arg_estate)
    })
}
pub unsafe fn CreateWorkExprContext(arg_estate: *mut EState) -> *mut ExprContext {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateWorkExprContext(arg_estate: *mut EState) -> *mut ExprContext;
        }
        CreateWorkExprContext(arg_estate)
    })
}
pub unsafe fn CreateStandaloneExprContext() -> *mut ExprContext {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateStandaloneExprContext() -> *mut ExprContext;
        }
        CreateStandaloneExprContext()
    })
}
pub unsafe fn FreeExprContext(arg_econtext: *mut ExprContext, arg_isCommit: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FreeExprContext(arg_econtext: *mut ExprContext, arg_isCommit: bool);
        }
        FreeExprContext(arg_econtext, arg_isCommit)
    })
}
pub unsafe fn ReScanExprContext(arg_econtext: *mut ExprContext) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReScanExprContext(arg_econtext: *mut ExprContext);
        }
        ReScanExprContext(arg_econtext)
    })
}
pub unsafe fn MakePerTupleExprContext(arg_estate: *mut EState) -> *mut ExprContext {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MakePerTupleExprContext(arg_estate: *mut EState) -> *mut ExprContext;
        }
        MakePerTupleExprContext(arg_estate)
    })
}
pub unsafe fn ExecAssignExprContext(arg_estate: *mut EState, arg_planstate: *mut PlanState) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecAssignExprContext(arg_estate: *mut EState, arg_planstate: *mut PlanState);
        }
        ExecAssignExprContext(arg_estate, arg_planstate)
    })
}
pub unsafe fn ExecGetResultType(arg_planstate: *mut PlanState) -> TupleDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecGetResultType(arg_planstate: *mut PlanState) -> TupleDesc;
        }
        ExecGetResultType(arg_planstate)
    })
}
pub unsafe fn ExecGetResultSlotOps(
    arg_planstate: *mut PlanState,
    arg_isfixed: *mut bool,
) -> *const TupleTableSlotOps {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecGetResultSlotOps(
                arg_planstate: *mut PlanState,
                arg_isfixed: *mut bool,
            ) -> *const TupleTableSlotOps;
        }
        ExecGetResultSlotOps(arg_planstate, arg_isfixed)
    })
}
pub unsafe fn ExecAssignProjectionInfo(arg_planstate: *mut PlanState, arg_inputDesc: TupleDesc) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecAssignProjectionInfo(arg_planstate: *mut PlanState, arg_inputDesc: TupleDesc);
        }
        ExecAssignProjectionInfo(arg_planstate, arg_inputDesc)
    })
}
pub unsafe fn ExecConditionalAssignProjectionInfo(
    arg_planstate: *mut PlanState,
    arg_inputDesc: TupleDesc,
    arg_varno: Index,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecConditionalAssignProjectionInfo(
                arg_planstate: *mut PlanState,
                arg_inputDesc: TupleDesc,
                arg_varno: Index,
            );
        }
        ExecConditionalAssignProjectionInfo(arg_planstate, arg_inputDesc, arg_varno)
    })
}
pub unsafe fn ExecFreeExprContext(arg_planstate: *mut PlanState) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecFreeExprContext(arg_planstate: *mut PlanState);
        }
        ExecFreeExprContext(arg_planstate)
    })
}
pub unsafe fn ExecAssignScanType(arg_scanstate: *mut ScanState, arg_tupDesc: TupleDesc) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecAssignScanType(arg_scanstate: *mut ScanState, arg_tupDesc: TupleDesc);
        }
        ExecAssignScanType(arg_scanstate, arg_tupDesc)
    })
}
pub unsafe fn ExecCreateScanSlotFromOuterPlan(
    arg_estate: *mut EState,
    arg_scanstate: *mut ScanState,
    arg_tts_ops: *const TupleTableSlotOps,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecCreateScanSlotFromOuterPlan(
                arg_estate: *mut EState,
                arg_scanstate: *mut ScanState,
                arg_tts_ops: *const TupleTableSlotOps,
            );
        }
        ExecCreateScanSlotFromOuterPlan(arg_estate, arg_scanstate, arg_tts_ops)
    })
}
pub unsafe fn ExecRelationIsTargetRelation(arg_estate: *mut EState, arg_scanrelid: Index) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecRelationIsTargetRelation(arg_estate: *mut EState, arg_scanrelid: Index) -> bool;
        }
        ExecRelationIsTargetRelation(arg_estate, arg_scanrelid)
    })
}
pub unsafe fn ExecOpenScanRelation(
    arg_estate: *mut EState,
    arg_scanrelid: Index,
    arg_eflags: ::std::os::raw::c_int,
) -> Relation {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecOpenScanRelation(
                arg_estate: *mut EState,
                arg_scanrelid: Index,
                arg_eflags: ::std::os::raw::c_int,
            ) -> Relation;
        }
        ExecOpenScanRelation(arg_estate, arg_scanrelid, arg_eflags)
    })
}
pub unsafe fn ExecInitRangeTable(arg_estate: *mut EState, arg_rangeTable: *mut List) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecInitRangeTable(arg_estate: *mut EState, arg_rangeTable: *mut List);
        }
        ExecInitRangeTable(arg_estate, arg_rangeTable)
    })
}
pub unsafe fn ExecGetRangeTableRelation(arg_estate: *mut EState, arg_rti: Index) -> Relation {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecGetRangeTableRelation(arg_estate: *mut EState, arg_rti: Index) -> Relation;
        }
        ExecGetRangeTableRelation(arg_estate, arg_rti)
    })
}
pub unsafe fn executor_errposition(
    arg_estate: *mut EState,
    arg_location: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn executor_errposition(
                arg_estate: *mut EState,
                arg_location: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        executor_errposition(arg_estate, arg_location)
    })
}
pub unsafe fn RegisterExprContextCallback(
    arg_econtext: *mut ExprContext,
    arg_function: ExprContextCallbackFunction,
    arg_arg: Datum,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RegisterExprContextCallback(
                arg_econtext: *mut ExprContext,
                arg_function: ExprContextCallbackFunction,
                arg_arg: Datum,
            );
        }
        RegisterExprContextCallback(arg_econtext, arg_function, arg_arg)
    })
}
pub unsafe fn UnregisterExprContextCallback(
    arg_econtext: *mut ExprContext,
    arg_function: ExprContextCallbackFunction,
    arg_arg: Datum,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn UnregisterExprContextCallback(
                arg_econtext: *mut ExprContext,
                arg_function: ExprContextCallbackFunction,
                arg_arg: Datum,
            );
        }
        UnregisterExprContextCallback(arg_econtext, arg_function, arg_arg)
    })
}
pub unsafe fn GetAttributeByName(
    arg_tuple: HeapTupleHeader,
    arg_attname: *const ::std::os::raw::c_char,
    arg_isNull: *mut bool,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetAttributeByName(
                arg_tuple: HeapTupleHeader,
                arg_attname: *const ::std::os::raw::c_char,
                arg_isNull: *mut bool,
            ) -> Datum;
        }
        GetAttributeByName(arg_tuple, arg_attname, arg_isNull)
    })
}
pub unsafe fn GetAttributeByNum(
    arg_tuple: HeapTupleHeader,
    arg_attrno: AttrNumber,
    arg_isNull: *mut bool,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetAttributeByNum(
                arg_tuple: HeapTupleHeader,
                arg_attrno: AttrNumber,
                arg_isNull: *mut bool,
            ) -> Datum;
        }
        GetAttributeByNum(arg_tuple, arg_attrno, arg_isNull)
    })
}
pub unsafe fn ExecTargetListLength(arg_targetlist: *mut List) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecTargetListLength(arg_targetlist: *mut List) -> ::std::os::raw::c_int;
        }
        ExecTargetListLength(arg_targetlist)
    })
}
pub unsafe fn ExecCleanTargetListLength(arg_targetlist: *mut List) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecCleanTargetListLength(arg_targetlist: *mut List) -> ::std::os::raw::c_int;
        }
        ExecCleanTargetListLength(arg_targetlist)
    })
}
pub unsafe fn ExecGetTriggerOldSlot(
    arg_estate: *mut EState,
    arg_relInfo: *mut ResultRelInfo,
) -> *mut TupleTableSlot {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecGetTriggerOldSlot(
                arg_estate: *mut EState,
                arg_relInfo: *mut ResultRelInfo,
            ) -> *mut TupleTableSlot;
        }
        ExecGetTriggerOldSlot(arg_estate, arg_relInfo)
    })
}
pub unsafe fn ExecGetTriggerNewSlot(
    arg_estate: *mut EState,
    arg_relInfo: *mut ResultRelInfo,
) -> *mut TupleTableSlot {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecGetTriggerNewSlot(
                arg_estate: *mut EState,
                arg_relInfo: *mut ResultRelInfo,
            ) -> *mut TupleTableSlot;
        }
        ExecGetTriggerNewSlot(arg_estate, arg_relInfo)
    })
}
pub unsafe fn ExecGetReturningSlot(
    arg_estate: *mut EState,
    arg_relInfo: *mut ResultRelInfo,
) -> *mut TupleTableSlot {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecGetReturningSlot(
                arg_estate: *mut EState,
                arg_relInfo: *mut ResultRelInfo,
            ) -> *mut TupleTableSlot;
        }
        ExecGetReturningSlot(arg_estate, arg_relInfo)
    })
}
pub unsafe fn ExecGetInsertedCols(
    arg_relinfo: *mut ResultRelInfo,
    arg_estate: *mut EState,
) -> *mut Bitmapset {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecGetInsertedCols(
                arg_relinfo: *mut ResultRelInfo,
                arg_estate: *mut EState,
            ) -> *mut Bitmapset;
        }
        ExecGetInsertedCols(arg_relinfo, arg_estate)
    })
}
pub unsafe fn ExecGetUpdatedCols(
    arg_relinfo: *mut ResultRelInfo,
    arg_estate: *mut EState,
) -> *mut Bitmapset {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecGetUpdatedCols(
                arg_relinfo: *mut ResultRelInfo,
                arg_estate: *mut EState,
            ) -> *mut Bitmapset;
        }
        ExecGetUpdatedCols(arg_relinfo, arg_estate)
    })
}
pub unsafe fn ExecGetExtraUpdatedCols(
    arg_relinfo: *mut ResultRelInfo,
    arg_estate: *mut EState,
) -> *mut Bitmapset {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecGetExtraUpdatedCols(
                arg_relinfo: *mut ResultRelInfo,
                arg_estate: *mut EState,
            ) -> *mut Bitmapset;
        }
        ExecGetExtraUpdatedCols(arg_relinfo, arg_estate)
    })
}
pub unsafe fn ExecGetAllUpdatedCols(
    arg_relinfo: *mut ResultRelInfo,
    arg_estate: *mut EState,
) -> *mut Bitmapset {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecGetAllUpdatedCols(
                arg_relinfo: *mut ResultRelInfo,
                arg_estate: *mut EState,
            ) -> *mut Bitmapset;
        }
        ExecGetAllUpdatedCols(arg_relinfo, arg_estate)
    })
}
pub unsafe fn ExecOpenIndices(arg_resultRelInfo: *mut ResultRelInfo, arg_speculative: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecOpenIndices(arg_resultRelInfo: *mut ResultRelInfo, arg_speculative: bool);
        }
        ExecOpenIndices(arg_resultRelInfo, arg_speculative)
    })
}
pub unsafe fn ExecCloseIndices(arg_resultRelInfo: *mut ResultRelInfo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecCloseIndices(arg_resultRelInfo: *mut ResultRelInfo);
        }
        ExecCloseIndices(arg_resultRelInfo)
    })
}
pub unsafe fn ExecInsertIndexTuples(
    arg_slot: *mut TupleTableSlot,
    arg_estate: *mut EState,
    arg_noDupErr: bool,
    arg_specConflict: *mut bool,
    arg_arbiterIndexes: *mut List,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecInsertIndexTuples(
                arg_slot: *mut TupleTableSlot,
                arg_estate: *mut EState,
                arg_noDupErr: bool,
                arg_specConflict: *mut bool,
                arg_arbiterIndexes: *mut List,
            ) -> *mut List;
        }
        ExecInsertIndexTuples(
            arg_slot,
            arg_estate,
            arg_noDupErr,
            arg_specConflict,
            arg_arbiterIndexes,
        )
    })
}
pub unsafe fn ExecCheckIndexConstraints(
    arg_slot: *mut TupleTableSlot,
    arg_estate: *mut EState,
    arg_conflictTid: ItemPointer,
    arg_arbiterIndexes: *mut List,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecCheckIndexConstraints(
                arg_slot: *mut TupleTableSlot,
                arg_estate: *mut EState,
                arg_conflictTid: ItemPointer,
                arg_arbiterIndexes: *mut List,
            ) -> bool;
        }
        ExecCheckIndexConstraints(arg_slot, arg_estate, arg_conflictTid, arg_arbiterIndexes)
    })
}
pub unsafe fn check_exclusion_constraint(
    arg_heap: Relation,
    arg_index: Relation,
    arg_indexInfo: *mut IndexInfo,
    arg_tupleid: ItemPointer,
    arg_values: *mut Datum,
    arg_isnull: *mut bool,
    arg_estate: *mut EState,
    arg_newIndex: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn check_exclusion_constraint(
                arg_heap: Relation,
                arg_index: Relation,
                arg_indexInfo: *mut IndexInfo,
                arg_tupleid: ItemPointer,
                arg_values: *mut Datum,
                arg_isnull: *mut bool,
                arg_estate: *mut EState,
                arg_newIndex: bool,
            );
        }
        check_exclusion_constraint(
            arg_heap,
            arg_index,
            arg_indexInfo,
            arg_tupleid,
            arg_values,
            arg_isnull,
            arg_estate,
            arg_newIndex,
        )
    })
}
pub unsafe fn RelationFindReplTupleByIndex(
    arg_rel: Relation,
    arg_idxoid: Oid,
    arg_lockmode: LockTupleMode,
    arg_searchslot: *mut TupleTableSlot,
    arg_outslot: *mut TupleTableSlot,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationFindReplTupleByIndex(
                arg_rel: Relation,
                arg_idxoid: Oid,
                arg_lockmode: LockTupleMode,
                arg_searchslot: *mut TupleTableSlot,
                arg_outslot: *mut TupleTableSlot,
            ) -> bool;
        }
        RelationFindReplTupleByIndex(arg_rel, arg_idxoid, arg_lockmode, arg_searchslot, arg_outslot)
    })
}
pub unsafe fn RelationFindReplTupleSeq(
    arg_rel: Relation,
    arg_lockmode: LockTupleMode,
    arg_searchslot: *mut TupleTableSlot,
    arg_outslot: *mut TupleTableSlot,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationFindReplTupleSeq(
                arg_rel: Relation,
                arg_lockmode: LockTupleMode,
                arg_searchslot: *mut TupleTableSlot,
                arg_outslot: *mut TupleTableSlot,
            ) -> bool;
        }
        RelationFindReplTupleSeq(arg_rel, arg_lockmode, arg_searchslot, arg_outslot)
    })
}
pub unsafe fn ExecSimpleRelationInsert(arg_estate: *mut EState, arg_slot: *mut TupleTableSlot) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecSimpleRelationInsert(arg_estate: *mut EState, arg_slot: *mut TupleTableSlot);
        }
        ExecSimpleRelationInsert(arg_estate, arg_slot)
    })
}
pub unsafe fn ExecSimpleRelationUpdate(
    arg_estate: *mut EState,
    arg_epqstate: *mut EPQState,
    arg_searchslot: *mut TupleTableSlot,
    arg_slot: *mut TupleTableSlot,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecSimpleRelationUpdate(
                arg_estate: *mut EState,
                arg_epqstate: *mut EPQState,
                arg_searchslot: *mut TupleTableSlot,
                arg_slot: *mut TupleTableSlot,
            );
        }
        ExecSimpleRelationUpdate(arg_estate, arg_epqstate, arg_searchslot, arg_slot)
    })
}
pub unsafe fn ExecSimpleRelationDelete(
    arg_estate: *mut EState,
    arg_epqstate: *mut EPQState,
    arg_searchslot: *mut TupleTableSlot,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecSimpleRelationDelete(
                arg_estate: *mut EState,
                arg_epqstate: *mut EPQState,
                arg_searchslot: *mut TupleTableSlot,
            );
        }
        ExecSimpleRelationDelete(arg_estate, arg_epqstate, arg_searchslot)
    })
}
pub unsafe fn CheckCmdReplicaIdentity(arg_rel: Relation, arg_cmd: CmdType) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CheckCmdReplicaIdentity(arg_rel: Relation, arg_cmd: CmdType);
        }
        CheckCmdReplicaIdentity(arg_rel, arg_cmd)
    })
}
pub unsafe fn CheckSubscriptionRelkind(
    arg_relkind: ::std::os::raw::c_char,
    arg_nspname: *const ::std::os::raw::c_char,
    arg_relname: *const ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CheckSubscriptionRelkind(
                arg_relkind: ::std::os::raw::c_char,
                arg_nspname: *const ::std::os::raw::c_char,
                arg_relname: *const ::std::os::raw::c_char,
            );
        }
        CheckSubscriptionRelkind(arg_relkind, arg_nspname, arg_relname)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AttInMetadata {
    pub tupdesc: TupleDesc,
    pub attinfuncs: *mut FmgrInfo,
    pub attioparams: *mut Oid,
    pub atttypmods: *mut int32,
}
impl Default for AttInMetadata {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuncCallContext {
    pub call_cntr: uint64,
    pub max_calls: uint64,
    pub user_fctx: *mut ::std::os::raw::c_void,
    pub attinmeta: *mut AttInMetadata,
    pub multi_call_memory_ctx: MemoryContext,
    pub tuple_desc: TupleDesc,
}
impl Default for FuncCallContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const TypeFuncClass_TYPEFUNC_SCALAR: TypeFuncClass = 0;
pub const TypeFuncClass_TYPEFUNC_COMPOSITE: TypeFuncClass = 1;
pub const TypeFuncClass_TYPEFUNC_COMPOSITE_DOMAIN: TypeFuncClass = 2;
pub const TypeFuncClass_TYPEFUNC_RECORD: TypeFuncClass = 3;
pub const TypeFuncClass_TYPEFUNC_OTHER: TypeFuncClass = 4;
pub type TypeFuncClass = ::std::os::raw::c_uint;
pub unsafe fn get_call_result_type(
    arg_fcinfo: FunctionCallInfo,
    arg_resultTypeId: *mut Oid,
    arg_resultTupleDesc: *mut TupleDesc,
) -> TypeFuncClass {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_call_result_type(
                arg_fcinfo: FunctionCallInfo,
                arg_resultTypeId: *mut Oid,
                arg_resultTupleDesc: *mut TupleDesc,
            ) -> TypeFuncClass;
        }
        get_call_result_type(arg_fcinfo, arg_resultTypeId, arg_resultTupleDesc)
    })
}
pub unsafe fn get_expr_result_type(
    arg_expr: *mut Node,
    arg_resultTypeId: *mut Oid,
    arg_resultTupleDesc: *mut TupleDesc,
) -> TypeFuncClass {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_expr_result_type(
                arg_expr: *mut Node,
                arg_resultTypeId: *mut Oid,
                arg_resultTupleDesc: *mut TupleDesc,
            ) -> TypeFuncClass;
        }
        get_expr_result_type(arg_expr, arg_resultTypeId, arg_resultTupleDesc)
    })
}
pub unsafe fn get_func_result_type(
    arg_functionId: Oid,
    arg_resultTypeId: *mut Oid,
    arg_resultTupleDesc: *mut TupleDesc,
) -> TypeFuncClass {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_func_result_type(
                arg_functionId: Oid,
                arg_resultTypeId: *mut Oid,
                arg_resultTupleDesc: *mut TupleDesc,
            ) -> TypeFuncClass;
        }
        get_func_result_type(arg_functionId, arg_resultTypeId, arg_resultTupleDesc)
    })
}
pub unsafe fn get_expr_result_tupdesc(arg_expr: *mut Node, arg_noError: bool) -> TupleDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_expr_result_tupdesc(arg_expr: *mut Node, arg_noError: bool) -> TupleDesc;
        }
        get_expr_result_tupdesc(arg_expr, arg_noError)
    })
}
pub unsafe fn resolve_polymorphic_argtypes(
    arg_numargs: ::std::os::raw::c_int,
    arg_argtypes: *mut Oid,
    arg_argmodes: *mut ::std::os::raw::c_char,
    arg_call_expr: *mut Node,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn resolve_polymorphic_argtypes(
                arg_numargs: ::std::os::raw::c_int,
                arg_argtypes: *mut Oid,
                arg_argmodes: *mut ::std::os::raw::c_char,
                arg_call_expr: *mut Node,
            ) -> bool;
        }
        resolve_polymorphic_argtypes(arg_numargs, arg_argtypes, arg_argmodes, arg_call_expr)
    })
}
pub unsafe fn get_func_arg_info(
    arg_procTup: HeapTuple,
    arg_p_argtypes: *mut *mut Oid,
    arg_p_argnames: *mut *mut *mut ::std::os::raw::c_char,
    arg_p_argmodes: *mut *mut ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_func_arg_info(
                arg_procTup: HeapTuple,
                arg_p_argtypes: *mut *mut Oid,
                arg_p_argnames: *mut *mut *mut ::std::os::raw::c_char,
                arg_p_argmodes: *mut *mut ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        get_func_arg_info(arg_procTup, arg_p_argtypes, arg_p_argnames, arg_p_argmodes)
    })
}
pub unsafe fn get_func_input_arg_names(
    arg_proargnames: Datum,
    arg_proargmodes: Datum,
    arg_arg_names: *mut *mut *mut ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_func_input_arg_names(
                arg_proargnames: Datum,
                arg_proargmodes: Datum,
                arg_arg_names: *mut *mut *mut ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        get_func_input_arg_names(arg_proargnames, arg_proargmodes, arg_arg_names)
    })
}
pub unsafe fn get_func_trftypes(
    arg_procTup: HeapTuple,
    arg_p_trftypes: *mut *mut Oid,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_func_trftypes(
                arg_procTup: HeapTuple,
                arg_p_trftypes: *mut *mut Oid,
            ) -> ::std::os::raw::c_int;
        }
        get_func_trftypes(arg_procTup, arg_p_trftypes)
    })
}
pub unsafe fn get_func_result_name(arg_functionId: Oid) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_func_result_name(arg_functionId: Oid) -> *mut ::std::os::raw::c_char;
        }
        get_func_result_name(arg_functionId)
    })
}
pub unsafe fn build_function_result_tupdesc_d(
    arg_prokind: ::std::os::raw::c_char,
    arg_proallargtypes: Datum,
    arg_proargmodes: Datum,
    arg_proargnames: Datum,
) -> TupleDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn build_function_result_tupdesc_d(
                arg_prokind: ::std::os::raw::c_char,
                arg_proallargtypes: Datum,
                arg_proargmodes: Datum,
                arg_proargnames: Datum,
            ) -> TupleDesc;
        }
        build_function_result_tupdesc_d(
            arg_prokind,
            arg_proallargtypes,
            arg_proargmodes,
            arg_proargnames,
        )
    })
}
pub unsafe fn build_function_result_tupdesc_t(arg_procTuple: HeapTuple) -> TupleDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn build_function_result_tupdesc_t(arg_procTuple: HeapTuple) -> TupleDesc;
        }
        build_function_result_tupdesc_t(arg_procTuple)
    })
}
pub unsafe fn RelationNameGetTupleDesc(arg_relname: *const ::std::os::raw::c_char) -> TupleDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationNameGetTupleDesc(arg_relname: *const ::std::os::raw::c_char) -> TupleDesc;
        }
        RelationNameGetTupleDesc(arg_relname)
    })
}
pub unsafe fn TypeGetTupleDesc(arg_typeoid: Oid, arg_colaliases: *mut List) -> TupleDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TypeGetTupleDesc(arg_typeoid: Oid, arg_colaliases: *mut List) -> TupleDesc;
        }
        TypeGetTupleDesc(arg_typeoid, arg_colaliases)
    })
}
pub unsafe fn BlessTupleDesc(arg_tupdesc: TupleDesc) -> TupleDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BlessTupleDesc(arg_tupdesc: TupleDesc) -> TupleDesc;
        }
        BlessTupleDesc(arg_tupdesc)
    })
}
pub unsafe fn TupleDescGetAttInMetadata(arg_tupdesc: TupleDesc) -> *mut AttInMetadata {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TupleDescGetAttInMetadata(arg_tupdesc: TupleDesc) -> *mut AttInMetadata;
        }
        TupleDescGetAttInMetadata(arg_tupdesc)
    })
}
pub unsafe fn BuildTupleFromCStrings(
    arg_attinmeta: *mut AttInMetadata,
    arg_values: *mut *mut ::std::os::raw::c_char,
) -> HeapTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BuildTupleFromCStrings(
                arg_attinmeta: *mut AttInMetadata,
                arg_values: *mut *mut ::std::os::raw::c_char,
            ) -> HeapTuple;
        }
        BuildTupleFromCStrings(arg_attinmeta, arg_values)
    })
}
pub unsafe fn HeapTupleHeaderGetDatum(arg_tuple: HeapTupleHeader) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn HeapTupleHeaderGetDatum(arg_tuple: HeapTupleHeader) -> Datum;
        }
        HeapTupleHeaderGetDatum(arg_tuple)
    })
}
pub unsafe fn init_MultiFuncCall(arg_fcinfo: FunctionCallInfo) -> *mut FuncCallContext {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn init_MultiFuncCall(arg_fcinfo: FunctionCallInfo) -> *mut FuncCallContext;
        }
        init_MultiFuncCall(arg_fcinfo)
    })
}
pub unsafe fn per_MultiFuncCall(arg_fcinfo: FunctionCallInfo) -> *mut FuncCallContext {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn per_MultiFuncCall(arg_fcinfo: FunctionCallInfo) -> *mut FuncCallContext;
        }
        per_MultiFuncCall(arg_fcinfo)
    })
}
pub unsafe fn end_MultiFuncCall(arg_fcinfo: FunctionCallInfo, arg_funcctx: *mut FuncCallContext) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn end_MultiFuncCall(arg_fcinfo: FunctionCallInfo, arg_funcctx: *mut FuncCallContext);
        }
        end_MultiFuncCall(arg_fcinfo, arg_funcctx)
    })
}
pub unsafe fn extract_variadic_args(
    arg_fcinfo: FunctionCallInfo,
    arg_variadic_start: ::std::os::raw::c_int,
    arg_convert_unknown: bool,
    arg_values: *mut *mut Datum,
    arg_types: *mut *mut Oid,
    arg_nulls: *mut *mut bool,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn extract_variadic_args(
                arg_fcinfo: FunctionCallInfo,
                arg_variadic_start: ::std::os::raw::c_int,
                arg_convert_unknown: bool,
                arg_values: *mut *mut Datum,
                arg_types: *mut *mut Oid,
                arg_nulls: *mut *mut bool,
            ) -> ::std::os::raw::c_int;
        }
        extract_variadic_args(
            arg_fcinfo,
            arg_variadic_start,
            arg_convert_unknown,
            arg_values,
            arg_types,
            arg_nulls,
        )
    })
}
extern "C" {
    pub static sys_signame: [*const ::std::os::raw::c_char; 32usize];
}
extern "C" {
    pub static sys_siglist: [*const ::std::os::raw::c_char; 32usize];
}
pub unsafe fn raise(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn raise(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        raise(arg_arg1)
    })
}
pub unsafe fn bsd_signal(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
) -> ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ),
> {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bsd_signal(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
            ) -> ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: ::std::os::raw::c_int,
                    arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
                ),
            >;
        }
        bsd_signal(arg_arg1, arg_arg2)
    })
}
pub unsafe fn kill(arg_arg1: pid_t, arg_arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn kill(arg_arg1: pid_t, arg_arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        kill(arg_arg1, arg_arg2)
    })
}
pub unsafe fn killpg(arg_arg1: pid_t, arg_arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn killpg(arg_arg1: pid_t, arg_arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        killpg(arg_arg1, arg_arg2)
    })
}
pub unsafe fn pthread_kill(
    arg_arg1: pthread_t,
    arg_arg2: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pthread_kill(
                arg_arg1: pthread_t,
                arg_arg2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        pthread_kill(arg_arg1, arg_arg2)
    })
}
pub unsafe fn pthread_sigmask(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: *const sigset_t,
    arg_arg3: *mut sigset_t,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pthread_sigmask(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: *const sigset_t,
                arg_arg3: *mut sigset_t,
            ) -> ::std::os::raw::c_int;
        }
        pthread_sigmask(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn sigaction(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: *const sigaction,
    arg_arg3: *mut sigaction,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sigaction(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: *const sigaction,
                arg_arg3: *mut sigaction,
            ) -> ::std::os::raw::c_int;
        }
        sigaction(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn sigaddset(
    arg_arg1: *mut sigset_t,
    arg_arg2: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sigaddset(
                arg_arg1: *mut sigset_t,
                arg_arg2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        sigaddset(arg_arg1, arg_arg2)
    })
}
pub unsafe fn sigaltstack(
    arg_arg1: *const stack_t,
    arg_arg2: *mut stack_t,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sigaltstack(
                arg_arg1: *const stack_t,
                arg_arg2: *mut stack_t,
            ) -> ::std::os::raw::c_int;
        }
        sigaltstack(arg_arg1, arg_arg2)
    })
}
pub unsafe fn sigdelset(
    arg_arg1: *mut sigset_t,
    arg_arg2: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sigdelset(
                arg_arg1: *mut sigset_t,
                arg_arg2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        sigdelset(arg_arg1, arg_arg2)
    })
}
pub unsafe fn sigemptyset(arg_arg1: *mut sigset_t) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sigemptyset(arg_arg1: *mut sigset_t) -> ::std::os::raw::c_int;
        }
        sigemptyset(arg_arg1)
    })
}
pub unsafe fn sigfillset(arg_arg1: *mut sigset_t) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sigfillset(arg_arg1: *mut sigset_t) -> ::std::os::raw::c_int;
        }
        sigfillset(arg_arg1)
    })
}
pub unsafe fn sighold(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sighold(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        sighold(arg_arg1)
    })
}
pub unsafe fn sigignore(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sigignore(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        sigignore(arg_arg1)
    })
}
pub unsafe fn siginterrupt(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn siginterrupt(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        siginterrupt(arg_arg1, arg_arg2)
    })
}
pub unsafe fn sigismember(
    arg_arg1: *const sigset_t,
    arg_arg2: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sigismember(
                arg_arg1: *const sigset_t,
                arg_arg2: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        sigismember(arg_arg1, arg_arg2)
    })
}
pub unsafe fn sigpause(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sigpause(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        sigpause(arg_arg1)
    })
}
pub unsafe fn sigpending(arg_arg1: *mut sigset_t) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sigpending(arg_arg1: *mut sigset_t) -> ::std::os::raw::c_int;
        }
        sigpending(arg_arg1)
    })
}
pub unsafe fn sigprocmask(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: *const sigset_t,
    arg_arg3: *mut sigset_t,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sigprocmask(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: *const sigset_t,
                arg_arg3: *mut sigset_t,
            ) -> ::std::os::raw::c_int;
        }
        sigprocmask(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub unsafe fn sigrelse(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sigrelse(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        sigrelse(arg_arg1)
    })
}
pub unsafe fn sigset(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
) -> ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ),
> {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sigset(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
            ) -> ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: ::std::os::raw::c_int,
                    arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
                ),
            >;
        }
        sigset(arg_arg1, arg_arg2)
    })
}
pub unsafe fn sigsuspend(arg_arg1: *const sigset_t) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sigsuspend(arg_arg1: *const sigset_t) -> ::std::os::raw::c_int;
        }
        sigsuspend(arg_arg1)
    })
}
pub unsafe fn sigwait(
    arg_arg1: *const sigset_t,
    arg_arg2: *mut ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sigwait(
                arg_arg1: *const sigset_t,
                arg_arg2: *mut ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        sigwait(arg_arg1, arg_arg2)
    })
}
pub unsafe fn psignal(arg_arg1: ::std::os::raw::c_uint, arg_arg2: *const ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn psignal(arg_arg1: ::std::os::raw::c_uint, arg_arg2: *const ::std::os::raw::c_char);
        }
        psignal(arg_arg1, arg_arg2)
    })
}
pub unsafe fn sigblock(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sigblock(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        sigblock(arg_arg1)
    })
}
pub unsafe fn sigsetmask(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sigsetmask(arg_arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        sigsetmask(arg_arg1)
    })
}
pub unsafe fn sigvec(
    arg_arg1: ::std::os::raw::c_int,
    arg_arg2: *mut sigvec,
    arg_arg3: *mut sigvec,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sigvec(
                arg_arg1: ::std::os::raw::c_int,
                arg_arg2: *mut sigvec,
                arg_arg3: *mut sigvec,
            ) -> ::std::os::raw::c_int;
        }
        sigvec(arg_arg1, arg_arg2, arg_arg3)
    })
}
pub type pg_time_t = int64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pg_tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
impl Default for pg_tm {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pg_tz {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pg_tzenum {
    _unused: [u8; 0],
}
pub unsafe fn pg_localtime(arg_timep: *const pg_time_t, arg_tz: *const pg_tz) -> *mut pg_tm {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_localtime(arg_timep: *const pg_time_t, arg_tz: *const pg_tz) -> *mut pg_tm;
        }
        pg_localtime(arg_timep, arg_tz)
    })
}
pub unsafe fn pg_gmtime(arg_timep: *const pg_time_t) -> *mut pg_tm {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_gmtime(arg_timep: *const pg_time_t) -> *mut pg_tm;
        }
        pg_gmtime(arg_timep)
    })
}
pub unsafe fn pg_next_dst_boundary(
    arg_timep: *const pg_time_t,
    arg_before_gmtoff: *mut ::std::os::raw::c_long,
    arg_before_isdst: *mut ::std::os::raw::c_int,
    arg_boundary: *mut pg_time_t,
    arg_after_gmtoff: *mut ::std::os::raw::c_long,
    arg_after_isdst: *mut ::std::os::raw::c_int,
    arg_tz: *const pg_tz,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_next_dst_boundary(
                arg_timep: *const pg_time_t,
                arg_before_gmtoff: *mut ::std::os::raw::c_long,
                arg_before_isdst: *mut ::std::os::raw::c_int,
                arg_boundary: *mut pg_time_t,
                arg_after_gmtoff: *mut ::std::os::raw::c_long,
                arg_after_isdst: *mut ::std::os::raw::c_int,
                arg_tz: *const pg_tz,
            ) -> ::std::os::raw::c_int;
        }
        pg_next_dst_boundary(
            arg_timep,
            arg_before_gmtoff,
            arg_before_isdst,
            arg_boundary,
            arg_after_gmtoff,
            arg_after_isdst,
            arg_tz,
        )
    })
}
pub unsafe fn pg_interpret_timezone_abbrev(
    arg_abbrev: *const ::std::os::raw::c_char,
    arg_timep: *const pg_time_t,
    arg_gmtoff: *mut ::std::os::raw::c_long,
    arg_isdst: *mut ::std::os::raw::c_int,
    arg_tz: *const pg_tz,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_interpret_timezone_abbrev(
                arg_abbrev: *const ::std::os::raw::c_char,
                arg_timep: *const pg_time_t,
                arg_gmtoff: *mut ::std::os::raw::c_long,
                arg_isdst: *mut ::std::os::raw::c_int,
                arg_tz: *const pg_tz,
            ) -> bool;
        }
        pg_interpret_timezone_abbrev(arg_abbrev, arg_timep, arg_gmtoff, arg_isdst, arg_tz)
    })
}
pub unsafe fn pg_get_timezone_offset(
    arg_tz: *const pg_tz,
    arg_gmtoff: *mut ::std::os::raw::c_long,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_timezone_offset(
                arg_tz: *const pg_tz,
                arg_gmtoff: *mut ::std::os::raw::c_long,
            ) -> bool;
        }
        pg_get_timezone_offset(arg_tz, arg_gmtoff)
    })
}
pub unsafe fn pg_get_timezone_name(arg_tz: *mut pg_tz) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_timezone_name(arg_tz: *mut pg_tz) -> *const ::std::os::raw::c_char;
        }
        pg_get_timezone_name(arg_tz)
    })
}
pub unsafe fn pg_tz_acceptable(arg_tz: *mut pg_tz) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_tz_acceptable(arg_tz: *mut pg_tz) -> bool;
        }
        pg_tz_acceptable(arg_tz)
    })
}
pub unsafe fn pg_strftime(
    arg_s: *mut ::std::os::raw::c_char,
    arg_max: usize,
    arg_format: *const ::std::os::raw::c_char,
    arg_tm: *const pg_tm,
) -> usize {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_strftime(
                arg_s: *mut ::std::os::raw::c_char,
                arg_max: usize,
                arg_format: *const ::std::os::raw::c_char,
                arg_tm: *const pg_tm,
            ) -> usize;
        }
        pg_strftime(arg_s, arg_max, arg_format, arg_tm)
    })
}
extern "C" {
    pub static mut session_timezone: *mut pg_tz;
}
extern "C" {
    pub static mut log_timezone: *mut pg_tz;
}
pub unsafe fn pg_timezone_initialize() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_timezone_initialize();
        }
        pg_timezone_initialize()
    })
}
pub unsafe fn pg_tzset(arg_tzname: *const ::std::os::raw::c_char) -> *mut pg_tz {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_tzset(arg_tzname: *const ::std::os::raw::c_char) -> *mut pg_tz;
        }
        pg_tzset(arg_tzname)
    })
}
pub unsafe fn pg_tzset_offset(arg_gmtoffset: ::std::os::raw::c_long) -> *mut pg_tz {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_tzset_offset(arg_gmtoffset: ::std::os::raw::c_long) -> *mut pg_tz;
        }
        pg_tzset_offset(arg_gmtoffset)
    })
}
pub unsafe fn pg_tzenumerate_start() -> *mut pg_tzenum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_tzenumerate_start() -> *mut pg_tzenum;
        }
        pg_tzenumerate_start()
    })
}
pub unsafe fn pg_tzenumerate_next(arg_dir: *mut pg_tzenum) -> *mut pg_tz {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_tzenumerate_next(arg_dir: *mut pg_tzenum) -> *mut pg_tz;
        }
        pg_tzenumerate_next(arg_dir)
    })
}
pub unsafe fn pg_tzenumerate_end(arg_dir: *mut pg_tzenum) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_tzenumerate_end(arg_dir: *mut pg_tzenum);
        }
        pg_tzenumerate_end(arg_dir)
    })
}
extern "C" {
    #[doc = "\t  System interrupt and critical section handling"]
    #[doc = ""]
    #[doc = " There are two types of interrupts that a running backend needs to accept"]
    #[doc = " without messing up its state: QueryCancel (SIGINT) and ProcDie (SIGTERM)."]
    #[doc = " In both cases, we need to be able to clean up the current transaction"]
    #[doc = " gracefully, so we can't respond to the interrupt instantaneously ---"]
    #[doc = " there's no guarantee that internal data structures would be self-consistent"]
    #[doc = " if the code is interrupted at an arbitrary instant.  Instead, the signal"]
    #[doc = " handlers set flags that are checked periodically during execution."]
    #[doc = ""]
    #[doc = " The CHECK_FOR_INTERRUPTS() macro is called at strategically located spots"]
    #[doc = " where it is normally safe to accept a cancel or die interrupt.  In some"]
    #[doc = " cases, we invoke CHECK_FOR_INTERRUPTS() inside low-level subroutines that"]
    #[doc = " might sometimes be called in contexts that do *not* want to allow a cancel"]
    #[doc = " or die interrupt.  The HOLD_INTERRUPTS() and RESUME_INTERRUPTS() macros"]
    #[doc = " allow code to ensure that no cancel or die interrupt will be accepted,"]
    #[doc = " even if CHECK_FOR_INTERRUPTS() gets called in a subroutine.  The interrupt"]
    #[doc = " will be held off until CHECK_FOR_INTERRUPTS() is done outside any"]
    #[doc = " HOLD_INTERRUPTS() ... RESUME_INTERRUPTS() section."]
    #[doc = ""]
    #[doc = " There is also a mechanism to prevent query cancel interrupts, while still"]
    #[doc = " allowing die interrupts: HOLD_CANCEL_INTERRUPTS() and"]
    #[doc = " RESUME_CANCEL_INTERRUPTS()."]
    #[doc = ""]
    #[doc = " Note that ProcessInterrupts() has also acquired a number of tasks that"]
    #[doc = " do not necessarily cause a query-cancel-or-die response.  Hence, it's"]
    #[doc = " possible that it will just clear InterruptPending and return."]
    #[doc = ""]
    #[doc = " INTERRUPTS_PENDING_CONDITION() can be checked to see whether an"]
    #[doc = " interrupt needs to be serviced, without trying to do so immediately."]
    #[doc = " Some callers are also interested in INTERRUPTS_CAN_BE_PROCESSED(),"]
    #[doc = " which tells whether ProcessInterrupts is sure to clear the interrupt."]
    #[doc = ""]
    #[doc = " Special mechanisms are used to let an interrupt be accepted when we are"]
    #[doc = " waiting for a lock or when we are waiting for command input (but, of"]
    #[doc = " course, only if the interrupt holdoff counter is zero).  See the"]
    #[doc = " related code for details."]
    #[doc = ""]
    #[doc = " A lost connection is handled similarly, although the loss of connection"]
    #[doc = " does not raise a signal, but is detected when we fail to write to the"]
    #[doc = " socket. If there was a signal for a broken connection, we could make use of"]
    #[doc = " it by setting ClientConnectionLost in the signal handler."]
    #[doc = ""]
    #[doc = " A related, but conceptually distinct, mechanism is the \"critical section\""]
    #[doc = " mechanism.  A critical section not only holds off cancel/die interrupts,"]
    #[doc = " but causes any ereport(ERROR) or ereport(FATAL) to become ereport(PANIC)"]
    #[doc = " --- that is, a system-wide reset is forced.  Needless to say, only really"]
    #[doc = " *critical* code should be marked as a critical section!\tCurrently, this"]
    #[doc = " mechanism is only used for XLOG-related code."]
    #[doc = ""]
    pub static mut InterruptPending: sig_atomic_t;
}
extern "C" {
    pub static mut QueryCancelPending: sig_atomic_t;
}
extern "C" {
    pub static mut ProcDiePending: sig_atomic_t;
}
extern "C" {
    pub static mut IdleInTransactionSessionTimeoutPending: sig_atomic_t;
}
extern "C" {
    pub static mut ProcSignalBarrierPending: sig_atomic_t;
}
extern "C" {
    pub static mut ClientConnectionLost: sig_atomic_t;
}
extern "C" {
    pub static mut InterruptHoldoffCount: uint32;
}
extern "C" {
    pub static mut QueryCancelHoldoffCount: uint32;
}
extern "C" {
    pub static mut CritSectionCount: uint32;
}
pub unsafe fn ProcessInterrupts() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcessInterrupts();
        }
        ProcessInterrupts()
    })
}
extern "C" {
    #[doc = "\t  globals.h --\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t *"]
    pub static mut PostmasterPid: pid_t;
}
extern "C" {
    pub static mut IsPostmasterEnvironment: bool;
}
extern "C" {
    pub static mut IsUnderPostmaster: bool;
}
extern "C" {
    pub static mut IsBackgroundWorker: bool;
}
extern "C" {
    pub static mut IsBinaryUpgrade: bool;
}
extern "C" {
    pub static mut ExitOnAnyError: bool;
}
extern "C" {
    pub static mut DataDir: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut data_directory_mode: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut NBuffers: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut MaxBackends: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut MaxConnections: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut max_worker_processes: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut max_parallel_workers: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut MyProcPid: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut MyStartTime: pg_time_t;
}
extern "C" {
    pub static mut MyStartTimestamp: TimestampTz;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Port {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut MyProcPort: *mut Port;
}
extern "C" {
    pub static mut MyLatch: *mut Latch;
}
extern "C" {
    pub static mut MyCancelKey: int32;
}
extern "C" {
    pub static mut MyPMChildSlot: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut OutputFileName: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut my_exec_path: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut pkglib_path: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut MyDatabaseId: Oid;
}
extern "C" {
    pub static mut MyDatabaseTableSpace: Oid;
}
extern "C" {
    pub static mut DateStyle: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut DateOrder: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut IntervalStyle: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut enableFsync: bool;
}
extern "C" {
    pub static mut allowSystemTableMods: bool;
}
extern "C" {
    pub static mut work_mem: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut hash_mem_multiplier: f64;
}
extern "C" {
    pub static mut maintenance_work_mem: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut max_parallel_maintenance_workers: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut VacuumCostPageHit: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut VacuumCostPageMiss: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut VacuumCostPageDirty: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut VacuumCostLimit: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut VacuumCostDelay: f64;
}
extern "C" {
    pub static mut VacuumPageHit: int64;
}
extern "C" {
    pub static mut VacuumPageMiss: int64;
}
extern "C" {
    pub static mut VacuumPageDirty: int64;
}
extern "C" {
    pub static mut VacuumCostBalance: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut VacuumCostActive: bool;
}
extern "C" {
    pub static mut vacuum_cleanup_index_scale_factor: f64;
}
pub type pg_stack_base_t = *mut ::std::os::raw::c_char;
pub unsafe fn set_stack_base() -> pg_stack_base_t {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn set_stack_base() -> pg_stack_base_t;
        }
        set_stack_base()
    })
}
pub unsafe fn restore_stack_base(arg_base: pg_stack_base_t) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn restore_stack_base(arg_base: pg_stack_base_t);
        }
        restore_stack_base(arg_base)
    })
}
pub unsafe fn check_stack_depth() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn check_stack_depth();
        }
        check_stack_depth()
    })
}
pub unsafe fn stack_is_too_deep() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn stack_is_too_deep() -> bool;
        }
        stack_is_too_deep()
    })
}
pub unsafe fn PreventCommandIfReadOnly(arg_cmdname: *const ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PreventCommandIfReadOnly(arg_cmdname: *const ::std::os::raw::c_char);
        }
        PreventCommandIfReadOnly(arg_cmdname)
    })
}
pub unsafe fn PreventCommandIfParallelMode(arg_cmdname: *const ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PreventCommandIfParallelMode(arg_cmdname: *const ::std::os::raw::c_char);
        }
        PreventCommandIfParallelMode(arg_cmdname)
    })
}
pub unsafe fn PreventCommandDuringRecovery(arg_cmdname: *const ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PreventCommandDuringRecovery(arg_cmdname: *const ::std::os::raw::c_char);
        }
        PreventCommandDuringRecovery(arg_cmdname)
    })
}
extern "C" {
    pub static mut trace_recovery_messages: ::std::os::raw::c_int;
}
pub unsafe fn trace_recovery(arg_trace_level: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn trace_recovery(arg_trace_level: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        trace_recovery(arg_trace_level)
    })
}
extern "C" {
    pub static mut DatabasePath: *mut ::std::os::raw::c_char;
}
pub unsafe fn InitPostmasterChild() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitPostmasterChild();
        }
        InitPostmasterChild()
    })
}
pub unsafe fn InitStandaloneProcess(arg_argv0: *const ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitStandaloneProcess(arg_argv0: *const ::std::os::raw::c_char);
        }
        InitStandaloneProcess(arg_argv0)
    })
}
pub unsafe fn SwitchToSharedLatch() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SwitchToSharedLatch();
        }
        SwitchToSharedLatch()
    })
}
pub unsafe fn SwitchBackToLocalLatch() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SwitchBackToLocalLatch();
        }
        SwitchBackToLocalLatch()
    })
}
pub const BackendType_B_INVALID: BackendType = 0;
pub const BackendType_B_AUTOVAC_LAUNCHER: BackendType = 1;
pub const BackendType_B_AUTOVAC_WORKER: BackendType = 2;
pub const BackendType_B_BACKEND: BackendType = 3;
pub const BackendType_B_BG_WORKER: BackendType = 4;
pub const BackendType_B_BG_WRITER: BackendType = 5;
pub const BackendType_B_CHECKPOINTER: BackendType = 6;
pub const BackendType_B_STARTUP: BackendType = 7;
pub const BackendType_B_WAL_RECEIVER: BackendType = 8;
pub const BackendType_B_WAL_SENDER: BackendType = 9;
pub const BackendType_B_WAL_WRITER: BackendType = 10;
pub const BackendType_B_ARCHIVER: BackendType = 11;
pub const BackendType_B_STATS_COLLECTOR: BackendType = 12;
pub const BackendType_B_LOGGER: BackendType = 13;
pub type BackendType = ::std::os::raw::c_uint;
extern "C" {
    pub static mut MyBackendType: BackendType;
}
pub unsafe fn GetBackendTypeDesc(arg_backendType: BackendType) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetBackendTypeDesc(arg_backendType: BackendType) -> *const ::std::os::raw::c_char;
        }
        GetBackendTypeDesc(arg_backendType)
    })
}
pub unsafe fn SetDatabasePath(arg_path: *const ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SetDatabasePath(arg_path: *const ::std::os::raw::c_char);
        }
        SetDatabasePath(arg_path)
    })
}
pub unsafe fn checkDataDir() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn checkDataDir();
        }
        checkDataDir()
    })
}
pub unsafe fn SetDataDir(arg_dir: *const ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SetDataDir(arg_dir: *const ::std::os::raw::c_char);
        }
        SetDataDir(arg_dir)
    })
}
pub unsafe fn ChangeToDataDir() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ChangeToDataDir();
        }
        ChangeToDataDir()
    })
}
pub unsafe fn GetUserNameFromId(arg_roleid: Oid, arg_noerr: bool) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetUserNameFromId(arg_roleid: Oid, arg_noerr: bool) -> *mut ::std::os::raw::c_char;
        }
        GetUserNameFromId(arg_roleid, arg_noerr)
    })
}
pub unsafe fn GetUserId() -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetUserId() -> Oid;
        }
        GetUserId()
    })
}
pub unsafe fn GetOuterUserId() -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetOuterUserId() -> Oid;
        }
        GetOuterUserId()
    })
}
pub unsafe fn GetSessionUserId() -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetSessionUserId() -> Oid;
        }
        GetSessionUserId()
    })
}
pub unsafe fn GetAuthenticatedUserId() -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetAuthenticatedUserId() -> Oid;
        }
        GetAuthenticatedUserId()
    })
}
pub unsafe fn GetUserIdAndSecContext(
    arg_userid: *mut Oid,
    arg_sec_context: *mut ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetUserIdAndSecContext(
                arg_userid: *mut Oid,
                arg_sec_context: *mut ::std::os::raw::c_int,
            );
        }
        GetUserIdAndSecContext(arg_userid, arg_sec_context)
    })
}
pub unsafe fn SetUserIdAndSecContext(arg_userid: Oid, arg_sec_context: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SetUserIdAndSecContext(arg_userid: Oid, arg_sec_context: ::std::os::raw::c_int);
        }
        SetUserIdAndSecContext(arg_userid, arg_sec_context)
    })
}
pub unsafe fn InLocalUserIdChange() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InLocalUserIdChange() -> bool;
        }
        InLocalUserIdChange()
    })
}
pub unsafe fn InSecurityRestrictedOperation() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InSecurityRestrictedOperation() -> bool;
        }
        InSecurityRestrictedOperation()
    })
}
pub unsafe fn InNoForceRLSOperation() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InNoForceRLSOperation() -> bool;
        }
        InNoForceRLSOperation()
    })
}
pub unsafe fn GetUserIdAndContext(arg_userid: *mut Oid, arg_sec_def_context: *mut bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetUserIdAndContext(arg_userid: *mut Oid, arg_sec_def_context: *mut bool);
        }
        GetUserIdAndContext(arg_userid, arg_sec_def_context)
    })
}
pub unsafe fn SetUserIdAndContext(arg_userid: Oid, arg_sec_def_context: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SetUserIdAndContext(arg_userid: Oid, arg_sec_def_context: bool);
        }
        SetUserIdAndContext(arg_userid, arg_sec_def_context)
    })
}
pub unsafe fn InitializeSessionUserId(
    arg_rolename: *const ::std::os::raw::c_char,
    arg_useroid: Oid,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitializeSessionUserId(
                arg_rolename: *const ::std::os::raw::c_char,
                arg_useroid: Oid,
            );
        }
        InitializeSessionUserId(arg_rolename, arg_useroid)
    })
}
pub unsafe fn InitializeSessionUserIdStandalone() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitializeSessionUserIdStandalone();
        }
        InitializeSessionUserIdStandalone()
    })
}
pub unsafe fn SetSessionAuthorization(arg_userid: Oid, arg_is_superuser: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SetSessionAuthorization(arg_userid: Oid, arg_is_superuser: bool);
        }
        SetSessionAuthorization(arg_userid, arg_is_superuser)
    })
}
pub unsafe fn GetCurrentRoleId() -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetCurrentRoleId() -> Oid;
        }
        GetCurrentRoleId()
    })
}
pub unsafe fn SetCurrentRoleId(arg_roleid: Oid, arg_is_superuser: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SetCurrentRoleId(arg_roleid: Oid, arg_is_superuser: bool);
        }
        SetCurrentRoleId(arg_roleid, arg_is_superuser)
    })
}
pub unsafe fn superuser() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn superuser() -> bool;
        }
        superuser()
    })
}
pub unsafe fn superuser_arg(arg_roleid: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn superuser_arg(arg_roleid: Oid) -> bool;
        }
        superuser_arg(arg_roleid)
    })
}
pub const ProcessingMode_BootstrapProcessing: ProcessingMode = 0;
pub const ProcessingMode_InitProcessing: ProcessingMode = 1;
pub const ProcessingMode_NormalProcessing: ProcessingMode = 2;
#[doc = "\t  pmod.h --\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t *"]
#[doc = "\t\t\tPOSTGRES processing mode definitions.                            *"]
pub type ProcessingMode = ::std::os::raw::c_uint;
extern "C" {
    pub static mut Mode: ProcessingMode;
}
pub const AuxProcType_NotAnAuxProcess: AuxProcType = -1;
pub const AuxProcType_CheckerProcess: AuxProcType = 0;
pub const AuxProcType_BootstrapProcess: AuxProcType = 1;
pub const AuxProcType_StartupProcess: AuxProcType = 2;
pub const AuxProcType_BgWriterProcess: AuxProcType = 3;
pub const AuxProcType_CheckpointerProcess: AuxProcType = 4;
pub const AuxProcType_WalWriterProcess: AuxProcType = 5;
pub const AuxProcType_WalReceiverProcess: AuxProcType = 6;
pub const AuxProcType_NUM_AUXPROCTYPES: AuxProcType = 7;
pub type AuxProcType = ::std::os::raw::c_int;
extern "C" {
    pub static mut MyAuxProcType: AuxProcType;
}
pub unsafe fn pg_split_opts(
    arg_argv: *mut *mut ::std::os::raw::c_char,
    arg_argcp: *mut ::std::os::raw::c_int,
    arg_optstr: *const ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_split_opts(
                arg_argv: *mut *mut ::std::os::raw::c_char,
                arg_argcp: *mut ::std::os::raw::c_int,
                arg_optstr: *const ::std::os::raw::c_char,
            );
        }
        pg_split_opts(arg_argv, arg_argcp, arg_optstr)
    })
}
pub unsafe fn InitializeMaxBackends() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitializeMaxBackends();
        }
        InitializeMaxBackends()
    })
}
pub unsafe fn InitPostgres(
    arg_in_dbname: *const ::std::os::raw::c_char,
    arg_dboid: Oid,
    arg_username: *const ::std::os::raw::c_char,
    arg_useroid: Oid,
    arg_out_dbname: *mut ::std::os::raw::c_char,
    arg_override_allow_connections: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitPostgres(
                arg_in_dbname: *const ::std::os::raw::c_char,
                arg_dboid: Oid,
                arg_username: *const ::std::os::raw::c_char,
                arg_useroid: Oid,
                arg_out_dbname: *mut ::std::os::raw::c_char,
                arg_override_allow_connections: bool,
            );
        }
        InitPostgres(
            arg_in_dbname,
            arg_dboid,
            arg_username,
            arg_useroid,
            arg_out_dbname,
            arg_override_allow_connections,
        )
    })
}
pub unsafe fn BaseInit() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BaseInit();
        }
        BaseInit()
    })
}
extern "C" {
    pub static mut IgnoreSystemIndexes: bool;
}
extern "C" {
    pub static mut process_shared_preload_libraries_in_progress: bool;
}
extern "C" {
    pub static mut session_preload_libraries_string: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut shared_preload_libraries_string: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut local_preload_libraries_string: *mut ::std::os::raw::c_char;
}
pub unsafe fn CreateDataDirLockFile(arg_amPostmaster: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateDataDirLockFile(arg_amPostmaster: bool);
        }
        CreateDataDirLockFile(arg_amPostmaster)
    })
}
pub unsafe fn CreateSocketLockFile(
    arg_socketfile: *const ::std::os::raw::c_char,
    arg_amPostmaster: bool,
    arg_socketDir: *const ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateSocketLockFile(
                arg_socketfile: *const ::std::os::raw::c_char,
                arg_amPostmaster: bool,
                arg_socketDir: *const ::std::os::raw::c_char,
            );
        }
        CreateSocketLockFile(arg_socketfile, arg_amPostmaster, arg_socketDir)
    })
}
pub unsafe fn TouchSocketLockFiles() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TouchSocketLockFiles();
        }
        TouchSocketLockFiles()
    })
}
pub unsafe fn AddToDataDirLockFile(
    arg_target_line: ::std::os::raw::c_int,
    arg_str_: *const ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AddToDataDirLockFile(
                arg_target_line: ::std::os::raw::c_int,
                arg_str_: *const ::std::os::raw::c_char,
            );
        }
        AddToDataDirLockFile(arg_target_line, arg_str_)
    })
}
pub unsafe fn RecheckDataDirLockFile() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RecheckDataDirLockFile() -> bool;
        }
        RecheckDataDirLockFile()
    })
}
pub unsafe fn ValidatePgVersion(arg_path: *const ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ValidatePgVersion(arg_path: *const ::std::os::raw::c_char);
        }
        ValidatePgVersion(arg_path)
    })
}
pub unsafe fn process_shared_preload_libraries() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn process_shared_preload_libraries();
        }
        process_shared_preload_libraries()
    })
}
pub unsafe fn process_session_preload_libraries() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn process_session_preload_libraries();
        }
        process_session_preload_libraries()
    })
}
pub unsafe fn pg_bindtextdomain(arg_domain: *const ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_bindtextdomain(arg_domain: *const ::std::os::raw::c_char);
        }
        pg_bindtextdomain(arg_domain)
    })
}
pub unsafe fn has_rolreplication(arg_roleid: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_rolreplication(arg_roleid: Oid) -> bool;
        }
        has_rolreplication(arg_roleid)
    })
}
pub unsafe fn BackupInProgress() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BackupInProgress() -> bool;
        }
        BackupInProgress()
    })
}
pub unsafe fn CancelBackup() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CancelBackup();
        }
        CancelBackup()
    })
}
pub unsafe fn get_hash_memory_limit() -> usize {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_hash_memory_limit() -> usize;
        }
        get_hash_memory_limit()
    })
}
pub unsafe fn get_hash_mem() -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_hash_mem() -> ::std::os::raw::c_int;
        }
        get_hash_mem()
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_un {
    pub sun_len: ::std::os::raw::c_uchar,
    pub sun_family: sa_family_t,
    pub sun_path: [::std::os::raw::c_char; 104usize],
}
impl Default for sockaddr_un {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SockAddr {
    pub addr: sockaddr_storage,
    pub salen: socklen_t,
}
impl Default for SockAddr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ProtocolVersion = uint32;
pub type MsgType = ProtocolVersion;
pub type PacketLen = uint32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StartupPacket {
    pub protoVersion: ProtocolVersion,
    pub database: [::std::os::raw::c_char; 64usize],
    pub user: [::std::os::raw::c_char; 32usize],
    pub options: [::std::os::raw::c_char; 64usize],
    pub unused: [::std::os::raw::c_char; 64usize],
    pub tty: [::std::os::raw::c_char; 64usize],
}
impl Default for StartupPacket {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut Db_user_namespace: bool;
}
pub type AuthRequest = uint32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CancelRequestPacket {
    pub cancelRequestCode: MsgType,
    pub backendPID: uint32,
    pub cancelAuthCode: uint32,
}
pub unsafe fn pgarch_start() -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgarch_start() -> ::std::os::raw::c_int;
        }
        pgarch_start()
    })
}
pub type RmgrId = uint8;
pub const RmgrIds_RM_XLOG_ID: RmgrIds = 0;
pub const RmgrIds_RM_XACT_ID: RmgrIds = 1;
pub const RmgrIds_RM_SMGR_ID: RmgrIds = 2;
pub const RmgrIds_RM_CLOG_ID: RmgrIds = 3;
pub const RmgrIds_RM_DBASE_ID: RmgrIds = 4;
pub const RmgrIds_RM_TBLSPC_ID: RmgrIds = 5;
pub const RmgrIds_RM_MULTIXACT_ID: RmgrIds = 6;
pub const RmgrIds_RM_RELMAP_ID: RmgrIds = 7;
pub const RmgrIds_RM_STANDBY_ID: RmgrIds = 8;
pub const RmgrIds_RM_HEAP2_ID: RmgrIds = 9;
pub const RmgrIds_RM_HEAP_ID: RmgrIds = 10;
pub const RmgrIds_RM_BTREE_ID: RmgrIds = 11;
pub const RmgrIds_RM_HASH_ID: RmgrIds = 12;
pub const RmgrIds_RM_GIN_ID: RmgrIds = 13;
pub const RmgrIds_RM_GIST_ID: RmgrIds = 14;
pub const RmgrIds_RM_SEQ_ID: RmgrIds = 15;
pub const RmgrIds_RM_SPGIST_ID: RmgrIds = 16;
pub const RmgrIds_RM_BRIN_ID: RmgrIds = 17;
pub const RmgrIds_RM_COMMIT_TS_ID: RmgrIds = 18;
pub const RmgrIds_RM_REPLORIGIN_ID: RmgrIds = 19;
pub const RmgrIds_RM_GENERIC_ID: RmgrIds = 20;
pub const RmgrIds_RM_LOGICALMSG_ID: RmgrIds = 21;
pub const RmgrIds_RM_NEXT_ID: RmgrIds = 22;
pub type RmgrIds = ::std::os::raw::c_uint;
pub type pg_crc32c = uint32;
pub unsafe fn pg_comp_crc32c_armv8(
    arg_crc: pg_crc32c,
    arg_data: *const ::std::os::raw::c_void,
    arg_len: usize,
) -> pg_crc32c {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_comp_crc32c_armv8(
                arg_crc: pg_crc32c,
                arg_data: *const ::std::os::raw::c_void,
                arg_len: usize,
            ) -> pg_crc32c;
        }
        pg_comp_crc32c_armv8(arg_crc, arg_data, arg_len)
    })
}
pub const ForkNumber_InvalidForkNumber: ForkNumber = -1;
pub const ForkNumber_MAIN_FORKNUM: ForkNumber = 0;
pub const ForkNumber_FSM_FORKNUM: ForkNumber = 1;
pub const ForkNumber_VISIBILITYMAP_FORKNUM: ForkNumber = 2;
pub const ForkNumber_INIT_FORKNUM: ForkNumber = 3;
pub type ForkNumber = ::std::os::raw::c_int;
extern "C" {
    pub static mut forkNames: [*const ::std::os::raw::c_char; 0usize];
}
pub unsafe fn forkname_to_number(arg_forkName: *const ::std::os::raw::c_char) -> ForkNumber {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn forkname_to_number(arg_forkName: *const ::std::os::raw::c_char) -> ForkNumber;
        }
        forkname_to_number(arg_forkName)
    })
}
pub unsafe fn forkname_chars(
    arg_str_: *const ::std::os::raw::c_char,
    arg_fork: *mut ForkNumber,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn forkname_chars(
                arg_str_: *const ::std::os::raw::c_char,
                arg_fork: *mut ForkNumber,
            ) -> ::std::os::raw::c_int;
        }
        forkname_chars(arg_str_, arg_fork)
    })
}
pub unsafe fn GetDatabasePath(arg_dbNode: Oid, arg_spcNode: Oid) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetDatabasePath(arg_dbNode: Oid, arg_spcNode: Oid) -> *mut ::std::os::raw::c_char;
        }
        GetDatabasePath(arg_dbNode, arg_spcNode)
    })
}
pub unsafe fn GetRelationPath(
    arg_dbNode: Oid,
    arg_spcNode: Oid,
    arg_relNode: Oid,
    arg_backendId: ::std::os::raw::c_int,
    arg_forkNumber: ForkNumber,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetRelationPath(
                arg_dbNode: Oid,
                arg_spcNode: Oid,
                arg_relNode: Oid,
                arg_backendId: ::std::os::raw::c_int,
                arg_forkNumber: ForkNumber,
            ) -> *mut ::std::os::raw::c_char;
        }
        GetRelationPath(arg_dbNode, arg_spcNode, arg_relNode, arg_backendId, arg_forkNumber)
    })
}
pub type BackendId = ::std::os::raw::c_int;
extern "C" {
    pub static mut MyBackendId: BackendId;
}
extern "C" {
    pub static mut ParallelMasterBackendId: BackendId;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RelFileNode {
    pub spcNode: Oid,
    pub dbNode: Oid,
    pub relNode: Oid,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RelFileNodeBackend {
    pub node: RelFileNode,
    pub backend: BackendId,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct XLogRecord {
    pub xl_tot_len: uint32,
    pub xl_xid: TransactionId,
    pub xl_prev: XLogRecPtr,
    pub xl_info: uint8,
    pub xl_rmid: RmgrId,
    pub xl_crc: pg_crc32c,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct XLogRecordBlockHeader {
    pub id: uint8,
    pub fork_flags: uint8,
    pub data_length: uint16,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct XLogRecordBlockImageHeader {
    pub length: uint16,
    pub hole_offset: uint16,
    pub bimg_info: uint8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct XLogRecordBlockCompressHeader {
    pub hole_length: uint16,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct XLogRecordDataHeaderShort {
    pub id: uint8,
    pub data_length: uint8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct XLogRecordDataHeaderLong {
    pub id: uint8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WALOpenSegment {
    pub ws_file: ::std::os::raw::c_int,
    pub ws_segno: XLogSegNo,
    pub ws_tli: TimeLineID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WALSegmentContext {
    pub ws_dir: [::std::os::raw::c_char; 1024usize],
    pub ws_segsize: ::std::os::raw::c_int,
}
impl Default for WALSegmentContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type XLogPageReadCB = ::std::option::Option<
    unsafe extern "C" fn(
        xlogreader: *mut XLogReaderState,
        targetPagePtr: XLogRecPtr,
        reqLen: ::std::os::raw::c_int,
        targetRecPtr: XLogRecPtr,
        readBuf: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
pub type WALSegmentOpenCB = ::std::option::Option<
    unsafe extern "C" fn(
        xlogreader: *mut XLogReaderState,
        nextSegNo: XLogSegNo,
        tli_p: *mut TimeLineID,
    ),
>;
pub type WALSegmentCloseCB =
    ::std::option::Option<unsafe extern "C" fn(xlogreader: *mut XLogReaderState)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct XLogReaderRoutine {
    pub page_read: XLogPageReadCB,
    pub segment_open: WALSegmentOpenCB,
    pub segment_close: WALSegmentCloseCB,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DecodedBkpBlock {
    pub in_use: bool,
    pub rnode: RelFileNode,
    pub forknum: ForkNumber,
    pub blkno: BlockNumber,
    pub flags: uint8,
    pub has_image: bool,
    pub apply_image: bool,
    pub bkp_image: *mut ::std::os::raw::c_char,
    pub hole_offset: uint16,
    pub hole_length: uint16,
    pub bimg_len: uint16,
    pub bimg_info: uint8,
    pub has_data: bool,
    pub data: *mut ::std::os::raw::c_char,
    pub data_len: uint16,
    pub data_bufsz: uint16,
}
impl Default for DecodedBkpBlock {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLogReaderState {
    pub routine: XLogReaderRoutine,
    pub system_identifier: uint64,
    pub private_data: *mut ::std::os::raw::c_void,
    pub ReadRecPtr: XLogRecPtr,
    pub EndRecPtr: XLogRecPtr,
    pub decoded_record: *mut XLogRecord,
    pub main_data: *mut ::std::os::raw::c_char,
    pub main_data_len: uint32,
    pub main_data_bufsz: uint32,
    pub record_origin: RepOriginId,
    pub blocks: [DecodedBkpBlock; 33usize],
    pub max_block_id: ::std::os::raw::c_int,
    pub readBuf: *mut ::std::os::raw::c_char,
    pub readLen: uint32,
    pub segcxt: WALSegmentContext,
    pub seg: WALOpenSegment,
    pub segoff: uint32,
    pub latestPagePtr: XLogRecPtr,
    pub latestPageTLI: TimeLineID,
    pub currRecPtr: XLogRecPtr,
    pub currTLI: TimeLineID,
    pub currTLIValidUntil: XLogRecPtr,
    pub nextTLI: TimeLineID,
    pub readRecordBuf: *mut ::std::os::raw::c_char,
    pub readRecordBufSize: uint32,
    pub errormsg_buf: *mut ::std::os::raw::c_char,
    pub abortedRecPtr: XLogRecPtr,
    pub missingContrecPtr: XLogRecPtr,
    pub overwrittenRecPtr: XLogRecPtr,
}
impl Default for XLogReaderState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn XLogReaderAllocate(
    arg_wal_segment_size: ::std::os::raw::c_int,
    arg_waldir: *const ::std::os::raw::c_char,
    arg_routine: *mut XLogReaderRoutine,
    arg_private_data: *mut ::std::os::raw::c_void,
) -> *mut XLogReaderState {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XLogReaderAllocate(
                arg_wal_segment_size: ::std::os::raw::c_int,
                arg_waldir: *const ::std::os::raw::c_char,
                arg_routine: *mut XLogReaderRoutine,
                arg_private_data: *mut ::std::os::raw::c_void,
            ) -> *mut XLogReaderState;
        }
        XLogReaderAllocate(arg_wal_segment_size, arg_waldir, arg_routine, arg_private_data)
    })
}
pub unsafe fn LocalXLogReaderRoutine() -> *mut XLogReaderRoutine {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LocalXLogReaderRoutine() -> *mut XLogReaderRoutine;
        }
        LocalXLogReaderRoutine()
    })
}
pub unsafe fn XLogReaderFree(arg_state: *mut XLogReaderState) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XLogReaderFree(arg_state: *mut XLogReaderState);
        }
        XLogReaderFree(arg_state)
    })
}
pub unsafe fn XLogBeginRead(arg_state: *mut XLogReaderState, arg_RecPtr: XLogRecPtr) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XLogBeginRead(arg_state: *mut XLogReaderState, arg_RecPtr: XLogRecPtr);
        }
        XLogBeginRead(arg_state, arg_RecPtr)
    })
}
pub unsafe fn XLogReadRecord(
    arg_state: *mut XLogReaderState,
    arg_errormsg: *mut *mut ::std::os::raw::c_char,
) -> *mut XLogRecord {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XLogReadRecord(
                arg_state: *mut XLogReaderState,
                arg_errormsg: *mut *mut ::std::os::raw::c_char,
            ) -> *mut XLogRecord;
        }
        XLogReadRecord(arg_state, arg_errormsg)
    })
}
pub unsafe fn XLogReaderValidatePageHeader(
    arg_state: *mut XLogReaderState,
    arg_recptr: XLogRecPtr,
    arg_phdr: *mut ::std::os::raw::c_char,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XLogReaderValidatePageHeader(
                arg_state: *mut XLogReaderState,
                arg_recptr: XLogRecPtr,
                arg_phdr: *mut ::std::os::raw::c_char,
            ) -> bool;
        }
        XLogReaderValidatePageHeader(arg_state, arg_recptr, arg_phdr)
    })
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WALReadError {
    pub wre_errno: ::std::os::raw::c_int,
    pub wre_off: ::std::os::raw::c_int,
    pub wre_req: ::std::os::raw::c_int,
    pub wre_read: ::std::os::raw::c_int,
    pub wre_seg: WALOpenSegment,
}
pub unsafe fn WALRead(
    arg_state: *mut XLogReaderState,
    arg_buf: *mut ::std::os::raw::c_char,
    arg_startptr: XLogRecPtr,
    arg_count: Size,
    arg_tli: TimeLineID,
    arg_errinfo: *mut WALReadError,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn WALRead(
                arg_state: *mut XLogReaderState,
                arg_buf: *mut ::std::os::raw::c_char,
                arg_startptr: XLogRecPtr,
                arg_count: Size,
                arg_tli: TimeLineID,
                arg_errinfo: *mut WALReadError,
            ) -> bool;
        }
        WALRead(arg_state, arg_buf, arg_startptr, arg_count, arg_tli, arg_errinfo)
    })
}
pub unsafe fn DecodeXLogRecord(
    arg_state: *mut XLogReaderState,
    arg_record: *mut XLogRecord,
    arg_errmsg: *mut *mut ::std::os::raw::c_char,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DecodeXLogRecord(
                arg_state: *mut XLogReaderState,
                arg_record: *mut XLogRecord,
                arg_errmsg: *mut *mut ::std::os::raw::c_char,
            ) -> bool;
        }
        DecodeXLogRecord(arg_state, arg_record, arg_errmsg)
    })
}
pub unsafe fn XLogRecGetFullXid(arg_record: *mut XLogReaderState) -> FullTransactionId {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XLogRecGetFullXid(arg_record: *mut XLogReaderState) -> FullTransactionId;
        }
        XLogRecGetFullXid(arg_record)
    })
}
pub unsafe fn RestoreBlockImage(
    arg_record: *mut XLogReaderState,
    arg_block_id: uint8,
    arg_page: *mut ::std::os::raw::c_char,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RestoreBlockImage(
                arg_record: *mut XLogReaderState,
                arg_block_id: uint8,
                arg_page: *mut ::std::os::raw::c_char,
            ) -> bool;
        }
        RestoreBlockImage(arg_record, arg_block_id, arg_page)
    })
}
pub unsafe fn XLogRecGetBlockData(
    arg_record: *mut XLogReaderState,
    arg_block_id: uint8,
    arg_len: *mut Size,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XLogRecGetBlockData(
                arg_record: *mut XLogReaderState,
                arg_block_id: uint8,
                arg_len: *mut Size,
            ) -> *mut ::std::os::raw::c_char;
        }
        XLogRecGetBlockData(arg_record, arg_block_id, arg_len)
    })
}
pub unsafe fn XLogRecGetBlockTag(
    arg_record: *mut XLogReaderState,
    arg_block_id: uint8,
    arg_rnode: *mut RelFileNode,
    arg_forknum: *mut ForkNumber,
    arg_blknum: *mut BlockNumber,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XLogRecGetBlockTag(
                arg_record: *mut XLogReaderState,
                arg_block_id: uint8,
                arg_rnode: *mut RelFileNode,
                arg_forknum: *mut ForkNumber,
                arg_blknum: *mut BlockNumber,
            ) -> bool;
        }
        XLogRecGetBlockTag(arg_record, arg_block_id, arg_rnode, arg_forknum, arg_blknum)
    })
}
pub type XidStatus = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xl_clog_truncate {
    pub pageno: ::std::os::raw::c_int,
    pub oldestXact: TransactionId,
    pub oldestXactDb: Oid,
}
pub unsafe fn TransactionIdSetTreeStatus(
    arg_xid: TransactionId,
    arg_nsubxids: ::std::os::raw::c_int,
    arg_subxids: *mut TransactionId,
    arg_status: XidStatus,
    arg_lsn: XLogRecPtr,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TransactionIdSetTreeStatus(
                arg_xid: TransactionId,
                arg_nsubxids: ::std::os::raw::c_int,
                arg_subxids: *mut TransactionId,
                arg_status: XidStatus,
                arg_lsn: XLogRecPtr,
            );
        }
        TransactionIdSetTreeStatus(arg_xid, arg_nsubxids, arg_subxids, arg_status, arg_lsn)
    })
}
pub unsafe fn TransactionIdGetStatus(
    arg_xid: TransactionId,
    arg_lsn: *mut XLogRecPtr,
) -> XidStatus {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TransactionIdGetStatus(
                arg_xid: TransactionId,
                arg_lsn: *mut XLogRecPtr,
            ) -> XidStatus;
        }
        TransactionIdGetStatus(arg_xid, arg_lsn)
    })
}
pub unsafe fn CLOGShmemBuffers() -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CLOGShmemBuffers() -> Size;
        }
        CLOGShmemBuffers()
    })
}
pub unsafe fn CLOGShmemSize() -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CLOGShmemSize() -> Size;
        }
        CLOGShmemSize()
    })
}
pub unsafe fn CLOGShmemInit() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CLOGShmemInit();
        }
        CLOGShmemInit()
    })
}
pub unsafe fn BootStrapCLOG() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BootStrapCLOG();
        }
        BootStrapCLOG()
    })
}
pub unsafe fn StartupCLOG() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn StartupCLOG();
        }
        StartupCLOG()
    })
}
pub unsafe fn TrimCLOG() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TrimCLOG();
        }
        TrimCLOG()
    })
}
pub unsafe fn ShutdownCLOG() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ShutdownCLOG();
        }
        ShutdownCLOG()
    })
}
pub unsafe fn CheckPointCLOG() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CheckPointCLOG();
        }
        CheckPointCLOG()
    })
}
pub unsafe fn ExtendCLOG(arg_newestXact: TransactionId) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExtendCLOG(arg_newestXact: TransactionId);
        }
        ExtendCLOG(arg_newestXact)
    })
}
pub unsafe fn TruncateCLOG(arg_oldestXact: TransactionId, arg_oldestxid_datoid: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TruncateCLOG(arg_oldestXact: TransactionId, arg_oldestxid_datoid: Oid);
        }
        TruncateCLOG(arg_oldestXact, arg_oldestxid_datoid)
    })
}
pub unsafe fn clog_redo(arg_record: *mut XLogReaderState) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn clog_redo(arg_record: *mut XLogReaderState);
        }
        clog_redo(arg_record)
    })
}
pub unsafe fn clog_desc(arg_buf: StringInfo, arg_record: *mut XLogReaderState) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn clog_desc(arg_buf: StringInfo, arg_record: *mut XLogReaderState);
        }
        clog_desc(arg_buf, arg_record)
    })
}
pub unsafe fn clog_identify(arg_info: uint8) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn clog_identify(arg_info: uint8) -> *const ::std::os::raw::c_char;
        }
        clog_identify(arg_info)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dlist_node {
    pub prev: *mut dlist_node,
    pub next: *mut dlist_node,
}
impl Default for dlist_node {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dlist_head {
    pub head: dlist_node,
}
impl Default for dlist_head {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dlist_iter {
    pub cur: *mut dlist_node,
    pub end: *mut dlist_node,
}
impl Default for dlist_iter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dlist_mutable_iter {
    pub cur: *mut dlist_node,
    pub next: *mut dlist_node,
    pub end: *mut dlist_node,
}
impl Default for dlist_mutable_iter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slist_node {
    pub next: *mut slist_node,
}
impl Default for slist_node {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slist_head {
    pub head: slist_node,
}
impl Default for slist_head {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slist_iter {
    pub cur: *mut slist_node,
}
impl Default for slist_iter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slist_mutable_iter {
    pub cur: *mut slist_node,
    pub next: *mut slist_node,
    pub prev: *mut slist_node,
}
impl Default for slist_mutable_iter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn slist_delete(arg_head: *mut slist_head, arg_node: *mut slist_node) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn slist_delete(arg_head: *mut slist_head, arg_node: *mut slist_node);
        }
        slist_delete(arg_head, arg_node)
    })
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Latch {
    pub is_set: sig_atomic_t,
    pub is_shared: bool,
    pub owner_pid: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WaitEvent {
    pub pos: ::std::os::raw::c_int,
    pub events: uint32,
    pub fd: pgsocket,
    pub user_data: *mut ::std::os::raw::c_void,
}
impl Default for WaitEvent {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WaitEventSet {
    _unused: [u8; 0],
}
pub unsafe fn InitializeLatchSupport() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitializeLatchSupport();
        }
        InitializeLatchSupport()
    })
}
pub unsafe fn InitLatch(arg_latch: *mut Latch) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitLatch(arg_latch: *mut Latch);
        }
        InitLatch(arg_latch)
    })
}
pub unsafe fn InitSharedLatch(arg_latch: *mut Latch) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitSharedLatch(arg_latch: *mut Latch);
        }
        InitSharedLatch(arg_latch)
    })
}
pub unsafe fn OwnLatch(arg_latch: *mut Latch) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn OwnLatch(arg_latch: *mut Latch);
        }
        OwnLatch(arg_latch)
    })
}
pub unsafe fn DisownLatch(arg_latch: *mut Latch) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DisownLatch(arg_latch: *mut Latch);
        }
        DisownLatch(arg_latch)
    })
}
pub unsafe fn SetLatch(arg_latch: *mut Latch) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SetLatch(arg_latch: *mut Latch);
        }
        SetLatch(arg_latch)
    })
}
pub unsafe fn ResetLatch(arg_latch: *mut Latch) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ResetLatch(arg_latch: *mut Latch);
        }
        ResetLatch(arg_latch)
    })
}
pub unsafe fn CreateWaitEventSet(
    arg_context: MemoryContext,
    arg_nevents: ::std::os::raw::c_int,
) -> *mut WaitEventSet {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateWaitEventSet(
                arg_context: MemoryContext,
                arg_nevents: ::std::os::raw::c_int,
            ) -> *mut WaitEventSet;
        }
        CreateWaitEventSet(arg_context, arg_nevents)
    })
}
pub unsafe fn FreeWaitEventSet(arg_set: *mut WaitEventSet) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FreeWaitEventSet(arg_set: *mut WaitEventSet);
        }
        FreeWaitEventSet(arg_set)
    })
}
pub unsafe fn AddWaitEventToSet(
    arg_set: *mut WaitEventSet,
    arg_events: uint32,
    arg_fd: pgsocket,
    arg_latch: *mut Latch,
    arg_user_data: *mut ::std::os::raw::c_void,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AddWaitEventToSet(
                arg_set: *mut WaitEventSet,
                arg_events: uint32,
                arg_fd: pgsocket,
                arg_latch: *mut Latch,
                arg_user_data: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int;
        }
        AddWaitEventToSet(arg_set, arg_events, arg_fd, arg_latch, arg_user_data)
    })
}
pub unsafe fn ModifyWaitEvent(
    arg_set: *mut WaitEventSet,
    arg_pos: ::std::os::raw::c_int,
    arg_events: uint32,
    arg_latch: *mut Latch,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ModifyWaitEvent(
                arg_set: *mut WaitEventSet,
                arg_pos: ::std::os::raw::c_int,
                arg_events: uint32,
                arg_latch: *mut Latch,
            );
        }
        ModifyWaitEvent(arg_set, arg_pos, arg_events, arg_latch)
    })
}
pub unsafe fn WaitEventSetWait(
    arg_set: *mut WaitEventSet,
    arg_timeout: ::std::os::raw::c_long,
    arg_occurred_events: *mut WaitEvent,
    arg_nevents: ::std::os::raw::c_int,
    arg_wait_event_info: uint32,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn WaitEventSetWait(
                arg_set: *mut WaitEventSet,
                arg_timeout: ::std::os::raw::c_long,
                arg_occurred_events: *mut WaitEvent,
                arg_nevents: ::std::os::raw::c_int,
                arg_wait_event_info: uint32,
            ) -> ::std::os::raw::c_int;
        }
        WaitEventSetWait(
            arg_set,
            arg_timeout,
            arg_occurred_events,
            arg_nevents,
            arg_wait_event_info,
        )
    })
}
pub unsafe fn WaitLatch(
    arg_latch: *mut Latch,
    arg_wakeEvents: ::std::os::raw::c_int,
    arg_timeout: ::std::os::raw::c_long,
    arg_wait_event_info: uint32,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn WaitLatch(
                arg_latch: *mut Latch,
                arg_wakeEvents: ::std::os::raw::c_int,
                arg_timeout: ::std::os::raw::c_long,
                arg_wait_event_info: uint32,
            ) -> ::std::os::raw::c_int;
        }
        WaitLatch(arg_latch, arg_wakeEvents, arg_timeout, arg_wait_event_info)
    })
}
pub unsafe fn WaitLatchOrSocket(
    arg_latch: *mut Latch,
    arg_wakeEvents: ::std::os::raw::c_int,
    arg_sock: pgsocket,
    arg_timeout: ::std::os::raw::c_long,
    arg_wait_event_info: uint32,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn WaitLatchOrSocket(
                arg_latch: *mut Latch,
                arg_wakeEvents: ::std::os::raw::c_int,
                arg_sock: pgsocket,
                arg_timeout: ::std::os::raw::c_long,
                arg_wait_event_info: uint32,
            ) -> ::std::os::raw::c_int;
        }
        WaitLatchOrSocket(arg_latch, arg_wakeEvents, arg_sock, arg_timeout, arg_wait_event_info)
    })
}
pub unsafe fn latch_sigusr1_handler() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn latch_sigusr1_handler();
        }
        latch_sigusr1_handler()
    })
}
pub type LOCKMASK = ::std::os::raw::c_int;
pub type LOCKMODE = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xl_standby_lock {
    pub xid: TransactionId,
    pub dbOid: Oid,
    pub relOid: Oid,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LWLock {
    pub tranche: uint16,
    pub state: pg_atomic_uint32,
    pub waiters: proclist_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union LWLockPadded {
    pub lock: LWLock,
    pub pad: [::std::os::raw::c_char; 128usize],
}
impl Default for LWLockPadded {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union LWLockMinimallyPadded {
    pub lock: LWLock,
    pub pad: [::std::os::raw::c_char; 32usize],
}
impl Default for LWLockMinimallyPadded {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut MainLWLockArray: *mut LWLockPadded;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NamedLWLockTranche {
    pub trancheId: ::std::os::raw::c_int,
    pub trancheName: *mut ::std::os::raw::c_char,
}
impl Default for NamedLWLockTranche {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut NamedLWLockTrancheArray: *mut NamedLWLockTranche;
}
extern "C" {
    pub static mut NamedLWLockTrancheRequests: ::std::os::raw::c_int;
}
pub const LWLockMode_LW_EXCLUSIVE: LWLockMode = 0;
pub const LWLockMode_LW_SHARED: LWLockMode = 1;
pub const LWLockMode_LW_WAIT_UNTIL_FREE: LWLockMode = 2;
pub type LWLockMode = ::std::os::raw::c_uint;
pub unsafe fn LWLockAcquire(arg_lock: *mut LWLock, arg_mode: LWLockMode) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LWLockAcquire(arg_lock: *mut LWLock, arg_mode: LWLockMode) -> bool;
        }
        LWLockAcquire(arg_lock, arg_mode)
    })
}
pub unsafe fn LWLockConditionalAcquire(arg_lock: *mut LWLock, arg_mode: LWLockMode) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LWLockConditionalAcquire(arg_lock: *mut LWLock, arg_mode: LWLockMode) -> bool;
        }
        LWLockConditionalAcquire(arg_lock, arg_mode)
    })
}
pub unsafe fn LWLockAcquireOrWait(arg_lock: *mut LWLock, arg_mode: LWLockMode) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LWLockAcquireOrWait(arg_lock: *mut LWLock, arg_mode: LWLockMode) -> bool;
        }
        LWLockAcquireOrWait(arg_lock, arg_mode)
    })
}
pub unsafe fn LWLockRelease(arg_lock: *mut LWLock) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LWLockRelease(arg_lock: *mut LWLock);
        }
        LWLockRelease(arg_lock)
    })
}
pub unsafe fn LWLockReleaseClearVar(
    arg_lock: *mut LWLock,
    arg_valptr: *mut uint64,
    arg_val: uint64,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LWLockReleaseClearVar(
                arg_lock: *mut LWLock,
                arg_valptr: *mut uint64,
                arg_val: uint64,
            );
        }
        LWLockReleaseClearVar(arg_lock, arg_valptr, arg_val)
    })
}
pub unsafe fn LWLockReleaseAll() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LWLockReleaseAll();
        }
        LWLockReleaseAll()
    })
}
pub unsafe fn LWLockHeldByMe(arg_lock: *mut LWLock) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LWLockHeldByMe(arg_lock: *mut LWLock) -> bool;
        }
        LWLockHeldByMe(arg_lock)
    })
}
pub unsafe fn LWLockHeldByMeInMode(arg_lock: *mut LWLock, arg_mode: LWLockMode) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LWLockHeldByMeInMode(arg_lock: *mut LWLock, arg_mode: LWLockMode) -> bool;
        }
        LWLockHeldByMeInMode(arg_lock, arg_mode)
    })
}
pub unsafe fn LWLockWaitForVar(
    arg_lock: *mut LWLock,
    arg_valptr: *mut uint64,
    arg_oldval: uint64,
    arg_newval: *mut uint64,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LWLockWaitForVar(
                arg_lock: *mut LWLock,
                arg_valptr: *mut uint64,
                arg_oldval: uint64,
                arg_newval: *mut uint64,
            ) -> bool;
        }
        LWLockWaitForVar(arg_lock, arg_valptr, arg_oldval, arg_newval)
    })
}
pub unsafe fn LWLockUpdateVar(arg_lock: *mut LWLock, arg_valptr: *mut uint64, arg_value: uint64) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LWLockUpdateVar(arg_lock: *mut LWLock, arg_valptr: *mut uint64, arg_value: uint64);
        }
        LWLockUpdateVar(arg_lock, arg_valptr, arg_value)
    })
}
pub unsafe fn LWLockShmemSize() -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LWLockShmemSize() -> Size;
        }
        LWLockShmemSize()
    })
}
pub unsafe fn CreateLWLocks() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateLWLocks();
        }
        CreateLWLocks()
    })
}
pub unsafe fn InitLWLockAccess() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitLWLockAccess();
        }
        InitLWLockAccess()
    })
}
pub unsafe fn GetLWLockIdentifier(
    arg_classId: uint32,
    arg_eventId: uint16,
) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetLWLockIdentifier(
                arg_classId: uint32,
                arg_eventId: uint16,
            ) -> *const ::std::os::raw::c_char;
        }
        GetLWLockIdentifier(arg_classId, arg_eventId)
    })
}
pub unsafe fn RequestNamedLWLockTranche(
    arg_tranche_name: *const ::std::os::raw::c_char,
    arg_num_lwlocks: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RequestNamedLWLockTranche(
                arg_tranche_name: *const ::std::os::raw::c_char,
                arg_num_lwlocks: ::std::os::raw::c_int,
            );
        }
        RequestNamedLWLockTranche(arg_tranche_name, arg_num_lwlocks)
    })
}
pub unsafe fn GetNamedLWLockTranche(
    arg_tranche_name: *const ::std::os::raw::c_char,
) -> *mut LWLockPadded {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetNamedLWLockTranche(
                arg_tranche_name: *const ::std::os::raw::c_char,
            ) -> *mut LWLockPadded;
        }
        GetNamedLWLockTranche(arg_tranche_name)
    })
}
pub unsafe fn LWLockNewTrancheId() -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LWLockNewTrancheId() -> ::std::os::raw::c_int;
        }
        LWLockNewTrancheId()
    })
}
pub unsafe fn LWLockRegisterTranche(
    arg_tranche_id: ::std::os::raw::c_int,
    arg_tranche_name: *const ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LWLockRegisterTranche(
                arg_tranche_id: ::std::os::raw::c_int,
                arg_tranche_name: *const ::std::os::raw::c_char,
            );
        }
        LWLockRegisterTranche(arg_tranche_id, arg_tranche_name)
    })
}
pub unsafe fn LWLockInitialize(arg_lock: *mut LWLock, arg_tranche_id: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LWLockInitialize(arg_lock: *mut LWLock, arg_tranche_id: ::std::os::raw::c_int);
        }
        LWLockInitialize(arg_lock, arg_tranche_id)
    })
}
pub const BuiltinTrancheIds_LWTRANCHE_XACT_BUFFER: BuiltinTrancheIds = 48;
pub const BuiltinTrancheIds_LWTRANCHE_COMMITTS_BUFFER: BuiltinTrancheIds = 49;
pub const BuiltinTrancheIds_LWTRANCHE_SUBTRANS_BUFFER: BuiltinTrancheIds = 50;
pub const BuiltinTrancheIds_LWTRANCHE_MULTIXACTOFFSET_BUFFER: BuiltinTrancheIds = 51;
pub const BuiltinTrancheIds_LWTRANCHE_MULTIXACTMEMBER_BUFFER: BuiltinTrancheIds = 52;
pub const BuiltinTrancheIds_LWTRANCHE_NOTIFY_BUFFER: BuiltinTrancheIds = 53;
pub const BuiltinTrancheIds_LWTRANCHE_SERIAL_BUFFER: BuiltinTrancheIds = 54;
pub const BuiltinTrancheIds_LWTRANCHE_WAL_INSERT: BuiltinTrancheIds = 55;
pub const BuiltinTrancheIds_LWTRANCHE_BUFFER_CONTENT: BuiltinTrancheIds = 56;
pub const BuiltinTrancheIds_LWTRANCHE_BUFFER_IO: BuiltinTrancheIds = 57;
pub const BuiltinTrancheIds_LWTRANCHE_REPLICATION_ORIGIN_STATE: BuiltinTrancheIds = 58;
pub const BuiltinTrancheIds_LWTRANCHE_REPLICATION_SLOT_IO: BuiltinTrancheIds = 59;
pub const BuiltinTrancheIds_LWTRANCHE_LOCK_FASTPATH: BuiltinTrancheIds = 60;
pub const BuiltinTrancheIds_LWTRANCHE_BUFFER_MAPPING: BuiltinTrancheIds = 61;
pub const BuiltinTrancheIds_LWTRANCHE_LOCK_MANAGER: BuiltinTrancheIds = 62;
pub const BuiltinTrancheIds_LWTRANCHE_PREDICATE_LOCK_MANAGER: BuiltinTrancheIds = 63;
pub const BuiltinTrancheIds_LWTRANCHE_PARALLEL_HASH_JOIN: BuiltinTrancheIds = 64;
pub const BuiltinTrancheIds_LWTRANCHE_PARALLEL_QUERY_DSA: BuiltinTrancheIds = 65;
pub const BuiltinTrancheIds_LWTRANCHE_PER_SESSION_DSA: BuiltinTrancheIds = 66;
pub const BuiltinTrancheIds_LWTRANCHE_PER_SESSION_RECORD_TYPE: BuiltinTrancheIds = 67;
pub const BuiltinTrancheIds_LWTRANCHE_PER_SESSION_RECORD_TYPMOD: BuiltinTrancheIds = 68;
pub const BuiltinTrancheIds_LWTRANCHE_SHARED_TUPLESTORE: BuiltinTrancheIds = 69;
pub const BuiltinTrancheIds_LWTRANCHE_SHARED_TIDBITMAP: BuiltinTrancheIds = 70;
pub const BuiltinTrancheIds_LWTRANCHE_PARALLEL_APPEND: BuiltinTrancheIds = 71;
pub const BuiltinTrancheIds_LWTRANCHE_PER_XACT_PREDICATE_LIST: BuiltinTrancheIds = 72;
pub const BuiltinTrancheIds_LWTRANCHE_FIRST_USER_DEFINED: BuiltinTrancheIds = 73;
pub type BuiltinTrancheIds = ::std::os::raw::c_uint;
pub type LWLockId = *mut LWLock;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHM_QUEUE {
    pub prev: *mut SHM_QUEUE,
    pub next: *mut SHM_QUEUE,
}
impl Default for SHM_QUEUE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn InitShmemAccess(arg_seghdr: *mut ::std::os::raw::c_void) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitShmemAccess(arg_seghdr: *mut ::std::os::raw::c_void);
        }
        InitShmemAccess(arg_seghdr)
    })
}
pub unsafe fn InitShmemAllocation() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitShmemAllocation();
        }
        InitShmemAllocation()
    })
}
pub unsafe fn ShmemAlloc(arg_size: Size) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ShmemAlloc(arg_size: Size) -> *mut ::std::os::raw::c_void;
        }
        ShmemAlloc(arg_size)
    })
}
pub unsafe fn ShmemAllocNoError(arg_size: Size) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ShmemAllocNoError(arg_size: Size) -> *mut ::std::os::raw::c_void;
        }
        ShmemAllocNoError(arg_size)
    })
}
pub unsafe fn ShmemAllocUnlocked(arg_size: Size) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ShmemAllocUnlocked(arg_size: Size) -> *mut ::std::os::raw::c_void;
        }
        ShmemAllocUnlocked(arg_size)
    })
}
pub unsafe fn ShmemAddrIsValid(arg_addr: *const ::std::os::raw::c_void) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ShmemAddrIsValid(arg_addr: *const ::std::os::raw::c_void) -> bool;
        }
        ShmemAddrIsValid(arg_addr)
    })
}
pub unsafe fn InitShmemIndex() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitShmemIndex();
        }
        InitShmemIndex()
    })
}
pub unsafe fn ShmemInitHash(
    arg_name: *const ::std::os::raw::c_char,
    arg_init_size: ::std::os::raw::c_long,
    arg_max_size: ::std::os::raw::c_long,
    arg_infoP: *mut HASHCTL,
    arg_hash_flags: ::std::os::raw::c_int,
) -> *mut HTAB {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ShmemInitHash(
                arg_name: *const ::std::os::raw::c_char,
                arg_init_size: ::std::os::raw::c_long,
                arg_max_size: ::std::os::raw::c_long,
                arg_infoP: *mut HASHCTL,
                arg_hash_flags: ::std::os::raw::c_int,
            ) -> *mut HTAB;
        }
        ShmemInitHash(arg_name, arg_init_size, arg_max_size, arg_infoP, arg_hash_flags)
    })
}
pub unsafe fn ShmemInitStruct(
    arg_name: *const ::std::os::raw::c_char,
    arg_size: Size,
    arg_foundPtr: *mut bool,
) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ShmemInitStruct(
                arg_name: *const ::std::os::raw::c_char,
                arg_size: Size,
                arg_foundPtr: *mut bool,
            ) -> *mut ::std::os::raw::c_void;
        }
        ShmemInitStruct(arg_name, arg_size, arg_foundPtr)
    })
}
pub unsafe fn add_size(arg_s1: Size, arg_s2: Size) -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn add_size(arg_s1: Size, arg_s2: Size) -> Size;
        }
        add_size(arg_s1, arg_s2)
    })
}
pub unsafe fn mul_size(arg_s1: Size, arg_s2: Size) -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn mul_size(arg_s1: Size, arg_s2: Size) -> Size;
        }
        mul_size(arg_s1, arg_s2)
    })
}
pub unsafe fn RequestAddinShmemSpace(arg_size: Size) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RequestAddinShmemSpace(arg_size: Size);
        }
        RequestAddinShmemSpace(arg_size)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ShmemIndexEnt {
    pub key: [::std::os::raw::c_char; 48usize],
    pub location: *mut ::std::os::raw::c_void,
    pub size: Size,
    pub allocated_size: Size,
}
impl Default for ShmemIndexEnt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn SHMQueueInit(arg_queue: *mut SHM_QUEUE) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SHMQueueInit(arg_queue: *mut SHM_QUEUE);
        }
        SHMQueueInit(arg_queue)
    })
}
pub unsafe fn SHMQueueElemInit(arg_queue: *mut SHM_QUEUE) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SHMQueueElemInit(arg_queue: *mut SHM_QUEUE);
        }
        SHMQueueElemInit(arg_queue)
    })
}
pub unsafe fn SHMQueueDelete(arg_queue: *mut SHM_QUEUE) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SHMQueueDelete(arg_queue: *mut SHM_QUEUE);
        }
        SHMQueueDelete(arg_queue)
    })
}
pub unsafe fn SHMQueueInsertBefore(arg_queue: *mut SHM_QUEUE, arg_elem: *mut SHM_QUEUE) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SHMQueueInsertBefore(arg_queue: *mut SHM_QUEUE, arg_elem: *mut SHM_QUEUE);
        }
        SHMQueueInsertBefore(arg_queue, arg_elem)
    })
}
pub unsafe fn SHMQueueInsertAfter(arg_queue: *mut SHM_QUEUE, arg_elem: *mut SHM_QUEUE) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SHMQueueInsertAfter(arg_queue: *mut SHM_QUEUE, arg_elem: *mut SHM_QUEUE);
        }
        SHMQueueInsertAfter(arg_queue, arg_elem)
    })
}
pub unsafe fn SHMQueueNext(
    arg_queue: *const SHM_QUEUE,
    arg_curElem: *const SHM_QUEUE,
    arg_linkOffset: Size,
) -> Pointer {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SHMQueueNext(
                arg_queue: *const SHM_QUEUE,
                arg_curElem: *const SHM_QUEUE,
                arg_linkOffset: Size,
            ) -> Pointer;
        }
        SHMQueueNext(arg_queue, arg_curElem, arg_linkOffset)
    })
}
pub unsafe fn SHMQueuePrev(
    arg_queue: *const SHM_QUEUE,
    arg_curElem: *const SHM_QUEUE,
    arg_linkOffset: Size,
) -> Pointer {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SHMQueuePrev(
                arg_queue: *const SHM_QUEUE,
                arg_curElem: *const SHM_QUEUE,
                arg_linkOffset: Size,
            ) -> Pointer;
        }
        SHMQueuePrev(arg_queue, arg_curElem, arg_linkOffset)
    })
}
pub unsafe fn SHMQueueEmpty(arg_queue: *const SHM_QUEUE) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SHMQueueEmpty(arg_queue: *const SHM_QUEUE) -> bool;
        }
        SHMQueueEmpty(arg_queue)
    })
}
pub unsafe fn SHMQueueIsDetached(arg_queue: *const SHM_QUEUE) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SHMQueueIsDetached(arg_queue: *const SHM_QUEUE) -> bool;
        }
        SHMQueueIsDetached(arg_queue)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PROC_QUEUE {
    pub links: SHM_QUEUE,
    pub size: ::std::os::raw::c_int,
}
impl Default for PROC_QUEUE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut max_locks_per_xact: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VirtualTransactionId {
    pub backendId: BackendId,
    pub localTransactionId: LocalTransactionId,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LockMethodData {
    pub numLockModes: ::std::os::raw::c_int,
    pub conflictTab: *const LOCKMASK,
    pub lockModeNames: *const *const ::std::os::raw::c_char,
    pub trace_flag: *const bool,
}
impl Default for LockMethodData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type LockMethod = *const LockMethodData;
pub type LOCKMETHODID = uint16;
pub const LockTagType_LOCKTAG_RELATION: LockTagType = 0;
pub const LockTagType_LOCKTAG_RELATION_EXTEND: LockTagType = 1;
pub const LockTagType_LOCKTAG_DATABASE_FROZEN_IDS: LockTagType = 2;
pub const LockTagType_LOCKTAG_PAGE: LockTagType = 3;
pub const LockTagType_LOCKTAG_TUPLE: LockTagType = 4;
pub const LockTagType_LOCKTAG_TRANSACTION: LockTagType = 5;
pub const LockTagType_LOCKTAG_VIRTUALTRANSACTION: LockTagType = 6;
pub const LockTagType_LOCKTAG_SPECULATIVE_TOKEN: LockTagType = 7;
pub const LockTagType_LOCKTAG_OBJECT: LockTagType = 8;
pub const LockTagType_LOCKTAG_USERLOCK: LockTagType = 9;
pub const LockTagType_LOCKTAG_ADVISORY: LockTagType = 10;
pub type LockTagType = ::std::os::raw::c_uint;
extern "C" {
    pub static mut LockTagTypeNames: [*const ::std::os::raw::c_char; 0usize];
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LOCKTAG {
    pub locktag_field1: uint32,
    pub locktag_field2: uint32,
    pub locktag_field3: uint32,
    pub locktag_field4: uint16,
    pub locktag_type: uint8,
    pub locktag_lockmethodid: uint8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LOCK {
    pub tag: LOCKTAG,
    pub grantMask: LOCKMASK,
    pub waitMask: LOCKMASK,
    pub procLocks: SHM_QUEUE,
    pub waitProcs: PROC_QUEUE,
    pub requested: [::std::os::raw::c_int; 10usize],
    pub nRequested: ::std::os::raw::c_int,
    pub granted: [::std::os::raw::c_int; 10usize],
    pub nGranted: ::std::os::raw::c_int,
}
impl Default for LOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PROCLOCKTAG {
    pub myLock: *mut LOCK,
    pub myProc: *mut PGPROC,
}
impl Default for PROCLOCKTAG {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PROCLOCK {
    pub tag: PROCLOCKTAG,
    pub groupLeader: *mut PGPROC,
    pub holdMask: LOCKMASK,
    pub releaseMask: LOCKMASK,
    pub lockLink: SHM_QUEUE,
    pub procLink: SHM_QUEUE,
}
impl Default for PROCLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LOCALLOCKTAG {
    pub lock: LOCKTAG,
    pub mode: LOCKMODE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LOCALLOCKOWNER {
    pub owner: *mut ResourceOwnerData,
    pub nLocks: int64,
}
impl Default for LOCALLOCKOWNER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LOCALLOCK {
    pub tag: LOCALLOCKTAG,
    pub hashcode: uint32,
    pub lock: *mut LOCK,
    pub proclock: *mut PROCLOCK,
    pub nLocks: int64,
    pub numLockOwners: ::std::os::raw::c_int,
    pub maxLockOwners: ::std::os::raw::c_int,
    pub lockOwners: *mut LOCALLOCKOWNER,
    pub holdsStrongLockCount: bool,
    pub lockCleared: bool,
}
impl Default for LOCALLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LockInstanceData {
    pub locktag: LOCKTAG,
    pub holdMask: LOCKMASK,
    pub waitLockMode: LOCKMODE,
    pub backend: BackendId,
    pub lxid: LocalTransactionId,
    pub pid: ::std::os::raw::c_int,
    pub leaderPid: ::std::os::raw::c_int,
    pub fastpath: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LockData {
    pub nelements: ::std::os::raw::c_int,
    pub locks: *mut LockInstanceData,
}
impl Default for LockData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct BlockedProcData {
    pub pid: ::std::os::raw::c_int,
    pub first_lock: ::std::os::raw::c_int,
    pub num_locks: ::std::os::raw::c_int,
    pub first_waiter: ::std::os::raw::c_int,
    pub num_waiters: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BlockedProcsData {
    pub procs: *mut BlockedProcData,
    pub locks: *mut LockInstanceData,
    pub waiter_pids: *mut ::std::os::raw::c_int,
    pub nprocs: ::std::os::raw::c_int,
    pub maxprocs: ::std::os::raw::c_int,
    pub nlocks: ::std::os::raw::c_int,
    pub maxlocks: ::std::os::raw::c_int,
    pub npids: ::std::os::raw::c_int,
    pub maxpids: ::std::os::raw::c_int,
}
impl Default for BlockedProcsData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const LockAcquireResult_LOCKACQUIRE_NOT_AVAIL: LockAcquireResult = 0;
pub const LockAcquireResult_LOCKACQUIRE_OK: LockAcquireResult = 1;
pub const LockAcquireResult_LOCKACQUIRE_ALREADY_HELD: LockAcquireResult = 2;
pub const LockAcquireResult_LOCKACQUIRE_ALREADY_CLEAR: LockAcquireResult = 3;
pub type LockAcquireResult = ::std::os::raw::c_uint;
pub const DeadLockState_DS_NOT_YET_CHECKED: DeadLockState = 0;
pub const DeadLockState_DS_NO_DEADLOCK: DeadLockState = 1;
pub const DeadLockState_DS_SOFT_DEADLOCK: DeadLockState = 2;
pub const DeadLockState_DS_HARD_DEADLOCK: DeadLockState = 3;
pub const DeadLockState_DS_BLOCKED_BY_AUTOVACUUM: DeadLockState = 4;
pub type DeadLockState = ::std::os::raw::c_uint;
pub unsafe fn InitLocks() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitLocks();
        }
        InitLocks()
    })
}
pub unsafe fn GetLocksMethodTable(arg_lock: *const LOCK) -> LockMethod {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetLocksMethodTable(arg_lock: *const LOCK) -> LockMethod;
        }
        GetLocksMethodTable(arg_lock)
    })
}
pub unsafe fn GetLockTagsMethodTable(arg_locktag: *const LOCKTAG) -> LockMethod {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetLockTagsMethodTable(arg_locktag: *const LOCKTAG) -> LockMethod;
        }
        GetLockTagsMethodTable(arg_locktag)
    })
}
pub unsafe fn LockTagHashCode(arg_locktag: *const LOCKTAG) -> uint32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LockTagHashCode(arg_locktag: *const LOCKTAG) -> uint32;
        }
        LockTagHashCode(arg_locktag)
    })
}
pub unsafe fn DoLockModesConflict(arg_mode1: LOCKMODE, arg_mode2: LOCKMODE) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DoLockModesConflict(arg_mode1: LOCKMODE, arg_mode2: LOCKMODE) -> bool;
        }
        DoLockModesConflict(arg_mode1, arg_mode2)
    })
}
pub unsafe fn LockAcquire(
    arg_locktag: *const LOCKTAG,
    arg_lockmode: LOCKMODE,
    arg_sessionLock: bool,
    arg_dontWait: bool,
) -> LockAcquireResult {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LockAcquire(
                arg_locktag: *const LOCKTAG,
                arg_lockmode: LOCKMODE,
                arg_sessionLock: bool,
                arg_dontWait: bool,
            ) -> LockAcquireResult;
        }
        LockAcquire(arg_locktag, arg_lockmode, arg_sessionLock, arg_dontWait)
    })
}
pub unsafe fn LockAcquireExtended(
    arg_locktag: *const LOCKTAG,
    arg_lockmode: LOCKMODE,
    arg_sessionLock: bool,
    arg_dontWait: bool,
    arg_reportMemoryError: bool,
    arg_locallockp: *mut *mut LOCALLOCK,
) -> LockAcquireResult {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LockAcquireExtended(
                arg_locktag: *const LOCKTAG,
                arg_lockmode: LOCKMODE,
                arg_sessionLock: bool,
                arg_dontWait: bool,
                arg_reportMemoryError: bool,
                arg_locallockp: *mut *mut LOCALLOCK,
            ) -> LockAcquireResult;
        }
        LockAcquireExtended(
            arg_locktag,
            arg_lockmode,
            arg_sessionLock,
            arg_dontWait,
            arg_reportMemoryError,
            arg_locallockp,
        )
    })
}
pub unsafe fn AbortStrongLockAcquire() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AbortStrongLockAcquire();
        }
        AbortStrongLockAcquire()
    })
}
pub unsafe fn MarkLockClear(arg_locallock: *mut LOCALLOCK) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MarkLockClear(arg_locallock: *mut LOCALLOCK);
        }
        MarkLockClear(arg_locallock)
    })
}
pub unsafe fn LockRelease(
    arg_locktag: *const LOCKTAG,
    arg_lockmode: LOCKMODE,
    arg_sessionLock: bool,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LockRelease(
                arg_locktag: *const LOCKTAG,
                arg_lockmode: LOCKMODE,
                arg_sessionLock: bool,
            ) -> bool;
        }
        LockRelease(arg_locktag, arg_lockmode, arg_sessionLock)
    })
}
pub unsafe fn LockReleaseAll(arg_lockmethodid: LOCKMETHODID, arg_allLocks: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LockReleaseAll(arg_lockmethodid: LOCKMETHODID, arg_allLocks: bool);
        }
        LockReleaseAll(arg_lockmethodid, arg_allLocks)
    })
}
pub unsafe fn LockReleaseSession(arg_lockmethodid: LOCKMETHODID) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LockReleaseSession(arg_lockmethodid: LOCKMETHODID);
        }
        LockReleaseSession(arg_lockmethodid)
    })
}
pub unsafe fn LockReleaseCurrentOwner(
    arg_locallocks: *mut *mut LOCALLOCK,
    arg_nlocks: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LockReleaseCurrentOwner(
                arg_locallocks: *mut *mut LOCALLOCK,
                arg_nlocks: ::std::os::raw::c_int,
            );
        }
        LockReleaseCurrentOwner(arg_locallocks, arg_nlocks)
    })
}
pub unsafe fn LockReassignCurrentOwner(
    arg_locallocks: *mut *mut LOCALLOCK,
    arg_nlocks: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LockReassignCurrentOwner(
                arg_locallocks: *mut *mut LOCALLOCK,
                arg_nlocks: ::std::os::raw::c_int,
            );
        }
        LockReassignCurrentOwner(arg_locallocks, arg_nlocks)
    })
}
pub unsafe fn LockHeldByMe(arg_locktag: *const LOCKTAG, arg_lockmode: LOCKMODE) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LockHeldByMe(arg_locktag: *const LOCKTAG, arg_lockmode: LOCKMODE) -> bool;
        }
        LockHeldByMe(arg_locktag, arg_lockmode)
    })
}
pub unsafe fn GetLockMethodLocalHash() -> *mut HTAB {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetLockMethodLocalHash() -> *mut HTAB;
        }
        GetLockMethodLocalHash()
    })
}
pub unsafe fn LockHasWaiters(
    arg_locktag: *const LOCKTAG,
    arg_lockmode: LOCKMODE,
    arg_sessionLock: bool,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LockHasWaiters(
                arg_locktag: *const LOCKTAG,
                arg_lockmode: LOCKMODE,
                arg_sessionLock: bool,
            ) -> bool;
        }
        LockHasWaiters(arg_locktag, arg_lockmode, arg_sessionLock)
    })
}
pub unsafe fn GetLockConflicts(
    arg_locktag: *const LOCKTAG,
    arg_lockmode: LOCKMODE,
    arg_countp: *mut ::std::os::raw::c_int,
) -> *mut VirtualTransactionId {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetLockConflicts(
                arg_locktag: *const LOCKTAG,
                arg_lockmode: LOCKMODE,
                arg_countp: *mut ::std::os::raw::c_int,
            ) -> *mut VirtualTransactionId;
        }
        GetLockConflicts(arg_locktag, arg_lockmode, arg_countp)
    })
}
pub unsafe fn AtPrepare_Locks() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AtPrepare_Locks();
        }
        AtPrepare_Locks()
    })
}
pub unsafe fn PostPrepare_Locks(arg_xid: TransactionId) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PostPrepare_Locks(arg_xid: TransactionId);
        }
        PostPrepare_Locks(arg_xid)
    })
}
pub unsafe fn LockCheckConflicts(
    arg_lockMethodTable: LockMethod,
    arg_lockmode: LOCKMODE,
    arg_lock: *mut LOCK,
    arg_proclock: *mut PROCLOCK,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LockCheckConflicts(
                arg_lockMethodTable: LockMethod,
                arg_lockmode: LOCKMODE,
                arg_lock: *mut LOCK,
                arg_proclock: *mut PROCLOCK,
            ) -> bool;
        }
        LockCheckConflicts(arg_lockMethodTable, arg_lockmode, arg_lock, arg_proclock)
    })
}
pub unsafe fn GrantLock(arg_lock: *mut LOCK, arg_proclock: *mut PROCLOCK, arg_lockmode: LOCKMODE) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GrantLock(arg_lock: *mut LOCK, arg_proclock: *mut PROCLOCK, arg_lockmode: LOCKMODE);
        }
        GrantLock(arg_lock, arg_proclock, arg_lockmode)
    })
}
pub unsafe fn GrantAwaitedLock() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GrantAwaitedLock();
        }
        GrantAwaitedLock()
    })
}
pub unsafe fn RemoveFromWaitQueue(arg_proc_: *mut PGPROC, arg_hashcode: uint32) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RemoveFromWaitQueue(arg_proc_: *mut PGPROC, arg_hashcode: uint32);
        }
        RemoveFromWaitQueue(arg_proc_, arg_hashcode)
    })
}
pub unsafe fn LockShmemSize() -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LockShmemSize() -> Size;
        }
        LockShmemSize()
    })
}
pub unsafe fn GetLockStatusData() -> *mut LockData {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetLockStatusData() -> *mut LockData;
        }
        GetLockStatusData()
    })
}
pub unsafe fn GetBlockerStatusData(
    arg_blocked_pid: ::std::os::raw::c_int,
) -> *mut BlockedProcsData {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetBlockerStatusData(
                arg_blocked_pid: ::std::os::raw::c_int,
            ) -> *mut BlockedProcsData;
        }
        GetBlockerStatusData(arg_blocked_pid)
    })
}
pub unsafe fn GetRunningTransactionLocks(
    arg_nlocks: *mut ::std::os::raw::c_int,
) -> *mut xl_standby_lock {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetRunningTransactionLocks(
                arg_nlocks: *mut ::std::os::raw::c_int,
            ) -> *mut xl_standby_lock;
        }
        GetRunningTransactionLocks(arg_nlocks)
    })
}
pub unsafe fn GetLockmodeName(
    arg_lockmethodid: LOCKMETHODID,
    arg_mode: LOCKMODE,
) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetLockmodeName(
                arg_lockmethodid: LOCKMETHODID,
                arg_mode: LOCKMODE,
            ) -> *const ::std::os::raw::c_char;
        }
        GetLockmodeName(arg_lockmethodid, arg_mode)
    })
}
pub unsafe fn lock_twophase_recover(
    arg_xid: TransactionId,
    arg_info: uint16,
    arg_recdata: *mut ::std::os::raw::c_void,
    arg_len: uint32,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lock_twophase_recover(
                arg_xid: TransactionId,
                arg_info: uint16,
                arg_recdata: *mut ::std::os::raw::c_void,
                arg_len: uint32,
            );
        }
        lock_twophase_recover(arg_xid, arg_info, arg_recdata, arg_len)
    })
}
pub unsafe fn lock_twophase_postcommit(
    arg_xid: TransactionId,
    arg_info: uint16,
    arg_recdata: *mut ::std::os::raw::c_void,
    arg_len: uint32,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lock_twophase_postcommit(
                arg_xid: TransactionId,
                arg_info: uint16,
                arg_recdata: *mut ::std::os::raw::c_void,
                arg_len: uint32,
            );
        }
        lock_twophase_postcommit(arg_xid, arg_info, arg_recdata, arg_len)
    })
}
pub unsafe fn lock_twophase_postabort(
    arg_xid: TransactionId,
    arg_info: uint16,
    arg_recdata: *mut ::std::os::raw::c_void,
    arg_len: uint32,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lock_twophase_postabort(
                arg_xid: TransactionId,
                arg_info: uint16,
                arg_recdata: *mut ::std::os::raw::c_void,
                arg_len: uint32,
            );
        }
        lock_twophase_postabort(arg_xid, arg_info, arg_recdata, arg_len)
    })
}
pub unsafe fn lock_twophase_standby_recover(
    arg_xid: TransactionId,
    arg_info: uint16,
    arg_recdata: *mut ::std::os::raw::c_void,
    arg_len: uint32,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lock_twophase_standby_recover(
                arg_xid: TransactionId,
                arg_info: uint16,
                arg_recdata: *mut ::std::os::raw::c_void,
                arg_len: uint32,
            );
        }
        lock_twophase_standby_recover(arg_xid, arg_info, arg_recdata, arg_len)
    })
}
pub unsafe fn DeadLockCheck(arg_proc_: *mut PGPROC) -> DeadLockState {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DeadLockCheck(arg_proc_: *mut PGPROC) -> DeadLockState;
        }
        DeadLockCheck(arg_proc_)
    })
}
pub unsafe fn GetBlockingAutoVacuumPgproc() -> *mut PGPROC {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetBlockingAutoVacuumPgproc() -> *mut PGPROC;
        }
        GetBlockingAutoVacuumPgproc()
    })
}
pub unsafe fn DeadLockReport() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DeadLockReport();
        }
        DeadLockReport()
    })
}
pub unsafe fn RememberSimpleDeadLock(
    arg_proc1: *mut PGPROC,
    arg_lockmode: LOCKMODE,
    arg_lock: *mut LOCK,
    arg_proc2: *mut PGPROC,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RememberSimpleDeadLock(
                arg_proc1: *mut PGPROC,
                arg_lockmode: LOCKMODE,
                arg_lock: *mut LOCK,
                arg_proc2: *mut PGPROC,
            );
        }
        RememberSimpleDeadLock(arg_proc1, arg_lockmode, arg_lock, arg_proc2)
    })
}
pub unsafe fn InitDeadLockChecking() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitDeadLockChecking();
        }
        InitDeadLockChecking()
    })
}
pub unsafe fn LockWaiterCount(arg_locktag: *const LOCKTAG) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LockWaiterCount(arg_locktag: *const LOCKTAG) -> ::std::os::raw::c_int;
        }
        LockWaiterCount(arg_locktag)
    })
}
pub unsafe fn VirtualXactLockTableInsert(arg_vxid: VirtualTransactionId) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn VirtualXactLockTableInsert(arg_vxid: VirtualTransactionId);
        }
        VirtualXactLockTableInsert(arg_vxid)
    })
}
pub unsafe fn VirtualXactLockTableCleanup() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn VirtualXactLockTableCleanup();
        }
        VirtualXactLockTableCleanup()
    })
}
pub unsafe fn VirtualXactLock(arg_vxid: VirtualTransactionId, arg_wait: bool) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn VirtualXactLock(arg_vxid: VirtualTransactionId, arg_wait: bool) -> bool;
        }
        VirtualXactLock(arg_vxid, arg_wait)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PGSemaphoreData {
    _unused: [u8; 0],
}
pub type PGSemaphore = *mut PGSemaphoreData;
pub unsafe fn PGSemaphoreShmemSize(arg_maxSemas: ::std::os::raw::c_int) -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PGSemaphoreShmemSize(arg_maxSemas: ::std::os::raw::c_int) -> Size;
        }
        PGSemaphoreShmemSize(arg_maxSemas)
    })
}
pub unsafe fn PGReserveSemaphores(arg_maxSemas: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PGReserveSemaphores(arg_maxSemas: ::std::os::raw::c_int);
        }
        PGReserveSemaphores(arg_maxSemas)
    })
}
pub unsafe fn PGSemaphoreCreate() -> PGSemaphore {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PGSemaphoreCreate() -> PGSemaphore;
        }
        PGSemaphoreCreate()
    })
}
pub unsafe fn PGSemaphoreReset(arg_sema: PGSemaphore) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PGSemaphoreReset(arg_sema: PGSemaphore);
        }
        PGSemaphoreReset(arg_sema)
    })
}
pub unsafe fn PGSemaphoreLock(arg_sema: PGSemaphore) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PGSemaphoreLock(arg_sema: PGSemaphore);
        }
        PGSemaphoreLock(arg_sema)
    })
}
pub unsafe fn PGSemaphoreUnlock(arg_sema: PGSemaphore) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PGSemaphoreUnlock(arg_sema: PGSemaphore);
        }
        PGSemaphoreUnlock(arg_sema)
    })
}
pub unsafe fn PGSemaphoreTryLock(arg_sema: PGSemaphore) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PGSemaphoreTryLock(arg_sema: PGSemaphore) -> bool;
        }
        PGSemaphoreTryLock(arg_sema)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XidCache {
    pub xids: [TransactionId; 64usize],
}
impl Default for XidCache {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PGPROC {
    pub links: SHM_QUEUE,
    pub procgloballist: *mut *mut PGPROC,
    pub sem: PGSemaphore,
    pub waitStatus: ::std::os::raw::c_int,
    pub procLatch: Latch,
    pub lxid: LocalTransactionId,
    pub pid: ::std::os::raw::c_int,
    pub pgprocno: ::std::os::raw::c_int,
    pub backendId: BackendId,
    pub databaseId: Oid,
    pub roleId: Oid,
    pub tempNamespaceId: Oid,
    pub isBackgroundWorker: bool,
    pub recoveryConflictPending: bool,
    pub lwWaiting: bool,
    pub lwWaitMode: uint8,
    pub lwWaitLink: proclist_node,
    pub cvWaitLink: proclist_node,
    pub waitLock: *mut LOCK,
    pub waitProcLock: *mut PROCLOCK,
    pub waitLockMode: LOCKMODE,
    pub heldLocks: LOCKMASK,
    pub delayChkpt: bool,
    pub waitLSN: XLogRecPtr,
    pub syncRepState: ::std::os::raw::c_int,
    pub syncRepLinks: SHM_QUEUE,
    pub myProcLocks: [SHM_QUEUE; 16usize],
    pub subxids: XidCache,
    pub procArrayGroupMember: bool,
    pub procArrayGroupNext: pg_atomic_uint32,
    pub procArrayGroupMemberXid: TransactionId,
    pub wait_event_info: uint32,
    pub clogGroupMember: bool,
    pub clogGroupNext: pg_atomic_uint32,
    pub clogGroupMemberXid: TransactionId,
    pub clogGroupMemberXidStatus: XidStatus,
    pub clogGroupMemberPage: ::std::os::raw::c_int,
    pub clogGroupMemberLsn: XLogRecPtr,
    pub fpInfoLock: LWLock,
    pub fpLockBits: uint64,
    pub fpRelId: [Oid; 16usize],
    pub fpVXIDLock: bool,
    pub fpLocalTransactionId: LocalTransactionId,
    pub lockGroupLeader: *mut PGPROC,
    pub lockGroupMembers: dlist_head,
    pub lockGroupLink: dlist_node,
}
impl Default for PGPROC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut MyProc: *mut PGPROC;
}
extern "C" {
    pub static mut MyPgXact: *mut PGXACT;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PGXACT {
    pub xid: TransactionId,
    pub xmin: TransactionId,
    pub vacuumFlags: uint8,
    pub overflowed: bool,
    pub nxids: uint8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PROC_HDR {
    pub allProcs: *mut PGPROC,
    pub allPgXact: *mut PGXACT,
    pub allProcCount: uint32,
    pub freeProcs: *mut PGPROC,
    pub autovacFreeProcs: *mut PGPROC,
    pub bgworkerFreeProcs: *mut PGPROC,
    pub walsenderFreeProcs: *mut PGPROC,
    pub procArrayGroupFirst: pg_atomic_uint32,
    pub clogGroupFirst: pg_atomic_uint32,
    pub walwriterLatch: *mut Latch,
    pub checkpointerLatch: *mut Latch,
    pub spins_per_delay: ::std::os::raw::c_int,
    pub startupProc: *mut PGPROC,
    pub startupProcPid: ::std::os::raw::c_int,
    pub startupBufferPinWaitBufId: ::std::os::raw::c_int,
}
impl Default for PROC_HDR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut ProcGlobal: *mut PROC_HDR;
}
extern "C" {
    pub static mut PreparedXactProcs: *mut PGPROC;
}
extern "C" {
    pub static mut DeadlockTimeout: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut StatementTimeout: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut LockTimeout: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut IdleInTransactionSessionTimeout: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut log_lock_waits: bool;
}
pub unsafe fn ProcGlobalSemas() -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcGlobalSemas() -> ::std::os::raw::c_int;
        }
        ProcGlobalSemas()
    })
}
pub unsafe fn ProcGlobalShmemSize() -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcGlobalShmemSize() -> Size;
        }
        ProcGlobalShmemSize()
    })
}
pub unsafe fn InitProcGlobal() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitProcGlobal();
        }
        InitProcGlobal()
    })
}
pub unsafe fn InitProcess() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitProcess();
        }
        InitProcess()
    })
}
pub unsafe fn InitProcessPhase2() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitProcessPhase2();
        }
        InitProcessPhase2()
    })
}
pub unsafe fn InitAuxiliaryProcess() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitAuxiliaryProcess();
        }
        InitAuxiliaryProcess()
    })
}
pub unsafe fn PublishStartupProcessInformation() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PublishStartupProcessInformation();
        }
        PublishStartupProcessInformation()
    })
}
pub unsafe fn SetStartupBufferPinWaitBufId(arg_bufid: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SetStartupBufferPinWaitBufId(arg_bufid: ::std::os::raw::c_int);
        }
        SetStartupBufferPinWaitBufId(arg_bufid)
    })
}
pub unsafe fn GetStartupBufferPinWaitBufId() -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetStartupBufferPinWaitBufId() -> ::std::os::raw::c_int;
        }
        GetStartupBufferPinWaitBufId()
    })
}
pub unsafe fn HaveNFreeProcs(arg_n: ::std::os::raw::c_int) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn HaveNFreeProcs(arg_n: ::std::os::raw::c_int) -> bool;
        }
        HaveNFreeProcs(arg_n)
    })
}
pub unsafe fn ProcReleaseLocks(arg_isCommit: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcReleaseLocks(arg_isCommit: bool);
        }
        ProcReleaseLocks(arg_isCommit)
    })
}
pub unsafe fn ProcQueueInit(arg_queue: *mut PROC_QUEUE) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcQueueInit(arg_queue: *mut PROC_QUEUE);
        }
        ProcQueueInit(arg_queue)
    })
}
pub unsafe fn ProcSleep(
    arg_locallock: *mut LOCALLOCK,
    arg_lockMethodTable: LockMethod,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcSleep(
                arg_locallock: *mut LOCALLOCK,
                arg_lockMethodTable: LockMethod,
            ) -> ::std::os::raw::c_int;
        }
        ProcSleep(arg_locallock, arg_lockMethodTable)
    })
}
pub unsafe fn ProcWakeup(
    arg_proc_: *mut PGPROC,
    arg_waitStatus: ::std::os::raw::c_int,
) -> *mut PGPROC {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcWakeup(
                arg_proc_: *mut PGPROC,
                arg_waitStatus: ::std::os::raw::c_int,
            ) -> *mut PGPROC;
        }
        ProcWakeup(arg_proc_, arg_waitStatus)
    })
}
pub unsafe fn ProcLockWakeup(arg_lockMethodTable: LockMethod, arg_lock: *mut LOCK) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcLockWakeup(arg_lockMethodTable: LockMethod, arg_lock: *mut LOCK);
        }
        ProcLockWakeup(arg_lockMethodTable, arg_lock)
    })
}
pub unsafe fn CheckDeadLockAlert() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CheckDeadLockAlert();
        }
        CheckDeadLockAlert()
    })
}
pub unsafe fn IsWaitingForLock() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn IsWaitingForLock() -> bool;
        }
        IsWaitingForLock()
    })
}
pub unsafe fn LockErrorCleanup() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LockErrorCleanup();
        }
        LockErrorCleanup()
    })
}
pub unsafe fn ProcWaitForSignal(arg_wait_event_info: uint32) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcWaitForSignal(arg_wait_event_info: uint32);
        }
        ProcWaitForSignal(arg_wait_event_info)
    })
}
pub unsafe fn ProcSendSignal(arg_pid: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcSendSignal(arg_pid: ::std::os::raw::c_int);
        }
        ProcSendSignal(arg_pid)
    })
}
pub unsafe fn AuxiliaryPidGetProc(arg_pid: ::std::os::raw::c_int) -> *mut PGPROC {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AuxiliaryPidGetProc(arg_pid: ::std::os::raw::c_int) -> *mut PGPROC;
        }
        AuxiliaryPidGetProc(arg_pid)
    })
}
pub unsafe fn BecomeLockGroupLeader() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BecomeLockGroupLeader();
        }
        BecomeLockGroupLeader()
    })
}
pub unsafe fn BecomeLockGroupMember(
    arg_leader: *mut PGPROC,
    arg_pid: ::std::os::raw::c_int,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BecomeLockGroupMember(
                arg_leader: *mut PGPROC,
                arg_pid: ::std::os::raw::c_int,
            ) -> bool;
        }
        BecomeLockGroupMember(arg_leader, arg_pid)
    })
}
pub const TrackFunctionsLevel_TRACK_FUNC_OFF: TrackFunctionsLevel = 0;
pub const TrackFunctionsLevel_TRACK_FUNC_PL: TrackFunctionsLevel = 1;
pub const TrackFunctionsLevel_TRACK_FUNC_ALL: TrackFunctionsLevel = 2;
pub type TrackFunctionsLevel = ::std::os::raw::c_uint;
pub const StatMsgType_PGSTAT_MTYPE_DUMMY: StatMsgType = 0;
pub const StatMsgType_PGSTAT_MTYPE_INQUIRY: StatMsgType = 1;
pub const StatMsgType_PGSTAT_MTYPE_TABSTAT: StatMsgType = 2;
pub const StatMsgType_PGSTAT_MTYPE_TABPURGE: StatMsgType = 3;
pub const StatMsgType_PGSTAT_MTYPE_DROPDB: StatMsgType = 4;
pub const StatMsgType_PGSTAT_MTYPE_RESETCOUNTER: StatMsgType = 5;
pub const StatMsgType_PGSTAT_MTYPE_RESETSHAREDCOUNTER: StatMsgType = 6;
pub const StatMsgType_PGSTAT_MTYPE_RESETSINGLECOUNTER: StatMsgType = 7;
pub const StatMsgType_PGSTAT_MTYPE_RESETSLRUCOUNTER: StatMsgType = 8;
pub const StatMsgType_PGSTAT_MTYPE_AUTOVAC_START: StatMsgType = 9;
pub const StatMsgType_PGSTAT_MTYPE_VACUUM: StatMsgType = 10;
pub const StatMsgType_PGSTAT_MTYPE_ANALYZE: StatMsgType = 11;
pub const StatMsgType_PGSTAT_MTYPE_ARCHIVER: StatMsgType = 12;
pub const StatMsgType_PGSTAT_MTYPE_BGWRITER: StatMsgType = 13;
pub const StatMsgType_PGSTAT_MTYPE_SLRU: StatMsgType = 14;
pub const StatMsgType_PGSTAT_MTYPE_FUNCSTAT: StatMsgType = 15;
pub const StatMsgType_PGSTAT_MTYPE_FUNCPURGE: StatMsgType = 16;
pub const StatMsgType_PGSTAT_MTYPE_RECOVERYCONFLICT: StatMsgType = 17;
pub const StatMsgType_PGSTAT_MTYPE_TEMPFILE: StatMsgType = 18;
pub const StatMsgType_PGSTAT_MTYPE_DEADLOCK: StatMsgType = 19;
pub const StatMsgType_PGSTAT_MTYPE_CHECKSUMFAILURE: StatMsgType = 20;
pub type StatMsgType = ::std::os::raw::c_uint;
pub type PgStat_Counter = int64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_TableCounts {
    pub t_numscans: PgStat_Counter,
    pub t_tuples_returned: PgStat_Counter,
    pub t_tuples_fetched: PgStat_Counter,
    pub t_tuples_inserted: PgStat_Counter,
    pub t_tuples_updated: PgStat_Counter,
    pub t_tuples_deleted: PgStat_Counter,
    pub t_tuples_hot_updated: PgStat_Counter,
    pub t_truncated: bool,
    pub t_delta_live_tuples: PgStat_Counter,
    pub t_delta_dead_tuples: PgStat_Counter,
    pub t_changed_tuples: PgStat_Counter,
    pub t_blocks_fetched: PgStat_Counter,
    pub t_blocks_hit: PgStat_Counter,
}
pub const PgStat_Shared_Reset_Target_RESET_ARCHIVER: PgStat_Shared_Reset_Target = 0;
pub const PgStat_Shared_Reset_Target_RESET_BGWRITER: PgStat_Shared_Reset_Target = 1;
pub type PgStat_Shared_Reset_Target = ::std::os::raw::c_uint;
pub const PgStat_Single_Reset_Type_RESET_TABLE: PgStat_Single_Reset_Type = 0;
pub const PgStat_Single_Reset_Type_RESET_FUNCTION: PgStat_Single_Reset_Type = 1;
pub type PgStat_Single_Reset_Type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_TableStatus {
    pub t_id: Oid,
    pub t_shared: bool,
    pub trans: *mut PgStat_TableXactStatus,
    pub t_counts: PgStat_TableCounts,
}
impl Default for PgStat_TableStatus {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_TableXactStatus {
    pub tuples_inserted: PgStat_Counter,
    pub tuples_updated: PgStat_Counter,
    pub tuples_deleted: PgStat_Counter,
    pub truncated: bool,
    pub inserted_pre_trunc: PgStat_Counter,
    pub updated_pre_trunc: PgStat_Counter,
    pub deleted_pre_trunc: PgStat_Counter,
    pub nest_level: ::std::os::raw::c_int,
    pub upper: *mut PgStat_TableXactStatus,
    pub parent: *mut PgStat_TableStatus,
    pub next: *mut PgStat_TableXactStatus,
}
impl Default for PgStat_TableXactStatus {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_MsgHdr {
    pub m_type: StatMsgType,
    pub m_size: ::std::os::raw::c_int,
}
impl Default for PgStat_MsgHdr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_MsgDummy {
    pub m_hdr: PgStat_MsgHdr,
}
impl Default for PgStat_MsgDummy {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_MsgInquiry {
    pub m_hdr: PgStat_MsgHdr,
    pub clock_time: TimestampTz,
    pub cutoff_time: TimestampTz,
    pub databaseid: Oid,
}
impl Default for PgStat_MsgInquiry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_TableEntry {
    pub t_id: Oid,
    pub t_counts: PgStat_TableCounts,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_MsgTabstat {
    pub m_hdr: PgStat_MsgHdr,
    pub m_databaseid: Oid,
    pub m_nentries: ::std::os::raw::c_int,
    pub m_xact_commit: ::std::os::raw::c_int,
    pub m_xact_rollback: ::std::os::raw::c_int,
    pub m_block_read_time: PgStat_Counter,
    pub m_block_write_time: PgStat_Counter,
    pub m_entry: [PgStat_TableEntry; 8usize],
}
impl Default for PgStat_MsgTabstat {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_MsgTabpurge {
    pub m_hdr: PgStat_MsgHdr,
    pub m_databaseid: Oid,
    pub m_nentries: ::std::os::raw::c_int,
    pub m_tableid: [Oid; 246usize],
}
impl Default for PgStat_MsgTabpurge {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_MsgDropdb {
    pub m_hdr: PgStat_MsgHdr,
    pub m_databaseid: Oid,
}
impl Default for PgStat_MsgDropdb {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_MsgResetcounter {
    pub m_hdr: PgStat_MsgHdr,
    pub m_databaseid: Oid,
}
impl Default for PgStat_MsgResetcounter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_MsgResetsharedcounter {
    pub m_hdr: PgStat_MsgHdr,
    pub m_resettarget: PgStat_Shared_Reset_Target,
}
impl Default for PgStat_MsgResetsharedcounter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_MsgResetsinglecounter {
    pub m_hdr: PgStat_MsgHdr,
    pub m_databaseid: Oid,
    pub m_resettype: PgStat_Single_Reset_Type,
    pub m_objectid: Oid,
}
impl Default for PgStat_MsgResetsinglecounter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_MsgResetslrucounter {
    pub m_hdr: PgStat_MsgHdr,
    pub m_index: ::std::os::raw::c_int,
}
impl Default for PgStat_MsgResetslrucounter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_MsgAutovacStart {
    pub m_hdr: PgStat_MsgHdr,
    pub m_databaseid: Oid,
    pub m_start_time: TimestampTz,
}
impl Default for PgStat_MsgAutovacStart {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_MsgVacuum {
    pub m_hdr: PgStat_MsgHdr,
    pub m_databaseid: Oid,
    pub m_tableoid: Oid,
    pub m_autovacuum: bool,
    pub m_vacuumtime: TimestampTz,
    pub m_live_tuples: PgStat_Counter,
    pub m_dead_tuples: PgStat_Counter,
}
impl Default for PgStat_MsgVacuum {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_MsgAnalyze {
    pub m_hdr: PgStat_MsgHdr,
    pub m_databaseid: Oid,
    pub m_tableoid: Oid,
    pub m_autovacuum: bool,
    pub m_resetcounter: bool,
    pub m_analyzetime: TimestampTz,
    pub m_live_tuples: PgStat_Counter,
    pub m_dead_tuples: PgStat_Counter,
}
impl Default for PgStat_MsgAnalyze {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_MsgArchiver {
    pub m_hdr: PgStat_MsgHdr,
    pub m_failed: bool,
    pub m_xlog: [::std::os::raw::c_char; 41usize],
    pub m_timestamp: TimestampTz,
}
impl Default for PgStat_MsgArchiver {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_MsgBgWriter {
    pub m_hdr: PgStat_MsgHdr,
    pub m_timed_checkpoints: PgStat_Counter,
    pub m_requested_checkpoints: PgStat_Counter,
    pub m_buf_written_checkpoints: PgStat_Counter,
    pub m_buf_written_clean: PgStat_Counter,
    pub m_maxwritten_clean: PgStat_Counter,
    pub m_buf_written_backend: PgStat_Counter,
    pub m_buf_fsync_backend: PgStat_Counter,
    pub m_buf_alloc: PgStat_Counter,
    pub m_checkpoint_write_time: PgStat_Counter,
    pub m_checkpoint_sync_time: PgStat_Counter,
}
impl Default for PgStat_MsgBgWriter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_MsgSLRU {
    pub m_hdr: PgStat_MsgHdr,
    pub m_index: PgStat_Counter,
    pub m_blocks_zeroed: PgStat_Counter,
    pub m_blocks_hit: PgStat_Counter,
    pub m_blocks_read: PgStat_Counter,
    pub m_blocks_written: PgStat_Counter,
    pub m_blocks_exists: PgStat_Counter,
    pub m_flush: PgStat_Counter,
    pub m_truncate: PgStat_Counter,
}
impl Default for PgStat_MsgSLRU {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_MsgRecoveryConflict {
    pub m_hdr: PgStat_MsgHdr,
    pub m_databaseid: Oid,
    pub m_reason: ::std::os::raw::c_int,
}
impl Default for PgStat_MsgRecoveryConflict {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_MsgTempFile {
    pub m_hdr: PgStat_MsgHdr,
    pub m_databaseid: Oid,
    pub m_filesize: usize,
}
impl Default for PgStat_MsgTempFile {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_FunctionCounts {
    pub f_numcalls: PgStat_Counter,
    pub f_total_time: instr_time,
    pub f_self_time: instr_time,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_BackendFunctionEntry {
    pub f_id: Oid,
    pub f_counts: PgStat_FunctionCounts,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_FunctionEntry {
    pub f_id: Oid,
    pub f_numcalls: PgStat_Counter,
    pub f_total_time: PgStat_Counter,
    pub f_self_time: PgStat_Counter,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_MsgFuncstat {
    pub m_hdr: PgStat_MsgHdr,
    pub m_databaseid: Oid,
    pub m_nentries: ::std::os::raw::c_int,
    pub m_entry: [PgStat_FunctionEntry; 30usize],
}
impl Default for PgStat_MsgFuncstat {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_MsgFuncpurge {
    pub m_hdr: PgStat_MsgHdr,
    pub m_databaseid: Oid,
    pub m_nentries: ::std::os::raw::c_int,
    pub m_functionid: [Oid; 246usize],
}
impl Default for PgStat_MsgFuncpurge {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_MsgDeadlock {
    pub m_hdr: PgStat_MsgHdr,
    pub m_databaseid: Oid,
}
impl Default for PgStat_MsgDeadlock {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_MsgChecksumFailure {
    pub m_hdr: PgStat_MsgHdr,
    pub m_databaseid: Oid,
    pub m_failurecount: ::std::os::raw::c_int,
    pub m_failure_time: TimestampTz,
}
impl Default for PgStat_MsgChecksumFailure {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PgStat_Msg {
    pub msg_hdr: PgStat_MsgHdr,
    pub msg_dummy: PgStat_MsgDummy,
    pub msg_inquiry: PgStat_MsgInquiry,
    pub msg_tabstat: PgStat_MsgTabstat,
    pub msg_tabpurge: PgStat_MsgTabpurge,
    pub msg_dropdb: PgStat_MsgDropdb,
    pub msg_resetcounter: PgStat_MsgResetcounter,
    pub msg_resetsharedcounter: PgStat_MsgResetsharedcounter,
    pub msg_resetsinglecounter: PgStat_MsgResetsinglecounter,
    pub msg_resetslrucounter: PgStat_MsgResetslrucounter,
    pub msg_autovacuum_start: PgStat_MsgAutovacStart,
    pub msg_vacuum: PgStat_MsgVacuum,
    pub msg_analyze: PgStat_MsgAnalyze,
    pub msg_archiver: PgStat_MsgArchiver,
    pub msg_bgwriter: PgStat_MsgBgWriter,
    pub msg_slru: PgStat_MsgSLRU,
    pub msg_funcstat: PgStat_MsgFuncstat,
    pub msg_funcpurge: PgStat_MsgFuncpurge,
    pub msg_recoveryconflict: PgStat_MsgRecoveryConflict,
    pub msg_deadlock: PgStat_MsgDeadlock,
    pub msg_tempfile: PgStat_MsgTempFile,
    pub msg_checksumfailure: PgStat_MsgChecksumFailure,
}
impl Default for PgStat_Msg {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_StatDBEntry {
    pub databaseid: Oid,
    pub n_xact_commit: PgStat_Counter,
    pub n_xact_rollback: PgStat_Counter,
    pub n_blocks_fetched: PgStat_Counter,
    pub n_blocks_hit: PgStat_Counter,
    pub n_tuples_returned: PgStat_Counter,
    pub n_tuples_fetched: PgStat_Counter,
    pub n_tuples_inserted: PgStat_Counter,
    pub n_tuples_updated: PgStat_Counter,
    pub n_tuples_deleted: PgStat_Counter,
    pub last_autovac_time: TimestampTz,
    pub n_conflict_tablespace: PgStat_Counter,
    pub n_conflict_lock: PgStat_Counter,
    pub n_conflict_snapshot: PgStat_Counter,
    pub n_conflict_bufferpin: PgStat_Counter,
    pub n_conflict_startup_deadlock: PgStat_Counter,
    pub n_temp_files: PgStat_Counter,
    pub n_temp_bytes: PgStat_Counter,
    pub n_deadlocks: PgStat_Counter,
    pub n_checksum_failures: PgStat_Counter,
    pub last_checksum_failure: TimestampTz,
    pub n_block_read_time: PgStat_Counter,
    pub n_block_write_time: PgStat_Counter,
    pub stat_reset_timestamp: TimestampTz,
    pub stats_timestamp: TimestampTz,
    pub tables: *mut HTAB,
    pub functions: *mut HTAB,
}
impl Default for PgStat_StatDBEntry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_StatTabEntry {
    pub tableid: Oid,
    pub numscans: PgStat_Counter,
    pub tuples_returned: PgStat_Counter,
    pub tuples_fetched: PgStat_Counter,
    pub tuples_inserted: PgStat_Counter,
    pub tuples_updated: PgStat_Counter,
    pub tuples_deleted: PgStat_Counter,
    pub tuples_hot_updated: PgStat_Counter,
    pub n_live_tuples: PgStat_Counter,
    pub n_dead_tuples: PgStat_Counter,
    pub changes_since_analyze: PgStat_Counter,
    pub inserts_since_vacuum: PgStat_Counter,
    pub blocks_fetched: PgStat_Counter,
    pub blocks_hit: PgStat_Counter,
    pub vacuum_timestamp: TimestampTz,
    pub vacuum_count: PgStat_Counter,
    pub autovac_vacuum_timestamp: TimestampTz,
    pub autovac_vacuum_count: PgStat_Counter,
    pub analyze_timestamp: TimestampTz,
    pub analyze_count: PgStat_Counter,
    pub autovac_analyze_timestamp: TimestampTz,
    pub autovac_analyze_count: PgStat_Counter,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_StatFuncEntry {
    pub functionid: Oid,
    pub f_numcalls: PgStat_Counter,
    pub f_total_time: PgStat_Counter,
    pub f_self_time: PgStat_Counter,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_ArchiverStats {
    pub archived_count: PgStat_Counter,
    pub last_archived_wal: [::std::os::raw::c_char; 41usize],
    pub last_archived_timestamp: TimestampTz,
    pub failed_count: PgStat_Counter,
    pub last_failed_wal: [::std::os::raw::c_char; 41usize],
    pub last_failed_timestamp: TimestampTz,
    pub stat_reset_timestamp: TimestampTz,
}
impl Default for PgStat_ArchiverStats {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_GlobalStats {
    pub stats_timestamp: TimestampTz,
    pub timed_checkpoints: PgStat_Counter,
    pub requested_checkpoints: PgStat_Counter,
    pub checkpoint_write_time: PgStat_Counter,
    pub checkpoint_sync_time: PgStat_Counter,
    pub buf_written_checkpoints: PgStat_Counter,
    pub buf_written_clean: PgStat_Counter,
    pub maxwritten_clean: PgStat_Counter,
    pub buf_written_backend: PgStat_Counter,
    pub buf_fsync_backend: PgStat_Counter,
    pub buf_alloc: PgStat_Counter,
    pub stat_reset_timestamp: TimestampTz,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PgStat_SLRUStats {
    pub blocks_zeroed: PgStat_Counter,
    pub blocks_hit: PgStat_Counter,
    pub blocks_read: PgStat_Counter,
    pub blocks_written: PgStat_Counter,
    pub blocks_exists: PgStat_Counter,
    pub flush: PgStat_Counter,
    pub truncate: PgStat_Counter,
    pub stat_reset_timestamp: TimestampTz,
}
pub const BackendState_STATE_UNDEFINED: BackendState = 0;
pub const BackendState_STATE_IDLE: BackendState = 1;
pub const BackendState_STATE_RUNNING: BackendState = 2;
pub const BackendState_STATE_IDLEINTRANSACTION: BackendState = 3;
pub const BackendState_STATE_FASTPATH: BackendState = 4;
pub const BackendState_STATE_IDLEINTRANSACTION_ABORTED: BackendState = 5;
pub const BackendState_STATE_DISABLED: BackendState = 6;
pub type BackendState = ::std::os::raw::c_uint;
pub const WaitEventActivity_WAIT_EVENT_ARCHIVER_MAIN: WaitEventActivity = 83886080;
pub const WaitEventActivity_WAIT_EVENT_AUTOVACUUM_MAIN: WaitEventActivity = 83886081;
pub const WaitEventActivity_WAIT_EVENT_BGWRITER_HIBERNATE: WaitEventActivity = 83886082;
pub const WaitEventActivity_WAIT_EVENT_BGWRITER_MAIN: WaitEventActivity = 83886083;
pub const WaitEventActivity_WAIT_EVENT_CHECKPOINTER_MAIN: WaitEventActivity = 83886084;
pub const WaitEventActivity_WAIT_EVENT_LOGICAL_APPLY_MAIN: WaitEventActivity = 83886085;
pub const WaitEventActivity_WAIT_EVENT_LOGICAL_LAUNCHER_MAIN: WaitEventActivity = 83886086;
pub const WaitEventActivity_WAIT_EVENT_PGSTAT_MAIN: WaitEventActivity = 83886087;
pub const WaitEventActivity_WAIT_EVENT_RECOVERY_WAL_STREAM: WaitEventActivity = 83886088;
pub const WaitEventActivity_WAIT_EVENT_SYSLOGGER_MAIN: WaitEventActivity = 83886089;
pub const WaitEventActivity_WAIT_EVENT_WAL_RECEIVER_MAIN: WaitEventActivity = 83886090;
pub const WaitEventActivity_WAIT_EVENT_WAL_SENDER_MAIN: WaitEventActivity = 83886091;
pub const WaitEventActivity_WAIT_EVENT_WAL_WRITER_MAIN: WaitEventActivity = 83886092;
pub type WaitEventActivity = ::std::os::raw::c_uint;
pub const WaitEventClient_WAIT_EVENT_CLIENT_READ: WaitEventClient = 100663296;
pub const WaitEventClient_WAIT_EVENT_CLIENT_WRITE: WaitEventClient = 100663297;
pub const WaitEventClient_WAIT_EVENT_GSS_OPEN_SERVER: WaitEventClient = 100663298;
pub const WaitEventClient_WAIT_EVENT_LIBPQWALRECEIVER_CONNECT: WaitEventClient = 100663299;
pub const WaitEventClient_WAIT_EVENT_LIBPQWALRECEIVER_RECEIVE: WaitEventClient = 100663300;
pub const WaitEventClient_WAIT_EVENT_SSL_OPEN_SERVER: WaitEventClient = 100663301;
pub const WaitEventClient_WAIT_EVENT_WAL_RECEIVER_WAIT_START: WaitEventClient = 100663302;
pub const WaitEventClient_WAIT_EVENT_WAL_SENDER_WAIT_WAL: WaitEventClient = 100663303;
pub const WaitEventClient_WAIT_EVENT_WAL_SENDER_WRITE_DATA: WaitEventClient = 100663304;
pub type WaitEventClient = ::std::os::raw::c_uint;
pub const WaitEventIPC_WAIT_EVENT_BACKUP_WAIT_WAL_ARCHIVE: WaitEventIPC = 134217728;
pub const WaitEventIPC_WAIT_EVENT_BGWORKER_SHUTDOWN: WaitEventIPC = 134217729;
pub const WaitEventIPC_WAIT_EVENT_BGWORKER_STARTUP: WaitEventIPC = 134217730;
pub const WaitEventIPC_WAIT_EVENT_BTREE_PAGE: WaitEventIPC = 134217731;
pub const WaitEventIPC_WAIT_EVENT_CHECKPOINT_DONE: WaitEventIPC = 134217732;
pub const WaitEventIPC_WAIT_EVENT_CHECKPOINT_START: WaitEventIPC = 134217733;
pub const WaitEventIPC_WAIT_EVENT_EXECUTE_GATHER: WaitEventIPC = 134217734;
pub const WaitEventIPC_WAIT_EVENT_HASH_BATCH_ALLOCATE: WaitEventIPC = 134217735;
pub const WaitEventIPC_WAIT_EVENT_HASH_BATCH_ELECT: WaitEventIPC = 134217736;
pub const WaitEventIPC_WAIT_EVENT_HASH_BATCH_LOAD: WaitEventIPC = 134217737;
pub const WaitEventIPC_WAIT_EVENT_HASH_BUILD_ALLOCATE: WaitEventIPC = 134217738;
pub const WaitEventIPC_WAIT_EVENT_HASH_BUILD_ELECT: WaitEventIPC = 134217739;
pub const WaitEventIPC_WAIT_EVENT_HASH_BUILD_HASH_INNER: WaitEventIPC = 134217740;
pub const WaitEventIPC_WAIT_EVENT_HASH_BUILD_HASH_OUTER: WaitEventIPC = 134217741;
pub const WaitEventIPC_WAIT_EVENT_HASH_GROW_BATCHES_ALLOCATE: WaitEventIPC = 134217742;
pub const WaitEventIPC_WAIT_EVENT_HASH_GROW_BATCHES_DECIDE: WaitEventIPC = 134217743;
pub const WaitEventIPC_WAIT_EVENT_HASH_GROW_BATCHES_ELECT: WaitEventIPC = 134217744;
pub const WaitEventIPC_WAIT_EVENT_HASH_GROW_BATCHES_FINISH: WaitEventIPC = 134217745;
pub const WaitEventIPC_WAIT_EVENT_HASH_GROW_BATCHES_REPARTITION: WaitEventIPC = 134217746;
pub const WaitEventIPC_WAIT_EVENT_HASH_GROW_BUCKETS_ALLOCATE: WaitEventIPC = 134217747;
pub const WaitEventIPC_WAIT_EVENT_HASH_GROW_BUCKETS_ELECT: WaitEventIPC = 134217748;
pub const WaitEventIPC_WAIT_EVENT_HASH_GROW_BUCKETS_REINSERT: WaitEventIPC = 134217749;
pub const WaitEventIPC_WAIT_EVENT_LOGICAL_SYNC_DATA: WaitEventIPC = 134217750;
pub const WaitEventIPC_WAIT_EVENT_LOGICAL_SYNC_STATE_CHANGE: WaitEventIPC = 134217751;
pub const WaitEventIPC_WAIT_EVENT_MQ_INTERNAL: WaitEventIPC = 134217752;
pub const WaitEventIPC_WAIT_EVENT_MQ_PUT_MESSAGE: WaitEventIPC = 134217753;
pub const WaitEventIPC_WAIT_EVENT_MQ_RECEIVE: WaitEventIPC = 134217754;
pub const WaitEventIPC_WAIT_EVENT_MQ_SEND: WaitEventIPC = 134217755;
pub const WaitEventIPC_WAIT_EVENT_PARALLEL_BITMAP_SCAN: WaitEventIPC = 134217756;
pub const WaitEventIPC_WAIT_EVENT_PARALLEL_CREATE_INDEX_SCAN: WaitEventIPC = 134217757;
pub const WaitEventIPC_WAIT_EVENT_PARALLEL_FINISH: WaitEventIPC = 134217758;
pub const WaitEventIPC_WAIT_EVENT_PROCARRAY_GROUP_UPDATE: WaitEventIPC = 134217759;
pub const WaitEventIPC_WAIT_EVENT_PROC_SIGNAL_BARRIER: WaitEventIPC = 134217760;
pub const WaitEventIPC_WAIT_EVENT_PROMOTE: WaitEventIPC = 134217761;
pub const WaitEventIPC_WAIT_EVENT_RECOVERY_CONFLICT_SNAPSHOT: WaitEventIPC = 134217762;
pub const WaitEventIPC_WAIT_EVENT_RECOVERY_CONFLICT_TABLESPACE: WaitEventIPC = 134217763;
pub const WaitEventIPC_WAIT_EVENT_RECOVERY_PAUSE: WaitEventIPC = 134217764;
pub const WaitEventIPC_WAIT_EVENT_REPLICATION_ORIGIN_DROP: WaitEventIPC = 134217765;
pub const WaitEventIPC_WAIT_EVENT_REPLICATION_SLOT_DROP: WaitEventIPC = 134217766;
pub const WaitEventIPC_WAIT_EVENT_SAFE_SNAPSHOT: WaitEventIPC = 134217767;
pub const WaitEventIPC_WAIT_EVENT_SYNC_REP: WaitEventIPC = 134217768;
pub const WaitEventIPC_WAIT_EVENT_XACT_GROUP_UPDATE: WaitEventIPC = 134217769;
pub type WaitEventIPC = ::std::os::raw::c_uint;
pub const WaitEventTimeout_WAIT_EVENT_BASE_BACKUP_THROTTLE: WaitEventTimeout = 150994944;
pub const WaitEventTimeout_WAIT_EVENT_PG_SLEEP: WaitEventTimeout = 150994945;
pub const WaitEventTimeout_WAIT_EVENT_RECOVERY_APPLY_DELAY: WaitEventTimeout = 150994946;
pub const WaitEventTimeout_WAIT_EVENT_RECOVERY_RETRIEVE_RETRY_INTERVAL: WaitEventTimeout =
    150994947;
pub const WaitEventTimeout_WAIT_EVENT_VACUUM_DELAY: WaitEventTimeout = 150994948;
pub type WaitEventTimeout = ::std::os::raw::c_uint;
pub const WaitEventIO_WAIT_EVENT_BUFFILE_READ: WaitEventIO = 167772160;
pub const WaitEventIO_WAIT_EVENT_BUFFILE_WRITE: WaitEventIO = 167772161;
pub const WaitEventIO_WAIT_EVENT_CONTROL_FILE_READ: WaitEventIO = 167772162;
pub const WaitEventIO_WAIT_EVENT_CONTROL_FILE_SYNC: WaitEventIO = 167772163;
pub const WaitEventIO_WAIT_EVENT_CONTROL_FILE_SYNC_UPDATE: WaitEventIO = 167772164;
pub const WaitEventIO_WAIT_EVENT_CONTROL_FILE_WRITE: WaitEventIO = 167772165;
pub const WaitEventIO_WAIT_EVENT_CONTROL_FILE_WRITE_UPDATE: WaitEventIO = 167772166;
pub const WaitEventIO_WAIT_EVENT_COPY_FILE_READ: WaitEventIO = 167772167;
pub const WaitEventIO_WAIT_EVENT_COPY_FILE_WRITE: WaitEventIO = 167772168;
pub const WaitEventIO_WAIT_EVENT_DATA_FILE_EXTEND: WaitEventIO = 167772169;
pub const WaitEventIO_WAIT_EVENT_DATA_FILE_FLUSH: WaitEventIO = 167772170;
pub const WaitEventIO_WAIT_EVENT_DATA_FILE_IMMEDIATE_SYNC: WaitEventIO = 167772171;
pub const WaitEventIO_WAIT_EVENT_DATA_FILE_PREFETCH: WaitEventIO = 167772172;
pub const WaitEventIO_WAIT_EVENT_DATA_FILE_READ: WaitEventIO = 167772173;
pub const WaitEventIO_WAIT_EVENT_DATA_FILE_SYNC: WaitEventIO = 167772174;
pub const WaitEventIO_WAIT_EVENT_DATA_FILE_TRUNCATE: WaitEventIO = 167772175;
pub const WaitEventIO_WAIT_EVENT_DATA_FILE_WRITE: WaitEventIO = 167772176;
pub const WaitEventIO_WAIT_EVENT_DSM_FILL_ZERO_WRITE: WaitEventIO = 167772177;
pub const WaitEventIO_WAIT_EVENT_LOCK_FILE_ADDTODATADIR_READ: WaitEventIO = 167772178;
pub const WaitEventIO_WAIT_EVENT_LOCK_FILE_ADDTODATADIR_SYNC: WaitEventIO = 167772179;
pub const WaitEventIO_WAIT_EVENT_LOCK_FILE_ADDTODATADIR_WRITE: WaitEventIO = 167772180;
pub const WaitEventIO_WAIT_EVENT_LOCK_FILE_CREATE_READ: WaitEventIO = 167772181;
pub const WaitEventIO_WAIT_EVENT_LOCK_FILE_CREATE_SYNC: WaitEventIO = 167772182;
pub const WaitEventIO_WAIT_EVENT_LOCK_FILE_CREATE_WRITE: WaitEventIO = 167772183;
pub const WaitEventIO_WAIT_EVENT_LOCK_FILE_RECHECKDATADIR_READ: WaitEventIO = 167772184;
pub const WaitEventIO_WAIT_EVENT_LOGICAL_REWRITE_CHECKPOINT_SYNC: WaitEventIO = 167772185;
pub const WaitEventIO_WAIT_EVENT_LOGICAL_REWRITE_MAPPING_SYNC: WaitEventIO = 167772186;
pub const WaitEventIO_WAIT_EVENT_LOGICAL_REWRITE_MAPPING_WRITE: WaitEventIO = 167772187;
pub const WaitEventIO_WAIT_EVENT_LOGICAL_REWRITE_SYNC: WaitEventIO = 167772188;
pub const WaitEventIO_WAIT_EVENT_LOGICAL_REWRITE_TRUNCATE: WaitEventIO = 167772189;
pub const WaitEventIO_WAIT_EVENT_LOGICAL_REWRITE_WRITE: WaitEventIO = 167772190;
pub const WaitEventIO_WAIT_EVENT_RELATION_MAP_READ: WaitEventIO = 167772191;
pub const WaitEventIO_WAIT_EVENT_RELATION_MAP_SYNC: WaitEventIO = 167772192;
pub const WaitEventIO_WAIT_EVENT_RELATION_MAP_WRITE: WaitEventIO = 167772193;
pub const WaitEventIO_WAIT_EVENT_REORDER_BUFFER_READ: WaitEventIO = 167772194;
pub const WaitEventIO_WAIT_EVENT_REORDER_BUFFER_WRITE: WaitEventIO = 167772195;
pub const WaitEventIO_WAIT_EVENT_REORDER_LOGICAL_MAPPING_READ: WaitEventIO = 167772196;
pub const WaitEventIO_WAIT_EVENT_REPLICATION_SLOT_READ: WaitEventIO = 167772197;
pub const WaitEventIO_WAIT_EVENT_REPLICATION_SLOT_RESTORE_SYNC: WaitEventIO = 167772198;
pub const WaitEventIO_WAIT_EVENT_REPLICATION_SLOT_SYNC: WaitEventIO = 167772199;
pub const WaitEventIO_WAIT_EVENT_REPLICATION_SLOT_WRITE: WaitEventIO = 167772200;
pub const WaitEventIO_WAIT_EVENT_SLRU_FLUSH_SYNC: WaitEventIO = 167772201;
pub const WaitEventIO_WAIT_EVENT_SLRU_READ: WaitEventIO = 167772202;
pub const WaitEventIO_WAIT_EVENT_SLRU_SYNC: WaitEventIO = 167772203;
pub const WaitEventIO_WAIT_EVENT_SLRU_WRITE: WaitEventIO = 167772204;
pub const WaitEventIO_WAIT_EVENT_SNAPBUILD_READ: WaitEventIO = 167772205;
pub const WaitEventIO_WAIT_EVENT_SNAPBUILD_SYNC: WaitEventIO = 167772206;
pub const WaitEventIO_WAIT_EVENT_SNAPBUILD_WRITE: WaitEventIO = 167772207;
pub const WaitEventIO_WAIT_EVENT_TIMELINE_HISTORY_FILE_SYNC: WaitEventIO = 167772208;
pub const WaitEventIO_WAIT_EVENT_TIMELINE_HISTORY_FILE_WRITE: WaitEventIO = 167772209;
pub const WaitEventIO_WAIT_EVENT_TIMELINE_HISTORY_READ: WaitEventIO = 167772210;
pub const WaitEventIO_WAIT_EVENT_TIMELINE_HISTORY_SYNC: WaitEventIO = 167772211;
pub const WaitEventIO_WAIT_EVENT_TIMELINE_HISTORY_WRITE: WaitEventIO = 167772212;
pub const WaitEventIO_WAIT_EVENT_TWOPHASE_FILE_READ: WaitEventIO = 167772213;
pub const WaitEventIO_WAIT_EVENT_TWOPHASE_FILE_SYNC: WaitEventIO = 167772214;
pub const WaitEventIO_WAIT_EVENT_TWOPHASE_FILE_WRITE: WaitEventIO = 167772215;
pub const WaitEventIO_WAIT_EVENT_WALSENDER_TIMELINE_HISTORY_READ: WaitEventIO = 167772216;
pub const WaitEventIO_WAIT_EVENT_WAL_BOOTSTRAP_SYNC: WaitEventIO = 167772217;
pub const WaitEventIO_WAIT_EVENT_WAL_BOOTSTRAP_WRITE: WaitEventIO = 167772218;
pub const WaitEventIO_WAIT_EVENT_WAL_COPY_READ: WaitEventIO = 167772219;
pub const WaitEventIO_WAIT_EVENT_WAL_COPY_SYNC: WaitEventIO = 167772220;
pub const WaitEventIO_WAIT_EVENT_WAL_COPY_WRITE: WaitEventIO = 167772221;
pub const WaitEventIO_WAIT_EVENT_WAL_INIT_SYNC: WaitEventIO = 167772222;
pub const WaitEventIO_WAIT_EVENT_WAL_INIT_WRITE: WaitEventIO = 167772223;
pub const WaitEventIO_WAIT_EVENT_WAL_READ: WaitEventIO = 167772224;
pub const WaitEventIO_WAIT_EVENT_WAL_SYNC: WaitEventIO = 167772225;
pub const WaitEventIO_WAIT_EVENT_WAL_SYNC_METHOD_ASSIGN: WaitEventIO = 167772226;
pub const WaitEventIO_WAIT_EVENT_WAL_WRITE: WaitEventIO = 167772227;
pub type WaitEventIO = ::std::os::raw::c_uint;
pub const ProgressCommandType_PROGRESS_COMMAND_INVALID: ProgressCommandType = 0;
pub const ProgressCommandType_PROGRESS_COMMAND_VACUUM: ProgressCommandType = 1;
pub const ProgressCommandType_PROGRESS_COMMAND_ANALYZE: ProgressCommandType = 2;
pub const ProgressCommandType_PROGRESS_COMMAND_CLUSTER: ProgressCommandType = 3;
pub const ProgressCommandType_PROGRESS_COMMAND_CREATE_INDEX: ProgressCommandType = 4;
pub const ProgressCommandType_PROGRESS_COMMAND_BASEBACKUP: ProgressCommandType = 5;
pub type ProgressCommandType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgBackendSSLStatus {
    pub ssl_bits: ::std::os::raw::c_int,
    pub ssl_compression: bool,
    pub ssl_version: [::std::os::raw::c_char; 64usize],
    pub ssl_cipher: [::std::os::raw::c_char; 64usize],
    pub ssl_client_dn: [::std::os::raw::c_char; 64usize],
    pub ssl_client_serial: [::std::os::raw::c_char; 64usize],
    pub ssl_issuer_dn: [::std::os::raw::c_char; 64usize],
}
impl Default for PgBackendSSLStatus {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgBackendGSSStatus {
    pub gss_princ: [::std::os::raw::c_char; 64usize],
    pub gss_auth: bool,
    pub gss_enc: bool,
}
impl Default for PgBackendGSSStatus {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgBackendStatus {
    pub st_changecount: ::std::os::raw::c_int,
    pub st_procpid: ::std::os::raw::c_int,
    pub st_backendType: BackendType,
    pub st_proc_start_timestamp: TimestampTz,
    pub st_xact_start_timestamp: TimestampTz,
    pub st_activity_start_timestamp: TimestampTz,
    pub st_state_start_timestamp: TimestampTz,
    pub st_databaseid: Oid,
    pub st_userid: Oid,
    pub st_clientaddr: SockAddr,
    pub st_clienthostname: *mut ::std::os::raw::c_char,
    pub st_ssl: bool,
    pub st_sslstatus: *mut PgBackendSSLStatus,
    pub st_gss: bool,
    pub st_gssstatus: *mut PgBackendGSSStatus,
    pub st_state: BackendState,
    pub st_appname: *mut ::std::os::raw::c_char,
    pub st_activity_raw: *mut ::std::os::raw::c_char,
    pub st_progress_command: ProgressCommandType,
    pub st_progress_command_target: Oid,
    pub st_progress_param: [int64; 20usize],
}
impl Default for PgBackendStatus {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LocalPgBackendStatus {
    pub backendStatus: PgBackendStatus,
    pub backend_xid: TransactionId,
    pub backend_xmin: TransactionId,
}
impl Default for LocalPgBackendStatus {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PgStat_FunctionCallUsage {
    pub fs: *mut PgStat_FunctionCounts,
    pub save_f_total_time: instr_time,
    pub save_total: instr_time,
    pub f_start: instr_time,
}
impl Default for PgStat_FunctionCallUsage {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut pgstat_track_activities: bool;
}
extern "C" {
    pub static mut pgstat_track_counts: bool;
}
extern "C" {
    pub static mut pgstat_track_functions: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut pgstat_track_activity_query_size: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut pgstat_stat_directory: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut pgstat_stat_tmpname: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut pgstat_stat_filename: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut BgWriterStats: PgStat_MsgBgWriter;
}
extern "C" {
    pub static mut pgStatBlockReadTime: PgStat_Counter;
}
extern "C" {
    pub static mut pgStatBlockWriteTime: PgStat_Counter;
}
pub unsafe fn BackendStatusShmemSize() -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BackendStatusShmemSize() -> Size;
        }
        BackendStatusShmemSize()
    })
}
pub unsafe fn CreateSharedBackendStatus() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateSharedBackendStatus();
        }
        CreateSharedBackendStatus()
    })
}
pub unsafe fn pgstat_init() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_init();
        }
        pgstat_init()
    })
}
pub unsafe fn pgstat_start() -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_start() -> ::std::os::raw::c_int;
        }
        pgstat_start()
    })
}
pub unsafe fn pgstat_reset_all() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_reset_all();
        }
        pgstat_reset_all()
    })
}
pub unsafe fn allow_immediate_pgstat_restart() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn allow_immediate_pgstat_restart();
        }
        allow_immediate_pgstat_restart()
    })
}
pub unsafe fn pgstat_ping() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_ping();
        }
        pgstat_ping()
    })
}
pub unsafe fn pgstat_report_stat(arg_force: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_report_stat(arg_force: bool);
        }
        pgstat_report_stat(arg_force)
    })
}
pub unsafe fn pgstat_vacuum_stat() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_vacuum_stat();
        }
        pgstat_vacuum_stat()
    })
}
pub unsafe fn pgstat_drop_database(arg_databaseid: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_drop_database(arg_databaseid: Oid);
        }
        pgstat_drop_database(arg_databaseid)
    })
}
pub unsafe fn pgstat_clear_snapshot() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_clear_snapshot();
        }
        pgstat_clear_snapshot()
    })
}
pub unsafe fn pgstat_reset_counters() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_reset_counters();
        }
        pgstat_reset_counters()
    })
}
pub unsafe fn pgstat_reset_shared_counters(arg_arg1: *const ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_reset_shared_counters(arg_arg1: *const ::std::os::raw::c_char);
        }
        pgstat_reset_shared_counters(arg_arg1)
    })
}
pub unsafe fn pgstat_reset_single_counter(arg_objectid: Oid, arg_type_: PgStat_Single_Reset_Type) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_reset_single_counter(arg_objectid: Oid, arg_type_: PgStat_Single_Reset_Type);
        }
        pgstat_reset_single_counter(arg_objectid, arg_type_)
    })
}
pub unsafe fn pgstat_reset_slru_counter(arg_arg1: *const ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_reset_slru_counter(arg_arg1: *const ::std::os::raw::c_char);
        }
        pgstat_reset_slru_counter(arg_arg1)
    })
}
pub unsafe fn pgstat_report_autovac(arg_dboid: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_report_autovac(arg_dboid: Oid);
        }
        pgstat_report_autovac(arg_dboid)
    })
}
pub unsafe fn pgstat_report_vacuum(
    arg_tableoid: Oid,
    arg_shared: bool,
    arg_livetuples: PgStat_Counter,
    arg_deadtuples: PgStat_Counter,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_report_vacuum(
                arg_tableoid: Oid,
                arg_shared: bool,
                arg_livetuples: PgStat_Counter,
                arg_deadtuples: PgStat_Counter,
            );
        }
        pgstat_report_vacuum(arg_tableoid, arg_shared, arg_livetuples, arg_deadtuples)
    })
}
pub unsafe fn pgstat_report_analyze(
    arg_rel: Relation,
    arg_livetuples: PgStat_Counter,
    arg_deadtuples: PgStat_Counter,
    arg_resetcounter: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_report_analyze(
                arg_rel: Relation,
                arg_livetuples: PgStat_Counter,
                arg_deadtuples: PgStat_Counter,
                arg_resetcounter: bool,
            );
        }
        pgstat_report_analyze(arg_rel, arg_livetuples, arg_deadtuples, arg_resetcounter)
    })
}
pub unsafe fn pgstat_report_recovery_conflict(arg_reason: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_report_recovery_conflict(arg_reason: ::std::os::raw::c_int);
        }
        pgstat_report_recovery_conflict(arg_reason)
    })
}
pub unsafe fn pgstat_report_deadlock() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_report_deadlock();
        }
        pgstat_report_deadlock()
    })
}
pub unsafe fn pgstat_report_checksum_failures_in_db(
    arg_dboid: Oid,
    arg_failurecount: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_report_checksum_failures_in_db(
                arg_dboid: Oid,
                arg_failurecount: ::std::os::raw::c_int,
            );
        }
        pgstat_report_checksum_failures_in_db(arg_dboid, arg_failurecount)
    })
}
pub unsafe fn pgstat_report_checksum_failure() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_report_checksum_failure();
        }
        pgstat_report_checksum_failure()
    })
}
pub unsafe fn pgstat_initialize() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_initialize();
        }
        pgstat_initialize()
    })
}
pub unsafe fn pgstat_bestart() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_bestart();
        }
        pgstat_bestart()
    })
}
pub unsafe fn pgstat_report_activity(
    arg_state: BackendState,
    arg_cmd_str: *const ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_report_activity(
                arg_state: BackendState,
                arg_cmd_str: *const ::std::os::raw::c_char,
            );
        }
        pgstat_report_activity(arg_state, arg_cmd_str)
    })
}
pub unsafe fn pgstat_report_tempfile(arg_filesize: usize) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_report_tempfile(arg_filesize: usize);
        }
        pgstat_report_tempfile(arg_filesize)
    })
}
pub unsafe fn pgstat_report_appname(arg_appname: *const ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_report_appname(arg_appname: *const ::std::os::raw::c_char);
        }
        pgstat_report_appname(arg_appname)
    })
}
pub unsafe fn pgstat_report_xact_timestamp(arg_tstamp: TimestampTz) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_report_xact_timestamp(arg_tstamp: TimestampTz);
        }
        pgstat_report_xact_timestamp(arg_tstamp)
    })
}
pub unsafe fn pgstat_get_wait_event(arg_wait_event_info: uint32) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_get_wait_event(arg_wait_event_info: uint32) -> *const ::std::os::raw::c_char;
        }
        pgstat_get_wait_event(arg_wait_event_info)
    })
}
pub unsafe fn pgstat_get_wait_event_type(
    arg_wait_event_info: uint32,
) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_get_wait_event_type(
                arg_wait_event_info: uint32,
            ) -> *const ::std::os::raw::c_char;
        }
        pgstat_get_wait_event_type(arg_wait_event_info)
    })
}
pub unsafe fn pgstat_get_backend_current_activity(
    arg_pid: ::std::os::raw::c_int,
    arg_checkUser: bool,
) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_get_backend_current_activity(
                arg_pid: ::std::os::raw::c_int,
                arg_checkUser: bool,
            ) -> *const ::std::os::raw::c_char;
        }
        pgstat_get_backend_current_activity(arg_pid, arg_checkUser)
    })
}
pub unsafe fn pgstat_get_crashed_backend_activity(
    arg_pid: ::std::os::raw::c_int,
    arg_buffer: *mut ::std::os::raw::c_char,
    arg_buflen: ::std::os::raw::c_int,
) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_get_crashed_backend_activity(
                arg_pid: ::std::os::raw::c_int,
                arg_buffer: *mut ::std::os::raw::c_char,
                arg_buflen: ::std::os::raw::c_int,
            ) -> *const ::std::os::raw::c_char;
        }
        pgstat_get_crashed_backend_activity(arg_pid, arg_buffer, arg_buflen)
    })
}
pub unsafe fn pgstat_progress_start_command(arg_cmdtype: ProgressCommandType, arg_relid: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_progress_start_command(arg_cmdtype: ProgressCommandType, arg_relid: Oid);
        }
        pgstat_progress_start_command(arg_cmdtype, arg_relid)
    })
}
pub unsafe fn pgstat_progress_update_param(arg_index: ::std::os::raw::c_int, arg_val: int64) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_progress_update_param(arg_index: ::std::os::raw::c_int, arg_val: int64);
        }
        pgstat_progress_update_param(arg_index, arg_val)
    })
}
pub unsafe fn pgstat_progress_update_multi_param(
    arg_nparam: ::std::os::raw::c_int,
    arg_index: *const ::std::os::raw::c_int,
    arg_val: *const int64,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_progress_update_multi_param(
                arg_nparam: ::std::os::raw::c_int,
                arg_index: *const ::std::os::raw::c_int,
                arg_val: *const int64,
            );
        }
        pgstat_progress_update_multi_param(arg_nparam, arg_index, arg_val)
    })
}
pub unsafe fn pgstat_progress_end_command() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_progress_end_command();
        }
        pgstat_progress_end_command()
    })
}
pub unsafe fn find_tabstat_entry(arg_rel_id: Oid) -> *mut PgStat_TableStatus {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn find_tabstat_entry(arg_rel_id: Oid) -> *mut PgStat_TableStatus;
        }
        find_tabstat_entry(arg_rel_id)
    })
}
pub unsafe fn find_funcstat_entry(arg_func_id: Oid) -> *mut PgStat_BackendFunctionEntry {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn find_funcstat_entry(arg_func_id: Oid) -> *mut PgStat_BackendFunctionEntry;
        }
        find_funcstat_entry(arg_func_id)
    })
}
pub unsafe fn pgstat_initstats(arg_rel: Relation) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_initstats(arg_rel: Relation);
        }
        pgstat_initstats(arg_rel)
    })
}
pub unsafe fn pgstat_clip_activity(
    arg_raw_activity: *const ::std::os::raw::c_char,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_clip_activity(
                arg_raw_activity: *const ::std::os::raw::c_char,
            ) -> *mut ::std::os::raw::c_char;
        }
        pgstat_clip_activity(arg_raw_activity)
    })
}
pub unsafe fn pgstat_count_heap_insert(arg_rel: Relation, arg_n: PgStat_Counter) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_count_heap_insert(arg_rel: Relation, arg_n: PgStat_Counter);
        }
        pgstat_count_heap_insert(arg_rel, arg_n)
    })
}
pub unsafe fn pgstat_count_heap_update(arg_rel: Relation, arg_hot: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_count_heap_update(arg_rel: Relation, arg_hot: bool);
        }
        pgstat_count_heap_update(arg_rel, arg_hot)
    })
}
pub unsafe fn pgstat_count_heap_delete(arg_rel: Relation) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_count_heap_delete(arg_rel: Relation);
        }
        pgstat_count_heap_delete(arg_rel)
    })
}
pub unsafe fn pgstat_count_truncate(arg_rel: Relation) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_count_truncate(arg_rel: Relation);
        }
        pgstat_count_truncate(arg_rel)
    })
}
pub unsafe fn pgstat_update_heap_dead_tuples(arg_rel: Relation, arg_delta: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_update_heap_dead_tuples(arg_rel: Relation, arg_delta: ::std::os::raw::c_int);
        }
        pgstat_update_heap_dead_tuples(arg_rel, arg_delta)
    })
}
pub unsafe fn pgstat_init_function_usage(
    arg_fcinfo: *mut FunctionCallInfoBaseData,
    arg_fcu: *mut PgStat_FunctionCallUsage,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_init_function_usage(
                arg_fcinfo: *mut FunctionCallInfoBaseData,
                arg_fcu: *mut PgStat_FunctionCallUsage,
            );
        }
        pgstat_init_function_usage(arg_fcinfo, arg_fcu)
    })
}
pub unsafe fn pgstat_end_function_usage(
    arg_fcu: *mut PgStat_FunctionCallUsage,
    arg_finalize: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_end_function_usage(
                arg_fcu: *mut PgStat_FunctionCallUsage,
                arg_finalize: bool,
            );
        }
        pgstat_end_function_usage(arg_fcu, arg_finalize)
    })
}
pub unsafe fn AtEOXact_PgStat(arg_isCommit: bool, arg_parallel: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AtEOXact_PgStat(arg_isCommit: bool, arg_parallel: bool);
        }
        AtEOXact_PgStat(arg_isCommit, arg_parallel)
    })
}
pub unsafe fn AtEOSubXact_PgStat(arg_isCommit: bool, arg_nestDepth: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AtEOSubXact_PgStat(arg_isCommit: bool, arg_nestDepth: ::std::os::raw::c_int);
        }
        AtEOSubXact_PgStat(arg_isCommit, arg_nestDepth)
    })
}
pub unsafe fn AtPrepare_PgStat() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AtPrepare_PgStat();
        }
        AtPrepare_PgStat()
    })
}
pub unsafe fn PostPrepare_PgStat() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PostPrepare_PgStat();
        }
        PostPrepare_PgStat()
    })
}
pub unsafe fn pgstat_twophase_postcommit(
    arg_xid: TransactionId,
    arg_info: uint16,
    arg_recdata: *mut ::std::os::raw::c_void,
    arg_len: uint32,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_twophase_postcommit(
                arg_xid: TransactionId,
                arg_info: uint16,
                arg_recdata: *mut ::std::os::raw::c_void,
                arg_len: uint32,
            );
        }
        pgstat_twophase_postcommit(arg_xid, arg_info, arg_recdata, arg_len)
    })
}
pub unsafe fn pgstat_twophase_postabort(
    arg_xid: TransactionId,
    arg_info: uint16,
    arg_recdata: *mut ::std::os::raw::c_void,
    arg_len: uint32,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_twophase_postabort(
                arg_xid: TransactionId,
                arg_info: uint16,
                arg_recdata: *mut ::std::os::raw::c_void,
                arg_len: uint32,
            );
        }
        pgstat_twophase_postabort(arg_xid, arg_info, arg_recdata, arg_len)
    })
}
pub unsafe fn pgstat_send_archiver(arg_xlog: *const ::std::os::raw::c_char, arg_failed: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_send_archiver(arg_xlog: *const ::std::os::raw::c_char, arg_failed: bool);
        }
        pgstat_send_archiver(arg_xlog, arg_failed)
    })
}
pub unsafe fn pgstat_send_bgwriter() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_send_bgwriter();
        }
        pgstat_send_bgwriter()
    })
}
pub unsafe fn pgstat_fetch_stat_dbentry(arg_dbid: Oid) -> *mut PgStat_StatDBEntry {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_fetch_stat_dbentry(arg_dbid: Oid) -> *mut PgStat_StatDBEntry;
        }
        pgstat_fetch_stat_dbentry(arg_dbid)
    })
}
pub unsafe fn pgstat_fetch_stat_tabentry(arg_relid: Oid) -> *mut PgStat_StatTabEntry {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_fetch_stat_tabentry(arg_relid: Oid) -> *mut PgStat_StatTabEntry;
        }
        pgstat_fetch_stat_tabentry(arg_relid)
    })
}
pub unsafe fn pgstat_fetch_stat_beentry(arg_beid: ::std::os::raw::c_int) -> *mut PgBackendStatus {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_fetch_stat_beentry(arg_beid: ::std::os::raw::c_int) -> *mut PgBackendStatus;
        }
        pgstat_fetch_stat_beentry(arg_beid)
    })
}
pub unsafe fn pgstat_fetch_stat_local_beentry(
    arg_beid: ::std::os::raw::c_int,
) -> *mut LocalPgBackendStatus {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_fetch_stat_local_beentry(
                arg_beid: ::std::os::raw::c_int,
            ) -> *mut LocalPgBackendStatus;
        }
        pgstat_fetch_stat_local_beentry(arg_beid)
    })
}
pub unsafe fn pgstat_fetch_stat_funcentry(arg_funcid: Oid) -> *mut PgStat_StatFuncEntry {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_fetch_stat_funcentry(arg_funcid: Oid) -> *mut PgStat_StatFuncEntry;
        }
        pgstat_fetch_stat_funcentry(arg_funcid)
    })
}
pub unsafe fn pgstat_fetch_stat_numbackends() -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_fetch_stat_numbackends() -> ::std::os::raw::c_int;
        }
        pgstat_fetch_stat_numbackends()
    })
}
pub unsafe fn pgstat_fetch_stat_archiver() -> *mut PgStat_ArchiverStats {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_fetch_stat_archiver() -> *mut PgStat_ArchiverStats;
        }
        pgstat_fetch_stat_archiver()
    })
}
pub unsafe fn pgstat_fetch_global() -> *mut PgStat_GlobalStats {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_fetch_global() -> *mut PgStat_GlobalStats;
        }
        pgstat_fetch_global()
    })
}
pub unsafe fn pgstat_fetch_slru() -> *mut PgStat_SLRUStats {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_fetch_slru() -> *mut PgStat_SLRUStats;
        }
        pgstat_fetch_slru()
    })
}
pub unsafe fn pgstat_count_slru_page_zeroed(arg_slru_idx: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_count_slru_page_zeroed(arg_slru_idx: ::std::os::raw::c_int);
        }
        pgstat_count_slru_page_zeroed(arg_slru_idx)
    })
}
pub unsafe fn pgstat_count_slru_page_hit(arg_slru_idx: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_count_slru_page_hit(arg_slru_idx: ::std::os::raw::c_int);
        }
        pgstat_count_slru_page_hit(arg_slru_idx)
    })
}
pub unsafe fn pgstat_count_slru_page_read(arg_slru_idx: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_count_slru_page_read(arg_slru_idx: ::std::os::raw::c_int);
        }
        pgstat_count_slru_page_read(arg_slru_idx)
    })
}
pub unsafe fn pgstat_count_slru_page_written(arg_slru_idx: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_count_slru_page_written(arg_slru_idx: ::std::os::raw::c_int);
        }
        pgstat_count_slru_page_written(arg_slru_idx)
    })
}
pub unsafe fn pgstat_count_slru_page_exists(arg_slru_idx: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_count_slru_page_exists(arg_slru_idx: ::std::os::raw::c_int);
        }
        pgstat_count_slru_page_exists(arg_slru_idx)
    })
}
pub unsafe fn pgstat_count_slru_flush(arg_slru_idx: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_count_slru_flush(arg_slru_idx: ::std::os::raw::c_int);
        }
        pgstat_count_slru_flush(arg_slru_idx)
    })
}
pub unsafe fn pgstat_count_slru_truncate(arg_slru_idx: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_count_slru_truncate(arg_slru_idx: ::std::os::raw::c_int);
        }
        pgstat_count_slru_truncate(arg_slru_idx)
    })
}
pub unsafe fn pgstat_slru_name(
    arg_slru_idx: ::std::os::raw::c_int,
) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_slru_name(
                arg_slru_idx: ::std::os::raw::c_int,
            ) -> *const ::std::os::raw::c_char;
        }
        pgstat_slru_name(arg_slru_idx)
    })
}
pub unsafe fn pgstat_slru_index(arg_name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgstat_slru_index(arg_name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
        }
        pgstat_slru_index(arg_name)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ScanKeyData {
    pub sk_flags: ::std::os::raw::c_int,
    pub sk_attno: AttrNumber,
    pub sk_strategy: StrategyNumber,
    pub sk_subtype: Oid,
    pub sk_collation: Oid,
    pub sk_func: FmgrInfo,
    pub sk_argument: Datum,
}
impl Default for ScanKeyData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ScanKey = *mut ScanKeyData;
pub unsafe fn ScanKeyInit(
    arg_entry: ScanKey,
    arg_attributeNumber: AttrNumber,
    arg_strategy: StrategyNumber,
    arg_procedure: RegProcedure,
    arg_argument: Datum,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ScanKeyInit(
                arg_entry: ScanKey,
                arg_attributeNumber: AttrNumber,
                arg_strategy: StrategyNumber,
                arg_procedure: RegProcedure,
                arg_argument: Datum,
            );
        }
        ScanKeyInit(arg_entry, arg_attributeNumber, arg_strategy, arg_procedure, arg_argument)
    })
}
pub unsafe fn ScanKeyEntryInitialize(
    arg_entry: ScanKey,
    arg_flags: ::std::os::raw::c_int,
    arg_attributeNumber: AttrNumber,
    arg_strategy: StrategyNumber,
    arg_subtype: Oid,
    arg_collation: Oid,
    arg_procedure: RegProcedure,
    arg_argument: Datum,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ScanKeyEntryInitialize(
                arg_entry: ScanKey,
                arg_flags: ::std::os::raw::c_int,
                arg_attributeNumber: AttrNumber,
                arg_strategy: StrategyNumber,
                arg_subtype: Oid,
                arg_collation: Oid,
                arg_procedure: RegProcedure,
                arg_argument: Datum,
            );
        }
        ScanKeyEntryInitialize(
            arg_entry,
            arg_flags,
            arg_attributeNumber,
            arg_strategy,
            arg_subtype,
            arg_collation,
            arg_procedure,
            arg_argument,
        )
    })
}
pub unsafe fn ScanKeyEntryInitializeWithInfo(
    arg_entry: ScanKey,
    arg_flags: ::std::os::raw::c_int,
    arg_attributeNumber: AttrNumber,
    arg_strategy: StrategyNumber,
    arg_subtype: Oid,
    arg_collation: Oid,
    arg_finfo: *mut FmgrInfo,
    arg_argument: Datum,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ScanKeyEntryInitializeWithInfo(
                arg_entry: ScanKey,
                arg_flags: ::std::os::raw::c_int,
                arg_attributeNumber: AttrNumber,
                arg_strategy: StrategyNumber,
                arg_subtype: Oid,
                arg_collation: Oid,
                arg_finfo: *mut FmgrInfo,
                arg_argument: Datum,
            );
        }
        ScanKeyEntryInitializeWithInfo(
            arg_entry,
            arg_flags,
            arg_attributeNumber,
            arg_strategy,
            arg_subtype,
            arg_collation,
            arg_finfo,
            arg_argument,
        )
    })
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IndexBuildResult {
    pub heap_tuples: f64,
    pub index_tuples: f64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexVacuumInfo {
    pub index: Relation,
    pub analyze_only: bool,
    pub report_progress: bool,
    pub estimated_count: bool,
    pub message_level: ::std::os::raw::c_int,
    pub num_heap_tuples: f64,
    pub strategy: BufferAccessStrategy,
}
impl Default for IndexVacuumInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IndexBulkDeleteResult {
    pub num_pages: BlockNumber,
    pub pages_removed: BlockNumber,
    pub estimated_count: bool,
    pub num_index_tuples: f64,
    pub tuples_removed: f64,
    pub pages_deleted: BlockNumber,
    pub pages_free: BlockNumber,
}
pub type IndexBulkDeleteCallback = ::std::option::Option<
    unsafe extern "C" fn(itemptr: ItemPointer, state: *mut ::std::os::raw::c_void) -> bool,
>;
pub type IndexScanDesc = *mut IndexScanDescData;
pub type SysScanDesc = *mut SysScanDescData;
pub type ParallelIndexScanDesc = *mut ParallelIndexScanDescData;
pub const IndexUniqueCheck_UNIQUE_CHECK_NO: IndexUniqueCheck = 0;
pub const IndexUniqueCheck_UNIQUE_CHECK_YES: IndexUniqueCheck = 1;
pub const IndexUniqueCheck_UNIQUE_CHECK_PARTIAL: IndexUniqueCheck = 2;
pub const IndexUniqueCheck_UNIQUE_CHECK_EXISTING: IndexUniqueCheck = 3;
pub type IndexUniqueCheck = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IndexOrderByDistance {
    pub value: f64,
    pub isnull: bool,
}
pub unsafe fn index_open(arg_relationId: Oid, arg_lockmode: LOCKMODE) -> Relation {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_open(arg_relationId: Oid, arg_lockmode: LOCKMODE) -> Relation;
        }
        index_open(arg_relationId, arg_lockmode)
    })
}
pub unsafe fn index_close(arg_relation: Relation, arg_lockmode: LOCKMODE) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_close(arg_relation: Relation, arg_lockmode: LOCKMODE);
        }
        index_close(arg_relation, arg_lockmode)
    })
}
pub unsafe fn index_insert(
    arg_indexRelation: Relation,
    arg_values: *mut Datum,
    arg_isnull: *mut bool,
    arg_heap_t_ctid: ItemPointer,
    arg_heapRelation: Relation,
    arg_checkUnique: IndexUniqueCheck,
    arg_indexInfo: *mut IndexInfo,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_insert(
                arg_indexRelation: Relation,
                arg_values: *mut Datum,
                arg_isnull: *mut bool,
                arg_heap_t_ctid: ItemPointer,
                arg_heapRelation: Relation,
                arg_checkUnique: IndexUniqueCheck,
                arg_indexInfo: *mut IndexInfo,
            ) -> bool;
        }
        index_insert(
            arg_indexRelation,
            arg_values,
            arg_isnull,
            arg_heap_t_ctid,
            arg_heapRelation,
            arg_checkUnique,
            arg_indexInfo,
        )
    })
}
pub unsafe fn index_beginscan(
    arg_heapRelation: Relation,
    arg_indexRelation: Relation,
    arg_snapshot: Snapshot,
    arg_nkeys: ::std::os::raw::c_int,
    arg_norderbys: ::std::os::raw::c_int,
) -> IndexScanDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_beginscan(
                arg_heapRelation: Relation,
                arg_indexRelation: Relation,
                arg_snapshot: Snapshot,
                arg_nkeys: ::std::os::raw::c_int,
                arg_norderbys: ::std::os::raw::c_int,
            ) -> IndexScanDesc;
        }
        index_beginscan(arg_heapRelation, arg_indexRelation, arg_snapshot, arg_nkeys, arg_norderbys)
    })
}
pub unsafe fn index_beginscan_bitmap(
    arg_indexRelation: Relation,
    arg_snapshot: Snapshot,
    arg_nkeys: ::std::os::raw::c_int,
) -> IndexScanDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_beginscan_bitmap(
                arg_indexRelation: Relation,
                arg_snapshot: Snapshot,
                arg_nkeys: ::std::os::raw::c_int,
            ) -> IndexScanDesc;
        }
        index_beginscan_bitmap(arg_indexRelation, arg_snapshot, arg_nkeys)
    })
}
pub unsafe fn index_rescan(
    arg_scan: IndexScanDesc,
    arg_keys: ScanKey,
    arg_nkeys: ::std::os::raw::c_int,
    arg_orderbys: ScanKey,
    arg_norderbys: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_rescan(
                arg_scan: IndexScanDesc,
                arg_keys: ScanKey,
                arg_nkeys: ::std::os::raw::c_int,
                arg_orderbys: ScanKey,
                arg_norderbys: ::std::os::raw::c_int,
            );
        }
        index_rescan(arg_scan, arg_keys, arg_nkeys, arg_orderbys, arg_norderbys)
    })
}
pub unsafe fn index_endscan(arg_scan: IndexScanDesc) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_endscan(arg_scan: IndexScanDesc);
        }
        index_endscan(arg_scan)
    })
}
pub unsafe fn index_markpos(arg_scan: IndexScanDesc) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_markpos(arg_scan: IndexScanDesc);
        }
        index_markpos(arg_scan)
    })
}
pub unsafe fn index_restrpos(arg_scan: IndexScanDesc) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_restrpos(arg_scan: IndexScanDesc);
        }
        index_restrpos(arg_scan)
    })
}
pub unsafe fn index_parallelscan_estimate(arg_indexrel: Relation, arg_snapshot: Snapshot) -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_parallelscan_estimate(arg_indexrel: Relation, arg_snapshot: Snapshot) -> Size;
        }
        index_parallelscan_estimate(arg_indexrel, arg_snapshot)
    })
}
pub unsafe fn index_parallelscan_initialize(
    arg_heaprel: Relation,
    arg_indexrel: Relation,
    arg_snapshot: Snapshot,
    arg_target: ParallelIndexScanDesc,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_parallelscan_initialize(
                arg_heaprel: Relation,
                arg_indexrel: Relation,
                arg_snapshot: Snapshot,
                arg_target: ParallelIndexScanDesc,
            );
        }
        index_parallelscan_initialize(arg_heaprel, arg_indexrel, arg_snapshot, arg_target)
    })
}
pub unsafe fn index_parallelrescan(arg_scan: IndexScanDesc) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_parallelrescan(arg_scan: IndexScanDesc);
        }
        index_parallelrescan(arg_scan)
    })
}
pub unsafe fn index_beginscan_parallel(
    arg_heaprel: Relation,
    arg_indexrel: Relation,
    arg_nkeys: ::std::os::raw::c_int,
    arg_norderbys: ::std::os::raw::c_int,
    arg_pscan: ParallelIndexScanDesc,
) -> IndexScanDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_beginscan_parallel(
                arg_heaprel: Relation,
                arg_indexrel: Relation,
                arg_nkeys: ::std::os::raw::c_int,
                arg_norderbys: ::std::os::raw::c_int,
                arg_pscan: ParallelIndexScanDesc,
            ) -> IndexScanDesc;
        }
        index_beginscan_parallel(arg_heaprel, arg_indexrel, arg_nkeys, arg_norderbys, arg_pscan)
    })
}
pub unsafe fn index_getnext_tid(
    arg_scan: IndexScanDesc,
    arg_direction: ScanDirection,
) -> ItemPointer {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_getnext_tid(
                arg_scan: IndexScanDesc,
                arg_direction: ScanDirection,
            ) -> ItemPointer;
        }
        index_getnext_tid(arg_scan, arg_direction)
    })
}
pub unsafe fn index_fetch_heap(arg_scan: IndexScanDesc, arg_slot: *mut TupleTableSlot) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_fetch_heap(arg_scan: IndexScanDesc, arg_slot: *mut TupleTableSlot) -> bool;
        }
        index_fetch_heap(arg_scan, arg_slot)
    })
}
pub unsafe fn index_getnext_slot(
    arg_scan: IndexScanDesc,
    arg_direction: ScanDirection,
    arg_slot: *mut TupleTableSlot,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_getnext_slot(
                arg_scan: IndexScanDesc,
                arg_direction: ScanDirection,
                arg_slot: *mut TupleTableSlot,
            ) -> bool;
        }
        index_getnext_slot(arg_scan, arg_direction, arg_slot)
    })
}
pub unsafe fn index_getbitmap(arg_scan: IndexScanDesc, arg_bitmap: *mut TIDBitmap) -> int64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_getbitmap(arg_scan: IndexScanDesc, arg_bitmap: *mut TIDBitmap) -> int64;
        }
        index_getbitmap(arg_scan, arg_bitmap)
    })
}
pub unsafe fn index_bulk_delete(
    arg_info: *mut IndexVacuumInfo,
    arg_stats: *mut IndexBulkDeleteResult,
    arg_callback: IndexBulkDeleteCallback,
    arg_callback_state: *mut ::std::os::raw::c_void,
) -> *mut IndexBulkDeleteResult {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_bulk_delete(
                arg_info: *mut IndexVacuumInfo,
                arg_stats: *mut IndexBulkDeleteResult,
                arg_callback: IndexBulkDeleteCallback,
                arg_callback_state: *mut ::std::os::raw::c_void,
            ) -> *mut IndexBulkDeleteResult;
        }
        index_bulk_delete(arg_info, arg_stats, arg_callback, arg_callback_state)
    })
}
pub unsafe fn index_vacuum_cleanup(
    arg_info: *mut IndexVacuumInfo,
    arg_stats: *mut IndexBulkDeleteResult,
) -> *mut IndexBulkDeleteResult {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_vacuum_cleanup(
                arg_info: *mut IndexVacuumInfo,
                arg_stats: *mut IndexBulkDeleteResult,
            ) -> *mut IndexBulkDeleteResult;
        }
        index_vacuum_cleanup(arg_info, arg_stats)
    })
}
pub unsafe fn index_can_return(
    arg_indexRelation: Relation,
    arg_attno: ::std::os::raw::c_int,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_can_return(
                arg_indexRelation: Relation,
                arg_attno: ::std::os::raw::c_int,
            ) -> bool;
        }
        index_can_return(arg_indexRelation, arg_attno)
    })
}
pub unsafe fn index_getprocid(
    arg_irel: Relation,
    arg_attnum: AttrNumber,
    arg_procnum: uint16,
) -> RegProcedure {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_getprocid(
                arg_irel: Relation,
                arg_attnum: AttrNumber,
                arg_procnum: uint16,
            ) -> RegProcedure;
        }
        index_getprocid(arg_irel, arg_attnum, arg_procnum)
    })
}
pub unsafe fn index_getprocinfo(
    arg_irel: Relation,
    arg_attnum: AttrNumber,
    arg_procnum: uint16,
) -> *mut FmgrInfo {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_getprocinfo(
                arg_irel: Relation,
                arg_attnum: AttrNumber,
                arg_procnum: uint16,
            ) -> *mut FmgrInfo;
        }
        index_getprocinfo(arg_irel, arg_attnum, arg_procnum)
    })
}
pub unsafe fn index_store_float8_orderby_distances(
    arg_scan: IndexScanDesc,
    arg_orderByTypes: *mut Oid,
    arg_distances: *mut IndexOrderByDistance,
    arg_recheckOrderBy: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_store_float8_orderby_distances(
                arg_scan: IndexScanDesc,
                arg_orderByTypes: *mut Oid,
                arg_distances: *mut IndexOrderByDistance,
                arg_recheckOrderBy: bool,
            );
        }
        index_store_float8_orderby_distances(
            arg_scan,
            arg_orderByTypes,
            arg_distances,
            arg_recheckOrderBy,
        )
    })
}
pub unsafe fn index_opclass_options(
    arg_relation: Relation,
    arg_attnum: AttrNumber,
    arg_attoptions: Datum,
    arg_validate: bool,
) -> *mut bytea {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_opclass_options(
                arg_relation: Relation,
                arg_attnum: AttrNumber,
                arg_attoptions: Datum,
                arg_validate: bool,
            ) -> *mut bytea;
        }
        index_opclass_options(arg_relation, arg_attnum, arg_attoptions, arg_validate)
    })
}
pub unsafe fn RelationGetIndexScan(
    arg_indexRelation: Relation,
    arg_nkeys: ::std::os::raw::c_int,
    arg_norderbys: ::std::os::raw::c_int,
) -> IndexScanDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationGetIndexScan(
                arg_indexRelation: Relation,
                arg_nkeys: ::std::os::raw::c_int,
                arg_norderbys: ::std::os::raw::c_int,
            ) -> IndexScanDesc;
        }
        RelationGetIndexScan(arg_indexRelation, arg_nkeys, arg_norderbys)
    })
}
pub unsafe fn IndexScanEnd(arg_scan: IndexScanDesc) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn IndexScanEnd(arg_scan: IndexScanDesc);
        }
        IndexScanEnd(arg_scan)
    })
}
pub unsafe fn BuildIndexValueDescription(
    arg_indexRelation: Relation,
    arg_values: *mut Datum,
    arg_isnull: *mut bool,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BuildIndexValueDescription(
                arg_indexRelation: Relation,
                arg_values: *mut Datum,
                arg_isnull: *mut bool,
            ) -> *mut ::std::os::raw::c_char;
        }
        BuildIndexValueDescription(arg_indexRelation, arg_values, arg_isnull)
    })
}
pub unsafe fn index_compute_xid_horizon_for_tuples(
    arg_irel: Relation,
    arg_hrel: Relation,
    arg_ibuf: Buffer,
    arg_itemnos: *mut OffsetNumber,
    arg_nitems: ::std::os::raw::c_int,
) -> TransactionId {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_compute_xid_horizon_for_tuples(
                arg_irel: Relation,
                arg_hrel: Relation,
                arg_ibuf: Buffer,
                arg_itemnos: *mut OffsetNumber,
                arg_nitems: ::std::os::raw::c_int,
            ) -> TransactionId;
        }
        index_compute_xid_horizon_for_tuples(arg_irel, arg_hrel, arg_ibuf, arg_itemnos, arg_nitems)
    })
}
pub unsafe fn systable_beginscan(
    arg_heapRelation: Relation,
    arg_indexId: Oid,
    arg_indexOK: bool,
    arg_snapshot: Snapshot,
    arg_nkeys: ::std::os::raw::c_int,
    arg_key: ScanKey,
) -> SysScanDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn systable_beginscan(
                arg_heapRelation: Relation,
                arg_indexId: Oid,
                arg_indexOK: bool,
                arg_snapshot: Snapshot,
                arg_nkeys: ::std::os::raw::c_int,
                arg_key: ScanKey,
            ) -> SysScanDesc;
        }
        systable_beginscan(
            arg_heapRelation,
            arg_indexId,
            arg_indexOK,
            arg_snapshot,
            arg_nkeys,
            arg_key,
        )
    })
}
pub unsafe fn systable_getnext(arg_sysscan: SysScanDesc) -> HeapTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn systable_getnext(arg_sysscan: SysScanDesc) -> HeapTuple;
        }
        systable_getnext(arg_sysscan)
    })
}
pub unsafe fn systable_recheck_tuple(arg_sysscan: SysScanDesc, arg_tup: HeapTuple) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn systable_recheck_tuple(arg_sysscan: SysScanDesc, arg_tup: HeapTuple) -> bool;
        }
        systable_recheck_tuple(arg_sysscan, arg_tup)
    })
}
pub unsafe fn systable_endscan(arg_sysscan: SysScanDesc) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn systable_endscan(arg_sysscan: SysScanDesc);
        }
        systable_endscan(arg_sysscan)
    })
}
pub unsafe fn systable_beginscan_ordered(
    arg_heapRelation: Relation,
    arg_indexRelation: Relation,
    arg_snapshot: Snapshot,
    arg_nkeys: ::std::os::raw::c_int,
    arg_key: ScanKey,
) -> SysScanDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn systable_beginscan_ordered(
                arg_heapRelation: Relation,
                arg_indexRelation: Relation,
                arg_snapshot: Snapshot,
                arg_nkeys: ::std::os::raw::c_int,
                arg_key: ScanKey,
            ) -> SysScanDesc;
        }
        systable_beginscan_ordered(
            arg_heapRelation,
            arg_indexRelation,
            arg_snapshot,
            arg_nkeys,
            arg_key,
        )
    })
}
pub unsafe fn systable_getnext_ordered(
    arg_sysscan: SysScanDesc,
    arg_direction: ScanDirection,
) -> HeapTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn systable_getnext_ordered(
                arg_sysscan: SysScanDesc,
                arg_direction: ScanDirection,
            ) -> HeapTuple;
        }
        systable_getnext_ordered(arg_sysscan, arg_direction)
    })
}
pub unsafe fn systable_endscan_ordered(arg_sysscan: SysScanDesc) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn systable_endscan_ordered(arg_sysscan: SysScanDesc);
        }
        systable_endscan_ordered(arg_sysscan)
    })
}
pub const IndexAMProperty_AMPROP_UNKNOWN: IndexAMProperty = 0;
pub const IndexAMProperty_AMPROP_ASC: IndexAMProperty = 1;
pub const IndexAMProperty_AMPROP_DESC: IndexAMProperty = 2;
pub const IndexAMProperty_AMPROP_NULLS_FIRST: IndexAMProperty = 3;
pub const IndexAMProperty_AMPROP_NULLS_LAST: IndexAMProperty = 4;
pub const IndexAMProperty_AMPROP_ORDERABLE: IndexAMProperty = 5;
pub const IndexAMProperty_AMPROP_DISTANCE_ORDERABLE: IndexAMProperty = 6;
pub const IndexAMProperty_AMPROP_RETURNABLE: IndexAMProperty = 7;
pub const IndexAMProperty_AMPROP_SEARCH_ARRAY: IndexAMProperty = 8;
pub const IndexAMProperty_AMPROP_SEARCH_NULLS: IndexAMProperty = 9;
pub const IndexAMProperty_AMPROP_CLUSTERABLE: IndexAMProperty = 10;
pub const IndexAMProperty_AMPROP_INDEX_SCAN: IndexAMProperty = 11;
pub const IndexAMProperty_AMPROP_BITMAP_SCAN: IndexAMProperty = 12;
pub const IndexAMProperty_AMPROP_BACKWARD_SCAN: IndexAMProperty = 13;
pub const IndexAMProperty_AMPROP_CAN_ORDER: IndexAMProperty = 14;
pub const IndexAMProperty_AMPROP_CAN_UNIQUE: IndexAMProperty = 15;
pub const IndexAMProperty_AMPROP_CAN_MULTI_COL: IndexAMProperty = 16;
pub const IndexAMProperty_AMPROP_CAN_EXCLUDE: IndexAMProperty = 17;
pub const IndexAMProperty_AMPROP_CAN_INCLUDE: IndexAMProperty = 18;
pub type IndexAMProperty = ::std::os::raw::c_uint;
pub type ambuild_function = ::std::option::Option<
    unsafe extern "C" fn(
        heapRelation: Relation,
        indexRelation: Relation,
        indexInfo: *mut IndexInfo,
    ) -> *mut IndexBuildResult,
>;
pub type ambuildempty_function =
    ::std::option::Option<unsafe extern "C" fn(indexRelation: Relation)>;
pub type aminsert_function = ::std::option::Option<
    unsafe extern "C" fn(
        indexRelation: Relation,
        values: *mut Datum,
        isnull: *mut bool,
        heap_tid: ItemPointer,
        heapRelation: Relation,
        checkUnique: IndexUniqueCheck,
        indexInfo: *mut IndexInfo,
    ) -> bool,
>;
pub type ambulkdelete_function = ::std::option::Option<
    unsafe extern "C" fn(
        info: *mut IndexVacuumInfo,
        stats: *mut IndexBulkDeleteResult,
        callback: IndexBulkDeleteCallback,
        callback_state: *mut ::std::os::raw::c_void,
    ) -> *mut IndexBulkDeleteResult,
>;
pub type amvacuumcleanup_function = ::std::option::Option<
    unsafe extern "C" fn(
        info: *mut IndexVacuumInfo,
        stats: *mut IndexBulkDeleteResult,
    ) -> *mut IndexBulkDeleteResult,
>;
pub type amcanreturn_function = ::std::option::Option<
    unsafe extern "C" fn(indexRelation: Relation, attno: ::std::os::raw::c_int) -> bool,
>;
pub type amcostestimate_function = ::std::option::Option<
    unsafe extern "C" fn(
        root: *mut PlannerInfo,
        path: *mut IndexPath,
        loop_count: f64,
        indexStartupCost: *mut Cost,
        indexTotalCost: *mut Cost,
        indexSelectivity: *mut Selectivity,
        indexCorrelation: *mut f64,
        indexPages: *mut f64,
    ),
>;
pub type amoptions_function =
    ::std::option::Option<unsafe extern "C" fn(reloptions: Datum, validate: bool) -> *mut bytea>;
pub type amproperty_function = ::std::option::Option<
    unsafe extern "C" fn(
        index_oid: Oid,
        attno: ::std::os::raw::c_int,
        prop: IndexAMProperty,
        propname: *const ::std::os::raw::c_char,
        res: *mut bool,
        isnull: *mut bool,
    ) -> bool,
>;
pub type ambuildphasename_function =
    ::std::option::Option<unsafe extern "C" fn(phasenum: int64) -> *mut ::std::os::raw::c_char>;
pub type amvalidate_function = ::std::option::Option<unsafe extern "C" fn(opclassoid: Oid) -> bool>;
pub type ambeginscan_function = ::std::option::Option<
    unsafe extern "C" fn(
        indexRelation: Relation,
        nkeys: ::std::os::raw::c_int,
        norderbys: ::std::os::raw::c_int,
    ) -> IndexScanDesc,
>;
pub type amrescan_function = ::std::option::Option<
    unsafe extern "C" fn(
        scan: IndexScanDesc,
        keys: ScanKey,
        nkeys: ::std::os::raw::c_int,
        orderbys: ScanKey,
        norderbys: ::std::os::raw::c_int,
    ),
>;
pub type amgettuple_function = ::std::option::Option<
    unsafe extern "C" fn(scan: IndexScanDesc, direction: ScanDirection) -> bool,
>;
pub type amgetbitmap_function =
    ::std::option::Option<unsafe extern "C" fn(scan: IndexScanDesc, tbm: *mut TIDBitmap) -> int64>;
pub type amendscan_function = ::std::option::Option<unsafe extern "C" fn(scan: IndexScanDesc)>;
pub type ammarkpos_function = ::std::option::Option<unsafe extern "C" fn(scan: IndexScanDesc)>;
pub type amrestrpos_function = ::std::option::Option<unsafe extern "C" fn(scan: IndexScanDesc)>;
pub type amestimateparallelscan_function = ::std::option::Option<unsafe extern "C" fn() -> Size>;
pub type aminitparallelscan_function =
    ::std::option::Option<unsafe extern "C" fn(target: *mut ::std::os::raw::c_void)>;
pub type amparallelrescan_function =
    ::std::option::Option<unsafe extern "C" fn(scan: IndexScanDesc)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexAmRoutine {
    pub type_: NodeTag,
    pub amstrategies: uint16,
    pub amsupport: uint16,
    pub amoptsprocnum: uint16,
    pub amcanorder: bool,
    pub amcanorderbyop: bool,
    pub amcanbackward: bool,
    pub amcanunique: bool,
    pub amcanmulticol: bool,
    pub amoptionalkey: bool,
    pub amsearcharray: bool,
    pub amsearchnulls: bool,
    pub amstorage: bool,
    pub amclusterable: bool,
    pub ampredlocks: bool,
    pub amcanparallel: bool,
    pub amcaninclude: bool,
    pub amusemaintenanceworkmem: bool,
    pub amparallelvacuumoptions: uint8,
    pub amkeytype: Oid,
    pub ambuild: ambuild_function,
    pub ambuildempty: ambuildempty_function,
    pub aminsert: aminsert_function,
    pub ambulkdelete: ambulkdelete_function,
    pub amvacuumcleanup: amvacuumcleanup_function,
    pub amcanreturn: amcanreturn_function,
    pub amcostestimate: amcostestimate_function,
    pub amoptions: amoptions_function,
    pub amproperty: amproperty_function,
    pub ambuildphasename: ambuildphasename_function,
    pub amvalidate: amvalidate_function,
    pub ambeginscan: ambeginscan_function,
    pub amrescan: amrescan_function,
    pub amgettuple: amgettuple_function,
    pub amgetbitmap: amgetbitmap_function,
    pub amendscan: amendscan_function,
    pub ammarkpos: ammarkpos_function,
    pub amrestrpos: amrestrpos_function,
    pub amestimateparallelscan: amestimateparallelscan_function,
    pub aminitparallelscan: aminitparallelscan_function,
    pub amparallelrescan: amparallelrescan_function,
}
impl Default for IndexAmRoutine {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn GetIndexAmRoutine(arg_amhandler: Oid) -> *mut IndexAmRoutine {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetIndexAmRoutine(arg_amhandler: Oid) -> *mut IndexAmRoutine;
        }
        GetIndexAmRoutine(arg_amhandler)
    })
}
pub unsafe fn GetIndexAmRoutineByAmId(arg_amoid: Oid, arg_noerror: bool) -> *mut IndexAmRoutine {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetIndexAmRoutineByAmId(arg_amoid: Oid, arg_noerror: bool) -> *mut IndexAmRoutine;
        }
        GetIndexAmRoutineByAmId(arg_amoid, arg_noerror)
    })
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GinStatsData {
    pub nPendingPages: BlockNumber,
    pub nTotalPages: BlockNumber,
    pub nEntryPages: BlockNumber,
    pub nDataPages: BlockNumber,
    pub nEntries: int64,
    pub ginVersion: int32,
}
pub type GinTernaryValue = ::std::os::raw::c_char;
extern "C" {
    pub static mut GinFuzzySearchLimit: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut gin_pending_list_limit: ::std::os::raw::c_int;
}
pub unsafe fn ginGetStats(arg_index: Relation, arg_stats: *mut GinStatsData) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ginGetStats(arg_index: Relation, arg_stats: *mut GinStatsData);
        }
        ginGetStats(arg_index, arg_stats)
    })
}
pub unsafe fn ginUpdateStats(
    arg_index: Relation,
    arg_stats: *const GinStatsData,
    arg_is_build: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ginUpdateStats(
                arg_index: Relation,
                arg_stats: *const GinStatsData,
                arg_is_build: bool,
            );
        }
        ginUpdateStats(arg_index, arg_stats, arg_is_build)
    })
}
pub unsafe fn XLogBeginInsert() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XLogBeginInsert();
        }
        XLogBeginInsert()
    })
}
pub unsafe fn XLogSetRecordFlags(arg_flags: uint8) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XLogSetRecordFlags(arg_flags: uint8);
        }
        XLogSetRecordFlags(arg_flags)
    })
}
pub unsafe fn XLogInsert(arg_rmid: RmgrId, arg_info: uint8) -> XLogRecPtr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XLogInsert(arg_rmid: RmgrId, arg_info: uint8) -> XLogRecPtr;
        }
        XLogInsert(arg_rmid, arg_info)
    })
}
pub unsafe fn XLogEnsureRecordSpace(
    arg_max_block_id: ::std::os::raw::c_int,
    arg_ndatas: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XLogEnsureRecordSpace(
                arg_max_block_id: ::std::os::raw::c_int,
                arg_ndatas: ::std::os::raw::c_int,
            );
        }
        XLogEnsureRecordSpace(arg_max_block_id, arg_ndatas)
    })
}
pub unsafe fn XLogRegisterData(
    arg_data: *mut ::std::os::raw::c_char,
    arg_len: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XLogRegisterData(
                arg_data: *mut ::std::os::raw::c_char,
                arg_len: ::std::os::raw::c_int,
            );
        }
        XLogRegisterData(arg_data, arg_len)
    })
}
pub unsafe fn XLogRegisterBuffer(arg_block_id: uint8, arg_buffer: Buffer, arg_flags: uint8) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XLogRegisterBuffer(arg_block_id: uint8, arg_buffer: Buffer, arg_flags: uint8);
        }
        XLogRegisterBuffer(arg_block_id, arg_buffer, arg_flags)
    })
}
pub unsafe fn XLogRegisterBlock(
    arg_block_id: uint8,
    arg_rnode: *mut RelFileNode,
    arg_forknum: ForkNumber,
    arg_blknum: BlockNumber,
    arg_page: *mut ::std::os::raw::c_char,
    arg_flags: uint8,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XLogRegisterBlock(
                arg_block_id: uint8,
                arg_rnode: *mut RelFileNode,
                arg_forknum: ForkNumber,
                arg_blknum: BlockNumber,
                arg_page: *mut ::std::os::raw::c_char,
                arg_flags: uint8,
            );
        }
        XLogRegisterBlock(arg_block_id, arg_rnode, arg_forknum, arg_blknum, arg_page, arg_flags)
    })
}
pub unsafe fn XLogRegisterBufData(
    arg_block_id: uint8,
    arg_data: *mut ::std::os::raw::c_char,
    arg_len: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XLogRegisterBufData(
                arg_block_id: uint8,
                arg_data: *mut ::std::os::raw::c_char,
                arg_len: ::std::os::raw::c_int,
            );
        }
        XLogRegisterBufData(arg_block_id, arg_data, arg_len)
    })
}
pub unsafe fn XLogResetInsertion() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XLogResetInsertion();
        }
        XLogResetInsertion()
    })
}
pub unsafe fn XLogCheckBufferNeedsBackup(arg_buffer: Buffer) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XLogCheckBufferNeedsBackup(arg_buffer: Buffer) -> bool;
        }
        XLogCheckBufferNeedsBackup(arg_buffer)
    })
}
pub unsafe fn log_newpage(
    arg_rnode: *mut RelFileNode,
    arg_forkNum: ForkNumber,
    arg_blk: BlockNumber,
    arg_page: *mut ::std::os::raw::c_char,
    arg_page_std: bool,
) -> XLogRecPtr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn log_newpage(
                arg_rnode: *mut RelFileNode,
                arg_forkNum: ForkNumber,
                arg_blk: BlockNumber,
                arg_page: *mut ::std::os::raw::c_char,
                arg_page_std: bool,
            ) -> XLogRecPtr;
        }
        log_newpage(arg_rnode, arg_forkNum, arg_blk, arg_page, arg_page_std)
    })
}
pub unsafe fn log_newpage_buffer(arg_buffer: Buffer, arg_page_std: bool) -> XLogRecPtr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn log_newpage_buffer(arg_buffer: Buffer, arg_page_std: bool) -> XLogRecPtr;
        }
        log_newpage_buffer(arg_buffer, arg_page_std)
    })
}
pub unsafe fn log_newpage_range(
    arg_rel: Relation,
    arg_forkNum: ForkNumber,
    arg_startblk: BlockNumber,
    arg_endblk: BlockNumber,
    arg_page_std: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn log_newpage_range(
                arg_rel: Relation,
                arg_forkNum: ForkNumber,
                arg_startblk: BlockNumber,
                arg_endblk: BlockNumber,
                arg_page_std: bool,
            );
        }
        log_newpage_range(arg_rel, arg_forkNum, arg_startblk, arg_endblk, arg_page_std)
    })
}
pub unsafe fn XLogSaveBufferForHint(arg_buffer: Buffer, arg_buffer_std: bool) -> XLogRecPtr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XLogSaveBufferForHint(arg_buffer: Buffer, arg_buffer_std: bool) -> XLogRecPtr;
        }
        XLogSaveBufferForHint(arg_buffer, arg_buffer_std)
    })
}
pub unsafe fn InitXLogInsert() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitXLogInsert();
        }
        InitXLogInsert()
    })
}
extern "C" {
    pub static mut sync_method: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut ThisTimeLineID: TimeLineID;
}
extern "C" {
    pub static mut InRecovery: bool;
}
pub const HotStandbyState_STANDBY_DISABLED: HotStandbyState = 0;
pub const HotStandbyState_STANDBY_INITIALIZED: HotStandbyState = 1;
pub const HotStandbyState_STANDBY_SNAPSHOT_PENDING: HotStandbyState = 2;
pub const HotStandbyState_STANDBY_SNAPSHOT_READY: HotStandbyState = 3;
pub type HotStandbyState = ::std::os::raw::c_uint;
extern "C" {
    pub static mut standbyState: HotStandbyState;
}
pub const RecoveryTargetType_RECOVERY_TARGET_UNSET: RecoveryTargetType = 0;
pub const RecoveryTargetType_RECOVERY_TARGET_XID: RecoveryTargetType = 1;
pub const RecoveryTargetType_RECOVERY_TARGET_TIME: RecoveryTargetType = 2;
pub const RecoveryTargetType_RECOVERY_TARGET_NAME: RecoveryTargetType = 3;
pub const RecoveryTargetType_RECOVERY_TARGET_LSN: RecoveryTargetType = 4;
pub const RecoveryTargetType_RECOVERY_TARGET_IMMEDIATE: RecoveryTargetType = 5;
pub type RecoveryTargetType = ::std::os::raw::c_uint;
pub const RecoveryTargetTimeLineGoal_RECOVERY_TARGET_TIMELINE_CONTROLFILE:
    RecoveryTargetTimeLineGoal = 0;
pub const RecoveryTargetTimeLineGoal_RECOVERY_TARGET_TIMELINE_LATEST: RecoveryTargetTimeLineGoal =
    1;
pub const RecoveryTargetTimeLineGoal_RECOVERY_TARGET_TIMELINE_NUMERIC: RecoveryTargetTimeLineGoal =
    2;
pub type RecoveryTargetTimeLineGoal = ::std::os::raw::c_uint;
extern "C" {
    pub static mut ProcLastRecPtr: XLogRecPtr;
}
extern "C" {
    pub static mut XactLastRecEnd: XLogRecPtr;
}
extern "C" {
    pub static mut XactLastCommitEnd: XLogRecPtr;
}
extern "C" {
    pub static mut reachedConsistency: bool;
}
extern "C" {
    pub static mut wal_segment_size: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut min_wal_size_mb: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut max_wal_size_mb: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut wal_keep_size_mb: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut max_slot_wal_keep_size_mb: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut XLOGbuffers: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut XLogArchiveTimeout: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut wal_retrieve_retry_interval: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut XLogArchiveCommand: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut EnableHotStandby: bool;
}
extern "C" {
    pub static mut fullPageWrites: bool;
}
extern "C" {
    pub static mut wal_log_hints: bool;
}
extern "C" {
    pub static mut wal_compression: bool;
}
extern "C" {
    pub static mut wal_init_zero: bool;
}
extern "C" {
    pub static mut wal_recycle: bool;
}
extern "C" {
    pub static mut wal_consistency_checking: *mut bool;
}
extern "C" {
    pub static mut wal_consistency_checking_string: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut log_checkpoints: bool;
}
extern "C" {
    pub static mut recoveryRestoreCommand: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut recoveryEndCommand: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut archiveCleanupCommand: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut recoveryTargetInclusive: bool;
}
extern "C" {
    pub static mut recoveryTargetAction: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut recovery_min_apply_delay: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut PrimaryConnInfo: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut PrimarySlotName: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut wal_receiver_create_temp_slot: bool;
}
extern "C" {
    pub static mut recoveryTargetXid: TransactionId;
}
extern "C" {
    pub static mut recovery_target_time_string: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut recoveryTargetName: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut recoveryTargetLSN: XLogRecPtr;
}
extern "C" {
    pub static mut recoveryTarget: RecoveryTargetType;
}
extern "C" {
    pub static mut PromoteTriggerFile: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut recoveryTargetTimeLineGoal: RecoveryTargetTimeLineGoal;
}
extern "C" {
    pub static mut recoveryTargetTLIRequested: TimeLineID;
}
extern "C" {
    pub static mut recoveryTargetTLI: TimeLineID;
}
extern "C" {
    pub static mut CheckPointSegments: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut StandbyModeRequested: bool;
}
extern "C" {
    pub static mut StandbyMode: bool;
}
pub const ArchiveMode_ARCHIVE_MODE_OFF: ArchiveMode = 0;
pub const ArchiveMode_ARCHIVE_MODE_ON: ArchiveMode = 1;
pub const ArchiveMode_ARCHIVE_MODE_ALWAYS: ArchiveMode = 2;
pub type ArchiveMode = ::std::os::raw::c_uint;
extern "C" {
    pub static mut XLogArchiveMode: ::std::os::raw::c_int;
}
pub const WalLevel_WAL_LEVEL_MINIMAL: WalLevel = 0;
pub const WalLevel_WAL_LEVEL_REPLICA: WalLevel = 1;
pub const WalLevel_WAL_LEVEL_LOGICAL: WalLevel = 2;
pub type WalLevel = ::std::os::raw::c_uint;
pub const RecoveryState_RECOVERY_STATE_CRASH: RecoveryState = 0;
pub const RecoveryState_RECOVERY_STATE_ARCHIVE: RecoveryState = 1;
pub const RecoveryState_RECOVERY_STATE_DONE: RecoveryState = 2;
pub type RecoveryState = ::std::os::raw::c_uint;
extern "C" {
    pub static mut wal_level: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CheckpointStatsData {
    pub ckpt_start_t: TimestampTz,
    pub ckpt_write_t: TimestampTz,
    pub ckpt_sync_t: TimestampTz,
    pub ckpt_sync_end_t: TimestampTz,
    pub ckpt_end_t: TimestampTz,
    pub ckpt_bufs_written: ::std::os::raw::c_int,
    pub ckpt_segs_added: ::std::os::raw::c_int,
    pub ckpt_segs_removed: ::std::os::raw::c_int,
    pub ckpt_segs_recycled: ::std::os::raw::c_int,
    pub ckpt_sync_rels: ::std::os::raw::c_int,
    pub ckpt_longest_sync: uint64,
    pub ckpt_agg_sync_time: uint64,
}
extern "C" {
    pub static mut CheckpointStats: CheckpointStatsData;
}
pub const WALAvailability_WALAVAIL_INVALID_LSN: WALAvailability = 0;
pub const WALAvailability_WALAVAIL_RESERVED: WALAvailability = 1;
pub const WALAvailability_WALAVAIL_EXTENDED: WALAvailability = 2;
pub const WALAvailability_WALAVAIL_UNRESERVED: WALAvailability = 3;
pub const WALAvailability_WALAVAIL_REMOVED: WALAvailability = 4;
pub type WALAvailability = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLogRecData {
    _unused: [u8; 0],
}
pub unsafe fn XLogInsertRecord(
    arg_rdata: *mut XLogRecData,
    arg_fpw_lsn: XLogRecPtr,
    arg_flags: uint8,
    arg_num_fpi: ::std::os::raw::c_int,
) -> XLogRecPtr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XLogInsertRecord(
                arg_rdata: *mut XLogRecData,
                arg_fpw_lsn: XLogRecPtr,
                arg_flags: uint8,
                arg_num_fpi: ::std::os::raw::c_int,
            ) -> XLogRecPtr;
        }
        XLogInsertRecord(arg_rdata, arg_fpw_lsn, arg_flags, arg_num_fpi)
    })
}
pub unsafe fn XLogFlush(arg_RecPtr: XLogRecPtr) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XLogFlush(arg_RecPtr: XLogRecPtr);
        }
        XLogFlush(arg_RecPtr)
    })
}
pub unsafe fn XLogBackgroundFlush() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XLogBackgroundFlush() -> bool;
        }
        XLogBackgroundFlush()
    })
}
pub unsafe fn XLogNeedsFlush(arg_RecPtr: XLogRecPtr) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XLogNeedsFlush(arg_RecPtr: XLogRecPtr) -> bool;
        }
        XLogNeedsFlush(arg_RecPtr)
    })
}
pub unsafe fn XLogFileInit(
    arg_segno: XLogSegNo,
    arg_use_existent: *mut bool,
    arg_use_lock: bool,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XLogFileInit(
                arg_segno: XLogSegNo,
                arg_use_existent: *mut bool,
                arg_use_lock: bool,
            ) -> ::std::os::raw::c_int;
        }
        XLogFileInit(arg_segno, arg_use_existent, arg_use_lock)
    })
}
pub unsafe fn XLogFileOpen(arg_segno: XLogSegNo) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XLogFileOpen(arg_segno: XLogSegNo) -> ::std::os::raw::c_int;
        }
        XLogFileOpen(arg_segno)
    })
}
pub unsafe fn CheckXLogRemoved(arg_segno: XLogSegNo, arg_tli: TimeLineID) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CheckXLogRemoved(arg_segno: XLogSegNo, arg_tli: TimeLineID);
        }
        CheckXLogRemoved(arg_segno, arg_tli)
    })
}
pub unsafe fn XLogGetLastRemovedSegno() -> XLogSegNo {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XLogGetLastRemovedSegno() -> XLogSegNo;
        }
        XLogGetLastRemovedSegno()
    })
}
pub unsafe fn XLogSetAsyncXactLSN(arg_record: XLogRecPtr) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XLogSetAsyncXactLSN(arg_record: XLogRecPtr);
        }
        XLogSetAsyncXactLSN(arg_record)
    })
}
pub unsafe fn XLogSetReplicationSlotMinimumLSN(arg_lsn: XLogRecPtr) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XLogSetReplicationSlotMinimumLSN(arg_lsn: XLogRecPtr);
        }
        XLogSetReplicationSlotMinimumLSN(arg_lsn)
    })
}
pub unsafe fn xlog_redo(arg_record: *mut XLogReaderState) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xlog_redo(arg_record: *mut XLogReaderState);
        }
        xlog_redo(arg_record)
    })
}
pub unsafe fn xlog_desc(arg_buf: StringInfo, arg_record: *mut XLogReaderState) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xlog_desc(arg_buf: StringInfo, arg_record: *mut XLogReaderState);
        }
        xlog_desc(arg_buf, arg_record)
    })
}
pub unsafe fn xlog_identify(arg_info: uint8) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xlog_identify(arg_info: uint8) -> *const ::std::os::raw::c_char;
        }
        xlog_identify(arg_info)
    })
}
pub unsafe fn issue_xlog_fsync(arg_fd: ::std::os::raw::c_int, arg_segno: XLogSegNo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn issue_xlog_fsync(arg_fd: ::std::os::raw::c_int, arg_segno: XLogSegNo);
        }
        issue_xlog_fsync(arg_fd, arg_segno)
    })
}
pub unsafe fn RecoveryInProgress() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RecoveryInProgress() -> bool;
        }
        RecoveryInProgress()
    })
}
pub unsafe fn GetRecoveryState() -> RecoveryState {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetRecoveryState() -> RecoveryState;
        }
        GetRecoveryState()
    })
}
pub unsafe fn HotStandbyActive() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn HotStandbyActive() -> bool;
        }
        HotStandbyActive()
    })
}
pub unsafe fn HotStandbyActiveInReplay() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn HotStandbyActiveInReplay() -> bool;
        }
        HotStandbyActiveInReplay()
    })
}
pub unsafe fn XLogInsertAllowed() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XLogInsertAllowed() -> bool;
        }
        XLogInsertAllowed()
    })
}
pub unsafe fn GetXLogReceiptTime(arg_rtime: *mut TimestampTz, arg_fromStream: *mut bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetXLogReceiptTime(arg_rtime: *mut TimestampTz, arg_fromStream: *mut bool);
        }
        GetXLogReceiptTime(arg_rtime, arg_fromStream)
    })
}
pub unsafe fn GetXLogReplayRecPtr(arg_replayTLI: *mut TimeLineID) -> XLogRecPtr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetXLogReplayRecPtr(arg_replayTLI: *mut TimeLineID) -> XLogRecPtr;
        }
        GetXLogReplayRecPtr(arg_replayTLI)
    })
}
pub unsafe fn GetXLogInsertRecPtr() -> XLogRecPtr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetXLogInsertRecPtr() -> XLogRecPtr;
        }
        GetXLogInsertRecPtr()
    })
}
pub unsafe fn GetXLogWriteRecPtr() -> XLogRecPtr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetXLogWriteRecPtr() -> XLogRecPtr;
        }
        GetXLogWriteRecPtr()
    })
}
pub unsafe fn RecoveryIsPaused() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RecoveryIsPaused() -> bool;
        }
        RecoveryIsPaused()
    })
}
pub unsafe fn SetRecoveryPause(arg_recoveryPause: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SetRecoveryPause(arg_recoveryPause: bool);
        }
        SetRecoveryPause(arg_recoveryPause)
    })
}
pub unsafe fn GetLatestXTime() -> TimestampTz {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetLatestXTime() -> TimestampTz;
        }
        GetLatestXTime()
    })
}
pub unsafe fn GetCurrentChunkReplayStartTime() -> TimestampTz {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetCurrentChunkReplayStartTime() -> TimestampTz;
        }
        GetCurrentChunkReplayStartTime()
    })
}
pub unsafe fn UpdateControlFile() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn UpdateControlFile();
        }
        UpdateControlFile()
    })
}
pub unsafe fn GetSystemIdentifier() -> uint64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetSystemIdentifier() -> uint64;
        }
        GetSystemIdentifier()
    })
}
pub unsafe fn GetMockAuthenticationNonce() -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetMockAuthenticationNonce() -> *mut ::std::os::raw::c_char;
        }
        GetMockAuthenticationNonce()
    })
}
pub unsafe fn DataChecksumsEnabled() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DataChecksumsEnabled() -> bool;
        }
        DataChecksumsEnabled()
    })
}
pub unsafe fn GetFakeLSNForUnloggedRel() -> XLogRecPtr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetFakeLSNForUnloggedRel() -> XLogRecPtr;
        }
        GetFakeLSNForUnloggedRel()
    })
}
pub unsafe fn XLOGShmemSize() -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XLOGShmemSize() -> Size;
        }
        XLOGShmemSize()
    })
}
pub unsafe fn XLOGShmemInit() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XLOGShmemInit();
        }
        XLOGShmemInit()
    })
}
pub unsafe fn BootStrapXLOG() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BootStrapXLOG();
        }
        BootStrapXLOG()
    })
}
pub unsafe fn LocalProcessControlFile(arg_reset: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LocalProcessControlFile(arg_reset: bool);
        }
        LocalProcessControlFile(arg_reset)
    })
}
pub unsafe fn StartupXLOG() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn StartupXLOG();
        }
        StartupXLOG()
    })
}
pub unsafe fn ShutdownXLOG(arg_code: ::std::os::raw::c_int, arg_arg: Datum) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ShutdownXLOG(arg_code: ::std::os::raw::c_int, arg_arg: Datum);
        }
        ShutdownXLOG(arg_code, arg_arg)
    })
}
pub unsafe fn InitXLOGAccess() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitXLOGAccess();
        }
        InitXLOGAccess()
    })
}
pub unsafe fn CreateCheckPoint(arg_flags: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateCheckPoint(arg_flags: ::std::os::raw::c_int);
        }
        CreateCheckPoint(arg_flags)
    })
}
pub unsafe fn CreateRestartPoint(arg_flags: ::std::os::raw::c_int) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateRestartPoint(arg_flags: ::std::os::raw::c_int) -> bool;
        }
        CreateRestartPoint(arg_flags)
    })
}
pub unsafe fn GetWALAvailability(arg_targetLSN: XLogRecPtr) -> WALAvailability {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetWALAvailability(arg_targetLSN: XLogRecPtr) -> WALAvailability;
        }
        GetWALAvailability(arg_targetLSN)
    })
}
pub unsafe fn CalculateMaxmumSafeLSN() -> XLogRecPtr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CalculateMaxmumSafeLSN() -> XLogRecPtr;
        }
        CalculateMaxmumSafeLSN()
    })
}
pub unsafe fn XLogPutNextOid(arg_nextOid: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XLogPutNextOid(arg_nextOid: Oid);
        }
        XLogPutNextOid(arg_nextOid)
    })
}
pub unsafe fn XLogRestorePoint(arg_rpName: *const ::std::os::raw::c_char) -> XLogRecPtr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XLogRestorePoint(arg_rpName: *const ::std::os::raw::c_char) -> XLogRecPtr;
        }
        XLogRestorePoint(arg_rpName)
    })
}
pub unsafe fn UpdateFullPageWrites() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn UpdateFullPageWrites();
        }
        UpdateFullPageWrites()
    })
}
pub unsafe fn GetFullPageWriteInfo(
    arg_RedoRecPtr_p: *mut XLogRecPtr,
    arg_doPageWrites_p: *mut bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetFullPageWriteInfo(
                arg_RedoRecPtr_p: *mut XLogRecPtr,
                arg_doPageWrites_p: *mut bool,
            );
        }
        GetFullPageWriteInfo(arg_RedoRecPtr_p, arg_doPageWrites_p)
    })
}
pub unsafe fn GetRedoRecPtr() -> XLogRecPtr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetRedoRecPtr() -> XLogRecPtr;
        }
        GetRedoRecPtr()
    })
}
pub unsafe fn GetInsertRecPtr() -> XLogRecPtr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetInsertRecPtr() -> XLogRecPtr;
        }
        GetInsertRecPtr()
    })
}
pub unsafe fn GetFlushRecPtr() -> XLogRecPtr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetFlushRecPtr() -> XLogRecPtr;
        }
        GetFlushRecPtr()
    })
}
pub unsafe fn GetLastImportantRecPtr() -> XLogRecPtr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetLastImportantRecPtr() -> XLogRecPtr;
        }
        GetLastImportantRecPtr()
    })
}
pub unsafe fn RemovePromoteSignalFiles() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RemovePromoteSignalFiles();
        }
        RemovePromoteSignalFiles()
    })
}
pub unsafe fn PromoteIsTriggered() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PromoteIsTriggered() -> bool;
        }
        PromoteIsTriggered()
    })
}
pub unsafe fn CheckPromoteSignal() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CheckPromoteSignal() -> bool;
        }
        CheckPromoteSignal()
    })
}
pub unsafe fn WakeupRecovery() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn WakeupRecovery();
        }
        WakeupRecovery()
    })
}
pub unsafe fn SetWalWriterSleeping(arg_sleeping: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SetWalWriterSleeping(arg_sleeping: bool);
        }
        SetWalWriterSleeping(arg_sleeping)
    })
}
pub unsafe fn StartupRequestWalReceiverRestart() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn StartupRequestWalReceiverRestart();
        }
        StartupRequestWalReceiverRestart()
    })
}
pub unsafe fn XLogRequestWalReceiverReply() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XLogRequestWalReceiverReply();
        }
        XLogRequestWalReceiverReply()
    })
}
pub unsafe fn assign_max_wal_size(
    arg_newval: ::std::os::raw::c_int,
    arg_extra: *mut ::std::os::raw::c_void,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn assign_max_wal_size(
                arg_newval: ::std::os::raw::c_int,
                arg_extra: *mut ::std::os::raw::c_void,
            );
        }
        assign_max_wal_size(arg_newval, arg_extra)
    })
}
pub unsafe fn assign_checkpoint_completion_target(
    arg_newval: f64,
    arg_extra: *mut ::std::os::raw::c_void,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn assign_checkpoint_completion_target(
                arg_newval: f64,
                arg_extra: *mut ::std::os::raw::c_void,
            );
        }
        assign_checkpoint_completion_target(arg_newval, arg_extra)
    })
}
pub const SessionBackupState_SESSION_BACKUP_NONE: SessionBackupState = 0;
pub const SessionBackupState_SESSION_BACKUP_EXCLUSIVE: SessionBackupState = 1;
pub const SessionBackupState_SESSION_BACKUP_NON_EXCLUSIVE: SessionBackupState = 2;
pub type SessionBackupState = ::std::os::raw::c_uint;
pub unsafe fn do_pg_start_backup(
    arg_backupidstr: *const ::std::os::raw::c_char,
    arg_fast: bool,
    arg_starttli_p: *mut TimeLineID,
    arg_labelfile: StringInfo,
    arg_tablespaces: *mut *mut List,
    arg_tblspcmapfile: StringInfo,
    arg_infotbssize: bool,
    arg_needtblspcmapfile: bool,
) -> XLogRecPtr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn do_pg_start_backup(
                arg_backupidstr: *const ::std::os::raw::c_char,
                arg_fast: bool,
                arg_starttli_p: *mut TimeLineID,
                arg_labelfile: StringInfo,
                arg_tablespaces: *mut *mut List,
                arg_tblspcmapfile: StringInfo,
                arg_infotbssize: bool,
                arg_needtblspcmapfile: bool,
            ) -> XLogRecPtr;
        }
        do_pg_start_backup(
            arg_backupidstr,
            arg_fast,
            arg_starttli_p,
            arg_labelfile,
            arg_tablespaces,
            arg_tblspcmapfile,
            arg_infotbssize,
            arg_needtblspcmapfile,
        )
    })
}
pub unsafe fn do_pg_stop_backup(
    arg_labelfile: *mut ::std::os::raw::c_char,
    arg_waitforarchive: bool,
    arg_stoptli_p: *mut TimeLineID,
) -> XLogRecPtr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn do_pg_stop_backup(
                arg_labelfile: *mut ::std::os::raw::c_char,
                arg_waitforarchive: bool,
                arg_stoptli_p: *mut TimeLineID,
            ) -> XLogRecPtr;
        }
        do_pg_stop_backup(arg_labelfile, arg_waitforarchive, arg_stoptli_p)
    })
}
pub unsafe fn do_pg_abort_backup(arg_code: ::std::os::raw::c_int, arg_arg: Datum) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn do_pg_abort_backup(arg_code: ::std::os::raw::c_int, arg_arg: Datum);
        }
        do_pg_abort_backup(arg_code, arg_arg)
    })
}
pub unsafe fn register_persistent_abort_backup_handler() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn register_persistent_abort_backup_handler();
        }
        register_persistent_abort_backup_handler()
    })
}
pub unsafe fn get_backup_status() -> SessionBackupState {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_backup_status() -> SessionBackupState;
        }
        get_backup_status()
    })
}
pub type GistNSN = XLogRecPtr;
pub type PageGistNSN = PageXLogRecPtr;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GISTPageOpaqueData {
    pub nsn: PageGistNSN,
    pub rightlink: BlockNumber,
    pub flags: uint16,
    pub gist_page_id: uint16,
}
pub type GISTPageOpaque = *mut GISTPageOpaqueData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GIST_SPLITVEC {
    pub spl_left: *mut OffsetNumber,
    pub spl_nleft: ::std::os::raw::c_int,
    pub spl_ldatum: Datum,
    pub spl_ldatum_exists: bool,
    pub spl_right: *mut OffsetNumber,
    pub spl_nright: ::std::os::raw::c_int,
    pub spl_rdatum: Datum,
    pub spl_rdatum_exists: bool,
}
impl Default for GIST_SPLITVEC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GISTENTRY {
    pub key: Datum,
    pub rel: Relation,
    pub page: Page,
    pub offset: OffsetNumber,
    pub leafkey: bool,
}
impl Default for GISTENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GISTDeletedPageContents {
    pub deleteXid: FullTransactionId,
}
#[repr(C)]
#[derive(Debug)]
pub struct GistEntryVector {
    pub n: int32,
    pub vector: __IncompleteArrayField<GISTENTRY>,
}
impl Default for GistEntryVector {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn relation_open(arg_relationId: Oid, arg_lockmode: LOCKMODE) -> Relation {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn relation_open(arg_relationId: Oid, arg_lockmode: LOCKMODE) -> Relation;
        }
        relation_open(arg_relationId, arg_lockmode)
    })
}
pub unsafe fn try_relation_open(arg_relationId: Oid, arg_lockmode: LOCKMODE) -> Relation {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn try_relation_open(arg_relationId: Oid, arg_lockmode: LOCKMODE) -> Relation;
        }
        try_relation_open(arg_relationId, arg_lockmode)
    })
}
pub unsafe fn relation_openrv(arg_relation: *const RangeVar, arg_lockmode: LOCKMODE) -> Relation {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn relation_openrv(arg_relation: *const RangeVar, arg_lockmode: LOCKMODE) -> Relation;
        }
        relation_openrv(arg_relation, arg_lockmode)
    })
}
pub unsafe fn relation_openrv_extended(
    arg_relation: *const RangeVar,
    arg_lockmode: LOCKMODE,
    arg_missing_ok: bool,
) -> Relation {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn relation_openrv_extended(
                arg_relation: *const RangeVar,
                arg_lockmode: LOCKMODE,
                arg_missing_ok: bool,
            ) -> Relation;
        }
        relation_openrv_extended(arg_relation, arg_lockmode, arg_missing_ok)
    })
}
pub unsafe fn relation_close(arg_relation: Relation, arg_lockmode: LOCKMODE) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn relation_close(arg_relation: Relation, arg_lockmode: LOCKMODE);
        }
        relation_close(arg_relation, arg_lockmode)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TableScanDescData {
    pub rs_rd: Relation,
    pub rs_snapshot: *mut SnapshotData,
    pub rs_nkeys: ::std::os::raw::c_int,
    pub rs_key: *mut ScanKeyData,
    pub rs_flags: uint32,
    pub rs_parallel: *mut ParallelTableScanDescData,
}
impl Default for TableScanDescData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TableScanDesc = *mut TableScanDescData;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ParallelTableScanDescData {
    pub phs_relid: Oid,
    pub phs_syncscan: bool,
    pub phs_snapshot_any: bool,
    pub phs_snapshot_off: Size,
}
pub type ParallelTableScanDesc = *mut ParallelTableScanDescData;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ParallelBlockTableScanDescData {
    pub base: ParallelTableScanDescData,
    pub phs_nblocks: BlockNumber,
    pub phs_mutex: slock_t,
    pub phs_startblock: BlockNumber,
    pub phs_nallocated: pg_atomic_uint64,
}
pub type ParallelBlockTableScanDesc = *mut ParallelBlockTableScanDescData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexFetchTableData {
    pub rel: Relation,
}
impl Default for IndexFetchTableData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexScanDescData {
    pub heapRelation: Relation,
    pub indexRelation: Relation,
    pub xs_snapshot: *mut SnapshotData,
    pub numberOfKeys: ::std::os::raw::c_int,
    pub numberOfOrderBys: ::std::os::raw::c_int,
    pub keyData: *mut ScanKeyData,
    pub orderByData: *mut ScanKeyData,
    pub xs_want_itup: bool,
    pub xs_temp_snap: bool,
    pub kill_prior_tuple: bool,
    pub ignore_killed_tuples: bool,
    pub xactStartedInRecovery: bool,
    pub opaque: *mut ::std::os::raw::c_void,
    pub xs_itup: IndexTuple,
    pub xs_itupdesc: *mut TupleDescData,
    pub xs_hitup: HeapTuple,
    pub xs_hitupdesc: *mut TupleDescData,
    pub xs_heaptid: ItemPointerData,
    pub xs_heap_continue: bool,
    pub xs_heapfetch: *mut IndexFetchTableData,
    pub xs_recheck: bool,
    pub xs_orderbyvals: *mut Datum,
    pub xs_orderbynulls: *mut bool,
    pub xs_recheckorderby: bool,
    pub parallel_scan: *mut ParallelIndexScanDescData,
}
impl Default for IndexScanDescData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct ParallelIndexScanDescData {
    pub ps_relid: Oid,
    pub ps_indexid: Oid,
    pub ps_offset: Size,
    pub ps_snapshot_data: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysScanDescData {
    pub heap_rel: Relation,
    pub irel: Relation,
    pub scan: *mut TableScanDescData,
    pub iscan: *mut IndexScanDescData,
    pub snapshot: *mut SnapshotData,
    pub slot: *mut TupleTableSlot,
}
impl Default for SysScanDescData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn table_open(arg_relationId: Oid, arg_lockmode: LOCKMODE) -> Relation {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn table_open(arg_relationId: Oid, arg_lockmode: LOCKMODE) -> Relation;
        }
        table_open(arg_relationId, arg_lockmode)
    })
}
pub unsafe fn table_openrv(arg_relation: *const RangeVar, arg_lockmode: LOCKMODE) -> Relation {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn table_openrv(arg_relation: *const RangeVar, arg_lockmode: LOCKMODE) -> Relation;
        }
        table_openrv(arg_relation, arg_lockmode)
    })
}
pub unsafe fn table_openrv_extended(
    arg_relation: *const RangeVar,
    arg_lockmode: LOCKMODE,
    arg_missing_ok: bool,
) -> Relation {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn table_openrv_extended(
                arg_relation: *const RangeVar,
                arg_lockmode: LOCKMODE,
                arg_missing_ok: bool,
            ) -> Relation;
        }
        table_openrv_extended(arg_relation, arg_lockmode, arg_missing_ok)
    })
}
pub unsafe fn table_close(arg_relation: Relation, arg_lockmode: LOCKMODE) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn table_close(arg_relation: Relation, arg_lockmode: LOCKMODE);
        }
        table_close(arg_relation, arg_lockmode)
    })
}
pub type EOM_get_flat_size_method =
    ::std::option::Option<unsafe extern "C" fn(eohptr: *mut ExpandedObjectHeader) -> Size>;
pub type EOM_flatten_into_method = ::std::option::Option<
    unsafe extern "C" fn(
        eohptr: *mut ExpandedObjectHeader,
        result: *mut ::std::os::raw::c_void,
        allocated_size: Size,
    ),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ExpandedObjectMethods {
    pub get_flat_size: EOM_get_flat_size_method,
    pub flatten_into: EOM_flatten_into_method,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExpandedObjectHeader {
    pub vl_len_: int32,
    pub eoh_methods: *const ExpandedObjectMethods,
    pub eoh_context: MemoryContext,
    pub eoh_rw_ptr: [::std::os::raw::c_char; 10usize],
    pub eoh_ro_ptr: [::std::os::raw::c_char; 10usize],
}
impl Default for ExpandedObjectHeader {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn DatumGetEOHP(arg_d: Datum) -> *mut ExpandedObjectHeader {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DatumGetEOHP(arg_d: Datum) -> *mut ExpandedObjectHeader;
        }
        DatumGetEOHP(arg_d)
    })
}
pub unsafe fn EOH_init_header(
    arg_eohptr: *mut ExpandedObjectHeader,
    arg_methods: *const ExpandedObjectMethods,
    arg_obj_context: MemoryContext,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EOH_init_header(
                arg_eohptr: *mut ExpandedObjectHeader,
                arg_methods: *const ExpandedObjectMethods,
                arg_obj_context: MemoryContext,
            );
        }
        EOH_init_header(arg_eohptr, arg_methods, arg_obj_context)
    })
}
pub unsafe fn EOH_get_flat_size(arg_eohptr: *mut ExpandedObjectHeader) -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EOH_get_flat_size(arg_eohptr: *mut ExpandedObjectHeader) -> Size;
        }
        EOH_get_flat_size(arg_eohptr)
    })
}
pub unsafe fn EOH_flatten_into(
    arg_eohptr: *mut ExpandedObjectHeader,
    arg_result: *mut ::std::os::raw::c_void,
    arg_allocated_size: Size,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EOH_flatten_into(
                arg_eohptr: *mut ExpandedObjectHeader,
                arg_result: *mut ::std::os::raw::c_void,
                arg_allocated_size: Size,
            );
        }
        EOH_flatten_into(arg_eohptr, arg_result, arg_allocated_size)
    })
}
pub unsafe fn MakeExpandedObjectReadOnlyInternal(arg_d: Datum) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MakeExpandedObjectReadOnlyInternal(arg_d: Datum) -> Datum;
        }
        MakeExpandedObjectReadOnlyInternal(arg_d)
    })
}
pub unsafe fn TransferExpandedObject(arg_d: Datum, arg_new_parent: MemoryContext) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TransferExpandedObject(arg_d: Datum, arg_new_parent: MemoryContext) -> Datum;
        }
        TransferExpandedObject(arg_d, arg_new_parent)
    })
}
pub unsafe fn DeleteExpandedObject(arg_d: Datum) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DeleteExpandedObject(arg_d: Datum);
        }
        DeleteExpandedObject(arg_d)
    })
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ArrayType {
    pub vl_len_: int32,
    pub ndim: ::std::os::raw::c_int,
    pub dataoffset: int32,
    pub elemtype: Oid,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExpandedArrayHeader {
    pub hdr: ExpandedObjectHeader,
    pub ea_magic: ::std::os::raw::c_int,
    pub ndims: ::std::os::raw::c_int,
    pub dims: *mut ::std::os::raw::c_int,
    pub lbound: *mut ::std::os::raw::c_int,
    pub element_type: Oid,
    pub typlen: int16,
    pub typbyval: bool,
    pub typalign: ::std::os::raw::c_char,
    pub dvalues: *mut Datum,
    pub dnulls: *mut bool,
    pub dvalueslen: ::std::os::raw::c_int,
    pub nelems: ::std::os::raw::c_int,
    pub flat_size: Size,
    pub fvalue: *mut ArrayType,
    pub fstartptr: *mut ::std::os::raw::c_char,
    pub fendptr: *mut ::std::os::raw::c_char,
}
impl Default for ExpandedArrayHeader {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AnyArrayType {
    pub flt: ArrayType,
    pub xpn: ExpandedArrayHeader,
}
impl Default for AnyArrayType {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayBuildState {
    pub mcontext: MemoryContext,
    pub dvalues: *mut Datum,
    pub dnulls: *mut bool,
    pub alen: ::std::os::raw::c_int,
    pub nelems: ::std::os::raw::c_int,
    pub element_type: Oid,
    pub typlen: int16,
    pub typbyval: bool,
    pub typalign: ::std::os::raw::c_char,
    pub private_cxt: bool,
}
impl Default for ArrayBuildState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayBuildStateArr {
    pub mcontext: MemoryContext,
    pub data: *mut ::std::os::raw::c_char,
    pub nullbitmap: *mut bits8,
    pub abytes: ::std::os::raw::c_int,
    pub nbytes: ::std::os::raw::c_int,
    pub aitems: ::std::os::raw::c_int,
    pub nitems: ::std::os::raw::c_int,
    pub ndims: ::std::os::raw::c_int,
    pub dims: [::std::os::raw::c_int; 6usize],
    pub lbs: [::std::os::raw::c_int; 6usize],
    pub array_type: Oid,
    pub element_type: Oid,
    pub private_cxt: bool,
}
impl Default for ArrayBuildStateArr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayBuildStateAny {
    pub scalarstate: *mut ArrayBuildState,
    pub arraystate: *mut ArrayBuildStateArr,
}
impl Default for ArrayBuildStateAny {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayMetaState {
    pub element_type: Oid,
    pub typlen: int16,
    pub typbyval: bool,
    pub typalign: ::std::os::raw::c_char,
    pub typdelim: ::std::os::raw::c_char,
    pub typioparam: Oid,
    pub typiofunc: Oid,
    pub proc_: FmgrInfo,
}
impl Default for ArrayMetaState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayMapState {
    pub inp_extra: ArrayMetaState,
    pub ret_extra: ArrayMetaState,
}
impl Default for ArrayMapState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayIteratorData {
    _unused: [u8; 0],
}
pub type ArrayIterator = *mut ArrayIteratorData;
extern "C" {
    pub static mut Array_nulls: bool;
}
pub unsafe fn CopyArrayEls(
    arg_array: *mut ArrayType,
    arg_values: *mut Datum,
    arg_nulls: *mut bool,
    arg_nitems: ::std::os::raw::c_int,
    arg_typlen: ::std::os::raw::c_int,
    arg_typbyval: bool,
    arg_typalign: ::std::os::raw::c_char,
    arg_freedata: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CopyArrayEls(
                arg_array: *mut ArrayType,
                arg_values: *mut Datum,
                arg_nulls: *mut bool,
                arg_nitems: ::std::os::raw::c_int,
                arg_typlen: ::std::os::raw::c_int,
                arg_typbyval: bool,
                arg_typalign: ::std::os::raw::c_char,
                arg_freedata: bool,
            );
        }
        CopyArrayEls(
            arg_array,
            arg_values,
            arg_nulls,
            arg_nitems,
            arg_typlen,
            arg_typbyval,
            arg_typalign,
            arg_freedata,
        )
    })
}
pub unsafe fn array_get_element(
    arg_arraydatum: Datum,
    arg_nSubscripts: ::std::os::raw::c_int,
    arg_indx: *mut ::std::os::raw::c_int,
    arg_arraytyplen: ::std::os::raw::c_int,
    arg_elmlen: ::std::os::raw::c_int,
    arg_elmbyval: bool,
    arg_elmalign: ::std::os::raw::c_char,
    arg_isNull: *mut bool,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_get_element(
                arg_arraydatum: Datum,
                arg_nSubscripts: ::std::os::raw::c_int,
                arg_indx: *mut ::std::os::raw::c_int,
                arg_arraytyplen: ::std::os::raw::c_int,
                arg_elmlen: ::std::os::raw::c_int,
                arg_elmbyval: bool,
                arg_elmalign: ::std::os::raw::c_char,
                arg_isNull: *mut bool,
            ) -> Datum;
        }
        array_get_element(
            arg_arraydatum,
            arg_nSubscripts,
            arg_indx,
            arg_arraytyplen,
            arg_elmlen,
            arg_elmbyval,
            arg_elmalign,
            arg_isNull,
        )
    })
}
pub unsafe fn array_set_element(
    arg_arraydatum: Datum,
    arg_nSubscripts: ::std::os::raw::c_int,
    arg_indx: *mut ::std::os::raw::c_int,
    arg_dataValue: Datum,
    arg_isNull: bool,
    arg_arraytyplen: ::std::os::raw::c_int,
    arg_elmlen: ::std::os::raw::c_int,
    arg_elmbyval: bool,
    arg_elmalign: ::std::os::raw::c_char,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_set_element(
                arg_arraydatum: Datum,
                arg_nSubscripts: ::std::os::raw::c_int,
                arg_indx: *mut ::std::os::raw::c_int,
                arg_dataValue: Datum,
                arg_isNull: bool,
                arg_arraytyplen: ::std::os::raw::c_int,
                arg_elmlen: ::std::os::raw::c_int,
                arg_elmbyval: bool,
                arg_elmalign: ::std::os::raw::c_char,
            ) -> Datum;
        }
        array_set_element(
            arg_arraydatum,
            arg_nSubscripts,
            arg_indx,
            arg_dataValue,
            arg_isNull,
            arg_arraytyplen,
            arg_elmlen,
            arg_elmbyval,
            arg_elmalign,
        )
    })
}
pub unsafe fn array_get_slice(
    arg_arraydatum: Datum,
    arg_nSubscripts: ::std::os::raw::c_int,
    arg_upperIndx: *mut ::std::os::raw::c_int,
    arg_lowerIndx: *mut ::std::os::raw::c_int,
    arg_upperProvided: *mut bool,
    arg_lowerProvided: *mut bool,
    arg_arraytyplen: ::std::os::raw::c_int,
    arg_elmlen: ::std::os::raw::c_int,
    arg_elmbyval: bool,
    arg_elmalign: ::std::os::raw::c_char,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_get_slice(
                arg_arraydatum: Datum,
                arg_nSubscripts: ::std::os::raw::c_int,
                arg_upperIndx: *mut ::std::os::raw::c_int,
                arg_lowerIndx: *mut ::std::os::raw::c_int,
                arg_upperProvided: *mut bool,
                arg_lowerProvided: *mut bool,
                arg_arraytyplen: ::std::os::raw::c_int,
                arg_elmlen: ::std::os::raw::c_int,
                arg_elmbyval: bool,
                arg_elmalign: ::std::os::raw::c_char,
            ) -> Datum;
        }
        array_get_slice(
            arg_arraydatum,
            arg_nSubscripts,
            arg_upperIndx,
            arg_lowerIndx,
            arg_upperProvided,
            arg_lowerProvided,
            arg_arraytyplen,
            arg_elmlen,
            arg_elmbyval,
            arg_elmalign,
        )
    })
}
pub unsafe fn array_set_slice(
    arg_arraydatum: Datum,
    arg_nSubscripts: ::std::os::raw::c_int,
    arg_upperIndx: *mut ::std::os::raw::c_int,
    arg_lowerIndx: *mut ::std::os::raw::c_int,
    arg_upperProvided: *mut bool,
    arg_lowerProvided: *mut bool,
    arg_srcArrayDatum: Datum,
    arg_isNull: bool,
    arg_arraytyplen: ::std::os::raw::c_int,
    arg_elmlen: ::std::os::raw::c_int,
    arg_elmbyval: bool,
    arg_elmalign: ::std::os::raw::c_char,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_set_slice(
                arg_arraydatum: Datum,
                arg_nSubscripts: ::std::os::raw::c_int,
                arg_upperIndx: *mut ::std::os::raw::c_int,
                arg_lowerIndx: *mut ::std::os::raw::c_int,
                arg_upperProvided: *mut bool,
                arg_lowerProvided: *mut bool,
                arg_srcArrayDatum: Datum,
                arg_isNull: bool,
                arg_arraytyplen: ::std::os::raw::c_int,
                arg_elmlen: ::std::os::raw::c_int,
                arg_elmbyval: bool,
                arg_elmalign: ::std::os::raw::c_char,
            ) -> Datum;
        }
        array_set_slice(
            arg_arraydatum,
            arg_nSubscripts,
            arg_upperIndx,
            arg_lowerIndx,
            arg_upperProvided,
            arg_lowerProvided,
            arg_srcArrayDatum,
            arg_isNull,
            arg_arraytyplen,
            arg_elmlen,
            arg_elmbyval,
            arg_elmalign,
        )
    })
}
pub unsafe fn array_ref(
    arg_array: *mut ArrayType,
    arg_nSubscripts: ::std::os::raw::c_int,
    arg_indx: *mut ::std::os::raw::c_int,
    arg_arraytyplen: ::std::os::raw::c_int,
    arg_elmlen: ::std::os::raw::c_int,
    arg_elmbyval: bool,
    arg_elmalign: ::std::os::raw::c_char,
    arg_isNull: *mut bool,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_ref(
                arg_array: *mut ArrayType,
                arg_nSubscripts: ::std::os::raw::c_int,
                arg_indx: *mut ::std::os::raw::c_int,
                arg_arraytyplen: ::std::os::raw::c_int,
                arg_elmlen: ::std::os::raw::c_int,
                arg_elmbyval: bool,
                arg_elmalign: ::std::os::raw::c_char,
                arg_isNull: *mut bool,
            ) -> Datum;
        }
        array_ref(
            arg_array,
            arg_nSubscripts,
            arg_indx,
            arg_arraytyplen,
            arg_elmlen,
            arg_elmbyval,
            arg_elmalign,
            arg_isNull,
        )
    })
}
pub unsafe fn array_set(
    arg_array: *mut ArrayType,
    arg_nSubscripts: ::std::os::raw::c_int,
    arg_indx: *mut ::std::os::raw::c_int,
    arg_dataValue: Datum,
    arg_isNull: bool,
    arg_arraytyplen: ::std::os::raw::c_int,
    arg_elmlen: ::std::os::raw::c_int,
    arg_elmbyval: bool,
    arg_elmalign: ::std::os::raw::c_char,
) -> *mut ArrayType {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_set(
                arg_array: *mut ArrayType,
                arg_nSubscripts: ::std::os::raw::c_int,
                arg_indx: *mut ::std::os::raw::c_int,
                arg_dataValue: Datum,
                arg_isNull: bool,
                arg_arraytyplen: ::std::os::raw::c_int,
                arg_elmlen: ::std::os::raw::c_int,
                arg_elmbyval: bool,
                arg_elmalign: ::std::os::raw::c_char,
            ) -> *mut ArrayType;
        }
        array_set(
            arg_array,
            arg_nSubscripts,
            arg_indx,
            arg_dataValue,
            arg_isNull,
            arg_arraytyplen,
            arg_elmlen,
            arg_elmbyval,
            arg_elmalign,
        )
    })
}
pub unsafe fn array_map(
    arg_arrayd: Datum,
    arg_exprstate: *mut ExprState,
    arg_econtext: *mut ExprContext,
    arg_retType: Oid,
    arg_amstate: *mut ArrayMapState,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_map(
                arg_arrayd: Datum,
                arg_exprstate: *mut ExprState,
                arg_econtext: *mut ExprContext,
                arg_retType: Oid,
                arg_amstate: *mut ArrayMapState,
            ) -> Datum;
        }
        array_map(arg_arrayd, arg_exprstate, arg_econtext, arg_retType, arg_amstate)
    })
}
pub unsafe fn array_bitmap_copy(
    arg_destbitmap: *mut bits8,
    arg_destoffset: ::std::os::raw::c_int,
    arg_srcbitmap: *const bits8,
    arg_srcoffset: ::std::os::raw::c_int,
    arg_nitems: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_bitmap_copy(
                arg_destbitmap: *mut bits8,
                arg_destoffset: ::std::os::raw::c_int,
                arg_srcbitmap: *const bits8,
                arg_srcoffset: ::std::os::raw::c_int,
                arg_nitems: ::std::os::raw::c_int,
            );
        }
        array_bitmap_copy(arg_destbitmap, arg_destoffset, arg_srcbitmap, arg_srcoffset, arg_nitems)
    })
}
pub unsafe fn construct_array(
    arg_elems: *mut Datum,
    arg_nelems: ::std::os::raw::c_int,
    arg_elmtype: Oid,
    arg_elmlen: ::std::os::raw::c_int,
    arg_elmbyval: bool,
    arg_elmalign: ::std::os::raw::c_char,
) -> *mut ArrayType {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn construct_array(
                arg_elems: *mut Datum,
                arg_nelems: ::std::os::raw::c_int,
                arg_elmtype: Oid,
                arg_elmlen: ::std::os::raw::c_int,
                arg_elmbyval: bool,
                arg_elmalign: ::std::os::raw::c_char,
            ) -> *mut ArrayType;
        }
        construct_array(arg_elems, arg_nelems, arg_elmtype, arg_elmlen, arg_elmbyval, arg_elmalign)
    })
}
pub unsafe fn construct_md_array(
    arg_elems: *mut Datum,
    arg_nulls: *mut bool,
    arg_ndims: ::std::os::raw::c_int,
    arg_dims: *mut ::std::os::raw::c_int,
    arg_lbs: *mut ::std::os::raw::c_int,
    arg_elmtype: Oid,
    arg_elmlen: ::std::os::raw::c_int,
    arg_elmbyval: bool,
    arg_elmalign: ::std::os::raw::c_char,
) -> *mut ArrayType {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn construct_md_array(
                arg_elems: *mut Datum,
                arg_nulls: *mut bool,
                arg_ndims: ::std::os::raw::c_int,
                arg_dims: *mut ::std::os::raw::c_int,
                arg_lbs: *mut ::std::os::raw::c_int,
                arg_elmtype: Oid,
                arg_elmlen: ::std::os::raw::c_int,
                arg_elmbyval: bool,
                arg_elmalign: ::std::os::raw::c_char,
            ) -> *mut ArrayType;
        }
        construct_md_array(
            arg_elems,
            arg_nulls,
            arg_ndims,
            arg_dims,
            arg_lbs,
            arg_elmtype,
            arg_elmlen,
            arg_elmbyval,
            arg_elmalign,
        )
    })
}
pub unsafe fn construct_empty_array(arg_elmtype: Oid) -> *mut ArrayType {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn construct_empty_array(arg_elmtype: Oid) -> *mut ArrayType;
        }
        construct_empty_array(arg_elmtype)
    })
}
pub unsafe fn construct_empty_expanded_array(
    arg_element_type: Oid,
    arg_parentcontext: MemoryContext,
    arg_metacache: *mut ArrayMetaState,
) -> *mut ExpandedArrayHeader {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn construct_empty_expanded_array(
                arg_element_type: Oid,
                arg_parentcontext: MemoryContext,
                arg_metacache: *mut ArrayMetaState,
            ) -> *mut ExpandedArrayHeader;
        }
        construct_empty_expanded_array(arg_element_type, arg_parentcontext, arg_metacache)
    })
}
pub unsafe fn deconstruct_array(
    arg_array: *mut ArrayType,
    arg_elmtype: Oid,
    arg_elmlen: ::std::os::raw::c_int,
    arg_elmbyval: bool,
    arg_elmalign: ::std::os::raw::c_char,
    arg_elemsp: *mut *mut Datum,
    arg_nullsp: *mut *mut bool,
    arg_nelemsp: *mut ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn deconstruct_array(
                arg_array: *mut ArrayType,
                arg_elmtype: Oid,
                arg_elmlen: ::std::os::raw::c_int,
                arg_elmbyval: bool,
                arg_elmalign: ::std::os::raw::c_char,
                arg_elemsp: *mut *mut Datum,
                arg_nullsp: *mut *mut bool,
                arg_nelemsp: *mut ::std::os::raw::c_int,
            );
        }
        deconstruct_array(
            arg_array,
            arg_elmtype,
            arg_elmlen,
            arg_elmbyval,
            arg_elmalign,
            arg_elemsp,
            arg_nullsp,
            arg_nelemsp,
        )
    })
}
pub unsafe fn array_contains_nulls(arg_array: *mut ArrayType) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_contains_nulls(arg_array: *mut ArrayType) -> bool;
        }
        array_contains_nulls(arg_array)
    })
}
pub unsafe fn initArrayResult(
    arg_element_type: Oid,
    arg_rcontext: MemoryContext,
    arg_subcontext: bool,
) -> *mut ArrayBuildState {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn initArrayResult(
                arg_element_type: Oid,
                arg_rcontext: MemoryContext,
                arg_subcontext: bool,
            ) -> *mut ArrayBuildState;
        }
        initArrayResult(arg_element_type, arg_rcontext, arg_subcontext)
    })
}
pub unsafe fn accumArrayResult(
    arg_astate: *mut ArrayBuildState,
    arg_dvalue: Datum,
    arg_disnull: bool,
    arg_element_type: Oid,
    arg_rcontext: MemoryContext,
) -> *mut ArrayBuildState {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn accumArrayResult(
                arg_astate: *mut ArrayBuildState,
                arg_dvalue: Datum,
                arg_disnull: bool,
                arg_element_type: Oid,
                arg_rcontext: MemoryContext,
            ) -> *mut ArrayBuildState;
        }
        accumArrayResult(arg_astate, arg_dvalue, arg_disnull, arg_element_type, arg_rcontext)
    })
}
pub unsafe fn makeArrayResult(
    arg_astate: *mut ArrayBuildState,
    arg_rcontext: MemoryContext,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeArrayResult(
                arg_astate: *mut ArrayBuildState,
                arg_rcontext: MemoryContext,
            ) -> Datum;
        }
        makeArrayResult(arg_astate, arg_rcontext)
    })
}
pub unsafe fn makeMdArrayResult(
    arg_astate: *mut ArrayBuildState,
    arg_ndims: ::std::os::raw::c_int,
    arg_dims: *mut ::std::os::raw::c_int,
    arg_lbs: *mut ::std::os::raw::c_int,
    arg_rcontext: MemoryContext,
    arg_release: bool,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeMdArrayResult(
                arg_astate: *mut ArrayBuildState,
                arg_ndims: ::std::os::raw::c_int,
                arg_dims: *mut ::std::os::raw::c_int,
                arg_lbs: *mut ::std::os::raw::c_int,
                arg_rcontext: MemoryContext,
                arg_release: bool,
            ) -> Datum;
        }
        makeMdArrayResult(arg_astate, arg_ndims, arg_dims, arg_lbs, arg_rcontext, arg_release)
    })
}
pub unsafe fn initArrayResultArr(
    arg_array_type: Oid,
    arg_element_type: Oid,
    arg_rcontext: MemoryContext,
    arg_subcontext: bool,
) -> *mut ArrayBuildStateArr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn initArrayResultArr(
                arg_array_type: Oid,
                arg_element_type: Oid,
                arg_rcontext: MemoryContext,
                arg_subcontext: bool,
            ) -> *mut ArrayBuildStateArr;
        }
        initArrayResultArr(arg_array_type, arg_element_type, arg_rcontext, arg_subcontext)
    })
}
pub unsafe fn accumArrayResultArr(
    arg_astate: *mut ArrayBuildStateArr,
    arg_dvalue: Datum,
    arg_disnull: bool,
    arg_array_type: Oid,
    arg_rcontext: MemoryContext,
) -> *mut ArrayBuildStateArr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn accumArrayResultArr(
                arg_astate: *mut ArrayBuildStateArr,
                arg_dvalue: Datum,
                arg_disnull: bool,
                arg_array_type: Oid,
                arg_rcontext: MemoryContext,
            ) -> *mut ArrayBuildStateArr;
        }
        accumArrayResultArr(arg_astate, arg_dvalue, arg_disnull, arg_array_type, arg_rcontext)
    })
}
pub unsafe fn makeArrayResultArr(
    arg_astate: *mut ArrayBuildStateArr,
    arg_rcontext: MemoryContext,
    arg_release: bool,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeArrayResultArr(
                arg_astate: *mut ArrayBuildStateArr,
                arg_rcontext: MemoryContext,
                arg_release: bool,
            ) -> Datum;
        }
        makeArrayResultArr(arg_astate, arg_rcontext, arg_release)
    })
}
pub unsafe fn initArrayResultAny(
    arg_input_type: Oid,
    arg_rcontext: MemoryContext,
    arg_subcontext: bool,
) -> *mut ArrayBuildStateAny {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn initArrayResultAny(
                arg_input_type: Oid,
                arg_rcontext: MemoryContext,
                arg_subcontext: bool,
            ) -> *mut ArrayBuildStateAny;
        }
        initArrayResultAny(arg_input_type, arg_rcontext, arg_subcontext)
    })
}
pub unsafe fn accumArrayResultAny(
    arg_astate: *mut ArrayBuildStateAny,
    arg_dvalue: Datum,
    arg_disnull: bool,
    arg_input_type: Oid,
    arg_rcontext: MemoryContext,
) -> *mut ArrayBuildStateAny {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn accumArrayResultAny(
                arg_astate: *mut ArrayBuildStateAny,
                arg_dvalue: Datum,
                arg_disnull: bool,
                arg_input_type: Oid,
                arg_rcontext: MemoryContext,
            ) -> *mut ArrayBuildStateAny;
        }
        accumArrayResultAny(arg_astate, arg_dvalue, arg_disnull, arg_input_type, arg_rcontext)
    })
}
pub unsafe fn makeArrayResultAny(
    arg_astate: *mut ArrayBuildStateAny,
    arg_rcontext: MemoryContext,
    arg_release: bool,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeArrayResultAny(
                arg_astate: *mut ArrayBuildStateAny,
                arg_rcontext: MemoryContext,
                arg_release: bool,
            ) -> Datum;
        }
        makeArrayResultAny(arg_astate, arg_rcontext, arg_release)
    })
}
pub unsafe fn array_create_iterator(
    arg_arr: *mut ArrayType,
    arg_slice_ndim: ::std::os::raw::c_int,
    arg_mstate: *mut ArrayMetaState,
) -> ArrayIterator {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_create_iterator(
                arg_arr: *mut ArrayType,
                arg_slice_ndim: ::std::os::raw::c_int,
                arg_mstate: *mut ArrayMetaState,
            ) -> ArrayIterator;
        }
        array_create_iterator(arg_arr, arg_slice_ndim, arg_mstate)
    })
}
pub unsafe fn array_iterate(
    arg_iterator: ArrayIterator,
    arg_value: *mut Datum,
    arg_isnull: *mut bool,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_iterate(
                arg_iterator: ArrayIterator,
                arg_value: *mut Datum,
                arg_isnull: *mut bool,
            ) -> bool;
        }
        array_iterate(arg_iterator, arg_value, arg_isnull)
    })
}
pub unsafe fn array_free_iterator(arg_iterator: ArrayIterator) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_free_iterator(arg_iterator: ArrayIterator);
        }
        array_free_iterator(arg_iterator)
    })
}
pub unsafe fn ArrayGetOffset(
    arg_n: ::std::os::raw::c_int,
    arg_dim: *const ::std::os::raw::c_int,
    arg_lb: *const ::std::os::raw::c_int,
    arg_indx: *const ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ArrayGetOffset(
                arg_n: ::std::os::raw::c_int,
                arg_dim: *const ::std::os::raw::c_int,
                arg_lb: *const ::std::os::raw::c_int,
                arg_indx: *const ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        ArrayGetOffset(arg_n, arg_dim, arg_lb, arg_indx)
    })
}
pub unsafe fn ArrayGetOffset0(
    arg_n: ::std::os::raw::c_int,
    arg_tup: *const ::std::os::raw::c_int,
    arg_scale: *const ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ArrayGetOffset0(
                arg_n: ::std::os::raw::c_int,
                arg_tup: *const ::std::os::raw::c_int,
                arg_scale: *const ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        ArrayGetOffset0(arg_n, arg_tup, arg_scale)
    })
}
pub unsafe fn ArrayGetNItems(
    arg_ndim: ::std::os::raw::c_int,
    arg_dims: *const ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ArrayGetNItems(
                arg_ndim: ::std::os::raw::c_int,
                arg_dims: *const ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        ArrayGetNItems(arg_ndim, arg_dims)
    })
}
pub unsafe fn ArrayCheckBounds(
    arg_ndim: ::std::os::raw::c_int,
    arg_dims: *const ::std::os::raw::c_int,
    arg_lb: *const ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ArrayCheckBounds(
                arg_ndim: ::std::os::raw::c_int,
                arg_dims: *const ::std::os::raw::c_int,
                arg_lb: *const ::std::os::raw::c_int,
            );
        }
        ArrayCheckBounds(arg_ndim, arg_dims, arg_lb)
    })
}
pub unsafe fn mda_get_range(
    arg_n: ::std::os::raw::c_int,
    arg_span: *mut ::std::os::raw::c_int,
    arg_st: *const ::std::os::raw::c_int,
    arg_endp: *const ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn mda_get_range(
                arg_n: ::std::os::raw::c_int,
                arg_span: *mut ::std::os::raw::c_int,
                arg_st: *const ::std::os::raw::c_int,
                arg_endp: *const ::std::os::raw::c_int,
            );
        }
        mda_get_range(arg_n, arg_span, arg_st, arg_endp)
    })
}
pub unsafe fn mda_get_prod(
    arg_n: ::std::os::raw::c_int,
    arg_range: *const ::std::os::raw::c_int,
    arg_prod: *mut ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn mda_get_prod(
                arg_n: ::std::os::raw::c_int,
                arg_range: *const ::std::os::raw::c_int,
                arg_prod: *mut ::std::os::raw::c_int,
            );
        }
        mda_get_prod(arg_n, arg_range, arg_prod)
    })
}
pub unsafe fn mda_get_offset_values(
    arg_n: ::std::os::raw::c_int,
    arg_dist: *mut ::std::os::raw::c_int,
    arg_prod: *const ::std::os::raw::c_int,
    arg_span: *const ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn mda_get_offset_values(
                arg_n: ::std::os::raw::c_int,
                arg_dist: *mut ::std::os::raw::c_int,
                arg_prod: *const ::std::os::raw::c_int,
                arg_span: *const ::std::os::raw::c_int,
            );
        }
        mda_get_offset_values(arg_n, arg_dist, arg_prod, arg_span)
    })
}
pub unsafe fn mda_next_tuple(
    arg_n: ::std::os::raw::c_int,
    arg_curr: *mut ::std::os::raw::c_int,
    arg_span: *const ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn mda_next_tuple(
                arg_n: ::std::os::raw::c_int,
                arg_curr: *mut ::std::os::raw::c_int,
                arg_span: *const ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        mda_next_tuple(arg_n, arg_curr, arg_span)
    })
}
pub unsafe fn ArrayGetIntegerTypmods(
    arg_arr: *mut ArrayType,
    arg_n: *mut ::std::os::raw::c_int,
) -> *mut int32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ArrayGetIntegerTypmods(
                arg_arr: *mut ArrayType,
                arg_n: *mut ::std::os::raw::c_int,
            ) -> *mut int32;
        }
        ArrayGetIntegerTypmods(arg_arr, arg_n)
    })
}
pub unsafe fn expand_array(
    arg_arraydatum: Datum,
    arg_parentcontext: MemoryContext,
    arg_metacache: *mut ArrayMetaState,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn expand_array(
                arg_arraydatum: Datum,
                arg_parentcontext: MemoryContext,
                arg_metacache: *mut ArrayMetaState,
            ) -> Datum;
        }
        expand_array(arg_arraydatum, arg_parentcontext, arg_metacache)
    })
}
pub unsafe fn DatumGetExpandedArray(arg_d: Datum) -> *mut ExpandedArrayHeader {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DatumGetExpandedArray(arg_d: Datum) -> *mut ExpandedArrayHeader;
        }
        DatumGetExpandedArray(arg_d)
    })
}
pub unsafe fn DatumGetExpandedArrayX(
    arg_d: Datum,
    arg_metacache: *mut ArrayMetaState,
) -> *mut ExpandedArrayHeader {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DatumGetExpandedArrayX(
                arg_d: Datum,
                arg_metacache: *mut ArrayMetaState,
            ) -> *mut ExpandedArrayHeader;
        }
        DatumGetExpandedArrayX(arg_d, arg_metacache)
    })
}
pub unsafe fn DatumGetAnyArrayP(arg_d: Datum) -> *mut AnyArrayType {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DatumGetAnyArrayP(arg_d: Datum) -> *mut AnyArrayType;
        }
        DatumGetAnyArrayP(arg_d)
    })
}
pub unsafe fn deconstruct_expanded_array(arg_eah: *mut ExpandedArrayHeader) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn deconstruct_expanded_array(arg_eah: *mut ExpandedArrayHeader);
        }
        deconstruct_expanded_array(arg_eah)
    })
}
pub const GucContext_PGC_INTERNAL: GucContext = 0;
pub const GucContext_PGC_POSTMASTER: GucContext = 1;
pub const GucContext_PGC_SIGHUP: GucContext = 2;
pub const GucContext_PGC_SU_BACKEND: GucContext = 3;
pub const GucContext_PGC_BACKEND: GucContext = 4;
pub const GucContext_PGC_SUSET: GucContext = 5;
pub const GucContext_PGC_USERSET: GucContext = 6;
pub type GucContext = ::std::os::raw::c_uint;
pub const GucSource_PGC_S_DEFAULT: GucSource = 0;
pub const GucSource_PGC_S_DYNAMIC_DEFAULT: GucSource = 1;
pub const GucSource_PGC_S_ENV_VAR: GucSource = 2;
pub const GucSource_PGC_S_FILE: GucSource = 3;
pub const GucSource_PGC_S_ARGV: GucSource = 4;
pub const GucSource_PGC_S_GLOBAL: GucSource = 5;
pub const GucSource_PGC_S_DATABASE: GucSource = 6;
pub const GucSource_PGC_S_USER: GucSource = 7;
pub const GucSource_PGC_S_DATABASE_USER: GucSource = 8;
pub const GucSource_PGC_S_CLIENT: GucSource = 9;
pub const GucSource_PGC_S_OVERRIDE: GucSource = 10;
pub const GucSource_PGC_S_INTERACTIVE: GucSource = 11;
pub const GucSource_PGC_S_TEST: GucSource = 12;
pub const GucSource_PGC_S_SESSION: GucSource = 13;
pub type GucSource = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConfigVariable {
    pub name: *mut ::std::os::raw::c_char,
    pub value: *mut ::std::os::raw::c_char,
    pub errmsg: *mut ::std::os::raw::c_char,
    pub filename: *mut ::std::os::raw::c_char,
    pub sourceline: ::std::os::raw::c_int,
    pub ignore: bool,
    pub applied: bool,
    pub next: *mut ConfigVariable,
}
impl Default for ConfigVariable {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn ParseConfigFile(
    arg_config_file: *const ::std::os::raw::c_char,
    arg_strict: bool,
    arg_calling_file: *const ::std::os::raw::c_char,
    arg_calling_lineno: ::std::os::raw::c_int,
    arg_depth: ::std::os::raw::c_int,
    arg_elevel: ::std::os::raw::c_int,
    arg_head_p: *mut *mut ConfigVariable,
    arg_tail_p: *mut *mut ConfigVariable,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ParseConfigFile(
                arg_config_file: *const ::std::os::raw::c_char,
                arg_strict: bool,
                arg_calling_file: *const ::std::os::raw::c_char,
                arg_calling_lineno: ::std::os::raw::c_int,
                arg_depth: ::std::os::raw::c_int,
                arg_elevel: ::std::os::raw::c_int,
                arg_head_p: *mut *mut ConfigVariable,
                arg_tail_p: *mut *mut ConfigVariable,
            ) -> bool;
        }
        ParseConfigFile(
            arg_config_file,
            arg_strict,
            arg_calling_file,
            arg_calling_lineno,
            arg_depth,
            arg_elevel,
            arg_head_p,
            arg_tail_p,
        )
    })
}
pub unsafe fn ParseConfigFp(
    arg_fp: *mut FILE,
    arg_config_file: *const ::std::os::raw::c_char,
    arg_depth: ::std::os::raw::c_int,
    arg_elevel: ::std::os::raw::c_int,
    arg_head_p: *mut *mut ConfigVariable,
    arg_tail_p: *mut *mut ConfigVariable,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ParseConfigFp(
                arg_fp: *mut FILE,
                arg_config_file: *const ::std::os::raw::c_char,
                arg_depth: ::std::os::raw::c_int,
                arg_elevel: ::std::os::raw::c_int,
                arg_head_p: *mut *mut ConfigVariable,
                arg_tail_p: *mut *mut ConfigVariable,
            ) -> bool;
        }
        ParseConfigFp(arg_fp, arg_config_file, arg_depth, arg_elevel, arg_head_p, arg_tail_p)
    })
}
pub unsafe fn ParseConfigDirectory(
    arg_includedir: *const ::std::os::raw::c_char,
    arg_calling_file: *const ::std::os::raw::c_char,
    arg_calling_lineno: ::std::os::raw::c_int,
    arg_depth: ::std::os::raw::c_int,
    arg_elevel: ::std::os::raw::c_int,
    arg_head_p: *mut *mut ConfigVariable,
    arg_tail_p: *mut *mut ConfigVariable,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ParseConfigDirectory(
                arg_includedir: *const ::std::os::raw::c_char,
                arg_calling_file: *const ::std::os::raw::c_char,
                arg_calling_lineno: ::std::os::raw::c_int,
                arg_depth: ::std::os::raw::c_int,
                arg_elevel: ::std::os::raw::c_int,
                arg_head_p: *mut *mut ConfigVariable,
                arg_tail_p: *mut *mut ConfigVariable,
            ) -> bool;
        }
        ParseConfigDirectory(
            arg_includedir,
            arg_calling_file,
            arg_calling_lineno,
            arg_depth,
            arg_elevel,
            arg_head_p,
            arg_tail_p,
        )
    })
}
pub unsafe fn FreeConfigVariables(arg_list: *mut ConfigVariable) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FreeConfigVariables(arg_list: *mut ConfigVariable);
        }
        FreeConfigVariables(arg_list)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct config_enum_entry {
    pub name: *const ::std::os::raw::c_char,
    pub val: ::std::os::raw::c_int,
    pub hidden: bool,
}
impl Default for config_enum_entry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type GucBoolCheckHook = ::std::option::Option<
    unsafe extern "C" fn(
        newval: *mut bool,
        extra: *mut *mut ::std::os::raw::c_void,
        source: GucSource,
    ) -> bool,
>;
pub type GucIntCheckHook = ::std::option::Option<
    unsafe extern "C" fn(
        newval: *mut ::std::os::raw::c_int,
        extra: *mut *mut ::std::os::raw::c_void,
        source: GucSource,
    ) -> bool,
>;
pub type GucRealCheckHook = ::std::option::Option<
    unsafe extern "C" fn(
        newval: *mut f64,
        extra: *mut *mut ::std::os::raw::c_void,
        source: GucSource,
    ) -> bool,
>;
pub type GucStringCheckHook = ::std::option::Option<
    unsafe extern "C" fn(
        newval: *mut *mut ::std::os::raw::c_char,
        extra: *mut *mut ::std::os::raw::c_void,
        source: GucSource,
    ) -> bool,
>;
pub type GucEnumCheckHook = ::std::option::Option<
    unsafe extern "C" fn(
        newval: *mut ::std::os::raw::c_int,
        extra: *mut *mut ::std::os::raw::c_void,
        source: GucSource,
    ) -> bool,
>;
pub type GucBoolAssignHook =
    ::std::option::Option<unsafe extern "C" fn(newval: bool, extra: *mut ::std::os::raw::c_void)>;
pub type GucIntAssignHook = ::std::option::Option<
    unsafe extern "C" fn(newval: ::std::os::raw::c_int, extra: *mut ::std::os::raw::c_void),
>;
pub type GucRealAssignHook =
    ::std::option::Option<unsafe extern "C" fn(newval: f64, extra: *mut ::std::os::raw::c_void)>;
pub type GucStringAssignHook = ::std::option::Option<
    unsafe extern "C" fn(newval: *const ::std::os::raw::c_char, extra: *mut ::std::os::raw::c_void),
>;
pub type GucEnumAssignHook = ::std::option::Option<
    unsafe extern "C" fn(newval: ::std::os::raw::c_int, extra: *mut ::std::os::raw::c_void),
>;
pub type GucShowHook =
    ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_char>;
pub const GucAction_GUC_ACTION_SET: GucAction = 0;
pub const GucAction_GUC_ACTION_LOCAL: GucAction = 1;
pub const GucAction_GUC_ACTION_SAVE: GucAction = 2;
pub type GucAction = ::std::os::raw::c_uint;
extern "C" {
    pub static mut Debug_print_plan: bool;
}
extern "C" {
    pub static mut Debug_print_parse: bool;
}
extern "C" {
    pub static mut Debug_print_rewritten: bool;
}
extern "C" {
    pub static mut Debug_pretty_print: bool;
}
extern "C" {
    pub static mut log_parser_stats: bool;
}
extern "C" {
    pub static mut log_planner_stats: bool;
}
extern "C" {
    pub static mut log_executor_stats: bool;
}
extern "C" {
    pub static mut log_statement_stats: bool;
}
extern "C" {
    pub static mut log_btree_build_stats: bool;
}
extern "C" {
    pub static mut check_function_bodies: bool;
}
extern "C" {
    pub static mut session_auth_is_superuser: bool;
}
extern "C" {
    pub static mut log_duration: bool;
}
extern "C" {
    pub static mut log_parameter_max_length: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut log_parameter_max_length_on_error: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut log_min_error_statement: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut log_min_messages: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut client_min_messages: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut log_min_duration_sample: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut log_min_duration_statement: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut log_temp_files: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut log_statement_sample_rate: f64;
}
extern "C" {
    pub static mut log_xact_sample_rate: f64;
}
extern "C" {
    pub static mut backtrace_functions: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut backtrace_symbol_list: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut temp_file_limit: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut num_temp_buffers: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut cluster_name: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut ConfigFileName: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut HbaFileName: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut IdentFileName: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut external_pid_file: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut application_name: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut tcp_keepalives_idle: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut tcp_keepalives_interval: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut tcp_keepalives_count: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut tcp_user_timeout: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut trace_sort: bool;
}
pub unsafe fn SetConfigOption(
    arg_name: *const ::std::os::raw::c_char,
    arg_value: *const ::std::os::raw::c_char,
    arg_context: GucContext,
    arg_source: GucSource,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SetConfigOption(
                arg_name: *const ::std::os::raw::c_char,
                arg_value: *const ::std::os::raw::c_char,
                arg_context: GucContext,
                arg_source: GucSource,
            );
        }
        SetConfigOption(arg_name, arg_value, arg_context, arg_source)
    })
}
pub unsafe fn DefineCustomBoolVariable(
    arg_name: *const ::std::os::raw::c_char,
    arg_short_desc: *const ::std::os::raw::c_char,
    arg_long_desc: *const ::std::os::raw::c_char,
    arg_valueAddr: *mut bool,
    arg_bootValue: bool,
    arg_context: GucContext,
    arg_flags: ::std::os::raw::c_int,
    arg_check_hook: GucBoolCheckHook,
    arg_assign_hook: GucBoolAssignHook,
    arg_show_hook: GucShowHook,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DefineCustomBoolVariable(
                arg_name: *const ::std::os::raw::c_char,
                arg_short_desc: *const ::std::os::raw::c_char,
                arg_long_desc: *const ::std::os::raw::c_char,
                arg_valueAddr: *mut bool,
                arg_bootValue: bool,
                arg_context: GucContext,
                arg_flags: ::std::os::raw::c_int,
                arg_check_hook: GucBoolCheckHook,
                arg_assign_hook: GucBoolAssignHook,
                arg_show_hook: GucShowHook,
            );
        }
        DefineCustomBoolVariable(
            arg_name,
            arg_short_desc,
            arg_long_desc,
            arg_valueAddr,
            arg_bootValue,
            arg_context,
            arg_flags,
            arg_check_hook,
            arg_assign_hook,
            arg_show_hook,
        )
    })
}
pub unsafe fn DefineCustomIntVariable(
    arg_name: *const ::std::os::raw::c_char,
    arg_short_desc: *const ::std::os::raw::c_char,
    arg_long_desc: *const ::std::os::raw::c_char,
    arg_valueAddr: *mut ::std::os::raw::c_int,
    arg_bootValue: ::std::os::raw::c_int,
    arg_minValue: ::std::os::raw::c_int,
    arg_maxValue: ::std::os::raw::c_int,
    arg_context: GucContext,
    arg_flags: ::std::os::raw::c_int,
    arg_check_hook: GucIntCheckHook,
    arg_assign_hook: GucIntAssignHook,
    arg_show_hook: GucShowHook,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DefineCustomIntVariable(
                arg_name: *const ::std::os::raw::c_char,
                arg_short_desc: *const ::std::os::raw::c_char,
                arg_long_desc: *const ::std::os::raw::c_char,
                arg_valueAddr: *mut ::std::os::raw::c_int,
                arg_bootValue: ::std::os::raw::c_int,
                arg_minValue: ::std::os::raw::c_int,
                arg_maxValue: ::std::os::raw::c_int,
                arg_context: GucContext,
                arg_flags: ::std::os::raw::c_int,
                arg_check_hook: GucIntCheckHook,
                arg_assign_hook: GucIntAssignHook,
                arg_show_hook: GucShowHook,
            );
        }
        DefineCustomIntVariable(
            arg_name,
            arg_short_desc,
            arg_long_desc,
            arg_valueAddr,
            arg_bootValue,
            arg_minValue,
            arg_maxValue,
            arg_context,
            arg_flags,
            arg_check_hook,
            arg_assign_hook,
            arg_show_hook,
        )
    })
}
pub unsafe fn DefineCustomRealVariable(
    arg_name: *const ::std::os::raw::c_char,
    arg_short_desc: *const ::std::os::raw::c_char,
    arg_long_desc: *const ::std::os::raw::c_char,
    arg_valueAddr: *mut f64,
    arg_bootValue: f64,
    arg_minValue: f64,
    arg_maxValue: f64,
    arg_context: GucContext,
    arg_flags: ::std::os::raw::c_int,
    arg_check_hook: GucRealCheckHook,
    arg_assign_hook: GucRealAssignHook,
    arg_show_hook: GucShowHook,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DefineCustomRealVariable(
                arg_name: *const ::std::os::raw::c_char,
                arg_short_desc: *const ::std::os::raw::c_char,
                arg_long_desc: *const ::std::os::raw::c_char,
                arg_valueAddr: *mut f64,
                arg_bootValue: f64,
                arg_minValue: f64,
                arg_maxValue: f64,
                arg_context: GucContext,
                arg_flags: ::std::os::raw::c_int,
                arg_check_hook: GucRealCheckHook,
                arg_assign_hook: GucRealAssignHook,
                arg_show_hook: GucShowHook,
            );
        }
        DefineCustomRealVariable(
            arg_name,
            arg_short_desc,
            arg_long_desc,
            arg_valueAddr,
            arg_bootValue,
            arg_minValue,
            arg_maxValue,
            arg_context,
            arg_flags,
            arg_check_hook,
            arg_assign_hook,
            arg_show_hook,
        )
    })
}
pub unsafe fn DefineCustomStringVariable(
    arg_name: *const ::std::os::raw::c_char,
    arg_short_desc: *const ::std::os::raw::c_char,
    arg_long_desc: *const ::std::os::raw::c_char,
    arg_valueAddr: *mut *mut ::std::os::raw::c_char,
    arg_bootValue: *const ::std::os::raw::c_char,
    arg_context: GucContext,
    arg_flags: ::std::os::raw::c_int,
    arg_check_hook: GucStringCheckHook,
    arg_assign_hook: GucStringAssignHook,
    arg_show_hook: GucShowHook,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DefineCustomStringVariable(
                arg_name: *const ::std::os::raw::c_char,
                arg_short_desc: *const ::std::os::raw::c_char,
                arg_long_desc: *const ::std::os::raw::c_char,
                arg_valueAddr: *mut *mut ::std::os::raw::c_char,
                arg_bootValue: *const ::std::os::raw::c_char,
                arg_context: GucContext,
                arg_flags: ::std::os::raw::c_int,
                arg_check_hook: GucStringCheckHook,
                arg_assign_hook: GucStringAssignHook,
                arg_show_hook: GucShowHook,
            );
        }
        DefineCustomStringVariable(
            arg_name,
            arg_short_desc,
            arg_long_desc,
            arg_valueAddr,
            arg_bootValue,
            arg_context,
            arg_flags,
            arg_check_hook,
            arg_assign_hook,
            arg_show_hook,
        )
    })
}
pub unsafe fn DefineCustomEnumVariable(
    arg_name: *const ::std::os::raw::c_char,
    arg_short_desc: *const ::std::os::raw::c_char,
    arg_long_desc: *const ::std::os::raw::c_char,
    arg_valueAddr: *mut ::std::os::raw::c_int,
    arg_bootValue: ::std::os::raw::c_int,
    arg_options: *const config_enum_entry,
    arg_context: GucContext,
    arg_flags: ::std::os::raw::c_int,
    arg_check_hook: GucEnumCheckHook,
    arg_assign_hook: GucEnumAssignHook,
    arg_show_hook: GucShowHook,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DefineCustomEnumVariable(
                arg_name: *const ::std::os::raw::c_char,
                arg_short_desc: *const ::std::os::raw::c_char,
                arg_long_desc: *const ::std::os::raw::c_char,
                arg_valueAddr: *mut ::std::os::raw::c_int,
                arg_bootValue: ::std::os::raw::c_int,
                arg_options: *const config_enum_entry,
                arg_context: GucContext,
                arg_flags: ::std::os::raw::c_int,
                arg_check_hook: GucEnumCheckHook,
                arg_assign_hook: GucEnumAssignHook,
                arg_show_hook: GucShowHook,
            );
        }
        DefineCustomEnumVariable(
            arg_name,
            arg_short_desc,
            arg_long_desc,
            arg_valueAddr,
            arg_bootValue,
            arg_options,
            arg_context,
            arg_flags,
            arg_check_hook,
            arg_assign_hook,
            arg_show_hook,
        )
    })
}
pub unsafe fn EmitWarningsOnPlaceholders(arg_className: *const ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EmitWarningsOnPlaceholders(arg_className: *const ::std::os::raw::c_char);
        }
        EmitWarningsOnPlaceholders(arg_className)
    })
}
pub unsafe fn GetConfigOption(
    arg_name: *const ::std::os::raw::c_char,
    arg_missing_ok: bool,
    arg_restrict_privileged: bool,
) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetConfigOption(
                arg_name: *const ::std::os::raw::c_char,
                arg_missing_ok: bool,
                arg_restrict_privileged: bool,
            ) -> *const ::std::os::raw::c_char;
        }
        GetConfigOption(arg_name, arg_missing_ok, arg_restrict_privileged)
    })
}
pub unsafe fn GetConfigOptionResetString(
    arg_name: *const ::std::os::raw::c_char,
) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetConfigOptionResetString(
                arg_name: *const ::std::os::raw::c_char,
            ) -> *const ::std::os::raw::c_char;
        }
        GetConfigOptionResetString(arg_name)
    })
}
pub unsafe fn GetConfigOptionFlags(
    arg_name: *const ::std::os::raw::c_char,
    arg_missing_ok: bool,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetConfigOptionFlags(
                arg_name: *const ::std::os::raw::c_char,
                arg_missing_ok: bool,
            ) -> ::std::os::raw::c_int;
        }
        GetConfigOptionFlags(arg_name, arg_missing_ok)
    })
}
pub unsafe fn ProcessConfigFile(arg_context: GucContext) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcessConfigFile(arg_context: GucContext);
        }
        ProcessConfigFile(arg_context)
    })
}
pub unsafe fn InitializeGUCOptions() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitializeGUCOptions();
        }
        InitializeGUCOptions()
    })
}
pub unsafe fn SelectConfigFiles(
    arg_userDoption: *const ::std::os::raw::c_char,
    arg_progname: *const ::std::os::raw::c_char,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SelectConfigFiles(
                arg_userDoption: *const ::std::os::raw::c_char,
                arg_progname: *const ::std::os::raw::c_char,
            ) -> bool;
        }
        SelectConfigFiles(arg_userDoption, arg_progname)
    })
}
pub unsafe fn ResetAllOptions() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ResetAllOptions();
        }
        ResetAllOptions()
    })
}
pub unsafe fn AtStart_GUC() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AtStart_GUC();
        }
        AtStart_GUC()
    })
}
pub unsafe fn NewGUCNestLevel() -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn NewGUCNestLevel() -> ::std::os::raw::c_int;
        }
        NewGUCNestLevel()
    })
}
pub unsafe fn AtEOXact_GUC(arg_isCommit: bool, arg_nestLevel: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AtEOXact_GUC(arg_isCommit: bool, arg_nestLevel: ::std::os::raw::c_int);
        }
        AtEOXact_GUC(arg_isCommit, arg_nestLevel)
    })
}
pub unsafe fn BeginReportingGUCOptions() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BeginReportingGUCOptions();
        }
        BeginReportingGUCOptions()
    })
}
pub unsafe fn ParseLongOption(
    arg_string: *const ::std::os::raw::c_char,
    arg_name: *mut *mut ::std::os::raw::c_char,
    arg_value: *mut *mut ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ParseLongOption(
                arg_string: *const ::std::os::raw::c_char,
                arg_name: *mut *mut ::std::os::raw::c_char,
                arg_value: *mut *mut ::std::os::raw::c_char,
            );
        }
        ParseLongOption(arg_string, arg_name, arg_value)
    })
}
pub unsafe fn parse_int(
    arg_value: *const ::std::os::raw::c_char,
    arg_result: *mut ::std::os::raw::c_int,
    arg_flags: ::std::os::raw::c_int,
    arg_hintmsg: *mut *const ::std::os::raw::c_char,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn parse_int(
                arg_value: *const ::std::os::raw::c_char,
                arg_result: *mut ::std::os::raw::c_int,
                arg_flags: ::std::os::raw::c_int,
                arg_hintmsg: *mut *const ::std::os::raw::c_char,
            ) -> bool;
        }
        parse_int(arg_value, arg_result, arg_flags, arg_hintmsg)
    })
}
pub unsafe fn parse_real(
    arg_value: *const ::std::os::raw::c_char,
    arg_result: *mut f64,
    arg_flags: ::std::os::raw::c_int,
    arg_hintmsg: *mut *const ::std::os::raw::c_char,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn parse_real(
                arg_value: *const ::std::os::raw::c_char,
                arg_result: *mut f64,
                arg_flags: ::std::os::raw::c_int,
                arg_hintmsg: *mut *const ::std::os::raw::c_char,
            ) -> bool;
        }
        parse_real(arg_value, arg_result, arg_flags, arg_hintmsg)
    })
}
pub unsafe fn set_config_option(
    arg_name: *const ::std::os::raw::c_char,
    arg_value: *const ::std::os::raw::c_char,
    arg_context: GucContext,
    arg_source: GucSource,
    arg_action: GucAction,
    arg_changeVal: bool,
    arg_elevel: ::std::os::raw::c_int,
    arg_is_reload: bool,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn set_config_option(
                arg_name: *const ::std::os::raw::c_char,
                arg_value: *const ::std::os::raw::c_char,
                arg_context: GucContext,
                arg_source: GucSource,
                arg_action: GucAction,
                arg_changeVal: bool,
                arg_elevel: ::std::os::raw::c_int,
                arg_is_reload: bool,
            ) -> ::std::os::raw::c_int;
        }
        set_config_option(
            arg_name,
            arg_value,
            arg_context,
            arg_source,
            arg_action,
            arg_changeVal,
            arg_elevel,
            arg_is_reload,
        )
    })
}
pub unsafe fn AlterSystemSetConfigFile(arg_altersysstmt: *mut AlterSystemStmt) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AlterSystemSetConfigFile(arg_altersysstmt: *mut AlterSystemStmt);
        }
        AlterSystemSetConfigFile(arg_altersysstmt)
    })
}
pub unsafe fn GetConfigOptionByName(
    arg_name: *const ::std::os::raw::c_char,
    arg_varname: *mut *const ::std::os::raw::c_char,
    arg_missing_ok: bool,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetConfigOptionByName(
                arg_name: *const ::std::os::raw::c_char,
                arg_varname: *mut *const ::std::os::raw::c_char,
                arg_missing_ok: bool,
            ) -> *mut ::std::os::raw::c_char;
        }
        GetConfigOptionByName(arg_name, arg_varname, arg_missing_ok)
    })
}
pub unsafe fn GetConfigOptionByNum(
    arg_varnum: ::std::os::raw::c_int,
    arg_values: *mut *const ::std::os::raw::c_char,
    arg_noshow: *mut bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetConfigOptionByNum(
                arg_varnum: ::std::os::raw::c_int,
                arg_values: *mut *const ::std::os::raw::c_char,
                arg_noshow: *mut bool,
            );
        }
        GetConfigOptionByNum(arg_varnum, arg_values, arg_noshow)
    })
}
pub unsafe fn GetNumConfigOptions() -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetNumConfigOptions() -> ::std::os::raw::c_int;
        }
        GetNumConfigOptions()
    })
}
pub unsafe fn SetPGVariable(
    arg_name: *const ::std::os::raw::c_char,
    arg_args: *mut List,
    arg_is_local: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SetPGVariable(
                arg_name: *const ::std::os::raw::c_char,
                arg_args: *mut List,
                arg_is_local: bool,
            );
        }
        SetPGVariable(arg_name, arg_args, arg_is_local)
    })
}
pub unsafe fn GetPGVariable(arg_name: *const ::std::os::raw::c_char, arg_dest: *mut DestReceiver) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetPGVariable(arg_name: *const ::std::os::raw::c_char, arg_dest: *mut DestReceiver);
        }
        GetPGVariable(arg_name, arg_dest)
    })
}
pub unsafe fn GetPGVariableResultDesc(arg_name: *const ::std::os::raw::c_char) -> TupleDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetPGVariableResultDesc(arg_name: *const ::std::os::raw::c_char) -> TupleDesc;
        }
        GetPGVariableResultDesc(arg_name)
    })
}
pub unsafe fn ExecSetVariableStmt(arg_stmt: *mut VariableSetStmt, arg_isTopLevel: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecSetVariableStmt(arg_stmt: *mut VariableSetStmt, arg_isTopLevel: bool);
        }
        ExecSetVariableStmt(arg_stmt, arg_isTopLevel)
    })
}
pub unsafe fn ExtractSetVariableArgs(
    arg_stmt: *mut VariableSetStmt,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExtractSetVariableArgs(
                arg_stmt: *mut VariableSetStmt,
            ) -> *mut ::std::os::raw::c_char;
        }
        ExtractSetVariableArgs(arg_stmt)
    })
}
pub unsafe fn ProcessGUCArray(
    arg_array: *mut ArrayType,
    arg_context: GucContext,
    arg_source: GucSource,
    arg_action: GucAction,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcessGUCArray(
                arg_array: *mut ArrayType,
                arg_context: GucContext,
                arg_source: GucSource,
                arg_action: GucAction,
            );
        }
        ProcessGUCArray(arg_array, arg_context, arg_source, arg_action)
    })
}
pub unsafe fn GUCArrayAdd(
    arg_array: *mut ArrayType,
    arg_name: *const ::std::os::raw::c_char,
    arg_value: *const ::std::os::raw::c_char,
) -> *mut ArrayType {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GUCArrayAdd(
                arg_array: *mut ArrayType,
                arg_name: *const ::std::os::raw::c_char,
                arg_value: *const ::std::os::raw::c_char,
            ) -> *mut ArrayType;
        }
        GUCArrayAdd(arg_array, arg_name, arg_value)
    })
}
pub unsafe fn GUCArrayDelete(
    arg_array: *mut ArrayType,
    arg_name: *const ::std::os::raw::c_char,
) -> *mut ArrayType {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GUCArrayDelete(
                arg_array: *mut ArrayType,
                arg_name: *const ::std::os::raw::c_char,
            ) -> *mut ArrayType;
        }
        GUCArrayDelete(arg_array, arg_name)
    })
}
pub unsafe fn GUCArrayReset(arg_array: *mut ArrayType) -> *mut ArrayType {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GUCArrayReset(arg_array: *mut ArrayType) -> *mut ArrayType;
        }
        GUCArrayReset(arg_array)
    })
}
pub unsafe fn EstimateGUCStateSpace() -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EstimateGUCStateSpace() -> Size;
        }
        EstimateGUCStateSpace()
    })
}
pub unsafe fn SerializeGUCState(arg_maxsize: Size, arg_start_address: *mut ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SerializeGUCState(arg_maxsize: Size, arg_start_address: *mut ::std::os::raw::c_char);
        }
        SerializeGUCState(arg_maxsize, arg_start_address)
    })
}
pub unsafe fn RestoreGUCState(arg_gucstate: *mut ::std::os::raw::c_void) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RestoreGUCState(arg_gucstate: *mut ::std::os::raw::c_void);
        }
        RestoreGUCState(arg_gucstate)
    })
}
extern "C" {
    pub static mut GUC_check_errmsg_string: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut GUC_check_errdetail_string: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut GUC_check_errhint_string: *mut ::std::os::raw::c_char;
}
pub unsafe fn GUC_check_errcode(arg_sqlerrcode: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GUC_check_errcode(arg_sqlerrcode: ::std::os::raw::c_int);
        }
        GUC_check_errcode(arg_sqlerrcode)
    })
}
pub unsafe fn check_default_tablespace(
    arg_newval: *mut *mut ::std::os::raw::c_char,
    arg_extra: *mut *mut ::std::os::raw::c_void,
    arg_source: GucSource,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn check_default_tablespace(
                arg_newval: *mut *mut ::std::os::raw::c_char,
                arg_extra: *mut *mut ::std::os::raw::c_void,
                arg_source: GucSource,
            ) -> bool;
        }
        check_default_tablespace(arg_newval, arg_extra, arg_source)
    })
}
pub unsafe fn check_temp_tablespaces(
    arg_newval: *mut *mut ::std::os::raw::c_char,
    arg_extra: *mut *mut ::std::os::raw::c_void,
    arg_source: GucSource,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn check_temp_tablespaces(
                arg_newval: *mut *mut ::std::os::raw::c_char,
                arg_extra: *mut *mut ::std::os::raw::c_void,
                arg_source: GucSource,
            ) -> bool;
        }
        check_temp_tablespaces(arg_newval, arg_extra, arg_source)
    })
}
pub unsafe fn assign_temp_tablespaces(
    arg_newval: *const ::std::os::raw::c_char,
    arg_extra: *mut ::std::os::raw::c_void,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn assign_temp_tablespaces(
                arg_newval: *const ::std::os::raw::c_char,
                arg_extra: *mut ::std::os::raw::c_void,
            );
        }
        assign_temp_tablespaces(arg_newval, arg_extra)
    })
}
pub unsafe fn check_search_path(
    arg_newval: *mut *mut ::std::os::raw::c_char,
    arg_extra: *mut *mut ::std::os::raw::c_void,
    arg_source: GucSource,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn check_search_path(
                arg_newval: *mut *mut ::std::os::raw::c_char,
                arg_extra: *mut *mut ::std::os::raw::c_void,
                arg_source: GucSource,
            ) -> bool;
        }
        check_search_path(arg_newval, arg_extra, arg_source)
    })
}
pub unsafe fn assign_search_path(
    arg_newval: *const ::std::os::raw::c_char,
    arg_extra: *mut ::std::os::raw::c_void,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn assign_search_path(
                arg_newval: *const ::std::os::raw::c_char,
                arg_extra: *mut ::std::os::raw::c_void,
            );
        }
        assign_search_path(arg_newval, arg_extra)
    })
}
pub unsafe fn check_wal_buffers(
    arg_newval: *mut ::std::os::raw::c_int,
    arg_extra: *mut *mut ::std::os::raw::c_void,
    arg_source: GucSource,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn check_wal_buffers(
                arg_newval: *mut ::std::os::raw::c_int,
                arg_extra: *mut *mut ::std::os::raw::c_void,
                arg_source: GucSource,
            ) -> bool;
        }
        check_wal_buffers(arg_newval, arg_extra, arg_source)
    })
}
pub unsafe fn assign_xlog_sync_method(
    arg_new_sync_method: ::std::os::raw::c_int,
    arg_extra: *mut ::std::os::raw::c_void,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn assign_xlog_sync_method(
                arg_new_sync_method: ::std::os::raw::c_int,
                arg_extra: *mut ::std::os::raw::c_void,
            );
        }
        assign_xlog_sync_method(arg_new_sync_method, arg_extra)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_class {
    pub oid: Oid,
    pub relname: NameData,
    pub relnamespace: Oid,
    pub reltype: Oid,
    pub reloftype: Oid,
    pub relowner: Oid,
    pub relam: Oid,
    pub relfilenode: Oid,
    pub reltablespace: Oid,
    pub relpages: int32,
    pub reltuples: float4,
    pub relallvisible: int32,
    pub reltoastrelid: Oid,
    pub relhasindex: bool,
    pub relisshared: bool,
    pub relpersistence: ::std::os::raw::c_char,
    pub relkind: ::std::os::raw::c_char,
    pub relnatts: int16,
    pub relchecks: int16,
    pub relhasrules: bool,
    pub relhastriggers: bool,
    pub relhassubclass: bool,
    pub relrowsecurity: bool,
    pub relforcerowsecurity: bool,
    pub relispopulated: bool,
    pub relreplident: ::std::os::raw::c_char,
    pub relispartition: bool,
    pub relrewrite: Oid,
    pub relfrozenxid: TransactionId,
    pub relminmxid: TransactionId,
}
impl Default for FormData_pg_class {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_class = *mut FormData_pg_class;
#[repr(C)]
#[derive(Debug, Default)]
pub struct FormData_pg_index {
    pub indexrelid: Oid,
    pub indrelid: Oid,
    pub indnatts: int16,
    pub indnkeyatts: int16,
    pub indisunique: bool,
    pub indisprimary: bool,
    pub indisexclusion: bool,
    pub indimmediate: bool,
    pub indisclustered: bool,
    pub indisvalid: bool,
    pub indcheckxmin: bool,
    pub indisready: bool,
    pub indislive: bool,
    pub indisreplident: bool,
    pub indkey: int2vector,
}
pub type Form_pg_index = *mut FormData_pg_index;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ObjectAddress {
    pub classId: Oid,
    pub objectId: Oid,
    pub objectSubId: int32,
}
extern "C" {
    pub static InvalidObjectAddress: ObjectAddress;
}
pub unsafe fn get_object_address(
    arg_objtype: ObjectType,
    arg_object: *mut Node,
    arg_relp: *mut Relation,
    arg_lockmode: LOCKMODE,
    arg_missing_ok: bool,
) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_object_address(
                arg_objtype: ObjectType,
                arg_object: *mut Node,
                arg_relp: *mut Relation,
                arg_lockmode: LOCKMODE,
                arg_missing_ok: bool,
            ) -> ObjectAddress;
        }
        get_object_address(arg_objtype, arg_object, arg_relp, arg_lockmode, arg_missing_ok)
    })
}
pub unsafe fn get_object_address_rv(
    arg_objtype: ObjectType,
    arg_rel: *mut RangeVar,
    arg_object: *mut List,
    arg_relp: *mut Relation,
    arg_lockmode: LOCKMODE,
    arg_missing_ok: bool,
) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_object_address_rv(
                arg_objtype: ObjectType,
                arg_rel: *mut RangeVar,
                arg_object: *mut List,
                arg_relp: *mut Relation,
                arg_lockmode: LOCKMODE,
                arg_missing_ok: bool,
            ) -> ObjectAddress;
        }
        get_object_address_rv(
            arg_objtype,
            arg_rel,
            arg_object,
            arg_relp,
            arg_lockmode,
            arg_missing_ok,
        )
    })
}
pub unsafe fn check_object_ownership(
    arg_roleid: Oid,
    arg_objtype: ObjectType,
    arg_address: ObjectAddress,
    arg_object: *mut Node,
    arg_relation: Relation,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn check_object_ownership(
                arg_roleid: Oid,
                arg_objtype: ObjectType,
                arg_address: ObjectAddress,
                arg_object: *mut Node,
                arg_relation: Relation,
            );
        }
        check_object_ownership(arg_roleid, arg_objtype, arg_address, arg_object, arg_relation)
    })
}
pub unsafe fn get_object_namespace(arg_address: *const ObjectAddress) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_object_namespace(arg_address: *const ObjectAddress) -> Oid;
        }
        get_object_namespace(arg_address)
    })
}
pub unsafe fn is_objectclass_supported(arg_class_id: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn is_objectclass_supported(arg_class_id: Oid) -> bool;
        }
        is_objectclass_supported(arg_class_id)
    })
}
pub unsafe fn get_object_oid_index(arg_class_id: Oid) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_object_oid_index(arg_class_id: Oid) -> Oid;
        }
        get_object_oid_index(arg_class_id)
    })
}
pub unsafe fn get_object_catcache_oid(arg_class_id: Oid) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_object_catcache_oid(arg_class_id: Oid) -> ::std::os::raw::c_int;
        }
        get_object_catcache_oid(arg_class_id)
    })
}
pub unsafe fn get_object_catcache_name(arg_class_id: Oid) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_object_catcache_name(arg_class_id: Oid) -> ::std::os::raw::c_int;
        }
        get_object_catcache_name(arg_class_id)
    })
}
pub unsafe fn get_object_attnum_oid(arg_class_id: Oid) -> AttrNumber {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_object_attnum_oid(arg_class_id: Oid) -> AttrNumber;
        }
        get_object_attnum_oid(arg_class_id)
    })
}
pub unsafe fn get_object_attnum_name(arg_class_id: Oid) -> AttrNumber {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_object_attnum_name(arg_class_id: Oid) -> AttrNumber;
        }
        get_object_attnum_name(arg_class_id)
    })
}
pub unsafe fn get_object_attnum_namespace(arg_class_id: Oid) -> AttrNumber {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_object_attnum_namespace(arg_class_id: Oid) -> AttrNumber;
        }
        get_object_attnum_namespace(arg_class_id)
    })
}
pub unsafe fn get_object_attnum_owner(arg_class_id: Oid) -> AttrNumber {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_object_attnum_owner(arg_class_id: Oid) -> AttrNumber;
        }
        get_object_attnum_owner(arg_class_id)
    })
}
pub unsafe fn get_object_attnum_acl(arg_class_id: Oid) -> AttrNumber {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_object_attnum_acl(arg_class_id: Oid) -> AttrNumber;
        }
        get_object_attnum_acl(arg_class_id)
    })
}
pub unsafe fn get_object_type(arg_class_id: Oid, arg_object_id: Oid) -> ObjectType {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_object_type(arg_class_id: Oid, arg_object_id: Oid) -> ObjectType;
        }
        get_object_type(arg_class_id, arg_object_id)
    })
}
pub unsafe fn get_object_namensp_unique(arg_class_id: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_object_namensp_unique(arg_class_id: Oid) -> bool;
        }
        get_object_namensp_unique(arg_class_id)
    })
}
pub unsafe fn get_catalog_object_by_oid(
    arg_catalog: Relation,
    arg_oidcol: AttrNumber,
    arg_objectId: Oid,
) -> HeapTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_catalog_object_by_oid(
                arg_catalog: Relation,
                arg_oidcol: AttrNumber,
                arg_objectId: Oid,
            ) -> HeapTuple;
        }
        get_catalog_object_by_oid(arg_catalog, arg_oidcol, arg_objectId)
    })
}
pub unsafe fn getObjectDescription(
    arg_object: *const ObjectAddress,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getObjectDescription(
                arg_object: *const ObjectAddress,
            ) -> *mut ::std::os::raw::c_char;
        }
        getObjectDescription(arg_object)
    })
}
pub unsafe fn getObjectDescriptionOids(
    arg_classid: Oid,
    arg_objid: Oid,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getObjectDescriptionOids(
                arg_classid: Oid,
                arg_objid: Oid,
            ) -> *mut ::std::os::raw::c_char;
        }
        getObjectDescriptionOids(arg_classid, arg_objid)
    })
}
pub unsafe fn read_objtype_from_string(
    arg_objtype: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn read_objtype_from_string(
                arg_objtype: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        read_objtype_from_string(arg_objtype)
    })
}
pub unsafe fn getObjectTypeDescription(
    arg_object: *const ObjectAddress,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getObjectTypeDescription(
                arg_object: *const ObjectAddress,
            ) -> *mut ::std::os::raw::c_char;
        }
        getObjectTypeDescription(arg_object)
    })
}
pub unsafe fn getObjectIdentity(arg_address: *const ObjectAddress) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getObjectIdentity(arg_address: *const ObjectAddress) -> *mut ::std::os::raw::c_char;
        }
        getObjectIdentity(arg_address)
    })
}
pub unsafe fn getObjectIdentityParts(
    arg_address: *const ObjectAddress,
    arg_objname: *mut *mut List,
    arg_objargs: *mut *mut List,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getObjectIdentityParts(
                arg_address: *const ObjectAddress,
                arg_objname: *mut *mut List,
                arg_objargs: *mut *mut List,
            ) -> *mut ::std::os::raw::c_char;
        }
        getObjectIdentityParts(arg_address, arg_objname, arg_objargs)
    })
}
pub unsafe fn strlist_to_textarray(arg_list: *mut List) -> *mut ArrayType {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strlist_to_textarray(arg_list: *mut List) -> *mut ArrayType;
        }
        strlist_to_textarray(arg_list)
    })
}
pub unsafe fn get_relkind_objtype(arg_relkind: ::std::os::raw::c_char) -> ObjectType {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_relkind_objtype(arg_relkind: ::std::os::raw::c_char) -> ObjectType;
        }
        get_relkind_objtype(arg_relkind)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_publication {
    pub oid: Oid,
    pub pubname: NameData,
    pub pubowner: Oid,
    pub puballtables: bool,
    pub pubinsert: bool,
    pub pubupdate: bool,
    pub pubdelete: bool,
    pub pubtruncate: bool,
    pub pubviaroot: bool,
}
impl Default for FormData_pg_publication {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_publication = *mut FormData_pg_publication;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PublicationActions {
    pub pubinsert: bool,
    pub pubupdate: bool,
    pub pubdelete: bool,
    pub pubtruncate: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Publication {
    pub oid: Oid,
    pub name: *mut ::std::os::raw::c_char,
    pub alltables: bool,
    pub pubviaroot: bool,
    pub pubactions: PublicationActions,
}
impl Default for Publication {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn GetPublication(arg_pubid: Oid) -> *mut Publication {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetPublication(arg_pubid: Oid) -> *mut Publication;
        }
        GetPublication(arg_pubid)
    })
}
pub unsafe fn GetPublicationByName(
    arg_pubname: *const ::std::os::raw::c_char,
    arg_missing_ok: bool,
) -> *mut Publication {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetPublicationByName(
                arg_pubname: *const ::std::os::raw::c_char,
                arg_missing_ok: bool,
            ) -> *mut Publication;
        }
        GetPublicationByName(arg_pubname, arg_missing_ok)
    })
}
pub unsafe fn GetRelationPublications(arg_relid: Oid) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetRelationPublications(arg_relid: Oid) -> *mut List;
        }
        GetRelationPublications(arg_relid)
    })
}
pub const PublicationPartOpt_PUBLICATION_PART_ROOT: PublicationPartOpt = 0;
pub const PublicationPartOpt_PUBLICATION_PART_LEAF: PublicationPartOpt = 1;
pub const PublicationPartOpt_PUBLICATION_PART_ALL: PublicationPartOpt = 2;
pub type PublicationPartOpt = ::std::os::raw::c_uint;
pub unsafe fn GetPublicationRelations(
    arg_pubid: Oid,
    arg_pub_partopt: PublicationPartOpt,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetPublicationRelations(
                arg_pubid: Oid,
                arg_pub_partopt: PublicationPartOpt,
            ) -> *mut List;
        }
        GetPublicationRelations(arg_pubid, arg_pub_partopt)
    })
}
pub unsafe fn GetAllTablesPublications() -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetAllTablesPublications() -> *mut List;
        }
        GetAllTablesPublications()
    })
}
pub unsafe fn GetAllTablesPublicationRelations(arg_pubviaroot: bool) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetAllTablesPublicationRelations(arg_pubviaroot: bool) -> *mut List;
        }
        GetAllTablesPublicationRelations(arg_pubviaroot)
    })
}
pub unsafe fn is_publishable_relation(arg_rel: Relation) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn is_publishable_relation(arg_rel: Relation) -> bool;
        }
        is_publishable_relation(arg_rel)
    })
}
pub unsafe fn publication_add_relation(
    arg_pubid: Oid,
    arg_targetrel: Relation,
    arg_if_not_exists: bool,
) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn publication_add_relation(
                arg_pubid: Oid,
                arg_targetrel: Relation,
                arg_if_not_exists: bool,
            ) -> ObjectAddress;
        }
        publication_add_relation(arg_pubid, arg_targetrel, arg_if_not_exists)
    })
}
pub unsafe fn GetPubPartitionOptionRelations(
    arg_result: *mut List,
    arg_pub_partopt: PublicationPartOpt,
    arg_relid: Oid,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetPubPartitionOptionRelations(
                arg_result: *mut List,
                arg_pub_partopt: PublicationPartOpt,
                arg_relid: Oid,
            ) -> *mut List;
        }
        GetPubPartitionOptionRelations(arg_result, arg_pub_partopt, arg_relid)
    })
}
pub unsafe fn get_publication_oid(
    arg_pubname: *const ::std::os::raw::c_char,
    arg_missing_ok: bool,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_publication_oid(
                arg_pubname: *const ::std::os::raw::c_char,
                arg_missing_ok: bool,
            ) -> Oid;
        }
        get_publication_oid(arg_pubname, arg_missing_ok)
    })
}
pub unsafe fn get_publication_name(
    arg_pubid: Oid,
    arg_missing_ok: bool,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_publication_name(
                arg_pubid: Oid,
                arg_missing_ok: bool,
            ) -> *mut ::std::os::raw::c_char;
        }
        get_publication_name(arg_pubid, arg_missing_ok)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RewriteRule {
    pub ruleId: Oid,
    pub event: CmdType,
    pub qual: *mut Node,
    pub actions: *mut List,
    pub enabled: ::std::os::raw::c_char,
    pub isInstead: bool,
}
impl Default for RewriteRule {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RuleLock {
    pub numLocks: ::std::os::raw::c_int,
    pub rules: *mut *mut RewriteRule,
}
impl Default for RuleLock {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LockRelId {
    pub relId: Oid,
    pub dbId: Oid,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LockInfoData {
    pub lockRelId: LockRelId,
}
pub type LockInfo = *mut LockInfoData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RelationData {
    pub rd_node: RelFileNode,
    pub rd_smgr: *mut SMgrRelationData,
    pub rd_refcnt: ::std::os::raw::c_int,
    pub rd_backend: BackendId,
    pub rd_islocaltemp: bool,
    pub rd_isnailed: bool,
    pub rd_isvalid: bool,
    pub rd_indexvalid: bool,
    pub rd_statvalid: bool,
    pub rd_createSubid: SubTransactionId,
    pub rd_newRelfilenodeSubid: SubTransactionId,
    pub rd_firstRelfilenodeSubid: SubTransactionId,
    pub rd_droppedSubid: SubTransactionId,
    pub rd_rel: Form_pg_class,
    pub rd_att: TupleDesc,
    pub rd_id: Oid,
    pub rd_lockInfo: LockInfoData,
    pub rd_rules: *mut RuleLock,
    pub rd_rulescxt: MemoryContext,
    pub trigdesc: *mut TriggerDesc,
    pub rd_rsdesc: *mut RowSecurityDesc,
    pub rd_fkeylist: *mut List,
    pub rd_fkeyvalid: bool,
    pub rd_partkey: PartitionKey,
    pub rd_partkeycxt: MemoryContext,
    pub rd_partdesc: PartitionDesc,
    pub rd_pdcxt: MemoryContext,
    pub rd_partcheck: *mut List,
    pub rd_partcheckvalid: bool,
    pub rd_partcheckcxt: MemoryContext,
    pub rd_indexlist: *mut List,
    pub rd_pkindex: Oid,
    pub rd_replidindex: Oid,
    pub rd_statlist: *mut List,
    pub rd_indexattr: *mut Bitmapset,
    pub rd_keyattr: *mut Bitmapset,
    pub rd_pkattr: *mut Bitmapset,
    pub rd_idattr: *mut Bitmapset,
    pub rd_pubactions: *mut PublicationActions,
    pub rd_options: *mut bytea,
    pub rd_amhandler: Oid,
    pub rd_tableam: *const TableAmRoutine,
    pub rd_index: Form_pg_index,
    pub rd_indextuple: *mut HeapTupleData,
    pub rd_indexcxt: MemoryContext,
    pub rd_indam: *mut IndexAmRoutine,
    pub rd_opfamily: *mut Oid,
    pub rd_opcintype: *mut Oid,
    pub rd_support: *mut RegProcedure,
    pub rd_supportinfo: *mut FmgrInfo,
    pub rd_indoption: *mut int16,
    pub rd_indexprs: *mut List,
    pub rd_indpred: *mut List,
    pub rd_exclops: *mut Oid,
    pub rd_exclprocs: *mut Oid,
    pub rd_exclstrats: *mut uint16,
    pub rd_indcollation: *mut Oid,
    pub rd_opcoptions: *mut *mut bytea,
    pub rd_amcache: *mut ::std::os::raw::c_void,
    pub rd_fdwroutine: *mut FdwRoutine,
    pub rd_toastoid: Oid,
    pub pgstat_info: *mut PgStat_TableStatus,
}
impl Default for RelationData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForeignKeyCacheInfo {
    pub type_: NodeTag,
    pub conoid: Oid,
    pub conrelid: Oid,
    pub confrelid: Oid,
    pub nkeys: ::std::os::raw::c_int,
    pub conkey: [AttrNumber; 32usize],
    pub confkey: [AttrNumber; 32usize],
    pub conpfeqop: [Oid; 32usize],
}
impl Default for ForeignKeyCacheInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AutoVacOpts {
    pub enabled: bool,
    pub vacuum_threshold: ::std::os::raw::c_int,
    pub vacuum_ins_threshold: ::std::os::raw::c_int,
    pub analyze_threshold: ::std::os::raw::c_int,
    pub vacuum_cost_limit: ::std::os::raw::c_int,
    pub freeze_min_age: ::std::os::raw::c_int,
    pub freeze_max_age: ::std::os::raw::c_int,
    pub freeze_table_age: ::std::os::raw::c_int,
    pub multixact_freeze_min_age: ::std::os::raw::c_int,
    pub multixact_freeze_max_age: ::std::os::raw::c_int,
    pub multixact_freeze_table_age: ::std::os::raw::c_int,
    pub log_min_duration: ::std::os::raw::c_int,
    pub vacuum_cost_delay: float8,
    pub vacuum_scale_factor: float8,
    pub vacuum_ins_scale_factor: float8,
    pub analyze_scale_factor: float8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct StdRdOptions {
    pub vl_len_: int32,
    pub fillfactor: ::std::os::raw::c_int,
    pub toast_tuple_target: ::std::os::raw::c_int,
    pub autovacuum: AutoVacOpts,
    pub user_catalog_table: bool,
    pub parallel_workers: ::std::os::raw::c_int,
    pub vacuum_index_cleanup: bool,
    pub vacuum_truncate: bool,
}
pub const ViewOptCheckOption_VIEW_OPTION_CHECK_OPTION_NOT_SET: ViewOptCheckOption = 0;
pub const ViewOptCheckOption_VIEW_OPTION_CHECK_OPTION_LOCAL: ViewOptCheckOption = 1;
pub const ViewOptCheckOption_VIEW_OPTION_CHECK_OPTION_CASCADED: ViewOptCheckOption = 2;
pub type ViewOptCheckOption = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ViewOptions {
    pub vl_len_: int32,
    pub security_barrier: bool,
    pub check_option: ViewOptCheckOption,
}
impl Default for ViewOptions {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn RelationIncrementReferenceCount(arg_rel: Relation) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationIncrementReferenceCount(arg_rel: Relation);
        }
        RelationIncrementReferenceCount(arg_rel)
    })
}
pub unsafe fn RelationDecrementReferenceCount(arg_rel: Relation) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationDecrementReferenceCount(arg_rel: Relation);
        }
        RelationDecrementReferenceCount(arg_rel)
    })
}
extern "C" {
    pub static mut default_table_access_method: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut synchronize_seqscans: bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BulkInsertStateData {
    _unused: [u8; 0],
}
pub const ScanOptions_SO_TYPE_SEQSCAN: ScanOptions = 1;
pub const ScanOptions_SO_TYPE_BITMAPSCAN: ScanOptions = 2;
pub const ScanOptions_SO_TYPE_SAMPLESCAN: ScanOptions = 4;
pub const ScanOptions_SO_TYPE_TIDSCAN: ScanOptions = 8;
pub const ScanOptions_SO_TYPE_ANALYZE: ScanOptions = 16;
pub const ScanOptions_SO_ALLOW_STRAT: ScanOptions = 32;
pub const ScanOptions_SO_ALLOW_SYNC: ScanOptions = 64;
pub const ScanOptions_SO_ALLOW_PAGEMODE: ScanOptions = 128;
pub const ScanOptions_SO_TEMP_SNAPSHOT: ScanOptions = 256;
pub type ScanOptions = ::std::os::raw::c_uint;
pub const TM_Result_TM_Ok: TM_Result = 0;
pub const TM_Result_TM_Invisible: TM_Result = 1;
pub const TM_Result_TM_SelfModified: TM_Result = 2;
pub const TM_Result_TM_Updated: TM_Result = 3;
pub const TM_Result_TM_Deleted: TM_Result = 4;
pub const TM_Result_TM_BeingModified: TM_Result = 5;
pub const TM_Result_TM_WouldBlock: TM_Result = 6;
pub type TM_Result = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TM_FailureData {
    pub ctid: ItemPointerData,
    pub xmax: TransactionId,
    pub cmax: CommandId,
    pub traversed: bool,
}
pub type IndexBuildCallback = ::std::option::Option<
    unsafe extern "C" fn(
        index: Relation,
        tid: ItemPointer,
        values: *mut Datum,
        isnull: *mut bool,
        tupleIsAlive: bool,
        state: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TableAmRoutine {
    pub type_: NodeTag,
    pub slot_callbacks:
        ::std::option::Option<unsafe extern "C" fn(rel: Relation) -> *const TupleTableSlotOps>,
    pub scan_begin: ::std::option::Option<
        unsafe extern "C" fn(
            rel: Relation,
            snapshot: Snapshot,
            nkeys: ::std::os::raw::c_int,
            key: *mut ScanKeyData,
            pscan: ParallelTableScanDesc,
            flags: uint32,
        ) -> TableScanDesc,
    >,
    pub scan_end: ::std::option::Option<unsafe extern "C" fn(scan: TableScanDesc)>,
    pub scan_rescan: ::std::option::Option<
        unsafe extern "C" fn(
            scan: TableScanDesc,
            key: *mut ScanKeyData,
            set_params: bool,
            allow_strat: bool,
            allow_sync: bool,
            allow_pagemode: bool,
        ),
    >,
    pub scan_getnextslot: ::std::option::Option<
        unsafe extern "C" fn(
            scan: TableScanDesc,
            direction: ScanDirection,
            slot: *mut TupleTableSlot,
        ) -> bool,
    >,
    pub parallelscan_estimate: ::std::option::Option<unsafe extern "C" fn(rel: Relation) -> Size>,
    pub parallelscan_initialize: ::std::option::Option<
        unsafe extern "C" fn(rel: Relation, pscan: ParallelTableScanDesc) -> Size,
    >,
    pub parallelscan_reinitialize:
        ::std::option::Option<unsafe extern "C" fn(rel: Relation, pscan: ParallelTableScanDesc)>,
    pub index_fetch_begin:
        ::std::option::Option<unsafe extern "C" fn(rel: Relation) -> *mut IndexFetchTableData>,
    pub index_fetch_reset:
        ::std::option::Option<unsafe extern "C" fn(data: *mut IndexFetchTableData)>,
    pub index_fetch_end:
        ::std::option::Option<unsafe extern "C" fn(data: *mut IndexFetchTableData)>,
    pub index_fetch_tuple: ::std::option::Option<
        unsafe extern "C" fn(
            scan: *mut IndexFetchTableData,
            tid: ItemPointer,
            snapshot: Snapshot,
            slot: *mut TupleTableSlot,
            call_again: *mut bool,
            all_dead: *mut bool,
        ) -> bool,
    >,
    pub tuple_fetch_row_version: ::std::option::Option<
        unsafe extern "C" fn(
            rel: Relation,
            tid: ItemPointer,
            snapshot: Snapshot,
            slot: *mut TupleTableSlot,
        ) -> bool,
    >,
    pub tuple_tid_valid:
        ::std::option::Option<unsafe extern "C" fn(scan: TableScanDesc, tid: ItemPointer) -> bool>,
    pub tuple_get_latest_tid:
        ::std::option::Option<unsafe extern "C" fn(scan: TableScanDesc, tid: ItemPointer)>,
    pub tuple_satisfies_snapshot: ::std::option::Option<
        unsafe extern "C" fn(rel: Relation, slot: *mut TupleTableSlot, snapshot: Snapshot) -> bool,
    >,
    pub compute_xid_horizon_for_tuples: ::std::option::Option<
        unsafe extern "C" fn(
            rel: Relation,
            items: *mut ItemPointerData,
            nitems: ::std::os::raw::c_int,
        ) -> TransactionId,
    >,
    pub tuple_insert: ::std::option::Option<
        unsafe extern "C" fn(
            rel: Relation,
            slot: *mut TupleTableSlot,
            cid: CommandId,
            options: ::std::os::raw::c_int,
            bistate: *mut BulkInsertStateData,
        ),
    >,
    pub tuple_insert_speculative: ::std::option::Option<
        unsafe extern "C" fn(
            rel: Relation,
            slot: *mut TupleTableSlot,
            cid: CommandId,
            options: ::std::os::raw::c_int,
            bistate: *mut BulkInsertStateData,
            specToken: uint32,
        ),
    >,
    pub tuple_complete_speculative: ::std::option::Option<
        unsafe extern "C" fn(
            rel: Relation,
            slot: *mut TupleTableSlot,
            specToken: uint32,
            succeeded: bool,
        ),
    >,
    pub multi_insert: ::std::option::Option<
        unsafe extern "C" fn(
            rel: Relation,
            slots: *mut *mut TupleTableSlot,
            nslots: ::std::os::raw::c_int,
            cid: CommandId,
            options: ::std::os::raw::c_int,
            bistate: *mut BulkInsertStateData,
        ),
    >,
    pub tuple_delete: ::std::option::Option<
        unsafe extern "C" fn(
            rel: Relation,
            tid: ItemPointer,
            cid: CommandId,
            snapshot: Snapshot,
            crosscheck: Snapshot,
            wait: bool,
            tmfd: *mut TM_FailureData,
            changingPart: bool,
        ) -> TM_Result,
    >,
    pub tuple_update: ::std::option::Option<
        unsafe extern "C" fn(
            rel: Relation,
            otid: ItemPointer,
            slot: *mut TupleTableSlot,
            cid: CommandId,
            snapshot: Snapshot,
            crosscheck: Snapshot,
            wait: bool,
            tmfd: *mut TM_FailureData,
            lockmode: *mut LockTupleMode,
            update_indexes: *mut bool,
        ) -> TM_Result,
    >,
    pub tuple_lock: ::std::option::Option<
        unsafe extern "C" fn(
            rel: Relation,
            tid: ItemPointer,
            snapshot: Snapshot,
            slot: *mut TupleTableSlot,
            cid: CommandId,
            mode: LockTupleMode,
            wait_policy: LockWaitPolicy,
            flags: uint8,
            tmfd: *mut TM_FailureData,
        ) -> TM_Result,
    >,
    pub finish_bulk_insert:
        ::std::option::Option<unsafe extern "C" fn(rel: Relation, options: ::std::os::raw::c_int)>,
    pub relation_set_new_filenode: ::std::option::Option<
        unsafe extern "C" fn(
            rel: Relation,
            newrnode: *const RelFileNode,
            persistence: ::std::os::raw::c_char,
            freezeXid: *mut TransactionId,
            minmulti: *mut MultiXactId,
        ),
    >,
    pub relation_nontransactional_truncate:
        ::std::option::Option<unsafe extern "C" fn(rel: Relation)>,
    pub relation_copy_data:
        ::std::option::Option<unsafe extern "C" fn(rel: Relation, newrnode: *const RelFileNode)>,
    pub relation_copy_for_cluster: ::std::option::Option<
        unsafe extern "C" fn(
            NewTable: Relation,
            OldTable: Relation,
            OldIndex: Relation,
            use_sort: bool,
            OldestXmin: TransactionId,
            xid_cutoff: *mut TransactionId,
            multi_cutoff: *mut MultiXactId,
            num_tuples: *mut f64,
            tups_vacuumed: *mut f64,
            tups_recently_dead: *mut f64,
        ),
    >,
    pub relation_vacuum: ::std::option::Option<
        unsafe extern "C" fn(
            onerel: Relation,
            params: *mut VacuumParams,
            bstrategy: BufferAccessStrategy,
        ),
    >,
    pub scan_analyze_next_block: ::std::option::Option<
        unsafe extern "C" fn(
            scan: TableScanDesc,
            blockno: BlockNumber,
            bstrategy: BufferAccessStrategy,
        ) -> bool,
    >,
    pub scan_analyze_next_tuple: ::std::option::Option<
        unsafe extern "C" fn(
            scan: TableScanDesc,
            OldestXmin: TransactionId,
            liverows: *mut f64,
            deadrows: *mut f64,
            slot: *mut TupleTableSlot,
        ) -> bool,
    >,
    pub index_build_range_scan: ::std::option::Option<
        unsafe extern "C" fn(
            table_rel: Relation,
            index_rel: Relation,
            index_info: *mut IndexInfo,
            allow_sync: bool,
            anyvisible: bool,
            progress: bool,
            start_blockno: BlockNumber,
            numblocks: BlockNumber,
            callback: IndexBuildCallback,
            callback_state: *mut ::std::os::raw::c_void,
            scan: TableScanDesc,
        ) -> f64,
    >,
    pub index_validate_scan: ::std::option::Option<
        unsafe extern "C" fn(
            table_rel: Relation,
            index_rel: Relation,
            index_info: *mut IndexInfo,
            snapshot: Snapshot,
            state: *mut ValidateIndexState,
        ),
    >,
    pub relation_size: ::std::option::Option<
        unsafe extern "C" fn(rel: Relation, forkNumber: ForkNumber) -> uint64,
    >,
    pub relation_needs_toast_table:
        ::std::option::Option<unsafe extern "C" fn(rel: Relation) -> bool>,
    pub relation_toast_am: ::std::option::Option<unsafe extern "C" fn(rel: Relation) -> Oid>,
    pub relation_fetch_toast_slice: ::std::option::Option<
        unsafe extern "C" fn(
            toastrel: Relation,
            valueid: Oid,
            attrsize: int32,
            sliceoffset: int32,
            slicelength: int32,
            result: *mut varlena,
        ),
    >,
    pub relation_estimate_size: ::std::option::Option<
        unsafe extern "C" fn(
            rel: Relation,
            attr_widths: *mut int32,
            pages: *mut BlockNumber,
            tuples: *mut f64,
            allvisfrac: *mut f64,
        ),
    >,
    pub scan_bitmap_next_block: ::std::option::Option<
        unsafe extern "C" fn(scan: TableScanDesc, tbmres: *mut TBMIterateResult) -> bool,
    >,
    pub scan_bitmap_next_tuple: ::std::option::Option<
        unsafe extern "C" fn(
            scan: TableScanDesc,
            tbmres: *mut TBMIterateResult,
            slot: *mut TupleTableSlot,
        ) -> bool,
    >,
    pub scan_sample_next_block: ::std::option::Option<
        unsafe extern "C" fn(scan: TableScanDesc, scanstate: *mut SampleScanState) -> bool,
    >,
    pub scan_sample_next_tuple: ::std::option::Option<
        unsafe extern "C" fn(
            scan: TableScanDesc,
            scanstate: *mut SampleScanState,
            slot: *mut TupleTableSlot,
        ) -> bool,
    >,
}
impl Default for TableAmRoutine {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn table_slot_callbacks(arg_rel: Relation) -> *const TupleTableSlotOps {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn table_slot_callbacks(arg_rel: Relation) -> *const TupleTableSlotOps;
        }
        table_slot_callbacks(arg_rel)
    })
}
pub unsafe fn table_slot_create(
    arg_rel: Relation,
    arg_reglist: *mut *mut List,
) -> *mut TupleTableSlot {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn table_slot_create(
                arg_rel: Relation,
                arg_reglist: *mut *mut List,
            ) -> *mut TupleTableSlot;
        }
        table_slot_create(arg_rel, arg_reglist)
    })
}
pub unsafe fn table_beginscan_catalog(
    arg_rel: Relation,
    arg_nkeys: ::std::os::raw::c_int,
    arg_key: *mut ScanKeyData,
) -> TableScanDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn table_beginscan_catalog(
                arg_rel: Relation,
                arg_nkeys: ::std::os::raw::c_int,
                arg_key: *mut ScanKeyData,
            ) -> TableScanDesc;
        }
        table_beginscan_catalog(arg_rel, arg_nkeys, arg_key)
    })
}
pub unsafe fn table_scan_update_snapshot(arg_scan: TableScanDesc, arg_snapshot: Snapshot) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn table_scan_update_snapshot(arg_scan: TableScanDesc, arg_snapshot: Snapshot);
        }
        table_scan_update_snapshot(arg_scan, arg_snapshot)
    })
}
pub unsafe fn table_parallelscan_estimate(arg_rel: Relation, arg_snapshot: Snapshot) -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn table_parallelscan_estimate(arg_rel: Relation, arg_snapshot: Snapshot) -> Size;
        }
        table_parallelscan_estimate(arg_rel, arg_snapshot)
    })
}
pub unsafe fn table_parallelscan_initialize(
    arg_rel: Relation,
    arg_pscan: ParallelTableScanDesc,
    arg_snapshot: Snapshot,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn table_parallelscan_initialize(
                arg_rel: Relation,
                arg_pscan: ParallelTableScanDesc,
                arg_snapshot: Snapshot,
            );
        }
        table_parallelscan_initialize(arg_rel, arg_pscan, arg_snapshot)
    })
}
pub unsafe fn table_beginscan_parallel(
    arg_rel: Relation,
    arg_pscan: ParallelTableScanDesc,
) -> TableScanDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn table_beginscan_parallel(
                arg_rel: Relation,
                arg_pscan: ParallelTableScanDesc,
            ) -> TableScanDesc;
        }
        table_beginscan_parallel(arg_rel, arg_pscan)
    })
}
pub unsafe fn table_index_fetch_tuple_check(
    arg_rel: Relation,
    arg_tid: ItemPointer,
    arg_snapshot: Snapshot,
    arg_all_dead: *mut bool,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn table_index_fetch_tuple_check(
                arg_rel: Relation,
                arg_tid: ItemPointer,
                arg_snapshot: Snapshot,
                arg_all_dead: *mut bool,
            ) -> bool;
        }
        table_index_fetch_tuple_check(arg_rel, arg_tid, arg_snapshot, arg_all_dead)
    })
}
pub unsafe fn table_tuple_get_latest_tid(arg_scan: TableScanDesc, arg_tid: ItemPointer) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn table_tuple_get_latest_tid(arg_scan: TableScanDesc, arg_tid: ItemPointer);
        }
        table_tuple_get_latest_tid(arg_scan, arg_tid)
    })
}
pub unsafe fn simple_table_tuple_insert(arg_rel: Relation, arg_slot: *mut TupleTableSlot) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn simple_table_tuple_insert(arg_rel: Relation, arg_slot: *mut TupleTableSlot);
        }
        simple_table_tuple_insert(arg_rel, arg_slot)
    })
}
pub unsafe fn simple_table_tuple_delete(
    arg_rel: Relation,
    arg_tid: ItemPointer,
    arg_snapshot: Snapshot,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn simple_table_tuple_delete(
                arg_rel: Relation,
                arg_tid: ItemPointer,
                arg_snapshot: Snapshot,
            );
        }
        simple_table_tuple_delete(arg_rel, arg_tid, arg_snapshot)
    })
}
pub unsafe fn simple_table_tuple_update(
    arg_rel: Relation,
    arg_otid: ItemPointer,
    arg_slot: *mut TupleTableSlot,
    arg_snapshot: Snapshot,
    arg_update_indexes: *mut bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn simple_table_tuple_update(
                arg_rel: Relation,
                arg_otid: ItemPointer,
                arg_slot: *mut TupleTableSlot,
                arg_snapshot: Snapshot,
                arg_update_indexes: *mut bool,
            );
        }
        simple_table_tuple_update(arg_rel, arg_otid, arg_slot, arg_snapshot, arg_update_indexes)
    })
}
pub unsafe fn table_block_parallelscan_estimate(arg_rel: Relation) -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn table_block_parallelscan_estimate(arg_rel: Relation) -> Size;
        }
        table_block_parallelscan_estimate(arg_rel)
    })
}
pub unsafe fn table_block_parallelscan_initialize(
    arg_rel: Relation,
    arg_pscan: ParallelTableScanDesc,
) -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn table_block_parallelscan_initialize(
                arg_rel: Relation,
                arg_pscan: ParallelTableScanDesc,
            ) -> Size;
        }
        table_block_parallelscan_initialize(arg_rel, arg_pscan)
    })
}
pub unsafe fn table_block_parallelscan_reinitialize(
    arg_rel: Relation,
    arg_pscan: ParallelTableScanDesc,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn table_block_parallelscan_reinitialize(
                arg_rel: Relation,
                arg_pscan: ParallelTableScanDesc,
            );
        }
        table_block_parallelscan_reinitialize(arg_rel, arg_pscan)
    })
}
pub unsafe fn table_block_parallelscan_nextpage(
    arg_rel: Relation,
    arg_pbscan: ParallelBlockTableScanDesc,
) -> BlockNumber {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn table_block_parallelscan_nextpage(
                arg_rel: Relation,
                arg_pbscan: ParallelBlockTableScanDesc,
            ) -> BlockNumber;
        }
        table_block_parallelscan_nextpage(arg_rel, arg_pbscan)
    })
}
pub unsafe fn table_block_parallelscan_startblock_init(
    arg_rel: Relation,
    arg_pbscan: ParallelBlockTableScanDesc,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn table_block_parallelscan_startblock_init(
                arg_rel: Relation,
                arg_pbscan: ParallelBlockTableScanDesc,
            );
        }
        table_block_parallelscan_startblock_init(arg_rel, arg_pbscan)
    })
}
pub unsafe fn table_block_relation_size(arg_rel: Relation, arg_forkNumber: ForkNumber) -> uint64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn table_block_relation_size(arg_rel: Relation, arg_forkNumber: ForkNumber) -> uint64;
        }
        table_block_relation_size(arg_rel, arg_forkNumber)
    })
}
pub unsafe fn table_block_relation_estimate_size(
    arg_rel: Relation,
    arg_attr_widths: *mut int32,
    arg_pages: *mut BlockNumber,
    arg_tuples: *mut f64,
    arg_allvisfrac: *mut f64,
    arg_overhead_bytes_per_tuple: Size,
    arg_usable_bytes_per_page: Size,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn table_block_relation_estimate_size(
                arg_rel: Relation,
                arg_attr_widths: *mut int32,
                arg_pages: *mut BlockNumber,
                arg_tuples: *mut f64,
                arg_allvisfrac: *mut f64,
                arg_overhead_bytes_per_tuple: Size,
                arg_usable_bytes_per_page: Size,
            );
        }
        table_block_relation_estimate_size(
            arg_rel,
            arg_attr_widths,
            arg_pages,
            arg_tuples,
            arg_allvisfrac,
            arg_overhead_bytes_per_tuple,
            arg_usable_bytes_per_page,
        )
    })
}
pub unsafe fn GetTableAmRoutine(arg_amhandler: Oid) -> *const TableAmRoutine {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetTableAmRoutine(arg_amhandler: Oid) -> *const TableAmRoutine;
        }
        GetTableAmRoutine(arg_amhandler)
    })
}
pub unsafe fn GetHeapamTableAmRoutine() -> *const TableAmRoutine {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetHeapamTableAmRoutine() -> *const TableAmRoutine;
        }
        GetHeapamTableAmRoutine()
    })
}
pub unsafe fn check_default_table_access_method(
    arg_newval: *mut *mut ::std::os::raw::c_char,
    arg_extra: *mut *mut ::std::os::raw::c_void,
    arg_source: GucSource,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn check_default_table_access_method(
                arg_newval: *mut *mut ::std::os::raw::c_char,
                arg_extra: *mut *mut ::std::os::raw::c_void,
                arg_source: GucSource,
            ) -> bool;
        }
        check_default_table_access_method(arg_newval, arg_extra, arg_source)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shm_toc {
    _unused: [u8; 0],
}
pub unsafe fn shm_toc_create(
    arg_magic: uint64,
    arg_address: *mut ::std::os::raw::c_void,
    arg_nbytes: Size,
) -> *mut shm_toc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn shm_toc_create(
                arg_magic: uint64,
                arg_address: *mut ::std::os::raw::c_void,
                arg_nbytes: Size,
            ) -> *mut shm_toc;
        }
        shm_toc_create(arg_magic, arg_address, arg_nbytes)
    })
}
pub unsafe fn shm_toc_attach(
    arg_magic: uint64,
    arg_address: *mut ::std::os::raw::c_void,
) -> *mut shm_toc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn shm_toc_attach(
                arg_magic: uint64,
                arg_address: *mut ::std::os::raw::c_void,
            ) -> *mut shm_toc;
        }
        shm_toc_attach(arg_magic, arg_address)
    })
}
pub unsafe fn shm_toc_allocate(
    arg_toc: *mut shm_toc,
    arg_nbytes: Size,
) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn shm_toc_allocate(
                arg_toc: *mut shm_toc,
                arg_nbytes: Size,
            ) -> *mut ::std::os::raw::c_void;
        }
        shm_toc_allocate(arg_toc, arg_nbytes)
    })
}
pub unsafe fn shm_toc_freespace(arg_toc: *mut shm_toc) -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn shm_toc_freespace(arg_toc: *mut shm_toc) -> Size;
        }
        shm_toc_freespace(arg_toc)
    })
}
pub unsafe fn shm_toc_insert(
    arg_toc: *mut shm_toc,
    arg_key: uint64,
    arg_address: *mut ::std::os::raw::c_void,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn shm_toc_insert(
                arg_toc: *mut shm_toc,
                arg_key: uint64,
                arg_address: *mut ::std::os::raw::c_void,
            );
        }
        shm_toc_insert(arg_toc, arg_key, arg_address)
    })
}
pub unsafe fn shm_toc_lookup(
    arg_toc: *mut shm_toc,
    arg_key: uint64,
    arg_noError: bool,
) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn shm_toc_lookup(
                arg_toc: *mut shm_toc,
                arg_key: uint64,
                arg_noError: bool,
            ) -> *mut ::std::os::raw::c_void;
        }
        shm_toc_lookup(arg_toc, arg_key, arg_noError)
    })
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct shm_toc_estimator {
    pub space_for_chunks: Size,
    pub number_of_keys: Size,
}
pub unsafe fn shm_toc_estimate(arg_e: *mut shm_toc_estimator) -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn shm_toc_estimate(arg_e: *mut shm_toc_estimator) -> Size;
        }
        shm_toc_estimate(arg_e)
    })
}
pub type BulkInsertState = *mut BulkInsertStateData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HeapScanDescData {
    pub rs_base: TableScanDescData,
    pub rs_nblocks: BlockNumber,
    pub rs_startblock: BlockNumber,
    pub rs_numblocks: BlockNumber,
    pub rs_inited: bool,
    pub rs_cblock: BlockNumber,
    pub rs_cbuf: Buffer,
    pub rs_strategy: BufferAccessStrategy,
    pub rs_ctup: HeapTupleData,
    pub rs_cindex: ::std::os::raw::c_int,
    pub rs_ntuples: ::std::os::raw::c_int,
    pub rs_vistuples: [OffsetNumber; 291usize],
}
impl Default for HeapScanDescData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type HeapScanDesc = *mut HeapScanDescData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexFetchHeapData {
    pub xs_base: IndexFetchTableData,
    pub xs_cbuf: Buffer,
}
impl Default for IndexFetchHeapData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const HTSV_Result_HEAPTUPLE_DEAD: HTSV_Result = 0;
pub const HTSV_Result_HEAPTUPLE_LIVE: HTSV_Result = 1;
pub const HTSV_Result_HEAPTUPLE_RECENTLY_DEAD: HTSV_Result = 2;
pub const HTSV_Result_HEAPTUPLE_INSERT_IN_PROGRESS: HTSV_Result = 3;
pub const HTSV_Result_HEAPTUPLE_DELETE_IN_PROGRESS: HTSV_Result = 4;
pub type HTSV_Result = ::std::os::raw::c_uint;
pub unsafe fn heap_beginscan(
    arg_relation: Relation,
    arg_snapshot: Snapshot,
    arg_nkeys: ::std::os::raw::c_int,
    arg_key: ScanKey,
    arg_parallel_scan: ParallelTableScanDesc,
    arg_flags: uint32,
) -> TableScanDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_beginscan(
                arg_relation: Relation,
                arg_snapshot: Snapshot,
                arg_nkeys: ::std::os::raw::c_int,
                arg_key: ScanKey,
                arg_parallel_scan: ParallelTableScanDesc,
                arg_flags: uint32,
            ) -> TableScanDesc;
        }
        heap_beginscan(arg_relation, arg_snapshot, arg_nkeys, arg_key, arg_parallel_scan, arg_flags)
    })
}
pub unsafe fn heap_setscanlimits(
    arg_scan: TableScanDesc,
    arg_startBlk: BlockNumber,
    arg_numBlks: BlockNumber,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_setscanlimits(
                arg_scan: TableScanDesc,
                arg_startBlk: BlockNumber,
                arg_numBlks: BlockNumber,
            );
        }
        heap_setscanlimits(arg_scan, arg_startBlk, arg_numBlks)
    })
}
pub unsafe fn heapgetpage(arg_scan: TableScanDesc, arg_page: BlockNumber) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heapgetpage(arg_scan: TableScanDesc, arg_page: BlockNumber);
        }
        heapgetpage(arg_scan, arg_page)
    })
}
pub unsafe fn heap_rescan(
    arg_scan: TableScanDesc,
    arg_key: ScanKey,
    arg_set_params: bool,
    arg_allow_strat: bool,
    arg_allow_sync: bool,
    arg_allow_pagemode: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_rescan(
                arg_scan: TableScanDesc,
                arg_key: ScanKey,
                arg_set_params: bool,
                arg_allow_strat: bool,
                arg_allow_sync: bool,
                arg_allow_pagemode: bool,
            );
        }
        heap_rescan(
            arg_scan,
            arg_key,
            arg_set_params,
            arg_allow_strat,
            arg_allow_sync,
            arg_allow_pagemode,
        )
    })
}
pub unsafe fn heap_endscan(arg_scan: TableScanDesc) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_endscan(arg_scan: TableScanDesc);
        }
        heap_endscan(arg_scan)
    })
}
pub unsafe fn heap_getnext(arg_scan: TableScanDesc, arg_direction: ScanDirection) -> HeapTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_getnext(arg_scan: TableScanDesc, arg_direction: ScanDirection) -> HeapTuple;
        }
        heap_getnext(arg_scan, arg_direction)
    })
}
pub unsafe fn heap_getnextslot(
    arg_sscan: TableScanDesc,
    arg_direction: ScanDirection,
    arg_slot: *mut TupleTableSlot,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_getnextslot(
                arg_sscan: TableScanDesc,
                arg_direction: ScanDirection,
                arg_slot: *mut TupleTableSlot,
            ) -> bool;
        }
        heap_getnextslot(arg_sscan, arg_direction, arg_slot)
    })
}
pub unsafe fn heap_fetch(
    arg_relation: Relation,
    arg_snapshot: Snapshot,
    arg_tuple: HeapTuple,
    arg_userbuf: *mut Buffer,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_fetch(
                arg_relation: Relation,
                arg_snapshot: Snapshot,
                arg_tuple: HeapTuple,
                arg_userbuf: *mut Buffer,
            ) -> bool;
        }
        heap_fetch(arg_relation, arg_snapshot, arg_tuple, arg_userbuf)
    })
}
pub unsafe fn heap_hot_search_buffer(
    arg_tid: ItemPointer,
    arg_relation: Relation,
    arg_buffer: Buffer,
    arg_snapshot: Snapshot,
    arg_heapTuple: HeapTuple,
    arg_all_dead: *mut bool,
    arg_first_call: bool,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_hot_search_buffer(
                arg_tid: ItemPointer,
                arg_relation: Relation,
                arg_buffer: Buffer,
                arg_snapshot: Snapshot,
                arg_heapTuple: HeapTuple,
                arg_all_dead: *mut bool,
                arg_first_call: bool,
            ) -> bool;
        }
        heap_hot_search_buffer(
            arg_tid,
            arg_relation,
            arg_buffer,
            arg_snapshot,
            arg_heapTuple,
            arg_all_dead,
            arg_first_call,
        )
    })
}
pub unsafe fn heap_get_latest_tid(arg_scan: TableScanDesc, arg_tid: ItemPointer) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_get_latest_tid(arg_scan: TableScanDesc, arg_tid: ItemPointer);
        }
        heap_get_latest_tid(arg_scan, arg_tid)
    })
}
pub unsafe fn setLastTid(arg_tid: ItemPointer) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn setLastTid(arg_tid: ItemPointer);
        }
        setLastTid(arg_tid)
    })
}
pub unsafe fn GetBulkInsertState() -> BulkInsertState {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetBulkInsertState() -> BulkInsertState;
        }
        GetBulkInsertState()
    })
}
pub unsafe fn FreeBulkInsertState(arg_arg1: BulkInsertState) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FreeBulkInsertState(arg_arg1: BulkInsertState);
        }
        FreeBulkInsertState(arg_arg1)
    })
}
pub unsafe fn ReleaseBulkInsertStatePin(arg_bistate: BulkInsertState) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReleaseBulkInsertStatePin(arg_bistate: BulkInsertState);
        }
        ReleaseBulkInsertStatePin(arg_bistate)
    })
}
pub unsafe fn heap_insert(
    arg_relation: Relation,
    arg_tup: HeapTuple,
    arg_cid: CommandId,
    arg_options: ::std::os::raw::c_int,
    arg_bistate: BulkInsertState,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_insert(
                arg_relation: Relation,
                arg_tup: HeapTuple,
                arg_cid: CommandId,
                arg_options: ::std::os::raw::c_int,
                arg_bistate: BulkInsertState,
            );
        }
        heap_insert(arg_relation, arg_tup, arg_cid, arg_options, arg_bistate)
    })
}
pub unsafe fn heap_multi_insert(
    arg_relation: Relation,
    arg_slots: *mut *mut TupleTableSlot,
    arg_ntuples: ::std::os::raw::c_int,
    arg_cid: CommandId,
    arg_options: ::std::os::raw::c_int,
    arg_bistate: BulkInsertState,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_multi_insert(
                arg_relation: Relation,
                arg_slots: *mut *mut TupleTableSlot,
                arg_ntuples: ::std::os::raw::c_int,
                arg_cid: CommandId,
                arg_options: ::std::os::raw::c_int,
                arg_bistate: BulkInsertState,
            );
        }
        heap_multi_insert(arg_relation, arg_slots, arg_ntuples, arg_cid, arg_options, arg_bistate)
    })
}
pub unsafe fn heap_delete(
    arg_relation: Relation,
    arg_tid: ItemPointer,
    arg_cid: CommandId,
    arg_crosscheck: Snapshot,
    arg_wait: bool,
    arg_tmfd: *mut TM_FailureData,
    arg_changingPart: bool,
) -> TM_Result {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_delete(
                arg_relation: Relation,
                arg_tid: ItemPointer,
                arg_cid: CommandId,
                arg_crosscheck: Snapshot,
                arg_wait: bool,
                arg_tmfd: *mut TM_FailureData,
                arg_changingPart: bool,
            ) -> TM_Result;
        }
        heap_delete(
            arg_relation,
            arg_tid,
            arg_cid,
            arg_crosscheck,
            arg_wait,
            arg_tmfd,
            arg_changingPart,
        )
    })
}
pub unsafe fn heap_finish_speculative(arg_relation: Relation, arg_tid: ItemPointer) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_finish_speculative(arg_relation: Relation, arg_tid: ItemPointer);
        }
        heap_finish_speculative(arg_relation, arg_tid)
    })
}
pub unsafe fn heap_abort_speculative(arg_relation: Relation, arg_tid: ItemPointer) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_abort_speculative(arg_relation: Relation, arg_tid: ItemPointer);
        }
        heap_abort_speculative(arg_relation, arg_tid)
    })
}
pub unsafe fn heap_update(
    arg_relation: Relation,
    arg_otid: ItemPointer,
    arg_newtup: HeapTuple,
    arg_cid: CommandId,
    arg_crosscheck: Snapshot,
    arg_wait: bool,
    arg_tmfd: *mut TM_FailureData,
    arg_lockmode: *mut LockTupleMode,
) -> TM_Result {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_update(
                arg_relation: Relation,
                arg_otid: ItemPointer,
                arg_newtup: HeapTuple,
                arg_cid: CommandId,
                arg_crosscheck: Snapshot,
                arg_wait: bool,
                arg_tmfd: *mut TM_FailureData,
                arg_lockmode: *mut LockTupleMode,
            ) -> TM_Result;
        }
        heap_update(
            arg_relation,
            arg_otid,
            arg_newtup,
            arg_cid,
            arg_crosscheck,
            arg_wait,
            arg_tmfd,
            arg_lockmode,
        )
    })
}
pub unsafe fn heap_lock_tuple(
    arg_relation: Relation,
    arg_tuple: HeapTuple,
    arg_cid: CommandId,
    arg_mode: LockTupleMode,
    arg_wait_policy: LockWaitPolicy,
    arg_follow_update: bool,
    arg_buffer: *mut Buffer,
    arg_tmfd: *mut TM_FailureData,
) -> TM_Result {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_lock_tuple(
                arg_relation: Relation,
                arg_tuple: HeapTuple,
                arg_cid: CommandId,
                arg_mode: LockTupleMode,
                arg_wait_policy: LockWaitPolicy,
                arg_follow_update: bool,
                arg_buffer: *mut Buffer,
                arg_tmfd: *mut TM_FailureData,
            ) -> TM_Result;
        }
        heap_lock_tuple(
            arg_relation,
            arg_tuple,
            arg_cid,
            arg_mode,
            arg_wait_policy,
            arg_follow_update,
            arg_buffer,
            arg_tmfd,
        )
    })
}
pub unsafe fn heap_inplace_update(arg_relation: Relation, arg_tuple: HeapTuple) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_inplace_update(arg_relation: Relation, arg_tuple: HeapTuple);
        }
        heap_inplace_update(arg_relation, arg_tuple)
    })
}
pub unsafe fn heap_freeze_tuple(
    arg_tuple: HeapTupleHeader,
    arg_relfrozenxid: TransactionId,
    arg_relminmxid: TransactionId,
    arg_cutoff_xid: TransactionId,
    arg_cutoff_multi: TransactionId,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_freeze_tuple(
                arg_tuple: HeapTupleHeader,
                arg_relfrozenxid: TransactionId,
                arg_relminmxid: TransactionId,
                arg_cutoff_xid: TransactionId,
                arg_cutoff_multi: TransactionId,
            ) -> bool;
        }
        heap_freeze_tuple(
            arg_tuple,
            arg_relfrozenxid,
            arg_relminmxid,
            arg_cutoff_xid,
            arg_cutoff_multi,
        )
    })
}
pub unsafe fn heap_tuple_needs_freeze(
    arg_tuple: HeapTupleHeader,
    arg_cutoff_xid: TransactionId,
    arg_cutoff_multi: MultiXactId,
    arg_buf: Buffer,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_tuple_needs_freeze(
                arg_tuple: HeapTupleHeader,
                arg_cutoff_xid: TransactionId,
                arg_cutoff_multi: MultiXactId,
                arg_buf: Buffer,
            ) -> bool;
        }
        heap_tuple_needs_freeze(arg_tuple, arg_cutoff_xid, arg_cutoff_multi, arg_buf)
    })
}
pub unsafe fn heap_tuple_needs_eventual_freeze(arg_tuple: HeapTupleHeader) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_tuple_needs_eventual_freeze(arg_tuple: HeapTupleHeader) -> bool;
        }
        heap_tuple_needs_eventual_freeze(arg_tuple)
    })
}
pub unsafe fn simple_heap_insert(arg_relation: Relation, arg_tup: HeapTuple) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn simple_heap_insert(arg_relation: Relation, arg_tup: HeapTuple);
        }
        simple_heap_insert(arg_relation, arg_tup)
    })
}
pub unsafe fn simple_heap_delete(arg_relation: Relation, arg_tid: ItemPointer) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn simple_heap_delete(arg_relation: Relation, arg_tid: ItemPointer);
        }
        simple_heap_delete(arg_relation, arg_tid)
    })
}
pub unsafe fn simple_heap_update(
    arg_relation: Relation,
    arg_otid: ItemPointer,
    arg_tup: HeapTuple,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn simple_heap_update(
                arg_relation: Relation,
                arg_otid: ItemPointer,
                arg_tup: HeapTuple,
            );
        }
        simple_heap_update(arg_relation, arg_otid, arg_tup)
    })
}
pub unsafe fn heap_compute_xid_horizon_for_tuples(
    arg_rel: Relation,
    arg_items: *mut ItemPointerData,
    arg_nitems: ::std::os::raw::c_int,
) -> TransactionId {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_compute_xid_horizon_for_tuples(
                arg_rel: Relation,
                arg_items: *mut ItemPointerData,
                arg_nitems: ::std::os::raw::c_int,
            ) -> TransactionId;
        }
        heap_compute_xid_horizon_for_tuples(arg_rel, arg_items, arg_nitems)
    })
}
pub unsafe fn heap_page_prune_opt(arg_relation: Relation, arg_buffer: Buffer) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_page_prune_opt(arg_relation: Relation, arg_buffer: Buffer);
        }
        heap_page_prune_opt(arg_relation, arg_buffer)
    })
}
pub unsafe fn heap_page_prune(
    arg_relation: Relation,
    arg_buffer: Buffer,
    arg_OldestXmin: TransactionId,
    arg_report_stats: bool,
    arg_latestRemovedXid: *mut TransactionId,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_page_prune(
                arg_relation: Relation,
                arg_buffer: Buffer,
                arg_OldestXmin: TransactionId,
                arg_report_stats: bool,
                arg_latestRemovedXid: *mut TransactionId,
            ) -> ::std::os::raw::c_int;
        }
        heap_page_prune(
            arg_relation,
            arg_buffer,
            arg_OldestXmin,
            arg_report_stats,
            arg_latestRemovedXid,
        )
    })
}
pub unsafe fn heap_page_prune_execute(
    arg_buffer: Buffer,
    arg_redirected: *mut OffsetNumber,
    arg_nredirected: ::std::os::raw::c_int,
    arg_nowdead: *mut OffsetNumber,
    arg_ndead: ::std::os::raw::c_int,
    arg_nowunused: *mut OffsetNumber,
    arg_nunused: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_page_prune_execute(
                arg_buffer: Buffer,
                arg_redirected: *mut OffsetNumber,
                arg_nredirected: ::std::os::raw::c_int,
                arg_nowdead: *mut OffsetNumber,
                arg_ndead: ::std::os::raw::c_int,
                arg_nowunused: *mut OffsetNumber,
                arg_nunused: ::std::os::raw::c_int,
            );
        }
        heap_page_prune_execute(
            arg_buffer,
            arg_redirected,
            arg_nredirected,
            arg_nowdead,
            arg_ndead,
            arg_nowunused,
            arg_nunused,
        )
    })
}
pub unsafe fn heap_get_root_tuples(arg_page: Page, arg_root_offsets: *mut OffsetNumber) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_get_root_tuples(arg_page: Page, arg_root_offsets: *mut OffsetNumber);
        }
        heap_get_root_tuples(arg_page, arg_root_offsets)
    })
}
pub unsafe fn ss_report_location(arg_rel: Relation, arg_location: BlockNumber) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ss_report_location(arg_rel: Relation, arg_location: BlockNumber);
        }
        ss_report_location(arg_rel, arg_location)
    })
}
pub unsafe fn ss_get_location(arg_rel: Relation, arg_relnblocks: BlockNumber) -> BlockNumber {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ss_get_location(arg_rel: Relation, arg_relnblocks: BlockNumber) -> BlockNumber;
        }
        ss_get_location(arg_rel, arg_relnblocks)
    })
}
pub unsafe fn SyncScanShmemInit() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SyncScanShmemInit();
        }
        SyncScanShmemInit()
    })
}
pub unsafe fn SyncScanShmemSize() -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SyncScanShmemSize() -> Size;
        }
        SyncScanShmemSize()
    })
}
pub unsafe fn heap_vacuum_rel(
    arg_onerel: Relation,
    arg_params: *mut VacuumParams,
    arg_bstrategy: BufferAccessStrategy,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_vacuum_rel(
                arg_onerel: Relation,
                arg_params: *mut VacuumParams,
                arg_bstrategy: BufferAccessStrategy,
            );
        }
        heap_vacuum_rel(arg_onerel, arg_params, arg_bstrategy)
    })
}
pub unsafe fn parallel_vacuum_main(arg_seg: *mut dsm_segment, arg_toc: *mut shm_toc) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn parallel_vacuum_main(arg_seg: *mut dsm_segment, arg_toc: *mut shm_toc);
        }
        parallel_vacuum_main(arg_seg, arg_toc)
    })
}
pub unsafe fn HeapTupleSatisfiesVisibility(
    arg_stup: HeapTuple,
    arg_snapshot: Snapshot,
    arg_buffer: Buffer,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn HeapTupleSatisfiesVisibility(
                arg_stup: HeapTuple,
                arg_snapshot: Snapshot,
                arg_buffer: Buffer,
            ) -> bool;
        }
        HeapTupleSatisfiesVisibility(arg_stup, arg_snapshot, arg_buffer)
    })
}
pub unsafe fn HeapTupleSatisfiesUpdate(
    arg_stup: HeapTuple,
    arg_curcid: CommandId,
    arg_buffer: Buffer,
) -> TM_Result {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn HeapTupleSatisfiesUpdate(
                arg_stup: HeapTuple,
                arg_curcid: CommandId,
                arg_buffer: Buffer,
            ) -> TM_Result;
        }
        HeapTupleSatisfiesUpdate(arg_stup, arg_curcid, arg_buffer)
    })
}
pub unsafe fn HeapTupleSatisfiesVacuum(
    arg_stup: HeapTuple,
    arg_OldestXmin: TransactionId,
    arg_buffer: Buffer,
) -> HTSV_Result {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn HeapTupleSatisfiesVacuum(
                arg_stup: HeapTuple,
                arg_OldestXmin: TransactionId,
                arg_buffer: Buffer,
            ) -> HTSV_Result;
        }
        HeapTupleSatisfiesVacuum(arg_stup, arg_OldestXmin, arg_buffer)
    })
}
pub unsafe fn HeapTupleSetHintBits(
    arg_tuple: HeapTupleHeader,
    arg_buffer: Buffer,
    arg_infomask: uint16,
    arg_xid: TransactionId,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn HeapTupleSetHintBits(
                arg_tuple: HeapTupleHeader,
                arg_buffer: Buffer,
                arg_infomask: uint16,
                arg_xid: TransactionId,
            );
        }
        HeapTupleSetHintBits(arg_tuple, arg_buffer, arg_infomask, arg_xid)
    })
}
pub unsafe fn HeapTupleHeaderIsOnlyLocked(arg_tuple: HeapTupleHeader) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn HeapTupleHeaderIsOnlyLocked(arg_tuple: HeapTupleHeader) -> bool;
        }
        HeapTupleHeaderIsOnlyLocked(arg_tuple)
    })
}
pub unsafe fn XidInMVCCSnapshot(arg_xid: TransactionId, arg_snapshot: Snapshot) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XidInMVCCSnapshot(arg_xid: TransactionId, arg_snapshot: Snapshot) -> bool;
        }
        XidInMVCCSnapshot(arg_xid, arg_snapshot)
    })
}
pub unsafe fn HeapTupleIsSurelyDead(arg_htup: HeapTuple, arg_OldestXmin: TransactionId) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn HeapTupleIsSurelyDead(arg_htup: HeapTuple, arg_OldestXmin: TransactionId) -> bool;
        }
        HeapTupleIsSurelyDead(arg_htup, arg_OldestXmin)
    })
}
pub unsafe fn ResolveCminCmaxDuringDecoding(
    arg_tuplecid_data: *mut HTAB,
    arg_snapshot: Snapshot,
    arg_htup: HeapTuple,
    arg_buffer: Buffer,
    arg_cmin: *mut CommandId,
    arg_cmax: *mut CommandId,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ResolveCminCmaxDuringDecoding(
                arg_tuplecid_data: *mut HTAB,
                arg_snapshot: Snapshot,
                arg_htup: HeapTuple,
                arg_buffer: Buffer,
                arg_cmin: *mut CommandId,
                arg_cmax: *mut CommandId,
            ) -> bool;
        }
        ResolveCminCmaxDuringDecoding(
            arg_tuplecid_data,
            arg_snapshot,
            arg_htup,
            arg_buffer,
            arg_cmin,
            arg_cmax,
        )
    })
}
pub unsafe fn HeapCheckForSerializableConflictOut(
    arg_valid: bool,
    arg_relation: Relation,
    arg_tuple: HeapTuple,
    arg_buffer: Buffer,
    arg_snapshot: Snapshot,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn HeapCheckForSerializableConflictOut(
                arg_valid: bool,
                arg_relation: Relation,
                arg_tuple: HeapTuple,
                arg_buffer: Buffer,
                arg_snapshot: Snapshot,
            );
        }
        HeapCheckForSerializableConflictOut(
            arg_valid,
            arg_relation,
            arg_tuple,
            arg_buffer,
            arg_snapshot,
        )
    })
}
pub const relopt_type_RELOPT_TYPE_BOOL: relopt_type = 0;
pub const relopt_type_RELOPT_TYPE_INT: relopt_type = 1;
pub const relopt_type_RELOPT_TYPE_REAL: relopt_type = 2;
pub const relopt_type_RELOPT_TYPE_ENUM: relopt_type = 3;
pub const relopt_type_RELOPT_TYPE_STRING: relopt_type = 4;
pub type relopt_type = ::std::os::raw::c_uint;
pub const relopt_kind_RELOPT_KIND_LOCAL: relopt_kind = 0;
pub const relopt_kind_RELOPT_KIND_HEAP: relopt_kind = 1;
pub const relopt_kind_RELOPT_KIND_TOAST: relopt_kind = 2;
pub const relopt_kind_RELOPT_KIND_BTREE: relopt_kind = 4;
pub const relopt_kind_RELOPT_KIND_HASH: relopt_kind = 8;
pub const relopt_kind_RELOPT_KIND_GIN: relopt_kind = 16;
pub const relopt_kind_RELOPT_KIND_GIST: relopt_kind = 32;
pub const relopt_kind_RELOPT_KIND_ATTRIBUTE: relopt_kind = 64;
pub const relopt_kind_RELOPT_KIND_TABLESPACE: relopt_kind = 128;
pub const relopt_kind_RELOPT_KIND_SPGIST: relopt_kind = 256;
pub const relopt_kind_RELOPT_KIND_VIEW: relopt_kind = 512;
pub const relopt_kind_RELOPT_KIND_BRIN: relopt_kind = 1024;
pub const relopt_kind_RELOPT_KIND_PARTITIONED: relopt_kind = 2048;
pub const relopt_kind_RELOPT_KIND_LAST_DEFAULT: relopt_kind = 2048;
pub const relopt_kind_RELOPT_KIND_MAX: relopt_kind = 1073741824;
pub type relopt_kind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct relopt_gen {
    pub name: *const ::std::os::raw::c_char,
    pub desc: *const ::std::os::raw::c_char,
    pub kinds: bits32,
    pub lockmode: LOCKMODE,
    pub namelen: ::std::os::raw::c_int,
    pub type_: relopt_type,
}
impl Default for relopt_gen {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct relopt_value {
    pub gen: *mut relopt_gen,
    pub isset: bool,
    pub values: relopt_value__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union relopt_value__bindgen_ty_1 {
    pub bool_val: bool,
    pub int_val: ::std::os::raw::c_int,
    pub real_val: f64,
    pub enum_val: ::std::os::raw::c_int,
    pub string_val: *mut ::std::os::raw::c_char,
}
impl Default for relopt_value__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for relopt_value {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct relopt_bool {
    pub gen: relopt_gen,
    pub default_val: bool,
}
impl Default for relopt_bool {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct relopt_int {
    pub gen: relopt_gen,
    pub default_val: ::std::os::raw::c_int,
    pub min: ::std::os::raw::c_int,
    pub max: ::std::os::raw::c_int,
}
impl Default for relopt_int {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct relopt_real {
    pub gen: relopt_gen,
    pub default_val: f64,
    pub min: f64,
    pub max: f64,
}
impl Default for relopt_real {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct relopt_enum_elt_def {
    pub string_val: *const ::std::os::raw::c_char,
    pub symbol_val: ::std::os::raw::c_int,
}
impl Default for relopt_enum_elt_def {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct relopt_enum {
    pub gen: relopt_gen,
    pub members: *mut relopt_enum_elt_def,
    pub default_val: ::std::os::raw::c_int,
    pub detailmsg: *const ::std::os::raw::c_char,
}
impl Default for relopt_enum {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type validate_string_relopt =
    ::std::option::Option<unsafe extern "C" fn(value: *const ::std::os::raw::c_char)>;
pub type fill_string_relopt = ::std::option::Option<
    unsafe extern "C" fn(
        value: *const ::std::os::raw::c_char,
        ptr: *mut ::std::os::raw::c_void,
    ) -> Size,
>;
pub type relopts_validator = ::std::option::Option<
    unsafe extern "C" fn(
        parsed_options: *mut ::std::os::raw::c_void,
        vals: *mut relopt_value,
        nvals: ::std::os::raw::c_int,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct relopt_string {
    pub gen: relopt_gen,
    pub default_len: ::std::os::raw::c_int,
    pub default_isnull: bool,
    pub validate_cb: validate_string_relopt,
    pub fill_cb: fill_string_relopt,
    pub default_val: *mut ::std::os::raw::c_char,
}
impl Default for relopt_string {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct relopt_parse_elt {
    pub optname: *const ::std::os::raw::c_char,
    pub opttype: relopt_type,
    pub offset: ::std::os::raw::c_int,
}
impl Default for relopt_parse_elt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_relopt {
    pub option: *mut relopt_gen,
    pub offset: ::std::os::raw::c_int,
}
impl Default for local_relopt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct local_relopts {
    pub options: *mut List,
    pub validators: *mut List,
    pub relopt_struct_size: Size,
}
impl Default for local_relopts {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn add_reloption_kind() -> relopt_kind {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn add_reloption_kind() -> relopt_kind;
        }
        add_reloption_kind()
    })
}
pub unsafe fn add_bool_reloption(
    arg_kinds: bits32,
    arg_name: *const ::std::os::raw::c_char,
    arg_desc: *const ::std::os::raw::c_char,
    arg_default_val: bool,
    arg_lockmode: LOCKMODE,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn add_bool_reloption(
                arg_kinds: bits32,
                arg_name: *const ::std::os::raw::c_char,
                arg_desc: *const ::std::os::raw::c_char,
                arg_default_val: bool,
                arg_lockmode: LOCKMODE,
            );
        }
        add_bool_reloption(arg_kinds, arg_name, arg_desc, arg_default_val, arg_lockmode)
    })
}
pub unsafe fn add_int_reloption(
    arg_kinds: bits32,
    arg_name: *const ::std::os::raw::c_char,
    arg_desc: *const ::std::os::raw::c_char,
    arg_default_val: ::std::os::raw::c_int,
    arg_min_val: ::std::os::raw::c_int,
    arg_max_val: ::std::os::raw::c_int,
    arg_lockmode: LOCKMODE,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn add_int_reloption(
                arg_kinds: bits32,
                arg_name: *const ::std::os::raw::c_char,
                arg_desc: *const ::std::os::raw::c_char,
                arg_default_val: ::std::os::raw::c_int,
                arg_min_val: ::std::os::raw::c_int,
                arg_max_val: ::std::os::raw::c_int,
                arg_lockmode: LOCKMODE,
            );
        }
        add_int_reloption(
            arg_kinds,
            arg_name,
            arg_desc,
            arg_default_val,
            arg_min_val,
            arg_max_val,
            arg_lockmode,
        )
    })
}
pub unsafe fn add_real_reloption(
    arg_kinds: bits32,
    arg_name: *const ::std::os::raw::c_char,
    arg_desc: *const ::std::os::raw::c_char,
    arg_default_val: f64,
    arg_min_val: f64,
    arg_max_val: f64,
    arg_lockmode: LOCKMODE,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn add_real_reloption(
                arg_kinds: bits32,
                arg_name: *const ::std::os::raw::c_char,
                arg_desc: *const ::std::os::raw::c_char,
                arg_default_val: f64,
                arg_min_val: f64,
                arg_max_val: f64,
                arg_lockmode: LOCKMODE,
            );
        }
        add_real_reloption(
            arg_kinds,
            arg_name,
            arg_desc,
            arg_default_val,
            arg_min_val,
            arg_max_val,
            arg_lockmode,
        )
    })
}
pub unsafe fn add_enum_reloption(
    arg_kinds: bits32,
    arg_name: *const ::std::os::raw::c_char,
    arg_desc: *const ::std::os::raw::c_char,
    arg_members: *mut relopt_enum_elt_def,
    arg_default_val: ::std::os::raw::c_int,
    arg_detailmsg: *const ::std::os::raw::c_char,
    arg_lockmode: LOCKMODE,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn add_enum_reloption(
                arg_kinds: bits32,
                arg_name: *const ::std::os::raw::c_char,
                arg_desc: *const ::std::os::raw::c_char,
                arg_members: *mut relopt_enum_elt_def,
                arg_default_val: ::std::os::raw::c_int,
                arg_detailmsg: *const ::std::os::raw::c_char,
                arg_lockmode: LOCKMODE,
            );
        }
        add_enum_reloption(
            arg_kinds,
            arg_name,
            arg_desc,
            arg_members,
            arg_default_val,
            arg_detailmsg,
            arg_lockmode,
        )
    })
}
pub unsafe fn add_string_reloption(
    arg_kinds: bits32,
    arg_name: *const ::std::os::raw::c_char,
    arg_desc: *const ::std::os::raw::c_char,
    arg_default_val: *const ::std::os::raw::c_char,
    arg_validator: validate_string_relopt,
    arg_lockmode: LOCKMODE,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn add_string_reloption(
                arg_kinds: bits32,
                arg_name: *const ::std::os::raw::c_char,
                arg_desc: *const ::std::os::raw::c_char,
                arg_default_val: *const ::std::os::raw::c_char,
                arg_validator: validate_string_relopt,
                arg_lockmode: LOCKMODE,
            );
        }
        add_string_reloption(
            arg_kinds,
            arg_name,
            arg_desc,
            arg_default_val,
            arg_validator,
            arg_lockmode,
        )
    })
}
pub unsafe fn init_local_reloptions(arg_opts: *mut local_relopts, arg_relopt_struct_size: Size) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn init_local_reloptions(arg_opts: *mut local_relopts, arg_relopt_struct_size: Size);
        }
        init_local_reloptions(arg_opts, arg_relopt_struct_size)
    })
}
pub unsafe fn register_reloptions_validator(
    arg_opts: *mut local_relopts,
    arg_validator: relopts_validator,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn register_reloptions_validator(
                arg_opts: *mut local_relopts,
                arg_validator: relopts_validator,
            );
        }
        register_reloptions_validator(arg_opts, arg_validator)
    })
}
pub unsafe fn add_local_bool_reloption(
    arg_opts: *mut local_relopts,
    arg_name: *const ::std::os::raw::c_char,
    arg_desc: *const ::std::os::raw::c_char,
    arg_default_val: bool,
    arg_offset: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn add_local_bool_reloption(
                arg_opts: *mut local_relopts,
                arg_name: *const ::std::os::raw::c_char,
                arg_desc: *const ::std::os::raw::c_char,
                arg_default_val: bool,
                arg_offset: ::std::os::raw::c_int,
            );
        }
        add_local_bool_reloption(arg_opts, arg_name, arg_desc, arg_default_val, arg_offset)
    })
}
pub unsafe fn add_local_int_reloption(
    arg_opts: *mut local_relopts,
    arg_name: *const ::std::os::raw::c_char,
    arg_desc: *const ::std::os::raw::c_char,
    arg_default_val: ::std::os::raw::c_int,
    arg_min_val: ::std::os::raw::c_int,
    arg_max_val: ::std::os::raw::c_int,
    arg_offset: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn add_local_int_reloption(
                arg_opts: *mut local_relopts,
                arg_name: *const ::std::os::raw::c_char,
                arg_desc: *const ::std::os::raw::c_char,
                arg_default_val: ::std::os::raw::c_int,
                arg_min_val: ::std::os::raw::c_int,
                arg_max_val: ::std::os::raw::c_int,
                arg_offset: ::std::os::raw::c_int,
            );
        }
        add_local_int_reloption(
            arg_opts,
            arg_name,
            arg_desc,
            arg_default_val,
            arg_min_val,
            arg_max_val,
            arg_offset,
        )
    })
}
pub unsafe fn add_local_real_reloption(
    arg_opts: *mut local_relopts,
    arg_name: *const ::std::os::raw::c_char,
    arg_desc: *const ::std::os::raw::c_char,
    arg_default_val: f64,
    arg_min_val: f64,
    arg_max_val: f64,
    arg_offset: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn add_local_real_reloption(
                arg_opts: *mut local_relopts,
                arg_name: *const ::std::os::raw::c_char,
                arg_desc: *const ::std::os::raw::c_char,
                arg_default_val: f64,
                arg_min_val: f64,
                arg_max_val: f64,
                arg_offset: ::std::os::raw::c_int,
            );
        }
        add_local_real_reloption(
            arg_opts,
            arg_name,
            arg_desc,
            arg_default_val,
            arg_min_val,
            arg_max_val,
            arg_offset,
        )
    })
}
pub unsafe fn add_local_enum_reloption(
    arg_relopts: *mut local_relopts,
    arg_name: *const ::std::os::raw::c_char,
    arg_desc: *const ::std::os::raw::c_char,
    arg_members: *mut relopt_enum_elt_def,
    arg_default_val: ::std::os::raw::c_int,
    arg_detailmsg: *const ::std::os::raw::c_char,
    arg_offset: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn add_local_enum_reloption(
                arg_relopts: *mut local_relopts,
                arg_name: *const ::std::os::raw::c_char,
                arg_desc: *const ::std::os::raw::c_char,
                arg_members: *mut relopt_enum_elt_def,
                arg_default_val: ::std::os::raw::c_int,
                arg_detailmsg: *const ::std::os::raw::c_char,
                arg_offset: ::std::os::raw::c_int,
            );
        }
        add_local_enum_reloption(
            arg_relopts,
            arg_name,
            arg_desc,
            arg_members,
            arg_default_val,
            arg_detailmsg,
            arg_offset,
        )
    })
}
pub unsafe fn add_local_string_reloption(
    arg_opts: *mut local_relopts,
    arg_name: *const ::std::os::raw::c_char,
    arg_desc: *const ::std::os::raw::c_char,
    arg_default_val: *const ::std::os::raw::c_char,
    arg_validator: validate_string_relopt,
    arg_filler: fill_string_relopt,
    arg_offset: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn add_local_string_reloption(
                arg_opts: *mut local_relopts,
                arg_name: *const ::std::os::raw::c_char,
                arg_desc: *const ::std::os::raw::c_char,
                arg_default_val: *const ::std::os::raw::c_char,
                arg_validator: validate_string_relopt,
                arg_filler: fill_string_relopt,
                arg_offset: ::std::os::raw::c_int,
            );
        }
        add_local_string_reloption(
            arg_opts,
            arg_name,
            arg_desc,
            arg_default_val,
            arg_validator,
            arg_filler,
            arg_offset,
        )
    })
}
pub unsafe fn transformRelOptions(
    arg_oldOptions: Datum,
    arg_defList: *mut List,
    arg_namspace: *const ::std::os::raw::c_char,
    arg_validnsps: *mut *mut ::std::os::raw::c_char,
    arg_acceptOidsOff: bool,
    arg_isReset: bool,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn transformRelOptions(
                arg_oldOptions: Datum,
                arg_defList: *mut List,
                arg_namspace: *const ::std::os::raw::c_char,
                arg_validnsps: *mut *mut ::std::os::raw::c_char,
                arg_acceptOidsOff: bool,
                arg_isReset: bool,
            ) -> Datum;
        }
        transformRelOptions(
            arg_oldOptions,
            arg_defList,
            arg_namspace,
            arg_validnsps,
            arg_acceptOidsOff,
            arg_isReset,
        )
    })
}
pub unsafe fn untransformRelOptions(arg_options: Datum) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn untransformRelOptions(arg_options: Datum) -> *mut List;
        }
        untransformRelOptions(arg_options)
    })
}
pub unsafe fn extractRelOptions(
    arg_tuple: HeapTuple,
    arg_tupdesc: TupleDesc,
    arg_amoptions: amoptions_function,
) -> *mut bytea {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn extractRelOptions(
                arg_tuple: HeapTuple,
                arg_tupdesc: TupleDesc,
                arg_amoptions: amoptions_function,
            ) -> *mut bytea;
        }
        extractRelOptions(arg_tuple, arg_tupdesc, arg_amoptions)
    })
}
pub unsafe fn build_reloptions(
    arg_reloptions: Datum,
    arg_validate: bool,
    arg_kind: relopt_kind,
    arg_relopt_struct_size: Size,
    arg_relopt_elems: *const relopt_parse_elt,
    arg_num_relopt_elems: ::std::os::raw::c_int,
) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn build_reloptions(
                arg_reloptions: Datum,
                arg_validate: bool,
                arg_kind: relopt_kind,
                arg_relopt_struct_size: Size,
                arg_relopt_elems: *const relopt_parse_elt,
                arg_num_relopt_elems: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_void;
        }
        build_reloptions(
            arg_reloptions,
            arg_validate,
            arg_kind,
            arg_relopt_struct_size,
            arg_relopt_elems,
            arg_num_relopt_elems,
        )
    })
}
pub unsafe fn build_local_reloptions(
    arg_relopts: *mut local_relopts,
    arg_options: Datum,
    arg_validate: bool,
) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn build_local_reloptions(
                arg_relopts: *mut local_relopts,
                arg_options: Datum,
                arg_validate: bool,
            ) -> *mut ::std::os::raw::c_void;
        }
        build_local_reloptions(arg_relopts, arg_options, arg_validate)
    })
}
pub unsafe fn default_reloptions(
    arg_reloptions: Datum,
    arg_validate: bool,
    arg_kind: relopt_kind,
) -> *mut bytea {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn default_reloptions(
                arg_reloptions: Datum,
                arg_validate: bool,
                arg_kind: relopt_kind,
            ) -> *mut bytea;
        }
        default_reloptions(arg_reloptions, arg_validate, arg_kind)
    })
}
pub unsafe fn heap_reloptions(
    arg_relkind: ::std::os::raw::c_char,
    arg_reloptions: Datum,
    arg_validate: bool,
) -> *mut bytea {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_reloptions(
                arg_relkind: ::std::os::raw::c_char,
                arg_reloptions: Datum,
                arg_validate: bool,
            ) -> *mut bytea;
        }
        heap_reloptions(arg_relkind, arg_reloptions, arg_validate)
    })
}
pub unsafe fn view_reloptions(arg_reloptions: Datum, arg_validate: bool) -> *mut bytea {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn view_reloptions(arg_reloptions: Datum, arg_validate: bool) -> *mut bytea;
        }
        view_reloptions(arg_reloptions, arg_validate)
    })
}
pub unsafe fn partitioned_table_reloptions(
    arg_reloptions: Datum,
    arg_validate: bool,
) -> *mut bytea {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn partitioned_table_reloptions(
                arg_reloptions: Datum,
                arg_validate: bool,
            ) -> *mut bytea;
        }
        partitioned_table_reloptions(arg_reloptions, arg_validate)
    })
}
pub unsafe fn index_reloptions(
    arg_amoptions: amoptions_function,
    arg_reloptions: Datum,
    arg_validate: bool,
) -> *mut bytea {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_reloptions(
                arg_amoptions: amoptions_function,
                arg_reloptions: Datum,
                arg_validate: bool,
            ) -> *mut bytea;
        }
        index_reloptions(arg_amoptions, arg_reloptions, arg_validate)
    })
}
pub unsafe fn attribute_reloptions(arg_reloptions: Datum, arg_validate: bool) -> *mut bytea {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn attribute_reloptions(arg_reloptions: Datum, arg_validate: bool) -> *mut bytea;
        }
        attribute_reloptions(arg_reloptions, arg_validate)
    })
}
pub unsafe fn tablespace_reloptions(arg_reloptions: Datum, arg_validate: bool) -> *mut bytea {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tablespace_reloptions(arg_reloptions: Datum, arg_validate: bool) -> *mut bytea;
        }
        tablespace_reloptions(arg_reloptions, arg_validate)
    })
}
pub unsafe fn AlterTableGetRelOptionsLockLevel(arg_defList: *mut List) -> LOCKMODE {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AlterTableGetRelOptionsLockLevel(arg_defList: *mut List) -> LOCKMODE;
        }
        AlterTableGetRelOptionsLockLevel(arg_defList)
    })
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SharedInvalCatcacheMsg {
    pub id: int8,
    pub dbId: Oid,
    pub hashValue: uint32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SharedInvalCatalogMsg {
    pub id: int8,
    pub dbId: Oid,
    pub catId: Oid,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SharedInvalRelcacheMsg {
    pub id: int8,
    pub dbId: Oid,
    pub relId: Oid,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SharedInvalSmgrMsg {
    pub id: int8,
    pub backend_hi: int8,
    pub backend_lo: uint16,
    pub rnode: RelFileNode,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SharedInvalRelmapMsg {
    pub id: int8,
    pub dbId: Oid,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SharedInvalSnapshotMsg {
    pub id: int8,
    pub dbId: Oid,
    pub relId: Oid,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SharedInvalidationMessage {
    pub id: int8,
    pub cc: SharedInvalCatcacheMsg,
    pub cat: SharedInvalCatalogMsg,
    pub rc: SharedInvalRelcacheMsg,
    pub sm: SharedInvalSmgrMsg,
    pub rm: SharedInvalRelmapMsg,
    pub sn: SharedInvalSnapshotMsg,
}
impl Default for SharedInvalidationMessage {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut SharedInvalidMessageCounter: uint64;
}
extern "C" {
    pub static mut catchupInterruptPending: sig_atomic_t;
}
pub unsafe fn SendSharedInvalidMessages(
    arg_msgs: *const SharedInvalidationMessage,
    arg_n: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SendSharedInvalidMessages(
                arg_msgs: *const SharedInvalidationMessage,
                arg_n: ::std::os::raw::c_int,
            );
        }
        SendSharedInvalidMessages(arg_msgs, arg_n)
    })
}
pub unsafe fn ReceiveSharedInvalidMessages(
    arg_invalFunction: ::std::option::Option<
        unsafe extern "C" fn(msg: *mut SharedInvalidationMessage),
    >,
    arg_resetFunction: ::std::option::Option<unsafe extern "C" fn()>,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReceiveSharedInvalidMessages(
                arg_invalFunction: ::std::option::Option<
                    unsafe extern "C" fn(msg: *mut SharedInvalidationMessage),
                >,
                arg_resetFunction: ::std::option::Option<unsafe extern "C" fn()>,
            );
        }
        ReceiveSharedInvalidMessages(arg_invalFunction, arg_resetFunction)
    })
}
pub unsafe fn HandleCatchupInterrupt() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn HandleCatchupInterrupt();
        }
        HandleCatchupInterrupt()
    })
}
pub unsafe fn ProcessCatchupInterrupt() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcessCatchupInterrupt();
        }
        ProcessCatchupInterrupt()
    })
}
pub unsafe fn xactGetCommittedInvalidationMessages(
    arg_msgs: *mut *mut SharedInvalidationMessage,
    arg_RelcacheInitFileInval: *mut bool,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xactGetCommittedInvalidationMessages(
                arg_msgs: *mut *mut SharedInvalidationMessage,
                arg_RelcacheInitFileInval: *mut bool,
            ) -> ::std::os::raw::c_int;
        }
        xactGetCommittedInvalidationMessages(arg_msgs, arg_RelcacheInitFileInval)
    })
}
pub unsafe fn ProcessCommittedInvalidationMessages(
    arg_msgs: *mut SharedInvalidationMessage,
    arg_nmsgs: ::std::os::raw::c_int,
    arg_RelcacheInitFileInval: bool,
    arg_dbid: Oid,
    arg_tsid: Oid,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcessCommittedInvalidationMessages(
                arg_msgs: *mut SharedInvalidationMessage,
                arg_nmsgs: ::std::os::raw::c_int,
                arg_RelcacheInitFileInval: bool,
                arg_dbid: Oid,
                arg_tsid: Oid,
            );
        }
        ProcessCommittedInvalidationMessages(
            arg_msgs,
            arg_nmsgs,
            arg_RelcacheInitFileInval,
            arg_dbid,
            arg_tsid,
        )
    })
}
pub unsafe fn LocalExecuteInvalidationMessage(arg_msg: *mut SharedInvalidationMessage) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LocalExecuteInvalidationMessage(arg_msg: *mut SharedInvalidationMessage);
        }
        LocalExecuteInvalidationMessage(arg_msg)
    })
}
extern "C" {
    pub static mut PgStartTime: TimestampTz;
}
extern "C" {
    pub static mut PgReloadTime: TimestampTz;
}
pub unsafe fn anytimestamp_typmod_check(arg_istz: bool, arg_typmod: int32) -> int32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn anytimestamp_typmod_check(arg_istz: bool, arg_typmod: int32) -> int32;
        }
        anytimestamp_typmod_check(arg_istz, arg_typmod)
    })
}
pub unsafe fn GetCurrentTimestamp() -> TimestampTz {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetCurrentTimestamp() -> TimestampTz;
        }
        GetCurrentTimestamp()
    })
}
pub unsafe fn GetSQLCurrentTimestamp(arg_typmod: int32) -> TimestampTz {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetSQLCurrentTimestamp(arg_typmod: int32) -> TimestampTz;
        }
        GetSQLCurrentTimestamp(arg_typmod)
    })
}
pub unsafe fn GetSQLLocalTimestamp(arg_typmod: int32) -> Timestamp {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetSQLLocalTimestamp(arg_typmod: int32) -> Timestamp;
        }
        GetSQLLocalTimestamp(arg_typmod)
    })
}
pub unsafe fn TimestampDifference(
    arg_start_time: TimestampTz,
    arg_stop_time: TimestampTz,
    arg_secs: *mut ::std::os::raw::c_long,
    arg_microsecs: *mut ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TimestampDifference(
                arg_start_time: TimestampTz,
                arg_stop_time: TimestampTz,
                arg_secs: *mut ::std::os::raw::c_long,
                arg_microsecs: *mut ::std::os::raw::c_int,
            );
        }
        TimestampDifference(arg_start_time, arg_stop_time, arg_secs, arg_microsecs)
    })
}
pub unsafe fn TimestampDifferenceMilliseconds(
    arg_start_time: TimestampTz,
    arg_stop_time: TimestampTz,
) -> ::std::os::raw::c_long {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TimestampDifferenceMilliseconds(
                arg_start_time: TimestampTz,
                arg_stop_time: TimestampTz,
            ) -> ::std::os::raw::c_long;
        }
        TimestampDifferenceMilliseconds(arg_start_time, arg_stop_time)
    })
}
pub unsafe fn TimestampDifferenceExceeds(
    arg_start_time: TimestampTz,
    arg_stop_time: TimestampTz,
    arg_msec: ::std::os::raw::c_int,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TimestampDifferenceExceeds(
                arg_start_time: TimestampTz,
                arg_stop_time: TimestampTz,
                arg_msec: ::std::os::raw::c_int,
            ) -> bool;
        }
        TimestampDifferenceExceeds(arg_start_time, arg_stop_time, arg_msec)
    })
}
pub unsafe fn time_t_to_timestamptz(arg_tm: pg_time_t) -> TimestampTz {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn time_t_to_timestamptz(arg_tm: pg_time_t) -> TimestampTz;
        }
        time_t_to_timestamptz(arg_tm)
    })
}
pub unsafe fn timestamptz_to_time_t(arg_t: TimestampTz) -> pg_time_t {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptz_to_time_t(arg_t: TimestampTz) -> pg_time_t;
        }
        timestamptz_to_time_t(arg_t)
    })
}
pub unsafe fn timestamptz_to_str(arg_t: TimestampTz) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptz_to_str(arg_t: TimestampTz) -> *const ::std::os::raw::c_char;
        }
        timestamptz_to_str(arg_t)
    })
}
pub unsafe fn tm2timestamp(
    arg_tm: *mut pg_tm,
    arg_fsec: fsec_t,
    arg_tzp: *mut ::std::os::raw::c_int,
    arg_dt: *mut Timestamp,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tm2timestamp(
                arg_tm: *mut pg_tm,
                arg_fsec: fsec_t,
                arg_tzp: *mut ::std::os::raw::c_int,
                arg_dt: *mut Timestamp,
            ) -> ::std::os::raw::c_int;
        }
        tm2timestamp(arg_tm, arg_fsec, arg_tzp, arg_dt)
    })
}
pub unsafe fn timestamp2tm(
    arg_dt: Timestamp,
    arg_tzp: *mut ::std::os::raw::c_int,
    arg_tm: *mut pg_tm,
    arg_fsec: *mut fsec_t,
    arg_tzn: *mut *const ::std::os::raw::c_char,
    arg_attimezone: *mut pg_tz,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp2tm(
                arg_dt: Timestamp,
                arg_tzp: *mut ::std::os::raw::c_int,
                arg_tm: *mut pg_tm,
                arg_fsec: *mut fsec_t,
                arg_tzn: *mut *const ::std::os::raw::c_char,
                arg_attimezone: *mut pg_tz,
            ) -> ::std::os::raw::c_int;
        }
        timestamp2tm(arg_dt, arg_tzp, arg_tm, arg_fsec, arg_tzn, arg_attimezone)
    })
}
pub unsafe fn dt2time(
    arg_dt: Timestamp,
    arg_hour: *mut ::std::os::raw::c_int,
    arg_min: *mut ::std::os::raw::c_int,
    arg_sec: *mut ::std::os::raw::c_int,
    arg_fsec: *mut fsec_t,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dt2time(
                arg_dt: Timestamp,
                arg_hour: *mut ::std::os::raw::c_int,
                arg_min: *mut ::std::os::raw::c_int,
                arg_sec: *mut ::std::os::raw::c_int,
                arg_fsec: *mut fsec_t,
            );
        }
        dt2time(arg_dt, arg_hour, arg_min, arg_sec, arg_fsec)
    })
}
pub unsafe fn interval2tm(
    arg_span: Interval,
    arg_tm: *mut pg_tm,
    arg_fsec: *mut fsec_t,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval2tm(
                arg_span: Interval,
                arg_tm: *mut pg_tm,
                arg_fsec: *mut fsec_t,
            ) -> ::std::os::raw::c_int;
        }
        interval2tm(arg_span, arg_tm, arg_fsec)
    })
}
pub unsafe fn tm2interval(
    arg_tm: *mut pg_tm,
    arg_fsec: fsec_t,
    arg_span: *mut Interval,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tm2interval(
                arg_tm: *mut pg_tm,
                arg_fsec: fsec_t,
                arg_span: *mut Interval,
            ) -> ::std::os::raw::c_int;
        }
        tm2interval(arg_tm, arg_fsec, arg_span)
    })
}
pub unsafe fn SetEpochTimestamp() -> Timestamp {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SetEpochTimestamp() -> Timestamp;
        }
        SetEpochTimestamp()
    })
}
pub unsafe fn GetEpochTime(arg_tm: *mut pg_tm) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetEpochTime(arg_tm: *mut pg_tm);
        }
        GetEpochTime(arg_tm)
    })
}
pub unsafe fn timestamp_cmp_internal(
    arg_dt1: Timestamp,
    arg_dt2: Timestamp,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_cmp_internal(
                arg_dt1: Timestamp,
                arg_dt2: Timestamp,
            ) -> ::std::os::raw::c_int;
        }
        timestamp_cmp_internal(arg_dt1, arg_dt2)
    })
}
pub unsafe fn timestamp2timestamptz_opt_overflow(
    arg_timestamp: Timestamp,
    arg_overflow: *mut ::std::os::raw::c_int,
) -> TimestampTz {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp2timestamptz_opt_overflow(
                arg_timestamp: Timestamp,
                arg_overflow: *mut ::std::os::raw::c_int,
            ) -> TimestampTz;
        }
        timestamp2timestamptz_opt_overflow(arg_timestamp, arg_overflow)
    })
}
pub unsafe fn timestamp_cmp_timestamptz_internal(
    arg_timestampVal: Timestamp,
    arg_dt2: TimestampTz,
) -> int32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_cmp_timestamptz_internal(
                arg_timestampVal: Timestamp,
                arg_dt2: TimestampTz,
            ) -> int32;
        }
        timestamp_cmp_timestamptz_internal(arg_timestampVal, arg_dt2)
    })
}
pub unsafe fn isoweek2j(
    arg_year: ::std::os::raw::c_int,
    arg_week: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn isoweek2j(
                arg_year: ::std::os::raw::c_int,
                arg_week: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        isoweek2j(arg_year, arg_week)
    })
}
pub unsafe fn isoweek2date(
    arg_woy: ::std::os::raw::c_int,
    arg_year: *mut ::std::os::raw::c_int,
    arg_mon: *mut ::std::os::raw::c_int,
    arg_mday: *mut ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn isoweek2date(
                arg_woy: ::std::os::raw::c_int,
                arg_year: *mut ::std::os::raw::c_int,
                arg_mon: *mut ::std::os::raw::c_int,
                arg_mday: *mut ::std::os::raw::c_int,
            );
        }
        isoweek2date(arg_woy, arg_year, arg_mon, arg_mday)
    })
}
pub unsafe fn isoweekdate2date(
    arg_isoweek: ::std::os::raw::c_int,
    arg_wday: ::std::os::raw::c_int,
    arg_year: *mut ::std::os::raw::c_int,
    arg_mon: *mut ::std::os::raw::c_int,
    arg_mday: *mut ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn isoweekdate2date(
                arg_isoweek: ::std::os::raw::c_int,
                arg_wday: ::std::os::raw::c_int,
                arg_year: *mut ::std::os::raw::c_int,
                arg_mon: *mut ::std::os::raw::c_int,
                arg_mday: *mut ::std::os::raw::c_int,
            );
        }
        isoweekdate2date(arg_isoweek, arg_wday, arg_year, arg_mon, arg_mday)
    })
}
pub unsafe fn date2isoweek(
    arg_year: ::std::os::raw::c_int,
    arg_mon: ::std::os::raw::c_int,
    arg_mday: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date2isoweek(
                arg_year: ::std::os::raw::c_int,
                arg_mon: ::std::os::raw::c_int,
                arg_mday: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        date2isoweek(arg_year, arg_mon, arg_mday)
    })
}
pub unsafe fn date2isoyear(
    arg_year: ::std::os::raw::c_int,
    arg_mon: ::std::os::raw::c_int,
    arg_mday: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date2isoyear(
                arg_year: ::std::os::raw::c_int,
                arg_mon: ::std::os::raw::c_int,
                arg_mday: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        date2isoyear(arg_year, arg_mon, arg_mday)
    })
}
pub unsafe fn date2isoyearday(
    arg_year: ::std::os::raw::c_int,
    arg_mon: ::std::os::raw::c_int,
    arg_mday: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date2isoyearday(
                arg_year: ::std::os::raw::c_int,
                arg_mon: ::std::os::raw::c_int,
                arg_mday: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        date2isoyearday(arg_year, arg_mon, arg_mday)
    })
}
pub unsafe fn TimestampTimestampTzRequiresRewrite() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TimestampTimestampTzRequiresRewrite() -> bool;
        }
        TimestampTimestampTzRequiresRewrite()
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tzEntry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct datetkn {
    pub token: [::std::os::raw::c_char; 11usize],
    pub type_: ::std::os::raw::c_char,
    pub value: int32,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct TimeZoneAbbrevTable {
    pub tblsize: Size,
    pub numabbrevs: ::std::os::raw::c_int,
    pub abbrevs: __IncompleteArrayField<datetkn>,
}
#[repr(C)]
#[derive(Debug)]
pub struct DynamicZoneAbbrev {
    pub tz: *mut pg_tz,
    pub zone: __IncompleteArrayField<::std::os::raw::c_char>,
}
impl Default for DynamicZoneAbbrev {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut months: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut days: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut day_tab: [[::std::os::raw::c_int; 13usize]; 2usize];
}
pub unsafe fn GetCurrentDateTime(arg_tm: *mut pg_tm) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetCurrentDateTime(arg_tm: *mut pg_tm);
        }
        GetCurrentDateTime(arg_tm)
    })
}
pub unsafe fn GetCurrentTimeUsec(
    arg_tm: *mut pg_tm,
    arg_fsec: *mut fsec_t,
    arg_tzp: *mut ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetCurrentTimeUsec(
                arg_tm: *mut pg_tm,
                arg_fsec: *mut fsec_t,
                arg_tzp: *mut ::std::os::raw::c_int,
            );
        }
        GetCurrentTimeUsec(arg_tm, arg_fsec, arg_tzp)
    })
}
pub unsafe fn j2date(
    arg_jd: ::std::os::raw::c_int,
    arg_year: *mut ::std::os::raw::c_int,
    arg_month: *mut ::std::os::raw::c_int,
    arg_day: *mut ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn j2date(
                arg_jd: ::std::os::raw::c_int,
                arg_year: *mut ::std::os::raw::c_int,
                arg_month: *mut ::std::os::raw::c_int,
                arg_day: *mut ::std::os::raw::c_int,
            );
        }
        j2date(arg_jd, arg_year, arg_month, arg_day)
    })
}
pub unsafe fn date2j(
    arg_year: ::std::os::raw::c_int,
    arg_month: ::std::os::raw::c_int,
    arg_day: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date2j(
                arg_year: ::std::os::raw::c_int,
                arg_month: ::std::os::raw::c_int,
                arg_day: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        date2j(arg_year, arg_month, arg_day)
    })
}
pub unsafe fn ParseDateTime(
    arg_timestr: *const ::std::os::raw::c_char,
    arg_workbuf: *mut ::std::os::raw::c_char,
    arg_buflen: usize,
    arg_field: *mut *mut ::std::os::raw::c_char,
    arg_ftype: *mut ::std::os::raw::c_int,
    arg_maxfields: ::std::os::raw::c_int,
    arg_numfields: *mut ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ParseDateTime(
                arg_timestr: *const ::std::os::raw::c_char,
                arg_workbuf: *mut ::std::os::raw::c_char,
                arg_buflen: usize,
                arg_field: *mut *mut ::std::os::raw::c_char,
                arg_ftype: *mut ::std::os::raw::c_int,
                arg_maxfields: ::std::os::raw::c_int,
                arg_numfields: *mut ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        ParseDateTime(
            arg_timestr,
            arg_workbuf,
            arg_buflen,
            arg_field,
            arg_ftype,
            arg_maxfields,
            arg_numfields,
        )
    })
}
pub unsafe fn DecodeDateTime(
    arg_field: *mut *mut ::std::os::raw::c_char,
    arg_ftype: *mut ::std::os::raw::c_int,
    arg_nf: ::std::os::raw::c_int,
    arg_dtype: *mut ::std::os::raw::c_int,
    arg_tm: *mut pg_tm,
    arg_fsec: *mut fsec_t,
    arg_tzp: *mut ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DecodeDateTime(
                arg_field: *mut *mut ::std::os::raw::c_char,
                arg_ftype: *mut ::std::os::raw::c_int,
                arg_nf: ::std::os::raw::c_int,
                arg_dtype: *mut ::std::os::raw::c_int,
                arg_tm: *mut pg_tm,
                arg_fsec: *mut fsec_t,
                arg_tzp: *mut ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        DecodeDateTime(arg_field, arg_ftype, arg_nf, arg_dtype, arg_tm, arg_fsec, arg_tzp)
    })
}
pub unsafe fn DecodeTimezone(
    arg_str_: *mut ::std::os::raw::c_char,
    arg_tzp: *mut ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DecodeTimezone(
                arg_str_: *mut ::std::os::raw::c_char,
                arg_tzp: *mut ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        DecodeTimezone(arg_str_, arg_tzp)
    })
}
pub unsafe fn DecodeTimeOnly(
    arg_field: *mut *mut ::std::os::raw::c_char,
    arg_ftype: *mut ::std::os::raw::c_int,
    arg_nf: ::std::os::raw::c_int,
    arg_dtype: *mut ::std::os::raw::c_int,
    arg_tm: *mut pg_tm,
    arg_fsec: *mut fsec_t,
    arg_tzp: *mut ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DecodeTimeOnly(
                arg_field: *mut *mut ::std::os::raw::c_char,
                arg_ftype: *mut ::std::os::raw::c_int,
                arg_nf: ::std::os::raw::c_int,
                arg_dtype: *mut ::std::os::raw::c_int,
                arg_tm: *mut pg_tm,
                arg_fsec: *mut fsec_t,
                arg_tzp: *mut ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        DecodeTimeOnly(arg_field, arg_ftype, arg_nf, arg_dtype, arg_tm, arg_fsec, arg_tzp)
    })
}
pub unsafe fn DecodeInterval(
    arg_field: *mut *mut ::std::os::raw::c_char,
    arg_ftype: *mut ::std::os::raw::c_int,
    arg_nf: ::std::os::raw::c_int,
    arg_range: ::std::os::raw::c_int,
    arg_dtype: *mut ::std::os::raw::c_int,
    arg_tm: *mut pg_tm,
    arg_fsec: *mut fsec_t,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DecodeInterval(
                arg_field: *mut *mut ::std::os::raw::c_char,
                arg_ftype: *mut ::std::os::raw::c_int,
                arg_nf: ::std::os::raw::c_int,
                arg_range: ::std::os::raw::c_int,
                arg_dtype: *mut ::std::os::raw::c_int,
                arg_tm: *mut pg_tm,
                arg_fsec: *mut fsec_t,
            ) -> ::std::os::raw::c_int;
        }
        DecodeInterval(arg_field, arg_ftype, arg_nf, arg_range, arg_dtype, arg_tm, arg_fsec)
    })
}
pub unsafe fn DecodeISO8601Interval(
    arg_str_: *mut ::std::os::raw::c_char,
    arg_dtype: *mut ::std::os::raw::c_int,
    arg_tm: *mut pg_tm,
    arg_fsec: *mut fsec_t,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DecodeISO8601Interval(
                arg_str_: *mut ::std::os::raw::c_char,
                arg_dtype: *mut ::std::os::raw::c_int,
                arg_tm: *mut pg_tm,
                arg_fsec: *mut fsec_t,
            ) -> ::std::os::raw::c_int;
        }
        DecodeISO8601Interval(arg_str_, arg_dtype, arg_tm, arg_fsec)
    })
}
pub unsafe fn DateTimeParseError(
    arg_dterr: ::std::os::raw::c_int,
    arg_str_: *const ::std::os::raw::c_char,
    arg_datatype: *const ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DateTimeParseError(
                arg_dterr: ::std::os::raw::c_int,
                arg_str_: *const ::std::os::raw::c_char,
                arg_datatype: *const ::std::os::raw::c_char,
            );
        }
        DateTimeParseError(arg_dterr, arg_str_, arg_datatype)
    })
}
pub unsafe fn DetermineTimeZoneOffset(
    arg_tm: *mut pg_tm,
    arg_tzp: *mut pg_tz,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DetermineTimeZoneOffset(
                arg_tm: *mut pg_tm,
                arg_tzp: *mut pg_tz,
            ) -> ::std::os::raw::c_int;
        }
        DetermineTimeZoneOffset(arg_tm, arg_tzp)
    })
}
pub unsafe fn DetermineTimeZoneAbbrevOffset(
    arg_tm: *mut pg_tm,
    arg_abbr: *const ::std::os::raw::c_char,
    arg_tzp: *mut pg_tz,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DetermineTimeZoneAbbrevOffset(
                arg_tm: *mut pg_tm,
                arg_abbr: *const ::std::os::raw::c_char,
                arg_tzp: *mut pg_tz,
            ) -> ::std::os::raw::c_int;
        }
        DetermineTimeZoneAbbrevOffset(arg_tm, arg_abbr, arg_tzp)
    })
}
pub unsafe fn DetermineTimeZoneAbbrevOffsetTS(
    arg_ts: TimestampTz,
    arg_abbr: *const ::std::os::raw::c_char,
    arg_tzp: *mut pg_tz,
    arg_isdst: *mut ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DetermineTimeZoneAbbrevOffsetTS(
                arg_ts: TimestampTz,
                arg_abbr: *const ::std::os::raw::c_char,
                arg_tzp: *mut pg_tz,
                arg_isdst: *mut ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        DetermineTimeZoneAbbrevOffsetTS(arg_ts, arg_abbr, arg_tzp, arg_isdst)
    })
}
pub unsafe fn EncodeDateOnly(
    arg_tm: *mut pg_tm,
    arg_style: ::std::os::raw::c_int,
    arg_str_: *mut ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EncodeDateOnly(
                arg_tm: *mut pg_tm,
                arg_style: ::std::os::raw::c_int,
                arg_str_: *mut ::std::os::raw::c_char,
            );
        }
        EncodeDateOnly(arg_tm, arg_style, arg_str_)
    })
}
pub unsafe fn EncodeTimeOnly(
    arg_tm: *mut pg_tm,
    arg_fsec: fsec_t,
    arg_print_tz: bool,
    arg_tz: ::std::os::raw::c_int,
    arg_style: ::std::os::raw::c_int,
    arg_str_: *mut ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EncodeTimeOnly(
                arg_tm: *mut pg_tm,
                arg_fsec: fsec_t,
                arg_print_tz: bool,
                arg_tz: ::std::os::raw::c_int,
                arg_style: ::std::os::raw::c_int,
                arg_str_: *mut ::std::os::raw::c_char,
            );
        }
        EncodeTimeOnly(arg_tm, arg_fsec, arg_print_tz, arg_tz, arg_style, arg_str_)
    })
}
pub unsafe fn EncodeDateTime(
    arg_tm: *mut pg_tm,
    arg_fsec: fsec_t,
    arg_print_tz: bool,
    arg_tz: ::std::os::raw::c_int,
    arg_tzn: *const ::std::os::raw::c_char,
    arg_style: ::std::os::raw::c_int,
    arg_str_: *mut ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EncodeDateTime(
                arg_tm: *mut pg_tm,
                arg_fsec: fsec_t,
                arg_print_tz: bool,
                arg_tz: ::std::os::raw::c_int,
                arg_tzn: *const ::std::os::raw::c_char,
                arg_style: ::std::os::raw::c_int,
                arg_str_: *mut ::std::os::raw::c_char,
            );
        }
        EncodeDateTime(arg_tm, arg_fsec, arg_print_tz, arg_tz, arg_tzn, arg_style, arg_str_)
    })
}
pub unsafe fn EncodeInterval(
    arg_tm: *mut pg_tm,
    arg_fsec: fsec_t,
    arg_style: ::std::os::raw::c_int,
    arg_str_: *mut ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EncodeInterval(
                arg_tm: *mut pg_tm,
                arg_fsec: fsec_t,
                arg_style: ::std::os::raw::c_int,
                arg_str_: *mut ::std::os::raw::c_char,
            );
        }
        EncodeInterval(arg_tm, arg_fsec, arg_style, arg_str_)
    })
}
pub unsafe fn EncodeSpecialTimestamp(arg_dt: Timestamp, arg_str_: *mut ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EncodeSpecialTimestamp(arg_dt: Timestamp, arg_str_: *mut ::std::os::raw::c_char);
        }
        EncodeSpecialTimestamp(arg_dt, arg_str_)
    })
}
pub unsafe fn ValidateDate(
    arg_fmask: ::std::os::raw::c_int,
    arg_isjulian: bool,
    arg_is2digits: bool,
    arg_bc: bool,
    arg_tm: *mut pg_tm,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ValidateDate(
                arg_fmask: ::std::os::raw::c_int,
                arg_isjulian: bool,
                arg_is2digits: bool,
                arg_bc: bool,
                arg_tm: *mut pg_tm,
            ) -> ::std::os::raw::c_int;
        }
        ValidateDate(arg_fmask, arg_isjulian, arg_is2digits, arg_bc, arg_tm)
    })
}
pub unsafe fn DecodeTimezoneAbbrev(
    arg_field: ::std::os::raw::c_int,
    arg_lowtoken: *mut ::std::os::raw::c_char,
    arg_offset: *mut ::std::os::raw::c_int,
    arg_tz: *mut *mut pg_tz,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DecodeTimezoneAbbrev(
                arg_field: ::std::os::raw::c_int,
                arg_lowtoken: *mut ::std::os::raw::c_char,
                arg_offset: *mut ::std::os::raw::c_int,
                arg_tz: *mut *mut pg_tz,
            ) -> ::std::os::raw::c_int;
        }
        DecodeTimezoneAbbrev(arg_field, arg_lowtoken, arg_offset, arg_tz)
    })
}
pub unsafe fn DecodeSpecial(
    arg_field: ::std::os::raw::c_int,
    arg_lowtoken: *mut ::std::os::raw::c_char,
    arg_val: *mut ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DecodeSpecial(
                arg_field: ::std::os::raw::c_int,
                arg_lowtoken: *mut ::std::os::raw::c_char,
                arg_val: *mut ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        DecodeSpecial(arg_field, arg_lowtoken, arg_val)
    })
}
pub unsafe fn DecodeUnits(
    arg_field: ::std::os::raw::c_int,
    arg_lowtoken: *mut ::std::os::raw::c_char,
    arg_val: *mut ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DecodeUnits(
                arg_field: ::std::os::raw::c_int,
                arg_lowtoken: *mut ::std::os::raw::c_char,
                arg_val: *mut ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        DecodeUnits(arg_field, arg_lowtoken, arg_val)
    })
}
pub unsafe fn j2day(arg_jd: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn j2day(arg_jd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        j2day(arg_jd)
    })
}
pub unsafe fn TemporalSimplify(arg_max_precis: int32, arg_node: *mut Node) -> *mut Node {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TemporalSimplify(arg_max_precis: int32, arg_node: *mut Node) -> *mut Node;
        }
        TemporalSimplify(arg_max_precis, arg_node)
    })
}
pub unsafe fn CheckDateTokenTables() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CheckDateTokenTables() -> bool;
        }
        CheckDateTokenTables()
    })
}
pub unsafe fn ConvertTimeZoneAbbrevs(
    arg_abbrevs: *mut tzEntry,
    arg_n: ::std::os::raw::c_int,
) -> *mut TimeZoneAbbrevTable {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ConvertTimeZoneAbbrevs(
                arg_abbrevs: *mut tzEntry,
                arg_n: ::std::os::raw::c_int,
            ) -> *mut TimeZoneAbbrevTable;
        }
        ConvertTimeZoneAbbrevs(arg_abbrevs, arg_n)
    })
}
pub unsafe fn InstallTimeZoneAbbrevs(arg_tbl: *mut TimeZoneAbbrevTable) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InstallTimeZoneAbbrevs(arg_tbl: *mut TimeZoneAbbrevTable);
        }
        InstallTimeZoneAbbrevs(arg_tbl)
    })
}
pub unsafe fn AdjustTimestampForTypmod(arg_time: *mut Timestamp, arg_typmod: int32) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AdjustTimestampForTypmod(arg_time: *mut Timestamp, arg_typmod: int32);
        }
        AdjustTimestampForTypmod(arg_time, arg_typmod)
    })
}
pub unsafe fn AdjustTimestampForTypmodError(
    arg_time: *mut Timestamp,
    arg_typmod: int32,
    arg_error: *mut bool,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AdjustTimestampForTypmodError(
                arg_time: *mut Timestamp,
                arg_typmod: int32,
                arg_error: *mut bool,
            ) -> bool;
        }
        AdjustTimestampForTypmodError(arg_time, arg_typmod, arg_error)
    })
}
extern "C" {
    pub static mut DefaultXactIsoLevel: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut XactIsoLevel: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut DefaultXactReadOnly: bool;
}
extern "C" {
    pub static mut XactReadOnly: bool;
}
extern "C" {
    pub static mut xact_is_sampled: bool;
}
extern "C" {
    pub static mut DefaultXactDeferrable: bool;
}
extern "C" {
    pub static mut XactDeferrable: bool;
}
pub const SyncCommitLevel_SYNCHRONOUS_COMMIT_OFF: SyncCommitLevel = 0;
pub const SyncCommitLevel_SYNCHRONOUS_COMMIT_LOCAL_FLUSH: SyncCommitLevel = 1;
pub const SyncCommitLevel_SYNCHRONOUS_COMMIT_REMOTE_WRITE: SyncCommitLevel = 2;
pub const SyncCommitLevel_SYNCHRONOUS_COMMIT_REMOTE_FLUSH: SyncCommitLevel = 3;
pub const SyncCommitLevel_SYNCHRONOUS_COMMIT_REMOTE_APPLY: SyncCommitLevel = 4;
pub type SyncCommitLevel = ::std::os::raw::c_uint;
extern "C" {
    pub static mut synchronous_commit: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut MyXactFlags: ::std::os::raw::c_int;
}
pub const XactEvent_XACT_EVENT_COMMIT: XactEvent = 0;
pub const XactEvent_XACT_EVENT_PARALLEL_COMMIT: XactEvent = 1;
pub const XactEvent_XACT_EVENT_ABORT: XactEvent = 2;
pub const XactEvent_XACT_EVENT_PARALLEL_ABORT: XactEvent = 3;
pub const XactEvent_XACT_EVENT_PREPARE: XactEvent = 4;
pub const XactEvent_XACT_EVENT_PRE_COMMIT: XactEvent = 5;
pub const XactEvent_XACT_EVENT_PARALLEL_PRE_COMMIT: XactEvent = 6;
pub const XactEvent_XACT_EVENT_PRE_PREPARE: XactEvent = 7;
pub type XactEvent = ::std::os::raw::c_uint;
pub type XactCallback =
    ::std::option::Option<unsafe extern "C" fn(event: XactEvent, arg: *mut ::std::os::raw::c_void)>;
pub const SubXactEvent_SUBXACT_EVENT_START_SUB: SubXactEvent = 0;
pub const SubXactEvent_SUBXACT_EVENT_COMMIT_SUB: SubXactEvent = 1;
pub const SubXactEvent_SUBXACT_EVENT_ABORT_SUB: SubXactEvent = 2;
pub const SubXactEvent_SUBXACT_EVENT_PRE_COMMIT_SUB: SubXactEvent = 3;
pub type SubXactEvent = ::std::os::raw::c_uint;
pub type SubXactCallback = ::std::option::Option<
    unsafe extern "C" fn(
        event: SubXactEvent,
        mySubid: SubTransactionId,
        parentSubid: SubTransactionId,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Default)]
pub struct xl_xact_assignment {
    pub xtop: TransactionId,
    pub nsubxacts: ::std::os::raw::c_int,
    pub xsub: __IncompleteArrayField<TransactionId>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xl_xact_xinfo {
    pub xinfo: uint32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xl_xact_dbinfo {
    pub dbId: Oid,
    pub tsId: Oid,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct xl_xact_subxacts {
    pub nsubxacts: ::std::os::raw::c_int,
    pub subxacts: __IncompleteArrayField<TransactionId>,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct xl_xact_relfilenodes {
    pub nrels: ::std::os::raw::c_int,
    pub xnodes: __IncompleteArrayField<RelFileNode>,
}
#[repr(C)]
pub struct xl_xact_invals {
    pub nmsgs: ::std::os::raw::c_int,
    pub msgs: __IncompleteArrayField<SharedInvalidationMessage>,
}
impl Default for xl_xact_invals {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xl_xact_twophase {
    pub xid: TransactionId,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xl_xact_origin {
    pub origin_lsn: XLogRecPtr,
    pub origin_timestamp: TimestampTz,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xl_xact_commit {
    pub xact_time: TimestampTz,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xl_xact_abort {
    pub xact_time: TimestampTz,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct xl_xact_prepare {
    pub magic: uint32,
    pub total_len: uint32,
    pub xid: TransactionId,
    pub database: Oid,
    pub prepared_at: TimestampTz,
    pub owner: Oid,
    pub nsubxacts: int32,
    pub ncommitrels: int32,
    pub nabortrels: int32,
    pub ninvalmsgs: int32,
    pub initfileinval: bool,
    pub gidlen: uint16,
    pub origin_lsn: XLogRecPtr,
    pub origin_timestamp: TimestampTz,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xl_xact_parsed_commit {
    pub xact_time: TimestampTz,
    pub xinfo: uint32,
    pub dbId: Oid,
    pub tsId: Oid,
    pub nsubxacts: ::std::os::raw::c_int,
    pub subxacts: *mut TransactionId,
    pub nrels: ::std::os::raw::c_int,
    pub xnodes: *mut RelFileNode,
    pub nmsgs: ::std::os::raw::c_int,
    pub msgs: *mut SharedInvalidationMessage,
    pub twophase_xid: TransactionId,
    pub twophase_gid: [::std::os::raw::c_char; 200usize],
    pub nabortrels: ::std::os::raw::c_int,
    pub abortnodes: *mut RelFileNode,
    pub origin_lsn: XLogRecPtr,
    pub origin_timestamp: TimestampTz,
}
impl Default for xl_xact_parsed_commit {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type xl_xact_parsed_prepare = xl_xact_parsed_commit;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xl_xact_parsed_abort {
    pub xact_time: TimestampTz,
    pub xinfo: uint32,
    pub dbId: Oid,
    pub tsId: Oid,
    pub nsubxacts: ::std::os::raw::c_int,
    pub subxacts: *mut TransactionId,
    pub nrels: ::std::os::raw::c_int,
    pub xnodes: *mut RelFileNode,
    pub twophase_xid: TransactionId,
    pub twophase_gid: [::std::os::raw::c_char; 200usize],
    pub origin_lsn: XLogRecPtr,
    pub origin_timestamp: TimestampTz,
}
impl Default for xl_xact_parsed_abort {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn IsTransactionState() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn IsTransactionState() -> bool;
        }
        IsTransactionState()
    })
}
pub unsafe fn IsAbortedTransactionBlockState() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn IsAbortedTransactionBlockState() -> bool;
        }
        IsAbortedTransactionBlockState()
    })
}
pub unsafe fn GetTopTransactionId() -> TransactionId {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetTopTransactionId() -> TransactionId;
        }
        GetTopTransactionId()
    })
}
pub unsafe fn GetTopTransactionIdIfAny() -> TransactionId {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetTopTransactionIdIfAny() -> TransactionId;
        }
        GetTopTransactionIdIfAny()
    })
}
pub unsafe fn GetCurrentTransactionId() -> TransactionId {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetCurrentTransactionId() -> TransactionId;
        }
        GetCurrentTransactionId()
    })
}
pub unsafe fn GetCurrentTransactionIdIfAny() -> TransactionId {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetCurrentTransactionIdIfAny() -> TransactionId;
        }
        GetCurrentTransactionIdIfAny()
    })
}
pub unsafe fn GetStableLatestTransactionId() -> TransactionId {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetStableLatestTransactionId() -> TransactionId;
        }
        GetStableLatestTransactionId()
    })
}
pub unsafe fn GetCurrentSubTransactionId() -> SubTransactionId {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetCurrentSubTransactionId() -> SubTransactionId;
        }
        GetCurrentSubTransactionId()
    })
}
pub unsafe fn GetTopFullTransactionId() -> FullTransactionId {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetTopFullTransactionId() -> FullTransactionId;
        }
        GetTopFullTransactionId()
    })
}
pub unsafe fn GetTopFullTransactionIdIfAny() -> FullTransactionId {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetTopFullTransactionIdIfAny() -> FullTransactionId;
        }
        GetTopFullTransactionIdIfAny()
    })
}
pub unsafe fn GetCurrentFullTransactionId() -> FullTransactionId {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetCurrentFullTransactionId() -> FullTransactionId;
        }
        GetCurrentFullTransactionId()
    })
}
pub unsafe fn GetCurrentFullTransactionIdIfAny() -> FullTransactionId {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetCurrentFullTransactionIdIfAny() -> FullTransactionId;
        }
        GetCurrentFullTransactionIdIfAny()
    })
}
pub unsafe fn MarkCurrentTransactionIdLoggedIfAny() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MarkCurrentTransactionIdLoggedIfAny();
        }
        MarkCurrentTransactionIdLoggedIfAny()
    })
}
pub unsafe fn SubTransactionIsActive(arg_subxid: SubTransactionId) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SubTransactionIsActive(arg_subxid: SubTransactionId) -> bool;
        }
        SubTransactionIsActive(arg_subxid)
    })
}
pub unsafe fn GetCurrentCommandId(arg_used: bool) -> CommandId {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetCurrentCommandId(arg_used: bool) -> CommandId;
        }
        GetCurrentCommandId(arg_used)
    })
}
pub unsafe fn SetParallelStartTimestamps(arg_xact_ts: TimestampTz, arg_stmt_ts: TimestampTz) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SetParallelStartTimestamps(arg_xact_ts: TimestampTz, arg_stmt_ts: TimestampTz);
        }
        SetParallelStartTimestamps(arg_xact_ts, arg_stmt_ts)
    })
}
pub unsafe fn GetCurrentTransactionStartTimestamp() -> TimestampTz {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetCurrentTransactionStartTimestamp() -> TimestampTz;
        }
        GetCurrentTransactionStartTimestamp()
    })
}
pub unsafe fn GetCurrentStatementStartTimestamp() -> TimestampTz {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetCurrentStatementStartTimestamp() -> TimestampTz;
        }
        GetCurrentStatementStartTimestamp()
    })
}
pub unsafe fn GetCurrentTransactionStopTimestamp() -> TimestampTz {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetCurrentTransactionStopTimestamp() -> TimestampTz;
        }
        GetCurrentTransactionStopTimestamp()
    })
}
pub unsafe fn SetCurrentStatementStartTimestamp() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SetCurrentStatementStartTimestamp();
        }
        SetCurrentStatementStartTimestamp()
    })
}
pub unsafe fn GetCurrentTransactionNestLevel() -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetCurrentTransactionNestLevel() -> ::std::os::raw::c_int;
        }
        GetCurrentTransactionNestLevel()
    })
}
pub unsafe fn TransactionIdIsCurrentTransactionId(arg_xid: TransactionId) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TransactionIdIsCurrentTransactionId(arg_xid: TransactionId) -> bool;
        }
        TransactionIdIsCurrentTransactionId(arg_xid)
    })
}
pub unsafe fn CommandCounterIncrement() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CommandCounterIncrement();
        }
        CommandCounterIncrement()
    })
}
pub unsafe fn ForceSyncCommit() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ForceSyncCommit();
        }
        ForceSyncCommit()
    })
}
pub unsafe fn StartTransactionCommand() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn StartTransactionCommand();
        }
        StartTransactionCommand()
    })
}
pub unsafe fn SaveTransactionCharacteristics() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SaveTransactionCharacteristics();
        }
        SaveTransactionCharacteristics()
    })
}
pub unsafe fn RestoreTransactionCharacteristics() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RestoreTransactionCharacteristics();
        }
        RestoreTransactionCharacteristics()
    })
}
pub unsafe fn CommitTransactionCommand() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CommitTransactionCommand();
        }
        CommitTransactionCommand()
    })
}
pub unsafe fn AbortCurrentTransaction() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AbortCurrentTransaction();
        }
        AbortCurrentTransaction()
    })
}
pub unsafe fn BeginTransactionBlock() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BeginTransactionBlock();
        }
        BeginTransactionBlock()
    })
}
pub unsafe fn EndTransactionBlock(arg_chain: bool) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EndTransactionBlock(arg_chain: bool) -> bool;
        }
        EndTransactionBlock(arg_chain)
    })
}
pub unsafe fn PrepareTransactionBlock(arg_gid: *const ::std::os::raw::c_char) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PrepareTransactionBlock(arg_gid: *const ::std::os::raw::c_char) -> bool;
        }
        PrepareTransactionBlock(arg_gid)
    })
}
pub unsafe fn UserAbortTransactionBlock(arg_chain: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn UserAbortTransactionBlock(arg_chain: bool);
        }
        UserAbortTransactionBlock(arg_chain)
    })
}
pub unsafe fn BeginImplicitTransactionBlock() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BeginImplicitTransactionBlock();
        }
        BeginImplicitTransactionBlock()
    })
}
pub unsafe fn EndImplicitTransactionBlock() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EndImplicitTransactionBlock();
        }
        EndImplicitTransactionBlock()
    })
}
pub unsafe fn ReleaseSavepoint(arg_name: *const ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReleaseSavepoint(arg_name: *const ::std::os::raw::c_char);
        }
        ReleaseSavepoint(arg_name)
    })
}
pub unsafe fn DefineSavepoint(arg_name: *const ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DefineSavepoint(arg_name: *const ::std::os::raw::c_char);
        }
        DefineSavepoint(arg_name)
    })
}
pub unsafe fn RollbackToSavepoint(arg_name: *const ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RollbackToSavepoint(arg_name: *const ::std::os::raw::c_char);
        }
        RollbackToSavepoint(arg_name)
    })
}
pub unsafe fn BeginInternalSubTransaction(arg_name: *const ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BeginInternalSubTransaction(arg_name: *const ::std::os::raw::c_char);
        }
        BeginInternalSubTransaction(arg_name)
    })
}
pub unsafe fn ReleaseCurrentSubTransaction() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReleaseCurrentSubTransaction();
        }
        ReleaseCurrentSubTransaction()
    })
}
pub unsafe fn RollbackAndReleaseCurrentSubTransaction() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RollbackAndReleaseCurrentSubTransaction();
        }
        RollbackAndReleaseCurrentSubTransaction()
    })
}
pub unsafe fn IsSubTransaction() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn IsSubTransaction() -> bool;
        }
        IsSubTransaction()
    })
}
pub unsafe fn EstimateTransactionStateSpace() -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EstimateTransactionStateSpace() -> Size;
        }
        EstimateTransactionStateSpace()
    })
}
pub unsafe fn SerializeTransactionState(
    arg_maxsize: Size,
    arg_start_address: *mut ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SerializeTransactionState(
                arg_maxsize: Size,
                arg_start_address: *mut ::std::os::raw::c_char,
            );
        }
        SerializeTransactionState(arg_maxsize, arg_start_address)
    })
}
pub unsafe fn StartParallelWorkerTransaction(arg_tstatespace: *mut ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn StartParallelWorkerTransaction(arg_tstatespace: *mut ::std::os::raw::c_char);
        }
        StartParallelWorkerTransaction(arg_tstatespace)
    })
}
pub unsafe fn EndParallelWorkerTransaction() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EndParallelWorkerTransaction();
        }
        EndParallelWorkerTransaction()
    })
}
pub unsafe fn IsTransactionBlock() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn IsTransactionBlock() -> bool;
        }
        IsTransactionBlock()
    })
}
pub unsafe fn IsTransactionOrTransactionBlock() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn IsTransactionOrTransactionBlock() -> bool;
        }
        IsTransactionOrTransactionBlock()
    })
}
pub unsafe fn TransactionBlockStatusCode() -> ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TransactionBlockStatusCode() -> ::std::os::raw::c_char;
        }
        TransactionBlockStatusCode()
    })
}
pub unsafe fn AbortOutOfAnyTransaction() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AbortOutOfAnyTransaction();
        }
        AbortOutOfAnyTransaction()
    })
}
pub unsafe fn PreventInTransactionBlock(
    arg_isTopLevel: bool,
    arg_stmtType: *const ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PreventInTransactionBlock(
                arg_isTopLevel: bool,
                arg_stmtType: *const ::std::os::raw::c_char,
            );
        }
        PreventInTransactionBlock(arg_isTopLevel, arg_stmtType)
    })
}
pub unsafe fn RequireTransactionBlock(
    arg_isTopLevel: bool,
    arg_stmtType: *const ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RequireTransactionBlock(
                arg_isTopLevel: bool,
                arg_stmtType: *const ::std::os::raw::c_char,
            );
        }
        RequireTransactionBlock(arg_isTopLevel, arg_stmtType)
    })
}
pub unsafe fn WarnNoTransactionBlock(
    arg_isTopLevel: bool,
    arg_stmtType: *const ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn WarnNoTransactionBlock(
                arg_isTopLevel: bool,
                arg_stmtType: *const ::std::os::raw::c_char,
            );
        }
        WarnNoTransactionBlock(arg_isTopLevel, arg_stmtType)
    })
}
pub unsafe fn IsInTransactionBlock(arg_isTopLevel: bool) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn IsInTransactionBlock(arg_isTopLevel: bool) -> bool;
        }
        IsInTransactionBlock(arg_isTopLevel)
    })
}
pub unsafe fn RegisterXactCallback(
    arg_callback: XactCallback,
    arg_arg: *mut ::std::os::raw::c_void,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RegisterXactCallback(
                arg_callback: XactCallback,
                arg_arg: *mut ::std::os::raw::c_void,
            );
        }
        RegisterXactCallback(arg_callback, arg_arg)
    })
}
pub unsafe fn UnregisterXactCallback(
    arg_callback: XactCallback,
    arg_arg: *mut ::std::os::raw::c_void,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn UnregisterXactCallback(
                arg_callback: XactCallback,
                arg_arg: *mut ::std::os::raw::c_void,
            );
        }
        UnregisterXactCallback(arg_callback, arg_arg)
    })
}
pub unsafe fn RegisterSubXactCallback(
    arg_callback: SubXactCallback,
    arg_arg: *mut ::std::os::raw::c_void,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RegisterSubXactCallback(
                arg_callback: SubXactCallback,
                arg_arg: *mut ::std::os::raw::c_void,
            );
        }
        RegisterSubXactCallback(arg_callback, arg_arg)
    })
}
pub unsafe fn UnregisterSubXactCallback(
    arg_callback: SubXactCallback,
    arg_arg: *mut ::std::os::raw::c_void,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn UnregisterSubXactCallback(
                arg_callback: SubXactCallback,
                arg_arg: *mut ::std::os::raw::c_void,
            );
        }
        UnregisterSubXactCallback(arg_callback, arg_arg)
    })
}
pub unsafe fn xactGetCommittedChildren(arg_ptr: *mut *mut TransactionId) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xactGetCommittedChildren(arg_ptr: *mut *mut TransactionId) -> ::std::os::raw::c_int;
        }
        xactGetCommittedChildren(arg_ptr)
    })
}
pub unsafe fn XactLogCommitRecord(
    arg_commit_time: TimestampTz,
    arg_nsubxacts: ::std::os::raw::c_int,
    arg_subxacts: *mut TransactionId,
    arg_nrels: ::std::os::raw::c_int,
    arg_rels: *mut RelFileNode,
    arg_nmsgs: ::std::os::raw::c_int,
    arg_msgs: *mut SharedInvalidationMessage,
    arg_relcacheInval: bool,
    arg_forceSync: bool,
    arg_xactflags: ::std::os::raw::c_int,
    arg_twophase_xid: TransactionId,
    arg_twophase_gid: *const ::std::os::raw::c_char,
) -> XLogRecPtr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XactLogCommitRecord(
                arg_commit_time: TimestampTz,
                arg_nsubxacts: ::std::os::raw::c_int,
                arg_subxacts: *mut TransactionId,
                arg_nrels: ::std::os::raw::c_int,
                arg_rels: *mut RelFileNode,
                arg_nmsgs: ::std::os::raw::c_int,
                arg_msgs: *mut SharedInvalidationMessage,
                arg_relcacheInval: bool,
                arg_forceSync: bool,
                arg_xactflags: ::std::os::raw::c_int,
                arg_twophase_xid: TransactionId,
                arg_twophase_gid: *const ::std::os::raw::c_char,
            ) -> XLogRecPtr;
        }
        XactLogCommitRecord(
            arg_commit_time,
            arg_nsubxacts,
            arg_subxacts,
            arg_nrels,
            arg_rels,
            arg_nmsgs,
            arg_msgs,
            arg_relcacheInval,
            arg_forceSync,
            arg_xactflags,
            arg_twophase_xid,
            arg_twophase_gid,
        )
    })
}
pub unsafe fn XactLogAbortRecord(
    arg_abort_time: TimestampTz,
    arg_nsubxacts: ::std::os::raw::c_int,
    arg_subxacts: *mut TransactionId,
    arg_nrels: ::std::os::raw::c_int,
    arg_rels: *mut RelFileNode,
    arg_xactflags: ::std::os::raw::c_int,
    arg_twophase_xid: TransactionId,
    arg_twophase_gid: *const ::std::os::raw::c_char,
) -> XLogRecPtr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XactLogAbortRecord(
                arg_abort_time: TimestampTz,
                arg_nsubxacts: ::std::os::raw::c_int,
                arg_subxacts: *mut TransactionId,
                arg_nrels: ::std::os::raw::c_int,
                arg_rels: *mut RelFileNode,
                arg_xactflags: ::std::os::raw::c_int,
                arg_twophase_xid: TransactionId,
                arg_twophase_gid: *const ::std::os::raw::c_char,
            ) -> XLogRecPtr;
        }
        XactLogAbortRecord(
            arg_abort_time,
            arg_nsubxacts,
            arg_subxacts,
            arg_nrels,
            arg_rels,
            arg_xactflags,
            arg_twophase_xid,
            arg_twophase_gid,
        )
    })
}
pub unsafe fn xact_redo(arg_record: *mut XLogReaderState) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xact_redo(arg_record: *mut XLogReaderState);
        }
        xact_redo(arg_record)
    })
}
pub unsafe fn xact_desc(arg_buf: StringInfo, arg_record: *mut XLogReaderState) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xact_desc(arg_buf: StringInfo, arg_record: *mut XLogReaderState);
        }
        xact_desc(arg_buf, arg_record)
    })
}
pub unsafe fn xact_identify(arg_info: uint8) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xact_identify(arg_info: uint8) -> *const ::std::os::raw::c_char;
        }
        xact_identify(arg_info)
    })
}
pub unsafe fn ParseCommitRecord(
    arg_info: uint8,
    arg_xlrec: *mut xl_xact_commit,
    arg_parsed: *mut xl_xact_parsed_commit,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ParseCommitRecord(
                arg_info: uint8,
                arg_xlrec: *mut xl_xact_commit,
                arg_parsed: *mut xl_xact_parsed_commit,
            );
        }
        ParseCommitRecord(arg_info, arg_xlrec, arg_parsed)
    })
}
pub unsafe fn ParseAbortRecord(
    arg_info: uint8,
    arg_xlrec: *mut xl_xact_abort,
    arg_parsed: *mut xl_xact_parsed_abort,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ParseAbortRecord(
                arg_info: uint8,
                arg_xlrec: *mut xl_xact_abort,
                arg_parsed: *mut xl_xact_parsed_abort,
            );
        }
        ParseAbortRecord(arg_info, arg_xlrec, arg_parsed)
    })
}
pub unsafe fn ParsePrepareRecord(
    arg_info: uint8,
    arg_xlrec: *mut xl_xact_prepare,
    arg_parsed: *mut xl_xact_parsed_prepare,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ParsePrepareRecord(
                arg_info: uint8,
                arg_xlrec: *mut xl_xact_prepare,
                arg_parsed: *mut xl_xact_parsed_prepare,
            );
        }
        ParsePrepareRecord(arg_info, arg_xlrec, arg_parsed)
    })
}
pub unsafe fn EnterParallelMode() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EnterParallelMode();
        }
        EnterParallelMode()
    })
}
pub unsafe fn ExitParallelMode() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExitParallelMode();
        }
        ExitParallelMode()
    })
}
pub unsafe fn IsInParallelMode() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn IsInParallelMode() -> bool;
        }
        IsInParallelMode()
    })
}
pub const DependencyType_DEPENDENCY_NORMAL: DependencyType = 110;
pub const DependencyType_DEPENDENCY_AUTO: DependencyType = 97;
pub const DependencyType_DEPENDENCY_INTERNAL: DependencyType = 105;
pub const DependencyType_DEPENDENCY_PARTITION_PRI: DependencyType = 80;
pub const DependencyType_DEPENDENCY_PARTITION_SEC: DependencyType = 83;
pub const DependencyType_DEPENDENCY_EXTENSION: DependencyType = 101;
pub const DependencyType_DEPENDENCY_AUTO_EXTENSION: DependencyType = 120;
pub const DependencyType_DEPENDENCY_PIN: DependencyType = 112;
pub type DependencyType = ::std::os::raw::c_uint;
pub const SharedDependencyType_SHARED_DEPENDENCY_PIN: SharedDependencyType = 112;
pub const SharedDependencyType_SHARED_DEPENDENCY_OWNER: SharedDependencyType = 111;
pub const SharedDependencyType_SHARED_DEPENDENCY_ACL: SharedDependencyType = 97;
pub const SharedDependencyType_SHARED_DEPENDENCY_POLICY: SharedDependencyType = 114;
pub const SharedDependencyType_SHARED_DEPENDENCY_TABLESPACE: SharedDependencyType = 116;
pub const SharedDependencyType_SHARED_DEPENDENCY_INVALID: SharedDependencyType = 0;
pub type SharedDependencyType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjectAddresses {
    _unused: [u8; 0],
}
pub const ObjectClass_OCLASS_CLASS: ObjectClass = 0;
pub const ObjectClass_OCLASS_PROC: ObjectClass = 1;
pub const ObjectClass_OCLASS_TYPE: ObjectClass = 2;
pub const ObjectClass_OCLASS_CAST: ObjectClass = 3;
pub const ObjectClass_OCLASS_COLLATION: ObjectClass = 4;
pub const ObjectClass_OCLASS_CONSTRAINT: ObjectClass = 5;
pub const ObjectClass_OCLASS_CONVERSION: ObjectClass = 6;
pub const ObjectClass_OCLASS_DEFAULT: ObjectClass = 7;
pub const ObjectClass_OCLASS_LANGUAGE: ObjectClass = 8;
pub const ObjectClass_OCLASS_LARGEOBJECT: ObjectClass = 9;
pub const ObjectClass_OCLASS_OPERATOR: ObjectClass = 10;
pub const ObjectClass_OCLASS_OPCLASS: ObjectClass = 11;
pub const ObjectClass_OCLASS_OPFAMILY: ObjectClass = 12;
pub const ObjectClass_OCLASS_AM: ObjectClass = 13;
pub const ObjectClass_OCLASS_AMOP: ObjectClass = 14;
pub const ObjectClass_OCLASS_AMPROC: ObjectClass = 15;
pub const ObjectClass_OCLASS_REWRITE: ObjectClass = 16;
pub const ObjectClass_OCLASS_TRIGGER: ObjectClass = 17;
pub const ObjectClass_OCLASS_SCHEMA: ObjectClass = 18;
pub const ObjectClass_OCLASS_STATISTIC_EXT: ObjectClass = 19;
pub const ObjectClass_OCLASS_TSPARSER: ObjectClass = 20;
pub const ObjectClass_OCLASS_TSDICT: ObjectClass = 21;
pub const ObjectClass_OCLASS_TSTEMPLATE: ObjectClass = 22;
pub const ObjectClass_OCLASS_TSCONFIG: ObjectClass = 23;
pub const ObjectClass_OCLASS_ROLE: ObjectClass = 24;
pub const ObjectClass_OCLASS_DATABASE: ObjectClass = 25;
pub const ObjectClass_OCLASS_TBLSPACE: ObjectClass = 26;
pub const ObjectClass_OCLASS_FDW: ObjectClass = 27;
pub const ObjectClass_OCLASS_FOREIGN_SERVER: ObjectClass = 28;
pub const ObjectClass_OCLASS_USER_MAPPING: ObjectClass = 29;
pub const ObjectClass_OCLASS_DEFACL: ObjectClass = 30;
pub const ObjectClass_OCLASS_EXTENSION: ObjectClass = 31;
pub const ObjectClass_OCLASS_EVENT_TRIGGER: ObjectClass = 32;
pub const ObjectClass_OCLASS_POLICY: ObjectClass = 33;
pub const ObjectClass_OCLASS_PUBLICATION: ObjectClass = 34;
pub const ObjectClass_OCLASS_PUBLICATION_REL: ObjectClass = 35;
pub const ObjectClass_OCLASS_SUBSCRIPTION: ObjectClass = 36;
pub const ObjectClass_OCLASS_TRANSFORM: ObjectClass = 37;
pub type ObjectClass = ::std::os::raw::c_uint;
pub unsafe fn AcquireDeletionLock(
    arg_object: *const ObjectAddress,
    arg_flags: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AcquireDeletionLock(
                arg_object: *const ObjectAddress,
                arg_flags: ::std::os::raw::c_int,
            );
        }
        AcquireDeletionLock(arg_object, arg_flags)
    })
}
pub unsafe fn ReleaseDeletionLock(arg_object: *const ObjectAddress) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReleaseDeletionLock(arg_object: *const ObjectAddress);
        }
        ReleaseDeletionLock(arg_object)
    })
}
pub unsafe fn performDeletion(
    arg_object: *const ObjectAddress,
    arg_behavior: DropBehavior,
    arg_flags: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn performDeletion(
                arg_object: *const ObjectAddress,
                arg_behavior: DropBehavior,
                arg_flags: ::std::os::raw::c_int,
            );
        }
        performDeletion(arg_object, arg_behavior, arg_flags)
    })
}
pub unsafe fn performMultipleDeletions(
    arg_objects: *const ObjectAddresses,
    arg_behavior: DropBehavior,
    arg_flags: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn performMultipleDeletions(
                arg_objects: *const ObjectAddresses,
                arg_behavior: DropBehavior,
                arg_flags: ::std::os::raw::c_int,
            );
        }
        performMultipleDeletions(arg_objects, arg_behavior, arg_flags)
    })
}
pub unsafe fn recordDependencyOnExpr(
    arg_depender: *const ObjectAddress,
    arg_expr: *mut Node,
    arg_rtable: *mut List,
    arg_behavior: DependencyType,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn recordDependencyOnExpr(
                arg_depender: *const ObjectAddress,
                arg_expr: *mut Node,
                arg_rtable: *mut List,
                arg_behavior: DependencyType,
            );
        }
        recordDependencyOnExpr(arg_depender, arg_expr, arg_rtable, arg_behavior)
    })
}
pub unsafe fn recordDependencyOnSingleRelExpr(
    arg_depender: *const ObjectAddress,
    arg_expr: *mut Node,
    arg_relId: Oid,
    arg_behavior: DependencyType,
    arg_self_behavior: DependencyType,
    arg_reverse_self: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn recordDependencyOnSingleRelExpr(
                arg_depender: *const ObjectAddress,
                arg_expr: *mut Node,
                arg_relId: Oid,
                arg_behavior: DependencyType,
                arg_self_behavior: DependencyType,
                arg_reverse_self: bool,
            );
        }
        recordDependencyOnSingleRelExpr(
            arg_depender,
            arg_expr,
            arg_relId,
            arg_behavior,
            arg_self_behavior,
            arg_reverse_self,
        )
    })
}
pub unsafe fn getObjectClass(arg_object: *const ObjectAddress) -> ObjectClass {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getObjectClass(arg_object: *const ObjectAddress) -> ObjectClass;
        }
        getObjectClass(arg_object)
    })
}
pub unsafe fn new_object_addresses() -> *mut ObjectAddresses {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn new_object_addresses() -> *mut ObjectAddresses;
        }
        new_object_addresses()
    })
}
pub unsafe fn add_exact_object_address(
    arg_object: *const ObjectAddress,
    arg_addrs: *mut ObjectAddresses,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn add_exact_object_address(
                arg_object: *const ObjectAddress,
                arg_addrs: *mut ObjectAddresses,
            );
        }
        add_exact_object_address(arg_object, arg_addrs)
    })
}
pub unsafe fn object_address_present(
    arg_object: *const ObjectAddress,
    arg_addrs: *const ObjectAddresses,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn object_address_present(
                arg_object: *const ObjectAddress,
                arg_addrs: *const ObjectAddresses,
            ) -> bool;
        }
        object_address_present(arg_object, arg_addrs)
    })
}
pub unsafe fn record_object_address_dependencies(
    arg_depender: *const ObjectAddress,
    arg_referenced: *mut ObjectAddresses,
    arg_behavior: DependencyType,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn record_object_address_dependencies(
                arg_depender: *const ObjectAddress,
                arg_referenced: *mut ObjectAddresses,
                arg_behavior: DependencyType,
            );
        }
        record_object_address_dependencies(arg_depender, arg_referenced, arg_behavior)
    })
}
pub unsafe fn sort_object_addresses(arg_addrs: *mut ObjectAddresses) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sort_object_addresses(arg_addrs: *mut ObjectAddresses);
        }
        sort_object_addresses(arg_addrs)
    })
}
pub unsafe fn free_object_addresses(arg_addrs: *mut ObjectAddresses) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn free_object_addresses(arg_addrs: *mut ObjectAddresses);
        }
        free_object_addresses(arg_addrs)
    })
}
pub unsafe fn recordDependencyOn(
    arg_depender: *const ObjectAddress,
    arg_referenced: *const ObjectAddress,
    arg_behavior: DependencyType,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn recordDependencyOn(
                arg_depender: *const ObjectAddress,
                arg_referenced: *const ObjectAddress,
                arg_behavior: DependencyType,
            );
        }
        recordDependencyOn(arg_depender, arg_referenced, arg_behavior)
    })
}
pub unsafe fn recordMultipleDependencies(
    arg_depender: *const ObjectAddress,
    arg_referenced: *const ObjectAddress,
    arg_nreferenced: ::std::os::raw::c_int,
    arg_behavior: DependencyType,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn recordMultipleDependencies(
                arg_depender: *const ObjectAddress,
                arg_referenced: *const ObjectAddress,
                arg_nreferenced: ::std::os::raw::c_int,
                arg_behavior: DependencyType,
            );
        }
        recordMultipleDependencies(arg_depender, arg_referenced, arg_nreferenced, arg_behavior)
    })
}
pub unsafe fn recordDependencyOnCurrentExtension(
    arg_object: *const ObjectAddress,
    arg_isReplace: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn recordDependencyOnCurrentExtension(
                arg_object: *const ObjectAddress,
                arg_isReplace: bool,
            );
        }
        recordDependencyOnCurrentExtension(arg_object, arg_isReplace)
    })
}
pub unsafe fn deleteDependencyRecordsFor(
    arg_classId: Oid,
    arg_objectId: Oid,
    arg_skipExtensionDeps: bool,
) -> ::std::os::raw::c_long {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn deleteDependencyRecordsFor(
                arg_classId: Oid,
                arg_objectId: Oid,
                arg_skipExtensionDeps: bool,
            ) -> ::std::os::raw::c_long;
        }
        deleteDependencyRecordsFor(arg_classId, arg_objectId, arg_skipExtensionDeps)
    })
}
pub unsafe fn deleteDependencyRecordsForClass(
    arg_classId: Oid,
    arg_objectId: Oid,
    arg_refclassId: Oid,
    arg_deptype: ::std::os::raw::c_char,
) -> ::std::os::raw::c_long {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn deleteDependencyRecordsForClass(
                arg_classId: Oid,
                arg_objectId: Oid,
                arg_refclassId: Oid,
                arg_deptype: ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_long;
        }
        deleteDependencyRecordsForClass(arg_classId, arg_objectId, arg_refclassId, arg_deptype)
    })
}
pub unsafe fn deleteDependencyRecordsForSpecific(
    arg_classId: Oid,
    arg_objectId: Oid,
    arg_deptype: ::std::os::raw::c_char,
    arg_refclassId: Oid,
    arg_refobjectId: Oid,
) -> ::std::os::raw::c_long {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn deleteDependencyRecordsForSpecific(
                arg_classId: Oid,
                arg_objectId: Oid,
                arg_deptype: ::std::os::raw::c_char,
                arg_refclassId: Oid,
                arg_refobjectId: Oid,
            ) -> ::std::os::raw::c_long;
        }
        deleteDependencyRecordsForSpecific(
            arg_classId,
            arg_objectId,
            arg_deptype,
            arg_refclassId,
            arg_refobjectId,
        )
    })
}
pub unsafe fn changeDependencyFor(
    arg_classId: Oid,
    arg_objectId: Oid,
    arg_refClassId: Oid,
    arg_oldRefObjectId: Oid,
    arg_newRefObjectId: Oid,
) -> ::std::os::raw::c_long {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn changeDependencyFor(
                arg_classId: Oid,
                arg_objectId: Oid,
                arg_refClassId: Oid,
                arg_oldRefObjectId: Oid,
                arg_newRefObjectId: Oid,
            ) -> ::std::os::raw::c_long;
        }
        changeDependencyFor(
            arg_classId,
            arg_objectId,
            arg_refClassId,
            arg_oldRefObjectId,
            arg_newRefObjectId,
        )
    })
}
pub unsafe fn changeDependenciesOf(
    arg_classId: Oid,
    arg_oldObjectId: Oid,
    arg_newObjectId: Oid,
) -> ::std::os::raw::c_long {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn changeDependenciesOf(
                arg_classId: Oid,
                arg_oldObjectId: Oid,
                arg_newObjectId: Oid,
            ) -> ::std::os::raw::c_long;
        }
        changeDependenciesOf(arg_classId, arg_oldObjectId, arg_newObjectId)
    })
}
pub unsafe fn changeDependenciesOn(
    arg_refClassId: Oid,
    arg_oldRefObjectId: Oid,
    arg_newRefObjectId: Oid,
) -> ::std::os::raw::c_long {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn changeDependenciesOn(
                arg_refClassId: Oid,
                arg_oldRefObjectId: Oid,
                arg_newRefObjectId: Oid,
            ) -> ::std::os::raw::c_long;
        }
        changeDependenciesOn(arg_refClassId, arg_oldRefObjectId, arg_newRefObjectId)
    })
}
pub unsafe fn getExtensionOfObject(arg_classId: Oid, arg_objectId: Oid) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getExtensionOfObject(arg_classId: Oid, arg_objectId: Oid) -> Oid;
        }
        getExtensionOfObject(arg_classId, arg_objectId)
    })
}
pub unsafe fn getAutoExtensionsOfObject(arg_classId: Oid, arg_objectId: Oid) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getAutoExtensionsOfObject(arg_classId: Oid, arg_objectId: Oid) -> *mut List;
        }
        getAutoExtensionsOfObject(arg_classId, arg_objectId)
    })
}
pub unsafe fn sequenceIsOwned(
    arg_seqId: Oid,
    arg_deptype: ::std::os::raw::c_char,
    arg_tableId: *mut Oid,
    arg_colId: *mut int32,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sequenceIsOwned(
                arg_seqId: Oid,
                arg_deptype: ::std::os::raw::c_char,
                arg_tableId: *mut Oid,
                arg_colId: *mut int32,
            ) -> bool;
        }
        sequenceIsOwned(arg_seqId, arg_deptype, arg_tableId, arg_colId)
    })
}
pub unsafe fn getOwnedSequences(arg_relid: Oid) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getOwnedSequences(arg_relid: Oid) -> *mut List;
        }
        getOwnedSequences(arg_relid)
    })
}
pub unsafe fn getIdentitySequence(
    arg_relid: Oid,
    arg_attnum: AttrNumber,
    arg_missing_ok: bool,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getIdentitySequence(
                arg_relid: Oid,
                arg_attnum: AttrNumber,
                arg_missing_ok: bool,
            ) -> Oid;
        }
        getIdentitySequence(arg_relid, arg_attnum, arg_missing_ok)
    })
}
pub unsafe fn get_constraint_index(arg_constraintId: Oid) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_constraint_index(arg_constraintId: Oid) -> Oid;
        }
        get_constraint_index(arg_constraintId)
    })
}
pub unsafe fn get_index_constraint(arg_indexId: Oid) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_index_constraint(arg_indexId: Oid) -> Oid;
        }
        get_index_constraint(arg_indexId)
    })
}
pub unsafe fn get_index_ref_constraints(arg_indexId: Oid) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_index_ref_constraints(arg_indexId: Oid) -> *mut List;
        }
        get_index_ref_constraints(arg_indexId)
    })
}
pub unsafe fn recordSharedDependencyOn(
    arg_depender: *mut ObjectAddress,
    arg_referenced: *mut ObjectAddress,
    arg_deptype: SharedDependencyType,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn recordSharedDependencyOn(
                arg_depender: *mut ObjectAddress,
                arg_referenced: *mut ObjectAddress,
                arg_deptype: SharedDependencyType,
            );
        }
        recordSharedDependencyOn(arg_depender, arg_referenced, arg_deptype)
    })
}
pub unsafe fn deleteSharedDependencyRecordsFor(
    arg_classId: Oid,
    arg_objectId: Oid,
    arg_objectSubId: int32,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn deleteSharedDependencyRecordsFor(
                arg_classId: Oid,
                arg_objectId: Oid,
                arg_objectSubId: int32,
            );
        }
        deleteSharedDependencyRecordsFor(arg_classId, arg_objectId, arg_objectSubId)
    })
}
pub unsafe fn recordDependencyOnOwner(arg_classId: Oid, arg_objectId: Oid, arg_owner: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn recordDependencyOnOwner(arg_classId: Oid, arg_objectId: Oid, arg_owner: Oid);
        }
        recordDependencyOnOwner(arg_classId, arg_objectId, arg_owner)
    })
}
pub unsafe fn changeDependencyOnOwner(arg_classId: Oid, arg_objectId: Oid, arg_newOwnerId: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn changeDependencyOnOwner(arg_classId: Oid, arg_objectId: Oid, arg_newOwnerId: Oid);
        }
        changeDependencyOnOwner(arg_classId, arg_objectId, arg_newOwnerId)
    })
}
pub unsafe fn recordDependencyOnTablespace(
    arg_classId: Oid,
    arg_objectId: Oid,
    arg_tablespace: Oid,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn recordDependencyOnTablespace(
                arg_classId: Oid,
                arg_objectId: Oid,
                arg_tablespace: Oid,
            );
        }
        recordDependencyOnTablespace(arg_classId, arg_objectId, arg_tablespace)
    })
}
pub unsafe fn changeDependencyOnTablespace(
    arg_classId: Oid,
    arg_objectId: Oid,
    arg_newTablespaceId: Oid,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn changeDependencyOnTablespace(
                arg_classId: Oid,
                arg_objectId: Oid,
                arg_newTablespaceId: Oid,
            );
        }
        changeDependencyOnTablespace(arg_classId, arg_objectId, arg_newTablespaceId)
    })
}
pub unsafe fn updateAclDependencies(
    arg_classId: Oid,
    arg_objectId: Oid,
    arg_objectSubId: int32,
    arg_ownerId: Oid,
    arg_noldmembers: ::std::os::raw::c_int,
    arg_oldmembers: *mut Oid,
    arg_nnewmembers: ::std::os::raw::c_int,
    arg_newmembers: *mut Oid,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn updateAclDependencies(
                arg_classId: Oid,
                arg_objectId: Oid,
                arg_objectSubId: int32,
                arg_ownerId: Oid,
                arg_noldmembers: ::std::os::raw::c_int,
                arg_oldmembers: *mut Oid,
                arg_nnewmembers: ::std::os::raw::c_int,
                arg_newmembers: *mut Oid,
            );
        }
        updateAclDependencies(
            arg_classId,
            arg_objectId,
            arg_objectSubId,
            arg_ownerId,
            arg_noldmembers,
            arg_oldmembers,
            arg_nnewmembers,
            arg_newmembers,
        )
    })
}
pub unsafe fn checkSharedDependencies(
    arg_classId: Oid,
    arg_objectId: Oid,
    arg_detail_msg: *mut *mut ::std::os::raw::c_char,
    arg_detail_log_msg: *mut *mut ::std::os::raw::c_char,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn checkSharedDependencies(
                arg_classId: Oid,
                arg_objectId: Oid,
                arg_detail_msg: *mut *mut ::std::os::raw::c_char,
                arg_detail_log_msg: *mut *mut ::std::os::raw::c_char,
            ) -> bool;
        }
        checkSharedDependencies(arg_classId, arg_objectId, arg_detail_msg, arg_detail_log_msg)
    })
}
pub unsafe fn shdepLockAndCheckObject(arg_classId: Oid, arg_objectId: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn shdepLockAndCheckObject(arg_classId: Oid, arg_objectId: Oid);
        }
        shdepLockAndCheckObject(arg_classId, arg_objectId)
    })
}
pub unsafe fn copyTemplateDependencies(arg_templateDbId: Oid, arg_newDbId: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn copyTemplateDependencies(arg_templateDbId: Oid, arg_newDbId: Oid);
        }
        copyTemplateDependencies(arg_templateDbId, arg_newDbId)
    })
}
pub unsafe fn dropDatabaseDependencies(arg_databaseId: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dropDatabaseDependencies(arg_databaseId: Oid);
        }
        dropDatabaseDependencies(arg_databaseId)
    })
}
pub unsafe fn shdepDropOwned(arg_relids: *mut List, arg_behavior: DropBehavior) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn shdepDropOwned(arg_relids: *mut List, arg_behavior: DropBehavior);
        }
        shdepDropOwned(arg_relids, arg_behavior)
    })
}
pub unsafe fn shdepReassignOwned(arg_relids: *mut List, arg_newrole: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn shdepReassignOwned(arg_relids: *mut List, arg_newrole: Oid);
        }
        shdepReassignOwned(arg_relids, arg_newrole)
    })
}
pub const IndexStateFlagsAction_INDEX_CREATE_SET_READY: IndexStateFlagsAction = 0;
pub const IndexStateFlagsAction_INDEX_CREATE_SET_VALID: IndexStateFlagsAction = 1;
pub const IndexStateFlagsAction_INDEX_DROP_CLEAR_VALID: IndexStateFlagsAction = 2;
pub const IndexStateFlagsAction_INDEX_DROP_SET_DEAD: IndexStateFlagsAction = 3;
pub type IndexStateFlagsAction = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ValidateIndexState {
    pub tuplesort: *mut Tuplesortstate,
    pub htups: f64,
    pub itups: f64,
    pub tups_inserted: f64,
}
impl Default for ValidateIndexState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn index_check_primary_key(
    arg_heapRel: Relation,
    arg_indexInfo: *mut IndexInfo,
    arg_is_alter_table: bool,
    arg_stmt: *mut IndexStmt,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_check_primary_key(
                arg_heapRel: Relation,
                arg_indexInfo: *mut IndexInfo,
                arg_is_alter_table: bool,
                arg_stmt: *mut IndexStmt,
            );
        }
        index_check_primary_key(arg_heapRel, arg_indexInfo, arg_is_alter_table, arg_stmt)
    })
}
pub unsafe fn index_create(
    arg_heapRelation: Relation,
    arg_indexRelationName: *const ::std::os::raw::c_char,
    arg_indexRelationId: Oid,
    arg_parentIndexRelid: Oid,
    arg_parentConstraintId: Oid,
    arg_relFileNode: Oid,
    arg_indexInfo: *mut IndexInfo,
    arg_indexColNames: *mut List,
    arg_accessMethodObjectId: Oid,
    arg_tableSpaceId: Oid,
    arg_collationObjectId: *mut Oid,
    arg_classObjectId: *mut Oid,
    arg_coloptions: *mut int16,
    arg_reloptions: Datum,
    arg_flags: bits16,
    arg_constr_flags: bits16,
    arg_allow_system_table_mods: bool,
    arg_is_internal: bool,
    arg_constraintId: *mut Oid,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_create(
                arg_heapRelation: Relation,
                arg_indexRelationName: *const ::std::os::raw::c_char,
                arg_indexRelationId: Oid,
                arg_parentIndexRelid: Oid,
                arg_parentConstraintId: Oid,
                arg_relFileNode: Oid,
                arg_indexInfo: *mut IndexInfo,
                arg_indexColNames: *mut List,
                arg_accessMethodObjectId: Oid,
                arg_tableSpaceId: Oid,
                arg_collationObjectId: *mut Oid,
                arg_classObjectId: *mut Oid,
                arg_coloptions: *mut int16,
                arg_reloptions: Datum,
                arg_flags: bits16,
                arg_constr_flags: bits16,
                arg_allow_system_table_mods: bool,
                arg_is_internal: bool,
                arg_constraintId: *mut Oid,
            ) -> Oid;
        }
        index_create(
            arg_heapRelation,
            arg_indexRelationName,
            arg_indexRelationId,
            arg_parentIndexRelid,
            arg_parentConstraintId,
            arg_relFileNode,
            arg_indexInfo,
            arg_indexColNames,
            arg_accessMethodObjectId,
            arg_tableSpaceId,
            arg_collationObjectId,
            arg_classObjectId,
            arg_coloptions,
            arg_reloptions,
            arg_flags,
            arg_constr_flags,
            arg_allow_system_table_mods,
            arg_is_internal,
            arg_constraintId,
        )
    })
}
pub unsafe fn index_concurrently_create_copy(
    arg_heapRelation: Relation,
    arg_oldIndexId: Oid,
    arg_newName: *const ::std::os::raw::c_char,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_concurrently_create_copy(
                arg_heapRelation: Relation,
                arg_oldIndexId: Oid,
                arg_newName: *const ::std::os::raw::c_char,
            ) -> Oid;
        }
        index_concurrently_create_copy(arg_heapRelation, arg_oldIndexId, arg_newName)
    })
}
pub unsafe fn index_concurrently_build(arg_heapRelationId: Oid, arg_indexRelationId: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_concurrently_build(arg_heapRelationId: Oid, arg_indexRelationId: Oid);
        }
        index_concurrently_build(arg_heapRelationId, arg_indexRelationId)
    })
}
pub unsafe fn index_concurrently_swap(
    arg_newIndexId: Oid,
    arg_oldIndexId: Oid,
    arg_oldName: *const ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_concurrently_swap(
                arg_newIndexId: Oid,
                arg_oldIndexId: Oid,
                arg_oldName: *const ::std::os::raw::c_char,
            );
        }
        index_concurrently_swap(arg_newIndexId, arg_oldIndexId, arg_oldName)
    })
}
pub unsafe fn index_concurrently_set_dead(arg_heapId: Oid, arg_indexId: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_concurrently_set_dead(arg_heapId: Oid, arg_indexId: Oid);
        }
        index_concurrently_set_dead(arg_heapId, arg_indexId)
    })
}
pub unsafe fn index_constraint_create(
    arg_heapRelation: Relation,
    arg_indexRelationId: Oid,
    arg_parentConstraintId: Oid,
    arg_indexInfo: *mut IndexInfo,
    arg_constraintName: *const ::std::os::raw::c_char,
    arg_constraintType: ::std::os::raw::c_char,
    arg_constr_flags: bits16,
    arg_allow_system_table_mods: bool,
    arg_is_internal: bool,
) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_constraint_create(
                arg_heapRelation: Relation,
                arg_indexRelationId: Oid,
                arg_parentConstraintId: Oid,
                arg_indexInfo: *mut IndexInfo,
                arg_constraintName: *const ::std::os::raw::c_char,
                arg_constraintType: ::std::os::raw::c_char,
                arg_constr_flags: bits16,
                arg_allow_system_table_mods: bool,
                arg_is_internal: bool,
            ) -> ObjectAddress;
        }
        index_constraint_create(
            arg_heapRelation,
            arg_indexRelationId,
            arg_parentConstraintId,
            arg_indexInfo,
            arg_constraintName,
            arg_constraintType,
            arg_constr_flags,
            arg_allow_system_table_mods,
            arg_is_internal,
        )
    })
}
pub unsafe fn index_drop(arg_indexId: Oid, arg_concurrent: bool, arg_concurrent_lock_mode: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_drop(arg_indexId: Oid, arg_concurrent: bool, arg_concurrent_lock_mode: bool);
        }
        index_drop(arg_indexId, arg_concurrent, arg_concurrent_lock_mode)
    })
}
pub unsafe fn BuildIndexInfo(arg_index: Relation) -> *mut IndexInfo {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BuildIndexInfo(arg_index: Relation) -> *mut IndexInfo;
        }
        BuildIndexInfo(arg_index)
    })
}
pub unsafe fn BuildDummyIndexInfo(arg_index: Relation) -> *mut IndexInfo {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BuildDummyIndexInfo(arg_index: Relation) -> *mut IndexInfo;
        }
        BuildDummyIndexInfo(arg_index)
    })
}
pub unsafe fn CompareIndexInfo(
    arg_info1: *mut IndexInfo,
    arg_info2: *mut IndexInfo,
    arg_collations1: *mut Oid,
    arg_collations2: *mut Oid,
    arg_opfamilies1: *mut Oid,
    arg_opfamilies2: *mut Oid,
    arg_attmap: *mut AttrMap,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CompareIndexInfo(
                arg_info1: *mut IndexInfo,
                arg_info2: *mut IndexInfo,
                arg_collations1: *mut Oid,
                arg_collations2: *mut Oid,
                arg_opfamilies1: *mut Oid,
                arg_opfamilies2: *mut Oid,
                arg_attmap: *mut AttrMap,
            ) -> bool;
        }
        CompareIndexInfo(
            arg_info1,
            arg_info2,
            arg_collations1,
            arg_collations2,
            arg_opfamilies1,
            arg_opfamilies2,
            arg_attmap,
        )
    })
}
pub unsafe fn BuildSpeculativeIndexInfo(arg_index: Relation, arg_ii: *mut IndexInfo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BuildSpeculativeIndexInfo(arg_index: Relation, arg_ii: *mut IndexInfo);
        }
        BuildSpeculativeIndexInfo(arg_index, arg_ii)
    })
}
pub unsafe fn FormIndexDatum(
    arg_indexInfo: *mut IndexInfo,
    arg_slot: *mut TupleTableSlot,
    arg_estate: *mut EState,
    arg_values: *mut Datum,
    arg_isnull: *mut bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FormIndexDatum(
                arg_indexInfo: *mut IndexInfo,
                arg_slot: *mut TupleTableSlot,
                arg_estate: *mut EState,
                arg_values: *mut Datum,
                arg_isnull: *mut bool,
            );
        }
        FormIndexDatum(arg_indexInfo, arg_slot, arg_estate, arg_values, arg_isnull)
    })
}
pub unsafe fn index_build(
    arg_heapRelation: Relation,
    arg_indexRelation: Relation,
    arg_indexInfo: *mut IndexInfo,
    arg_isreindex: bool,
    arg_parallel: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_build(
                arg_heapRelation: Relation,
                arg_indexRelation: Relation,
                arg_indexInfo: *mut IndexInfo,
                arg_isreindex: bool,
                arg_parallel: bool,
            );
        }
        index_build(arg_heapRelation, arg_indexRelation, arg_indexInfo, arg_isreindex, arg_parallel)
    })
}
pub unsafe fn validate_index(arg_heapId: Oid, arg_indexId: Oid, arg_snapshot: Snapshot) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn validate_index(arg_heapId: Oid, arg_indexId: Oid, arg_snapshot: Snapshot);
        }
        validate_index(arg_heapId, arg_indexId, arg_snapshot)
    })
}
pub unsafe fn index_set_state_flags(arg_indexId: Oid, arg_action: IndexStateFlagsAction) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_set_state_flags(arg_indexId: Oid, arg_action: IndexStateFlagsAction);
        }
        index_set_state_flags(arg_indexId, arg_action)
    })
}
pub unsafe fn IndexGetRelation(arg_indexId: Oid, arg_missing_ok: bool) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn IndexGetRelation(arg_indexId: Oid, arg_missing_ok: bool) -> Oid;
        }
        IndexGetRelation(arg_indexId, arg_missing_ok)
    })
}
pub unsafe fn reindex_index(
    arg_indexId: Oid,
    arg_skip_constraint_checks: bool,
    arg_relpersistence: ::std::os::raw::c_char,
    arg_options: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn reindex_index(
                arg_indexId: Oid,
                arg_skip_constraint_checks: bool,
                arg_relpersistence: ::std::os::raw::c_char,
                arg_options: ::std::os::raw::c_int,
            );
        }
        reindex_index(arg_indexId, arg_skip_constraint_checks, arg_relpersistence, arg_options)
    })
}
pub unsafe fn reindex_relation(
    arg_relid: Oid,
    arg_flags: ::std::os::raw::c_int,
    arg_options: ::std::os::raw::c_int,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn reindex_relation(
                arg_relid: Oid,
                arg_flags: ::std::os::raw::c_int,
                arg_options: ::std::os::raw::c_int,
            ) -> bool;
        }
        reindex_relation(arg_relid, arg_flags, arg_options)
    })
}
pub unsafe fn ReindexIsProcessingHeap(arg_heapOid: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReindexIsProcessingHeap(arg_heapOid: Oid) -> bool;
        }
        ReindexIsProcessingHeap(arg_heapOid)
    })
}
pub unsafe fn ReindexIsProcessingIndex(arg_indexOid: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReindexIsProcessingIndex(arg_indexOid: Oid) -> bool;
        }
        ReindexIsProcessingIndex(arg_indexOid)
    })
}
pub unsafe fn ResetReindexState(arg_nestLevel: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ResetReindexState(arg_nestLevel: ::std::os::raw::c_int);
        }
        ResetReindexState(arg_nestLevel)
    })
}
pub unsafe fn EstimateReindexStateSpace() -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EstimateReindexStateSpace() -> Size;
        }
        EstimateReindexStateSpace()
    })
}
pub unsafe fn SerializeReindexState(
    arg_maxsize: Size,
    arg_start_address: *mut ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SerializeReindexState(
                arg_maxsize: Size,
                arg_start_address: *mut ::std::os::raw::c_char,
            );
        }
        SerializeReindexState(arg_maxsize, arg_start_address)
    })
}
pub unsafe fn RestoreReindexState(arg_reindexstate: *mut ::std::os::raw::c_void) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RestoreReindexState(arg_reindexstate: *mut ::std::os::raw::c_void);
        }
        RestoreReindexState(arg_reindexstate)
    })
}
pub unsafe fn IndexSetParentIndex(arg_idx: Relation, arg_parentOid: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn IndexSetParentIndex(arg_idx: Relation, arg_parentOid: Oid);
        }
        IndexSetParentIndex(arg_idx, arg_parentOid)
    })
}
#[repr(C)]
#[derive(Debug)]
pub struct _FuncCandidateList {
    pub next: *mut _FuncCandidateList,
    pub pathpos: ::std::os::raw::c_int,
    pub oid: Oid,
    pub nargs: ::std::os::raw::c_int,
    pub nvargs: ::std::os::raw::c_int,
    pub ndargs: ::std::os::raw::c_int,
    pub argnumbers: *mut ::std::os::raw::c_int,
    pub args: __IncompleteArrayField<Oid>,
}
impl Default for _FuncCandidateList {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FuncCandidateList = *mut _FuncCandidateList;
pub const TempNamespaceStatus_TEMP_NAMESPACE_NOT_TEMP: TempNamespaceStatus = 0;
pub const TempNamespaceStatus_TEMP_NAMESPACE_IDLE: TempNamespaceStatus = 1;
pub const TempNamespaceStatus_TEMP_NAMESPACE_IN_USE: TempNamespaceStatus = 2;
pub type TempNamespaceStatus = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OverrideSearchPath {
    pub schemas: *mut List,
    pub addCatalog: bool,
    pub addTemp: bool,
    pub generation: uint64,
}
impl Default for OverrideSearchPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const RVROption_RVR_MISSING_OK: RVROption = 1;
pub const RVROption_RVR_NOWAIT: RVROption = 2;
pub const RVROption_RVR_SKIP_LOCKED: RVROption = 4;
pub type RVROption = ::std::os::raw::c_uint;
pub type RangeVarGetRelidCallback = ::std::option::Option<
    unsafe extern "C" fn(
        relation: *const RangeVar,
        relId: Oid,
        oldRelId: Oid,
        callback_arg: *mut ::std::os::raw::c_void,
    ),
>;
pub unsafe fn RangeVarGetRelidExtended(
    arg_relation: *const RangeVar,
    arg_lockmode: LOCKMODE,
    arg_flags: uint32,
    arg_callback: RangeVarGetRelidCallback,
    arg_callback_arg: *mut ::std::os::raw::c_void,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RangeVarGetRelidExtended(
                arg_relation: *const RangeVar,
                arg_lockmode: LOCKMODE,
                arg_flags: uint32,
                arg_callback: RangeVarGetRelidCallback,
                arg_callback_arg: *mut ::std::os::raw::c_void,
            ) -> Oid;
        }
        RangeVarGetRelidExtended(
            arg_relation,
            arg_lockmode,
            arg_flags,
            arg_callback,
            arg_callback_arg,
        )
    })
}
pub unsafe fn RangeVarGetCreationNamespace(arg_newRelation: *const RangeVar) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RangeVarGetCreationNamespace(arg_newRelation: *const RangeVar) -> Oid;
        }
        RangeVarGetCreationNamespace(arg_newRelation)
    })
}
pub unsafe fn RangeVarGetAndCheckCreationNamespace(
    arg_newRelation: *mut RangeVar,
    arg_lockmode: LOCKMODE,
    arg_existing_relation_id: *mut Oid,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RangeVarGetAndCheckCreationNamespace(
                arg_newRelation: *mut RangeVar,
                arg_lockmode: LOCKMODE,
                arg_existing_relation_id: *mut Oid,
            ) -> Oid;
        }
        RangeVarGetAndCheckCreationNamespace(
            arg_newRelation,
            arg_lockmode,
            arg_existing_relation_id,
        )
    })
}
pub unsafe fn RangeVarAdjustRelationPersistence(arg_newRelation: *mut RangeVar, arg_nspid: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RangeVarAdjustRelationPersistence(arg_newRelation: *mut RangeVar, arg_nspid: Oid);
        }
        RangeVarAdjustRelationPersistence(arg_newRelation, arg_nspid)
    })
}
pub unsafe fn RelnameGetRelid(arg_relname: *const ::std::os::raw::c_char) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelnameGetRelid(arg_relname: *const ::std::os::raw::c_char) -> Oid;
        }
        RelnameGetRelid(arg_relname)
    })
}
pub unsafe fn RelationIsVisible(arg_relid: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationIsVisible(arg_relid: Oid) -> bool;
        }
        RelationIsVisible(arg_relid)
    })
}
pub unsafe fn TypenameGetTypid(arg_typname: *const ::std::os::raw::c_char) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TypenameGetTypid(arg_typname: *const ::std::os::raw::c_char) -> Oid;
        }
        TypenameGetTypid(arg_typname)
    })
}
pub unsafe fn TypenameGetTypidExtended(
    arg_typname: *const ::std::os::raw::c_char,
    arg_temp_ok: bool,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TypenameGetTypidExtended(
                arg_typname: *const ::std::os::raw::c_char,
                arg_temp_ok: bool,
            ) -> Oid;
        }
        TypenameGetTypidExtended(arg_typname, arg_temp_ok)
    })
}
pub unsafe fn TypeIsVisible(arg_typid: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TypeIsVisible(arg_typid: Oid) -> bool;
        }
        TypeIsVisible(arg_typid)
    })
}
pub unsafe fn FuncnameGetCandidates(
    arg_names: *mut List,
    arg_nargs: ::std::os::raw::c_int,
    arg_argnames: *mut List,
    arg_expand_variadic: bool,
    arg_expand_defaults: bool,
    arg_missing_ok: bool,
) -> FuncCandidateList {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FuncnameGetCandidates(
                arg_names: *mut List,
                arg_nargs: ::std::os::raw::c_int,
                arg_argnames: *mut List,
                arg_expand_variadic: bool,
                arg_expand_defaults: bool,
                arg_missing_ok: bool,
            ) -> FuncCandidateList;
        }
        FuncnameGetCandidates(
            arg_names,
            arg_nargs,
            arg_argnames,
            arg_expand_variadic,
            arg_expand_defaults,
            arg_missing_ok,
        )
    })
}
pub unsafe fn FunctionIsVisible(arg_funcid: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FunctionIsVisible(arg_funcid: Oid) -> bool;
        }
        FunctionIsVisible(arg_funcid)
    })
}
pub unsafe fn OpernameGetOprid(arg_names: *mut List, arg_oprleft: Oid, arg_oprright: Oid) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn OpernameGetOprid(arg_names: *mut List, arg_oprleft: Oid, arg_oprright: Oid) -> Oid;
        }
        OpernameGetOprid(arg_names, arg_oprleft, arg_oprright)
    })
}
pub unsafe fn OpernameGetCandidates(
    arg_names: *mut List,
    arg_oprkind: ::std::os::raw::c_char,
    arg_missing_schema_ok: bool,
) -> FuncCandidateList {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn OpernameGetCandidates(
                arg_names: *mut List,
                arg_oprkind: ::std::os::raw::c_char,
                arg_missing_schema_ok: bool,
            ) -> FuncCandidateList;
        }
        OpernameGetCandidates(arg_names, arg_oprkind, arg_missing_schema_ok)
    })
}
pub unsafe fn OperatorIsVisible(arg_oprid: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn OperatorIsVisible(arg_oprid: Oid) -> bool;
        }
        OperatorIsVisible(arg_oprid)
    })
}
pub unsafe fn OpclassnameGetOpcid(
    arg_amid: Oid,
    arg_opcname: *const ::std::os::raw::c_char,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn OpclassnameGetOpcid(
                arg_amid: Oid,
                arg_opcname: *const ::std::os::raw::c_char,
            ) -> Oid;
        }
        OpclassnameGetOpcid(arg_amid, arg_opcname)
    })
}
pub unsafe fn OpclassIsVisible(arg_opcid: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn OpclassIsVisible(arg_opcid: Oid) -> bool;
        }
        OpclassIsVisible(arg_opcid)
    })
}
pub unsafe fn OpfamilynameGetOpfid(
    arg_amid: Oid,
    arg_opfname: *const ::std::os::raw::c_char,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn OpfamilynameGetOpfid(
                arg_amid: Oid,
                arg_opfname: *const ::std::os::raw::c_char,
            ) -> Oid;
        }
        OpfamilynameGetOpfid(arg_amid, arg_opfname)
    })
}
pub unsafe fn OpfamilyIsVisible(arg_opfid: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn OpfamilyIsVisible(arg_opfid: Oid) -> bool;
        }
        OpfamilyIsVisible(arg_opfid)
    })
}
pub unsafe fn CollationGetCollid(arg_collname: *const ::std::os::raw::c_char) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CollationGetCollid(arg_collname: *const ::std::os::raw::c_char) -> Oid;
        }
        CollationGetCollid(arg_collname)
    })
}
pub unsafe fn CollationIsVisible(arg_collid: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CollationIsVisible(arg_collid: Oid) -> bool;
        }
        CollationIsVisible(arg_collid)
    })
}
pub unsafe fn ConversionGetConid(arg_conname: *const ::std::os::raw::c_char) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ConversionGetConid(arg_conname: *const ::std::os::raw::c_char) -> Oid;
        }
        ConversionGetConid(arg_conname)
    })
}
pub unsafe fn ConversionIsVisible(arg_conid: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ConversionIsVisible(arg_conid: Oid) -> bool;
        }
        ConversionIsVisible(arg_conid)
    })
}
pub unsafe fn get_statistics_object_oid(arg_names: *mut List, arg_missing_ok: bool) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_statistics_object_oid(arg_names: *mut List, arg_missing_ok: bool) -> Oid;
        }
        get_statistics_object_oid(arg_names, arg_missing_ok)
    })
}
pub unsafe fn StatisticsObjIsVisible(arg_relid: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn StatisticsObjIsVisible(arg_relid: Oid) -> bool;
        }
        StatisticsObjIsVisible(arg_relid)
    })
}
pub unsafe fn get_ts_parser_oid(arg_names: *mut List, arg_missing_ok: bool) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_ts_parser_oid(arg_names: *mut List, arg_missing_ok: bool) -> Oid;
        }
        get_ts_parser_oid(arg_names, arg_missing_ok)
    })
}
pub unsafe fn TSParserIsVisible(arg_prsId: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TSParserIsVisible(arg_prsId: Oid) -> bool;
        }
        TSParserIsVisible(arg_prsId)
    })
}
pub unsafe fn get_ts_dict_oid(arg_names: *mut List, arg_missing_ok: bool) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_ts_dict_oid(arg_names: *mut List, arg_missing_ok: bool) -> Oid;
        }
        get_ts_dict_oid(arg_names, arg_missing_ok)
    })
}
pub unsafe fn TSDictionaryIsVisible(arg_dictId: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TSDictionaryIsVisible(arg_dictId: Oid) -> bool;
        }
        TSDictionaryIsVisible(arg_dictId)
    })
}
pub unsafe fn get_ts_template_oid(arg_names: *mut List, arg_missing_ok: bool) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_ts_template_oid(arg_names: *mut List, arg_missing_ok: bool) -> Oid;
        }
        get_ts_template_oid(arg_names, arg_missing_ok)
    })
}
pub unsafe fn TSTemplateIsVisible(arg_tmplId: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TSTemplateIsVisible(arg_tmplId: Oid) -> bool;
        }
        TSTemplateIsVisible(arg_tmplId)
    })
}
pub unsafe fn get_ts_config_oid(arg_names: *mut List, arg_missing_ok: bool) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_ts_config_oid(arg_names: *mut List, arg_missing_ok: bool) -> Oid;
        }
        get_ts_config_oid(arg_names, arg_missing_ok)
    })
}
pub unsafe fn TSConfigIsVisible(arg_cfgid: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TSConfigIsVisible(arg_cfgid: Oid) -> bool;
        }
        TSConfigIsVisible(arg_cfgid)
    })
}
pub unsafe fn DeconstructQualifiedName(
    arg_names: *mut List,
    arg_nspname_p: *mut *mut ::std::os::raw::c_char,
    arg_objname_p: *mut *mut ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DeconstructQualifiedName(
                arg_names: *mut List,
                arg_nspname_p: *mut *mut ::std::os::raw::c_char,
                arg_objname_p: *mut *mut ::std::os::raw::c_char,
            );
        }
        DeconstructQualifiedName(arg_names, arg_nspname_p, arg_objname_p)
    })
}
pub unsafe fn LookupNamespaceNoError(arg_nspname: *const ::std::os::raw::c_char) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LookupNamespaceNoError(arg_nspname: *const ::std::os::raw::c_char) -> Oid;
        }
        LookupNamespaceNoError(arg_nspname)
    })
}
pub unsafe fn LookupExplicitNamespace(
    arg_nspname: *const ::std::os::raw::c_char,
    arg_missing_ok: bool,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LookupExplicitNamespace(
                arg_nspname: *const ::std::os::raw::c_char,
                arg_missing_ok: bool,
            ) -> Oid;
        }
        LookupExplicitNamespace(arg_nspname, arg_missing_ok)
    })
}
pub unsafe fn get_namespace_oid(
    arg_nspname: *const ::std::os::raw::c_char,
    arg_missing_ok: bool,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_namespace_oid(
                arg_nspname: *const ::std::os::raw::c_char,
                arg_missing_ok: bool,
            ) -> Oid;
        }
        get_namespace_oid(arg_nspname, arg_missing_ok)
    })
}
pub unsafe fn LookupCreationNamespace(arg_nspname: *const ::std::os::raw::c_char) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LookupCreationNamespace(arg_nspname: *const ::std::os::raw::c_char) -> Oid;
        }
        LookupCreationNamespace(arg_nspname)
    })
}
pub unsafe fn CheckSetNamespace(arg_oldNspOid: Oid, arg_nspOid: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CheckSetNamespace(arg_oldNspOid: Oid, arg_nspOid: Oid);
        }
        CheckSetNamespace(arg_oldNspOid, arg_nspOid)
    })
}
pub unsafe fn QualifiedNameGetCreationNamespace(
    arg_names: *mut List,
    arg_objname_p: *mut *mut ::std::os::raw::c_char,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn QualifiedNameGetCreationNamespace(
                arg_names: *mut List,
                arg_objname_p: *mut *mut ::std::os::raw::c_char,
            ) -> Oid;
        }
        QualifiedNameGetCreationNamespace(arg_names, arg_objname_p)
    })
}
pub unsafe fn makeRangeVarFromNameList(arg_names: *mut List) -> *mut RangeVar {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeRangeVarFromNameList(arg_names: *mut List) -> *mut RangeVar;
        }
        makeRangeVarFromNameList(arg_names)
    })
}
pub unsafe fn NameListToString(arg_names: *mut List) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn NameListToString(arg_names: *mut List) -> *mut ::std::os::raw::c_char;
        }
        NameListToString(arg_names)
    })
}
pub unsafe fn NameListToQuotedString(arg_names: *mut List) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn NameListToQuotedString(arg_names: *mut List) -> *mut ::std::os::raw::c_char;
        }
        NameListToQuotedString(arg_names)
    })
}
pub unsafe fn isTempNamespace(arg_namespaceId: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn isTempNamespace(arg_namespaceId: Oid) -> bool;
        }
        isTempNamespace(arg_namespaceId)
    })
}
pub unsafe fn isTempToastNamespace(arg_namespaceId: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn isTempToastNamespace(arg_namespaceId: Oid) -> bool;
        }
        isTempToastNamespace(arg_namespaceId)
    })
}
pub unsafe fn isTempOrTempToastNamespace(arg_namespaceId: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn isTempOrTempToastNamespace(arg_namespaceId: Oid) -> bool;
        }
        isTempOrTempToastNamespace(arg_namespaceId)
    })
}
pub unsafe fn isAnyTempNamespace(arg_namespaceId: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn isAnyTempNamespace(arg_namespaceId: Oid) -> bool;
        }
        isAnyTempNamespace(arg_namespaceId)
    })
}
pub unsafe fn isOtherTempNamespace(arg_namespaceId: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn isOtherTempNamespace(arg_namespaceId: Oid) -> bool;
        }
        isOtherTempNamespace(arg_namespaceId)
    })
}
pub unsafe fn checkTempNamespaceStatus(arg_namespaceId: Oid) -> TempNamespaceStatus {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn checkTempNamespaceStatus(arg_namespaceId: Oid) -> TempNamespaceStatus;
        }
        checkTempNamespaceStatus(arg_namespaceId)
    })
}
pub unsafe fn GetTempNamespaceBackendId(arg_namespaceId: Oid) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetTempNamespaceBackendId(arg_namespaceId: Oid) -> ::std::os::raw::c_int;
        }
        GetTempNamespaceBackendId(arg_namespaceId)
    })
}
pub unsafe fn GetTempToastNamespace() -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetTempToastNamespace() -> Oid;
        }
        GetTempToastNamespace()
    })
}
pub unsafe fn GetTempNamespaceState(
    arg_tempNamespaceId: *mut Oid,
    arg_tempToastNamespaceId: *mut Oid,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetTempNamespaceState(
                arg_tempNamespaceId: *mut Oid,
                arg_tempToastNamespaceId: *mut Oid,
            );
        }
        GetTempNamespaceState(arg_tempNamespaceId, arg_tempToastNamespaceId)
    })
}
pub unsafe fn SetTempNamespaceState(arg_tempNamespaceId: Oid, arg_tempToastNamespaceId: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SetTempNamespaceState(arg_tempNamespaceId: Oid, arg_tempToastNamespaceId: Oid);
        }
        SetTempNamespaceState(arg_tempNamespaceId, arg_tempToastNamespaceId)
    })
}
pub unsafe fn ResetTempTableNamespace() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ResetTempTableNamespace();
        }
        ResetTempTableNamespace()
    })
}
pub unsafe fn GetOverrideSearchPath(arg_context: MemoryContext) -> *mut OverrideSearchPath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetOverrideSearchPath(arg_context: MemoryContext) -> *mut OverrideSearchPath;
        }
        GetOverrideSearchPath(arg_context)
    })
}
pub unsafe fn CopyOverrideSearchPath(arg_path: *mut OverrideSearchPath) -> *mut OverrideSearchPath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CopyOverrideSearchPath(arg_path: *mut OverrideSearchPath)
                -> *mut OverrideSearchPath;
        }
        CopyOverrideSearchPath(arg_path)
    })
}
pub unsafe fn OverrideSearchPathMatchesCurrent(arg_path: *mut OverrideSearchPath) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn OverrideSearchPathMatchesCurrent(arg_path: *mut OverrideSearchPath) -> bool;
        }
        OverrideSearchPathMatchesCurrent(arg_path)
    })
}
pub unsafe fn PushOverrideSearchPath(arg_newpath: *mut OverrideSearchPath) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PushOverrideSearchPath(arg_newpath: *mut OverrideSearchPath);
        }
        PushOverrideSearchPath(arg_newpath)
    })
}
pub unsafe fn PopOverrideSearchPath() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PopOverrideSearchPath();
        }
        PopOverrideSearchPath()
    })
}
pub unsafe fn get_collation_oid(arg_collname: *mut List, arg_missing_ok: bool) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_collation_oid(arg_collname: *mut List, arg_missing_ok: bool) -> Oid;
        }
        get_collation_oid(arg_collname, arg_missing_ok)
    })
}
pub unsafe fn get_conversion_oid(arg_conname: *mut List, arg_missing_ok: bool) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_conversion_oid(arg_conname: *mut List, arg_missing_ok: bool) -> Oid;
        }
        get_conversion_oid(arg_conname, arg_missing_ok)
    })
}
pub unsafe fn FindDefaultConversionProc(arg_for_encoding: int32, arg_to_encoding: int32) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FindDefaultConversionProc(arg_for_encoding: int32, arg_to_encoding: int32) -> Oid;
        }
        FindDefaultConversionProc(arg_for_encoding, arg_to_encoding)
    })
}
pub unsafe fn InitializeSearchPath() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitializeSearchPath();
        }
        InitializeSearchPath()
    })
}
pub unsafe fn AtEOXact_Namespace(arg_isCommit: bool, arg_parallel: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AtEOXact_Namespace(arg_isCommit: bool, arg_parallel: bool);
        }
        AtEOXact_Namespace(arg_isCommit, arg_parallel)
    })
}
pub unsafe fn AtEOSubXact_Namespace(
    arg_isCommit: bool,
    arg_mySubid: SubTransactionId,
    arg_parentSubid: SubTransactionId,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AtEOSubXact_Namespace(
                arg_isCommit: bool,
                arg_mySubid: SubTransactionId,
                arg_parentSubid: SubTransactionId,
            );
        }
        AtEOSubXact_Namespace(arg_isCommit, arg_mySubid, arg_parentSubid)
    })
}
extern "C" {
    pub static mut namespace_search_path: *mut ::std::os::raw::c_char;
}
pub unsafe fn fetch_search_path(arg_includeImplicit: bool) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fetch_search_path(arg_includeImplicit: bool) -> *mut List;
        }
        fetch_search_path(arg_includeImplicit)
    })
}
pub unsafe fn fetch_search_path_array(
    arg_sarray: *mut Oid,
    arg_sarray_len: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fetch_search_path_array(
                arg_sarray: *mut Oid,
                arg_sarray_len: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        fetch_search_path_array(arg_sarray, arg_sarray_len)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_authid {
    pub oid: Oid,
    pub rolname: NameData,
    pub rolsuper: bool,
    pub rolinherit: bool,
    pub rolcreaterole: bool,
    pub rolcreatedb: bool,
    pub rolcanlogin: bool,
    pub rolreplication: bool,
    pub rolbypassrls: bool,
    pub rolconnlimit: int32,
}
impl Default for FormData_pg_authid {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_authid = *mut FormData_pg_authid;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_database {
    pub oid: Oid,
    pub datname: NameData,
    pub datdba: Oid,
    pub encoding: int32,
    pub datcollate: NameData,
    pub datctype: NameData,
    pub datistemplate: bool,
    pub datallowconn: bool,
    pub datconnlimit: int32,
    pub datlastsysoid: Oid,
    pub datfrozenxid: TransactionId,
    pub datminmxid: TransactionId,
    pub dattablespace: Oid,
}
impl Default for FormData_pg_database {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_database = *mut FormData_pg_database;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_enum {
    pub oid: Oid,
    pub enumtypid: Oid,
    pub enumsortorder: float4,
    pub enumlabel: NameData,
}
impl Default for FormData_pg_enum {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_enum = *mut FormData_pg_enum;
pub unsafe fn EnumValuesCreate(arg_enumTypeOid: Oid, arg_vals: *mut List) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EnumValuesCreate(arg_enumTypeOid: Oid, arg_vals: *mut List);
        }
        EnumValuesCreate(arg_enumTypeOid, arg_vals)
    })
}
pub unsafe fn EnumValuesDelete(arg_enumTypeOid: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EnumValuesDelete(arg_enumTypeOid: Oid);
        }
        EnumValuesDelete(arg_enumTypeOid)
    })
}
pub unsafe fn AddEnumLabel(
    arg_enumTypeOid: Oid,
    arg_newVal: *const ::std::os::raw::c_char,
    arg_neighbor: *const ::std::os::raw::c_char,
    arg_newValIsAfter: bool,
    arg_skipIfExists: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AddEnumLabel(
                arg_enumTypeOid: Oid,
                arg_newVal: *const ::std::os::raw::c_char,
                arg_neighbor: *const ::std::os::raw::c_char,
                arg_newValIsAfter: bool,
                arg_skipIfExists: bool,
            );
        }
        AddEnumLabel(arg_enumTypeOid, arg_newVal, arg_neighbor, arg_newValIsAfter, arg_skipIfExists)
    })
}
pub unsafe fn RenameEnumLabel(
    arg_enumTypeOid: Oid,
    arg_oldVal: *const ::std::os::raw::c_char,
    arg_newVal: *const ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RenameEnumLabel(
                arg_enumTypeOid: Oid,
                arg_oldVal: *const ::std::os::raw::c_char,
                arg_newVal: *const ::std::os::raw::c_char,
            );
        }
        RenameEnumLabel(arg_enumTypeOid, arg_oldVal, arg_newVal)
    })
}
pub unsafe fn EnumBlacklisted(arg_enum_id: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EnumBlacklisted(arg_enum_id: Oid) -> bool;
        }
        EnumBlacklisted(arg_enum_id)
    })
}
pub unsafe fn EstimateEnumBlacklistSpace() -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EstimateEnumBlacklistSpace() -> Size;
        }
        EstimateEnumBlacklistSpace()
    })
}
pub unsafe fn SerializeEnumBlacklist(arg_space: *mut ::std::os::raw::c_void, arg_size: Size) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SerializeEnumBlacklist(arg_space: *mut ::std::os::raw::c_void, arg_size: Size);
        }
        SerializeEnumBlacklist(arg_space, arg_size)
    })
}
pub unsafe fn RestoreEnumBlacklist(arg_space: *mut ::std::os::raw::c_void) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RestoreEnumBlacklist(arg_space: *mut ::std::os::raw::c_void);
        }
        RestoreEnumBlacklist(arg_space)
    })
}
pub unsafe fn AtEOXact_Enum() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AtEOXact_Enum();
        }
        AtEOXact_Enum()
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_operator {
    pub oid: Oid,
    pub oprname: NameData,
    pub oprnamespace: Oid,
    pub oprowner: Oid,
    pub oprkind: ::std::os::raw::c_char,
    pub oprcanmerge: bool,
    pub oprcanhash: bool,
    pub oprleft: Oid,
    pub oprright: Oid,
    pub oprresult: Oid,
    pub oprcom: Oid,
    pub oprnegate: Oid,
    pub oprcode: regproc,
    pub oprrest: regproc,
    pub oprjoin: regproc,
}
impl Default for FormData_pg_operator {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_operator = *mut FormData_pg_operator;
pub unsafe fn OperatorCreate(
    arg_operatorName: *const ::std::os::raw::c_char,
    arg_operatorNamespace: Oid,
    arg_leftTypeId: Oid,
    arg_rightTypeId: Oid,
    arg_procedureId: Oid,
    arg_commutatorName: *mut List,
    arg_negatorName: *mut List,
    arg_restrictionId: Oid,
    arg_joinId: Oid,
    arg_canMerge: bool,
    arg_canHash: bool,
) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn OperatorCreate(
                arg_operatorName: *const ::std::os::raw::c_char,
                arg_operatorNamespace: Oid,
                arg_leftTypeId: Oid,
                arg_rightTypeId: Oid,
                arg_procedureId: Oid,
                arg_commutatorName: *mut List,
                arg_negatorName: *mut List,
                arg_restrictionId: Oid,
                arg_joinId: Oid,
                arg_canMerge: bool,
                arg_canHash: bool,
            ) -> ObjectAddress;
        }
        OperatorCreate(
            arg_operatorName,
            arg_operatorNamespace,
            arg_leftTypeId,
            arg_rightTypeId,
            arg_procedureId,
            arg_commutatorName,
            arg_negatorName,
            arg_restrictionId,
            arg_joinId,
            arg_canMerge,
            arg_canHash,
        )
    })
}
pub unsafe fn makeOperatorDependencies(
    arg_tuple: HeapTuple,
    arg_makeExtensionDep: bool,
    arg_isUpdate: bool,
) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeOperatorDependencies(
                arg_tuple: HeapTuple,
                arg_makeExtensionDep: bool,
                arg_isUpdate: bool,
            ) -> ObjectAddress;
        }
        makeOperatorDependencies(arg_tuple, arg_makeExtensionDep, arg_isUpdate)
    })
}
pub unsafe fn OperatorUpd(arg_baseId: Oid, arg_commId: Oid, arg_negId: Oid, arg_isDelete: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn OperatorUpd(arg_baseId: Oid, arg_commId: Oid, arg_negId: Oid, arg_isDelete: bool);
        }
        OperatorUpd(arg_baseId, arg_commId, arg_negId, arg_isDelete)
    })
}
#[repr(C)]
#[derive(Debug)]
pub struct FormData_pg_proc {
    pub oid: Oid,
    pub proname: NameData,
    pub pronamespace: Oid,
    pub proowner: Oid,
    pub prolang: Oid,
    pub procost: float4,
    pub prorows: float4,
    pub provariadic: Oid,
    pub prosupport: regproc,
    pub prokind: ::std::os::raw::c_char,
    pub prosecdef: bool,
    pub proleakproof: bool,
    pub proisstrict: bool,
    pub proretset: bool,
    pub provolatile: ::std::os::raw::c_char,
    pub proparallel: ::std::os::raw::c_char,
    pub pronargs: int16,
    pub pronargdefaults: int16,
    pub prorettype: Oid,
    pub proargtypes: oidvector,
}
impl Default for FormData_pg_proc {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_proc = *mut FormData_pg_proc;
pub unsafe fn ProcedureCreate(
    arg_procedureName: *const ::std::os::raw::c_char,
    arg_procNamespace: Oid,
    arg_replace: bool,
    arg_returnsSet: bool,
    arg_returnType: Oid,
    arg_proowner: Oid,
    arg_languageObjectId: Oid,
    arg_languageValidator: Oid,
    arg_prosrc: *const ::std::os::raw::c_char,
    arg_probin: *const ::std::os::raw::c_char,
    arg_prokind: ::std::os::raw::c_char,
    arg_security_definer: bool,
    arg_isLeakProof: bool,
    arg_isStrict: bool,
    arg_volatility: ::std::os::raw::c_char,
    arg_parallel: ::std::os::raw::c_char,
    arg_parameterTypes: *mut oidvector,
    arg_allParameterTypes: Datum,
    arg_parameterModes: Datum,
    arg_parameterNames: Datum,
    arg_parameterDefaults: *mut List,
    arg_trftypes: Datum,
    arg_proconfig: Datum,
    arg_prosupport: Oid,
    arg_procost: float4,
    arg_prorows: float4,
) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcedureCreate(
                arg_procedureName: *const ::std::os::raw::c_char,
                arg_procNamespace: Oid,
                arg_replace: bool,
                arg_returnsSet: bool,
                arg_returnType: Oid,
                arg_proowner: Oid,
                arg_languageObjectId: Oid,
                arg_languageValidator: Oid,
                arg_prosrc: *const ::std::os::raw::c_char,
                arg_probin: *const ::std::os::raw::c_char,
                arg_prokind: ::std::os::raw::c_char,
                arg_security_definer: bool,
                arg_isLeakProof: bool,
                arg_isStrict: bool,
                arg_volatility: ::std::os::raw::c_char,
                arg_parallel: ::std::os::raw::c_char,
                arg_parameterTypes: *mut oidvector,
                arg_allParameterTypes: Datum,
                arg_parameterModes: Datum,
                arg_parameterNames: Datum,
                arg_parameterDefaults: *mut List,
                arg_trftypes: Datum,
                arg_proconfig: Datum,
                arg_prosupport: Oid,
                arg_procost: float4,
                arg_prorows: float4,
            ) -> ObjectAddress;
        }
        ProcedureCreate(
            arg_procedureName,
            arg_procNamespace,
            arg_replace,
            arg_returnsSet,
            arg_returnType,
            arg_proowner,
            arg_languageObjectId,
            arg_languageValidator,
            arg_prosrc,
            arg_probin,
            arg_prokind,
            arg_security_definer,
            arg_isLeakProof,
            arg_isStrict,
            arg_volatility,
            arg_parallel,
            arg_parameterTypes,
            arg_allParameterTypes,
            arg_parameterModes,
            arg_parameterNames,
            arg_parameterDefaults,
            arg_trftypes,
            arg_proconfig,
            arg_prosupport,
            arg_procost,
            arg_prorows,
        )
    })
}
pub unsafe fn function_parse_error_transpose(arg_prosrc: *const ::std::os::raw::c_char) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn function_parse_error_transpose(arg_prosrc: *const ::std::os::raw::c_char) -> bool;
        }
        function_parse_error_transpose(arg_prosrc)
    })
}
pub unsafe fn oid_array_to_list(arg_datum: Datum) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn oid_array_to_list(arg_datum: Datum) -> *mut List;
        }
        oid_array_to_list(arg_datum)
    })
}
#[repr(C)]
#[derive(Debug)]
pub struct FormData_pg_trigger {
    pub oid: Oid,
    pub tgrelid: Oid,
    pub tgparentid: Oid,
    pub tgname: NameData,
    pub tgfoid: Oid,
    pub tgtype: int16,
    pub tgenabled: ::std::os::raw::c_char,
    pub tgisinternal: bool,
    pub tgconstrrelid: Oid,
    pub tgconstrindid: Oid,
    pub tgconstraint: Oid,
    pub tgdeferrable: bool,
    pub tginitdeferred: bool,
    pub tgnargs: int16,
    pub tgattr: int2vector,
}
impl Default for FormData_pg_trigger {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_trigger = *mut FormData_pg_trigger;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_type {
    pub oid: Oid,
    pub typname: NameData,
    pub typnamespace: Oid,
    pub typowner: Oid,
    pub typlen: int16,
    pub typbyval: bool,
    pub typtype: ::std::os::raw::c_char,
    pub typcategory: ::std::os::raw::c_char,
    pub typispreferred: bool,
    pub typisdefined: bool,
    pub typdelim: ::std::os::raw::c_char,
    pub typrelid: Oid,
    pub typelem: Oid,
    pub typarray: Oid,
    pub typinput: regproc,
    pub typoutput: regproc,
    pub typreceive: regproc,
    pub typsend: regproc,
    pub typmodin: regproc,
    pub typmodout: regproc,
    pub typanalyze: regproc,
    pub typalign: ::std::os::raw::c_char,
    pub typstorage: ::std::os::raw::c_char,
    pub typnotnull: bool,
    pub typbasetype: Oid,
    pub typtypmod: int32,
    pub typndims: int32,
    pub typcollation: Oid,
}
impl Default for FormData_pg_type {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_type = *mut FormData_pg_type;
pub unsafe fn TypeShellMake(
    arg_typeName: *const ::std::os::raw::c_char,
    arg_typeNamespace: Oid,
    arg_ownerId: Oid,
) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TypeShellMake(
                arg_typeName: *const ::std::os::raw::c_char,
                arg_typeNamespace: Oid,
                arg_ownerId: Oid,
            ) -> ObjectAddress;
        }
        TypeShellMake(arg_typeName, arg_typeNamespace, arg_ownerId)
    })
}
pub unsafe fn TypeCreate(
    arg_newTypeOid: Oid,
    arg_typeName: *const ::std::os::raw::c_char,
    arg_typeNamespace: Oid,
    arg_relationOid: Oid,
    arg_relationKind: ::std::os::raw::c_char,
    arg_ownerId: Oid,
    arg_internalSize: int16,
    arg_typeType: ::std::os::raw::c_char,
    arg_typeCategory: ::std::os::raw::c_char,
    arg_typePreferred: bool,
    arg_typDelim: ::std::os::raw::c_char,
    arg_inputProcedure: Oid,
    arg_outputProcedure: Oid,
    arg_receiveProcedure: Oid,
    arg_sendProcedure: Oid,
    arg_typmodinProcedure: Oid,
    arg_typmodoutProcedure: Oid,
    arg_analyzeProcedure: Oid,
    arg_elementType: Oid,
    arg_isImplicitArray: bool,
    arg_arrayType: Oid,
    arg_baseType: Oid,
    arg_defaultTypeValue: *const ::std::os::raw::c_char,
    arg_defaultTypeBin: *mut ::std::os::raw::c_char,
    arg_passedByValue: bool,
    arg_alignment: ::std::os::raw::c_char,
    arg_storage: ::std::os::raw::c_char,
    arg_typeMod: int32,
    arg_typNDims: int32,
    arg_typeNotNull: bool,
    arg_typeCollation: Oid,
) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TypeCreate(
                arg_newTypeOid: Oid,
                arg_typeName: *const ::std::os::raw::c_char,
                arg_typeNamespace: Oid,
                arg_relationOid: Oid,
                arg_relationKind: ::std::os::raw::c_char,
                arg_ownerId: Oid,
                arg_internalSize: int16,
                arg_typeType: ::std::os::raw::c_char,
                arg_typeCategory: ::std::os::raw::c_char,
                arg_typePreferred: bool,
                arg_typDelim: ::std::os::raw::c_char,
                arg_inputProcedure: Oid,
                arg_outputProcedure: Oid,
                arg_receiveProcedure: Oid,
                arg_sendProcedure: Oid,
                arg_typmodinProcedure: Oid,
                arg_typmodoutProcedure: Oid,
                arg_analyzeProcedure: Oid,
                arg_elementType: Oid,
                arg_isImplicitArray: bool,
                arg_arrayType: Oid,
                arg_baseType: Oid,
                arg_defaultTypeValue: *const ::std::os::raw::c_char,
                arg_defaultTypeBin: *mut ::std::os::raw::c_char,
                arg_passedByValue: bool,
                arg_alignment: ::std::os::raw::c_char,
                arg_storage: ::std::os::raw::c_char,
                arg_typeMod: int32,
                arg_typNDims: int32,
                arg_typeNotNull: bool,
                arg_typeCollation: Oid,
            ) -> ObjectAddress;
        }
        TypeCreate(
            arg_newTypeOid,
            arg_typeName,
            arg_typeNamespace,
            arg_relationOid,
            arg_relationKind,
            arg_ownerId,
            arg_internalSize,
            arg_typeType,
            arg_typeCategory,
            arg_typePreferred,
            arg_typDelim,
            arg_inputProcedure,
            arg_outputProcedure,
            arg_receiveProcedure,
            arg_sendProcedure,
            arg_typmodinProcedure,
            arg_typmodoutProcedure,
            arg_analyzeProcedure,
            arg_elementType,
            arg_isImplicitArray,
            arg_arrayType,
            arg_baseType,
            arg_defaultTypeValue,
            arg_defaultTypeBin,
            arg_passedByValue,
            arg_alignment,
            arg_storage,
            arg_typeMod,
            arg_typNDims,
            arg_typeNotNull,
            arg_typeCollation,
        )
    })
}
pub unsafe fn GenerateTypeDependencies(
    arg_typeTuple: HeapTuple,
    arg_typeCatalog: Relation,
    arg_defaultExpr: *mut Node,
    arg_typacl: *mut ::std::os::raw::c_void,
    arg_relationKind: ::std::os::raw::c_char,
    arg_isImplicitArray: bool,
    arg_isDependentType: bool,
    arg_makeExtensionDep: bool,
    arg_rebuild: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GenerateTypeDependencies(
                arg_typeTuple: HeapTuple,
                arg_typeCatalog: Relation,
                arg_defaultExpr: *mut Node,
                arg_typacl: *mut ::std::os::raw::c_void,
                arg_relationKind: ::std::os::raw::c_char,
                arg_isImplicitArray: bool,
                arg_isDependentType: bool,
                arg_makeExtensionDep: bool,
                arg_rebuild: bool,
            );
        }
        GenerateTypeDependencies(
            arg_typeTuple,
            arg_typeCatalog,
            arg_defaultExpr,
            arg_typacl,
            arg_relationKind,
            arg_isImplicitArray,
            arg_isDependentType,
            arg_makeExtensionDep,
            arg_rebuild,
        )
    })
}
pub unsafe fn RenameTypeInternal(
    arg_typeOid: Oid,
    arg_newTypeName: *const ::std::os::raw::c_char,
    arg_typeNamespace: Oid,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RenameTypeInternal(
                arg_typeOid: Oid,
                arg_newTypeName: *const ::std::os::raw::c_char,
                arg_typeNamespace: Oid,
            );
        }
        RenameTypeInternal(arg_typeOid, arg_newTypeName, arg_typeNamespace)
    })
}
pub unsafe fn makeArrayTypeName(
    arg_typeName: *const ::std::os::raw::c_char,
    arg_typeNamespace: Oid,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeArrayTypeName(
                arg_typeName: *const ::std::os::raw::c_char,
                arg_typeNamespace: Oid,
            ) -> *mut ::std::os::raw::c_char;
        }
        makeArrayTypeName(arg_typeName, arg_typeNamespace)
    })
}
pub unsafe fn moveArrayTypeName(
    arg_typeOid: Oid,
    arg_typeName: *const ::std::os::raw::c_char,
    arg_typeNamespace: Oid,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn moveArrayTypeName(
                arg_typeOid: Oid,
                arg_typeName: *const ::std::os::raw::c_char,
                arg_typeNamespace: Oid,
            ) -> bool;
        }
        moveArrayTypeName(arg_typeOid, arg_typeName, arg_typeNamespace)
    })
}
pub unsafe fn CommentObject(arg_stmt: *mut CommentStmt) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CommentObject(arg_stmt: *mut CommentStmt) -> ObjectAddress;
        }
        CommentObject(arg_stmt)
    })
}
pub unsafe fn DeleteComments(arg_oid: Oid, arg_classoid: Oid, arg_subid: int32) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DeleteComments(arg_oid: Oid, arg_classoid: Oid, arg_subid: int32);
        }
        DeleteComments(arg_oid, arg_classoid, arg_subid)
    })
}
pub unsafe fn CreateComments(
    arg_oid: Oid,
    arg_classoid: Oid,
    arg_subid: int32,
    arg_comment: *const ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateComments(
                arg_oid: Oid,
                arg_classoid: Oid,
                arg_subid: int32,
                arg_comment: *const ::std::os::raw::c_char,
            );
        }
        CreateComments(arg_oid, arg_classoid, arg_subid, arg_comment)
    })
}
pub unsafe fn DeleteSharedComments(arg_oid: Oid, arg_classoid: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DeleteSharedComments(arg_oid: Oid, arg_classoid: Oid);
        }
        DeleteSharedComments(arg_oid, arg_classoid)
    })
}
pub unsafe fn CreateSharedComments(
    arg_oid: Oid,
    arg_classoid: Oid,
    arg_comment: *const ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateSharedComments(
                arg_oid: Oid,
                arg_classoid: Oid,
                arg_comment: *const ::std::os::raw::c_char,
            );
        }
        CreateSharedComments(arg_oid, arg_classoid, arg_comment)
    })
}
pub unsafe fn GetComment(
    arg_oid: Oid,
    arg_classoid: Oid,
    arg_subid: int32,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetComment(
                arg_oid: Oid,
                arg_classoid: Oid,
                arg_subid: int32,
            ) -> *mut ::std::os::raw::c_char;
        }
        GetComment(arg_oid, arg_classoid, arg_subid)
    })
}
pub const ParseExprKind_EXPR_KIND_NONE: ParseExprKind = 0;
pub const ParseExprKind_EXPR_KIND_OTHER: ParseExprKind = 1;
pub const ParseExprKind_EXPR_KIND_JOIN_ON: ParseExprKind = 2;
pub const ParseExprKind_EXPR_KIND_JOIN_USING: ParseExprKind = 3;
pub const ParseExprKind_EXPR_KIND_FROM_SUBSELECT: ParseExprKind = 4;
pub const ParseExprKind_EXPR_KIND_FROM_FUNCTION: ParseExprKind = 5;
pub const ParseExprKind_EXPR_KIND_WHERE: ParseExprKind = 6;
pub const ParseExprKind_EXPR_KIND_HAVING: ParseExprKind = 7;
pub const ParseExprKind_EXPR_KIND_FILTER: ParseExprKind = 8;
pub const ParseExprKind_EXPR_KIND_WINDOW_PARTITION: ParseExprKind = 9;
pub const ParseExprKind_EXPR_KIND_WINDOW_ORDER: ParseExprKind = 10;
pub const ParseExprKind_EXPR_KIND_WINDOW_FRAME_RANGE: ParseExprKind = 11;
pub const ParseExprKind_EXPR_KIND_WINDOW_FRAME_ROWS: ParseExprKind = 12;
pub const ParseExprKind_EXPR_KIND_WINDOW_FRAME_GROUPS: ParseExprKind = 13;
pub const ParseExprKind_EXPR_KIND_SELECT_TARGET: ParseExprKind = 14;
pub const ParseExprKind_EXPR_KIND_INSERT_TARGET: ParseExprKind = 15;
pub const ParseExprKind_EXPR_KIND_UPDATE_SOURCE: ParseExprKind = 16;
pub const ParseExprKind_EXPR_KIND_UPDATE_TARGET: ParseExprKind = 17;
pub const ParseExprKind_EXPR_KIND_GROUP_BY: ParseExprKind = 18;
pub const ParseExprKind_EXPR_KIND_ORDER_BY: ParseExprKind = 19;
pub const ParseExprKind_EXPR_KIND_DISTINCT_ON: ParseExprKind = 20;
pub const ParseExprKind_EXPR_KIND_LIMIT: ParseExprKind = 21;
pub const ParseExprKind_EXPR_KIND_OFFSET: ParseExprKind = 22;
pub const ParseExprKind_EXPR_KIND_RETURNING: ParseExprKind = 23;
pub const ParseExprKind_EXPR_KIND_VALUES: ParseExprKind = 24;
pub const ParseExprKind_EXPR_KIND_VALUES_SINGLE: ParseExprKind = 25;
pub const ParseExprKind_EXPR_KIND_CHECK_CONSTRAINT: ParseExprKind = 26;
pub const ParseExprKind_EXPR_KIND_DOMAIN_CHECK: ParseExprKind = 27;
pub const ParseExprKind_EXPR_KIND_COLUMN_DEFAULT: ParseExprKind = 28;
pub const ParseExprKind_EXPR_KIND_FUNCTION_DEFAULT: ParseExprKind = 29;
pub const ParseExprKind_EXPR_KIND_INDEX_EXPRESSION: ParseExprKind = 30;
pub const ParseExprKind_EXPR_KIND_INDEX_PREDICATE: ParseExprKind = 31;
pub const ParseExprKind_EXPR_KIND_ALTER_COL_TRANSFORM: ParseExprKind = 32;
pub const ParseExprKind_EXPR_KIND_EXECUTE_PARAMETER: ParseExprKind = 33;
pub const ParseExprKind_EXPR_KIND_TRIGGER_WHEN: ParseExprKind = 34;
pub const ParseExprKind_EXPR_KIND_POLICY: ParseExprKind = 35;
pub const ParseExprKind_EXPR_KIND_PARTITION_BOUND: ParseExprKind = 36;
pub const ParseExprKind_EXPR_KIND_PARTITION_EXPRESSION: ParseExprKind = 37;
pub const ParseExprKind_EXPR_KIND_CALL_ARGUMENT: ParseExprKind = 38;
pub const ParseExprKind_EXPR_KIND_COPY_WHERE: ParseExprKind = 39;
pub const ParseExprKind_EXPR_KIND_GENERATED_COLUMN: ParseExprKind = 40;
pub type ParseExprKind = ::std::os::raw::c_uint;
pub type PreParseColumnRefHook = ::std::option::Option<
    unsafe extern "C" fn(pstate: *mut ParseState, cref: *mut ColumnRef) -> *mut Node,
>;
pub type PostParseColumnRefHook = ::std::option::Option<
    unsafe extern "C" fn(
        pstate: *mut ParseState,
        cref: *mut ColumnRef,
        var: *mut Node,
    ) -> *mut Node,
>;
pub type ParseParamRefHook = ::std::option::Option<
    unsafe extern "C" fn(pstate: *mut ParseState, pref: *mut ParamRef) -> *mut Node,
>;
pub type CoerceParamHook = ::std::option::Option<
    unsafe extern "C" fn(
        pstate: *mut ParseState,
        param: *mut Param,
        targetTypeId: Oid,
        targetTypeMod: int32,
        location: ::std::os::raw::c_int,
    ) -> *mut Node,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParseState {
    pub parentParseState: *mut ParseState,
    pub p_sourcetext: *const ::std::os::raw::c_char,
    pub p_rtable: *mut List,
    pub p_joinexprs: *mut List,
    pub p_joinlist: *mut List,
    pub p_namespace: *mut List,
    pub p_lateral_active: bool,
    pub p_ctenamespace: *mut List,
    pub p_future_ctes: *mut List,
    pub p_parent_cte: *mut CommonTableExpr,
    pub p_target_relation: Relation,
    pub p_target_nsitem: *mut ParseNamespaceItem,
    pub p_is_insert: bool,
    pub p_windowdefs: *mut List,
    pub p_expr_kind: ParseExprKind,
    pub p_next_resno: ::std::os::raw::c_int,
    pub p_multiassign_exprs: *mut List,
    pub p_locking_clause: *mut List,
    pub p_locked_from_parent: bool,
    pub p_resolve_unknowns: bool,
    pub p_queryEnv: *mut QueryEnvironment,
    pub p_hasAggs: bool,
    pub p_hasWindowFuncs: bool,
    pub p_hasTargetSRFs: bool,
    pub p_hasSubLinks: bool,
    pub p_hasModifyingCTE: bool,
    pub p_last_srf: *mut Node,
    pub p_pre_columnref_hook: PreParseColumnRefHook,
    pub p_post_columnref_hook: PostParseColumnRefHook,
    pub p_paramref_hook: ParseParamRefHook,
    pub p_coerce_param_hook: CoerceParamHook,
    pub p_ref_hook_state: *mut ::std::os::raw::c_void,
}
impl Default for ParseState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParseNamespaceItem {
    pub p_rte: *mut RangeTblEntry,
    pub p_rtindex: ::std::os::raw::c_int,
    pub p_nscolumns: *mut ParseNamespaceColumn,
    pub p_rel_visible: bool,
    pub p_cols_visible: bool,
    pub p_lateral_only: bool,
    pub p_lateral_ok: bool,
}
impl Default for ParseNamespaceItem {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ParseNamespaceColumn {
    pub p_varno: Index,
    pub p_varattno: AttrNumber,
    pub p_vartype: Oid,
    pub p_vartypmod: int32,
    pub p_varcollid: Oid,
    pub p_varnosyn: Index,
    pub p_varattnosyn: AttrNumber,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParseCallbackState {
    pub pstate: *mut ParseState,
    pub location: ::std::os::raw::c_int,
    pub errcallback: ErrorContextCallback,
}
impl Default for ParseCallbackState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn make_parsestate(arg_parentParseState: *mut ParseState) -> *mut ParseState {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_parsestate(arg_parentParseState: *mut ParseState) -> *mut ParseState;
        }
        make_parsestate(arg_parentParseState)
    })
}
pub unsafe fn free_parsestate(arg_pstate: *mut ParseState) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn free_parsestate(arg_pstate: *mut ParseState);
        }
        free_parsestate(arg_pstate)
    })
}
pub unsafe fn parser_errposition(
    arg_pstate: *mut ParseState,
    arg_location: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn parser_errposition(
                arg_pstate: *mut ParseState,
                arg_location: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        parser_errposition(arg_pstate, arg_location)
    })
}
pub unsafe fn setup_parser_errposition_callback(
    arg_pcbstate: *mut ParseCallbackState,
    arg_pstate: *mut ParseState,
    arg_location: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn setup_parser_errposition_callback(
                arg_pcbstate: *mut ParseCallbackState,
                arg_pstate: *mut ParseState,
                arg_location: ::std::os::raw::c_int,
            );
        }
        setup_parser_errposition_callback(arg_pcbstate, arg_pstate, arg_location)
    })
}
pub unsafe fn cancel_parser_errposition_callback(arg_pcbstate: *mut ParseCallbackState) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cancel_parser_errposition_callback(arg_pcbstate: *mut ParseCallbackState);
        }
        cancel_parser_errposition_callback(arg_pcbstate)
    })
}
pub unsafe fn transformContainerType(
    arg_containerType: *mut Oid,
    arg_containerTypmod: *mut int32,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn transformContainerType(
                arg_containerType: *mut Oid,
                arg_containerTypmod: *mut int32,
            ) -> Oid;
        }
        transformContainerType(arg_containerType, arg_containerTypmod)
    })
}
pub unsafe fn transformContainerSubscripts(
    arg_pstate: *mut ParseState,
    arg_containerBase: *mut Node,
    arg_containerType: Oid,
    arg_elementType: Oid,
    arg_containerTypMod: int32,
    arg_indirection: *mut List,
    arg_assignFrom: *mut Node,
) -> *mut SubscriptingRef {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn transformContainerSubscripts(
                arg_pstate: *mut ParseState,
                arg_containerBase: *mut Node,
                arg_containerType: Oid,
                arg_elementType: Oid,
                arg_containerTypMod: int32,
                arg_indirection: *mut List,
                arg_assignFrom: *mut Node,
            ) -> *mut SubscriptingRef;
        }
        transformContainerSubscripts(
            arg_pstate,
            arg_containerBase,
            arg_containerType,
            arg_elementType,
            arg_containerTypMod,
            arg_indirection,
            arg_assignFrom,
        )
    })
}
pub unsafe fn make_const(
    arg_pstate: *mut ParseState,
    arg_value: *mut Value,
    arg_location: ::std::os::raw::c_int,
) -> *mut Const {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_const(
                arg_pstate: *mut ParseState,
                arg_value: *mut Value,
                arg_location: ::std::os::raw::c_int,
            ) -> *mut Const;
        }
        make_const(arg_pstate, arg_value, arg_location)
    })
}
pub unsafe fn createdb(arg_pstate: *mut ParseState, arg_stmt: *const CreatedbStmt) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn createdb(arg_pstate: *mut ParseState, arg_stmt: *const CreatedbStmt) -> Oid;
        }
        createdb(arg_pstate, arg_stmt)
    })
}
pub unsafe fn dropdb(
    arg_dbname: *const ::std::os::raw::c_char,
    arg_missing_ok: bool,
    arg_force: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dropdb(
                arg_dbname: *const ::std::os::raw::c_char,
                arg_missing_ok: bool,
                arg_force: bool,
            );
        }
        dropdb(arg_dbname, arg_missing_ok, arg_force)
    })
}
pub unsafe fn DropDatabase(arg_pstate: *mut ParseState, arg_stmt: *mut DropdbStmt) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DropDatabase(arg_pstate: *mut ParseState, arg_stmt: *mut DropdbStmt);
        }
        DropDatabase(arg_pstate, arg_stmt)
    })
}
pub unsafe fn RenameDatabase(
    arg_oldname: *const ::std::os::raw::c_char,
    arg_newname: *const ::std::os::raw::c_char,
) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RenameDatabase(
                arg_oldname: *const ::std::os::raw::c_char,
                arg_newname: *const ::std::os::raw::c_char,
            ) -> ObjectAddress;
        }
        RenameDatabase(arg_oldname, arg_newname)
    })
}
pub unsafe fn AlterDatabase(
    arg_pstate: *mut ParseState,
    arg_stmt: *mut AlterDatabaseStmt,
    arg_isTopLevel: bool,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AlterDatabase(
                arg_pstate: *mut ParseState,
                arg_stmt: *mut AlterDatabaseStmt,
                arg_isTopLevel: bool,
            ) -> Oid;
        }
        AlterDatabase(arg_pstate, arg_stmt, arg_isTopLevel)
    })
}
pub unsafe fn AlterDatabaseSet(arg_stmt: *mut AlterDatabaseSetStmt) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AlterDatabaseSet(arg_stmt: *mut AlterDatabaseSetStmt) -> Oid;
        }
        AlterDatabaseSet(arg_stmt)
    })
}
pub unsafe fn AlterDatabaseOwner(
    arg_dbname: *const ::std::os::raw::c_char,
    arg_newOwnerId: Oid,
) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AlterDatabaseOwner(
                arg_dbname: *const ::std::os::raw::c_char,
                arg_newOwnerId: Oid,
            ) -> ObjectAddress;
        }
        AlterDatabaseOwner(arg_dbname, arg_newOwnerId)
    })
}
pub unsafe fn get_database_oid(
    arg_dbname: *const ::std::os::raw::c_char,
    arg_missing_ok: bool,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_database_oid(
                arg_dbname: *const ::std::os::raw::c_char,
                arg_missing_ok: bool,
            ) -> Oid;
        }
        get_database_oid(arg_dbname, arg_missing_ok)
    })
}
pub unsafe fn get_database_name(arg_dbid: Oid) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_database_name(arg_dbid: Oid) -> *mut ::std::os::raw::c_char;
        }
        get_database_name(arg_dbid)
    })
}
pub unsafe fn check_encoding_locale_matches(
    arg_encoding: ::std::os::raw::c_int,
    arg_collate: *const ::std::os::raw::c_char,
    arg_ctype: *const ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn check_encoding_locale_matches(
                arg_encoding: ::std::os::raw::c_int,
                arg_collate: *const ::std::os::raw::c_char,
                arg_ctype: *const ::std::os::raw::c_char,
            );
        }
        check_encoding_locale_matches(arg_encoding, arg_collate, arg_ctype)
    })
}
pub unsafe fn RemoveObjects(arg_stmt: *mut DropStmt) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RemoveObjects(arg_stmt: *mut DropStmt);
        }
        RemoveObjects(arg_stmt)
    })
}
pub unsafe fn DefineIndex(
    arg_relationId: Oid,
    arg_stmt: *mut IndexStmt,
    arg_indexRelationId: Oid,
    arg_parentIndexId: Oid,
    arg_parentConstraintId: Oid,
    arg_is_alter_table: bool,
    arg_check_rights: bool,
    arg_check_not_in_use: bool,
    arg_skip_build: bool,
    arg_quiet: bool,
) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DefineIndex(
                arg_relationId: Oid,
                arg_stmt: *mut IndexStmt,
                arg_indexRelationId: Oid,
                arg_parentIndexId: Oid,
                arg_parentConstraintId: Oid,
                arg_is_alter_table: bool,
                arg_check_rights: bool,
                arg_check_not_in_use: bool,
                arg_skip_build: bool,
                arg_quiet: bool,
            ) -> ObjectAddress;
        }
        DefineIndex(
            arg_relationId,
            arg_stmt,
            arg_indexRelationId,
            arg_parentIndexId,
            arg_parentConstraintId,
            arg_is_alter_table,
            arg_check_rights,
            arg_check_not_in_use,
            arg_skip_build,
            arg_quiet,
        )
    })
}
pub unsafe fn ReindexIndex(
    arg_indexRelation: *mut RangeVar,
    arg_options: ::std::os::raw::c_int,
    arg_concurrent: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReindexIndex(
                arg_indexRelation: *mut RangeVar,
                arg_options: ::std::os::raw::c_int,
                arg_concurrent: bool,
            );
        }
        ReindexIndex(arg_indexRelation, arg_options, arg_concurrent)
    })
}
pub unsafe fn ReindexTable(
    arg_relation: *mut RangeVar,
    arg_options: ::std::os::raw::c_int,
    arg_concurrent: bool,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReindexTable(
                arg_relation: *mut RangeVar,
                arg_options: ::std::os::raw::c_int,
                arg_concurrent: bool,
            ) -> Oid;
        }
        ReindexTable(arg_relation, arg_options, arg_concurrent)
    })
}
pub unsafe fn ReindexMultipleTables(
    arg_objectName: *const ::std::os::raw::c_char,
    arg_objectKind: ReindexObjectType,
    arg_options: ::std::os::raw::c_int,
    arg_concurrent: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReindexMultipleTables(
                arg_objectName: *const ::std::os::raw::c_char,
                arg_objectKind: ReindexObjectType,
                arg_options: ::std::os::raw::c_int,
                arg_concurrent: bool,
            );
        }
        ReindexMultipleTables(arg_objectName, arg_objectKind, arg_options, arg_concurrent)
    })
}
pub unsafe fn makeObjectName(
    arg_name1: *const ::std::os::raw::c_char,
    arg_name2: *const ::std::os::raw::c_char,
    arg_label: *const ::std::os::raw::c_char,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeObjectName(
                arg_name1: *const ::std::os::raw::c_char,
                arg_name2: *const ::std::os::raw::c_char,
                arg_label: *const ::std::os::raw::c_char,
            ) -> *mut ::std::os::raw::c_char;
        }
        makeObjectName(arg_name1, arg_name2, arg_label)
    })
}
pub unsafe fn ChooseRelationName(
    arg_name1: *const ::std::os::raw::c_char,
    arg_name2: *const ::std::os::raw::c_char,
    arg_label: *const ::std::os::raw::c_char,
    arg_namespaceid: Oid,
    arg_isconstraint: bool,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ChooseRelationName(
                arg_name1: *const ::std::os::raw::c_char,
                arg_name2: *const ::std::os::raw::c_char,
                arg_label: *const ::std::os::raw::c_char,
                arg_namespaceid: Oid,
                arg_isconstraint: bool,
            ) -> *mut ::std::os::raw::c_char;
        }
        ChooseRelationName(arg_name1, arg_name2, arg_label, arg_namespaceid, arg_isconstraint)
    })
}
pub unsafe fn CheckIndexCompatible(
    arg_oldId: Oid,
    arg_accessMethodName: *const ::std::os::raw::c_char,
    arg_attributeList: *mut List,
    arg_exclusionOpNames: *mut List,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CheckIndexCompatible(
                arg_oldId: Oid,
                arg_accessMethodName: *const ::std::os::raw::c_char,
                arg_attributeList: *mut List,
                arg_exclusionOpNames: *mut List,
            ) -> bool;
        }
        CheckIndexCompatible(
            arg_oldId,
            arg_accessMethodName,
            arg_attributeList,
            arg_exclusionOpNames,
        )
    })
}
pub unsafe fn GetDefaultOpClass(arg_type_id: Oid, arg_am_id: Oid) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetDefaultOpClass(arg_type_id: Oid, arg_am_id: Oid) -> Oid;
        }
        GetDefaultOpClass(arg_type_id, arg_am_id)
    })
}
pub unsafe fn ResolveOpClass(
    arg_opclass: *mut List,
    arg_attrType: Oid,
    arg_accessMethodName: *const ::std::os::raw::c_char,
    arg_accessMethodId: Oid,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ResolveOpClass(
                arg_opclass: *mut List,
                arg_attrType: Oid,
                arg_accessMethodName: *const ::std::os::raw::c_char,
                arg_accessMethodId: Oid,
            ) -> Oid;
        }
        ResolveOpClass(arg_opclass, arg_attrType, arg_accessMethodName, arg_accessMethodId)
    })
}
pub unsafe fn CreateFunction(
    arg_pstate: *mut ParseState,
    arg_stmt: *mut CreateFunctionStmt,
) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateFunction(
                arg_pstate: *mut ParseState,
                arg_stmt: *mut CreateFunctionStmt,
            ) -> ObjectAddress;
        }
        CreateFunction(arg_pstate, arg_stmt)
    })
}
pub unsafe fn RemoveFunctionById(arg_funcOid: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RemoveFunctionById(arg_funcOid: Oid);
        }
        RemoveFunctionById(arg_funcOid)
    })
}
pub unsafe fn AlterFunction(
    arg_pstate: *mut ParseState,
    arg_stmt: *mut AlterFunctionStmt,
) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AlterFunction(
                arg_pstate: *mut ParseState,
                arg_stmt: *mut AlterFunctionStmt,
            ) -> ObjectAddress;
        }
        AlterFunction(arg_pstate, arg_stmt)
    })
}
pub unsafe fn CreateCast(arg_stmt: *mut CreateCastStmt) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateCast(arg_stmt: *mut CreateCastStmt) -> ObjectAddress;
        }
        CreateCast(arg_stmt)
    })
}
pub unsafe fn DropCastById(arg_castOid: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DropCastById(arg_castOid: Oid);
        }
        DropCastById(arg_castOid)
    })
}
pub unsafe fn CreateTransform(arg_stmt: *mut CreateTransformStmt) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateTransform(arg_stmt: *mut CreateTransformStmt) -> ObjectAddress;
        }
        CreateTransform(arg_stmt)
    })
}
pub unsafe fn DropTransformById(arg_transformOid: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DropTransformById(arg_transformOid: Oid);
        }
        DropTransformById(arg_transformOid)
    })
}
pub unsafe fn IsThereFunctionInNamespace(
    arg_proname: *const ::std::os::raw::c_char,
    arg_pronargs: ::std::os::raw::c_int,
    arg_proargtypes: *mut oidvector,
    arg_nspOid: Oid,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn IsThereFunctionInNamespace(
                arg_proname: *const ::std::os::raw::c_char,
                arg_pronargs: ::std::os::raw::c_int,
                arg_proargtypes: *mut oidvector,
                arg_nspOid: Oid,
            );
        }
        IsThereFunctionInNamespace(arg_proname, arg_pronargs, arg_proargtypes, arg_nspOid)
    })
}
pub unsafe fn ExecuteDoStmt(arg_stmt: *mut DoStmt, arg_atomic: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecuteDoStmt(arg_stmt: *mut DoStmt, arg_atomic: bool);
        }
        ExecuteDoStmt(arg_stmt, arg_atomic)
    })
}
pub unsafe fn ExecuteCallStmt(
    arg_stmt: *mut CallStmt,
    arg_params: ParamListInfo,
    arg_atomic: bool,
    arg_dest: *mut DestReceiver,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecuteCallStmt(
                arg_stmt: *mut CallStmt,
                arg_params: ParamListInfo,
                arg_atomic: bool,
                arg_dest: *mut DestReceiver,
            );
        }
        ExecuteCallStmt(arg_stmt, arg_params, arg_atomic, arg_dest)
    })
}
pub unsafe fn CallStmtResultDesc(arg_stmt: *mut CallStmt) -> TupleDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CallStmtResultDesc(arg_stmt: *mut CallStmt) -> TupleDesc;
        }
        CallStmtResultDesc(arg_stmt)
    })
}
pub unsafe fn get_transform_oid(arg_type_id: Oid, arg_lang_id: Oid, arg_missing_ok: bool) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_transform_oid(arg_type_id: Oid, arg_lang_id: Oid, arg_missing_ok: bool) -> Oid;
        }
        get_transform_oid(arg_type_id, arg_lang_id, arg_missing_ok)
    })
}
pub unsafe fn interpret_function_parameter_list(
    arg_pstate: *mut ParseState,
    arg_parameters: *mut List,
    arg_languageOid: Oid,
    arg_objtype: ObjectType,
    arg_parameterTypes: *mut *mut oidvector,
    arg_allParameterTypes: *mut *mut ArrayType,
    arg_parameterModes: *mut *mut ArrayType,
    arg_parameterNames: *mut *mut ArrayType,
    arg_parameterDefaults: *mut *mut List,
    arg_variadicArgType: *mut Oid,
    arg_requiredResultType: *mut Oid,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interpret_function_parameter_list(
                arg_pstate: *mut ParseState,
                arg_parameters: *mut List,
                arg_languageOid: Oid,
                arg_objtype: ObjectType,
                arg_parameterTypes: *mut *mut oidvector,
                arg_allParameterTypes: *mut *mut ArrayType,
                arg_parameterModes: *mut *mut ArrayType,
                arg_parameterNames: *mut *mut ArrayType,
                arg_parameterDefaults: *mut *mut List,
                arg_variadicArgType: *mut Oid,
                arg_requiredResultType: *mut Oid,
            );
        }
        interpret_function_parameter_list(
            arg_pstate,
            arg_parameters,
            arg_languageOid,
            arg_objtype,
            arg_parameterTypes,
            arg_allParameterTypes,
            arg_parameterModes,
            arg_parameterNames,
            arg_parameterDefaults,
            arg_variadicArgType,
            arg_requiredResultType,
        )
    })
}
pub unsafe fn DefineOperator(arg_names: *mut List, arg_parameters: *mut List) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DefineOperator(arg_names: *mut List, arg_parameters: *mut List) -> ObjectAddress;
        }
        DefineOperator(arg_names, arg_parameters)
    })
}
pub unsafe fn RemoveOperatorById(arg_operOid: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RemoveOperatorById(arg_operOid: Oid);
        }
        RemoveOperatorById(arg_operOid)
    })
}
pub unsafe fn AlterOperator(arg_stmt: *mut AlterOperatorStmt) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AlterOperator(arg_stmt: *mut AlterOperatorStmt) -> ObjectAddress;
        }
        AlterOperator(arg_stmt)
    })
}
pub unsafe fn CreateStatistics(arg_stmt: *mut CreateStatsStmt) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateStatistics(arg_stmt: *mut CreateStatsStmt) -> ObjectAddress;
        }
        CreateStatistics(arg_stmt)
    })
}
pub unsafe fn AlterStatistics(arg_stmt: *mut AlterStatsStmt) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AlterStatistics(arg_stmt: *mut AlterStatsStmt) -> ObjectAddress;
        }
        AlterStatistics(arg_stmt)
    })
}
pub unsafe fn RemoveStatisticsById(arg_statsOid: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RemoveStatisticsById(arg_statsOid: Oid);
        }
        RemoveStatisticsById(arg_statsOid)
    })
}
pub unsafe fn UpdateStatisticsForTypeChange(
    arg_statsOid: Oid,
    arg_relationOid: Oid,
    arg_attnum: ::std::os::raw::c_int,
    arg_oldColumnType: Oid,
    arg_newColumnType: Oid,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn UpdateStatisticsForTypeChange(
                arg_statsOid: Oid,
                arg_relationOid: Oid,
                arg_attnum: ::std::os::raw::c_int,
                arg_oldColumnType: Oid,
                arg_newColumnType: Oid,
            );
        }
        UpdateStatisticsForTypeChange(
            arg_statsOid,
            arg_relationOid,
            arg_attnum,
            arg_oldColumnType,
            arg_newColumnType,
        )
    })
}
pub unsafe fn DefineAggregate(
    arg_pstate: *mut ParseState,
    arg_name: *mut List,
    arg_args: *mut List,
    arg_oldstyle: bool,
    arg_parameters: *mut List,
    arg_replace: bool,
) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DefineAggregate(
                arg_pstate: *mut ParseState,
                arg_name: *mut List,
                arg_args: *mut List,
                arg_oldstyle: bool,
                arg_parameters: *mut List,
                arg_replace: bool,
            ) -> ObjectAddress;
        }
        DefineAggregate(arg_pstate, arg_name, arg_args, arg_oldstyle, arg_parameters, arg_replace)
    })
}
pub unsafe fn DefineOpClass(arg_stmt: *mut CreateOpClassStmt) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DefineOpClass(arg_stmt: *mut CreateOpClassStmt) -> ObjectAddress;
        }
        DefineOpClass(arg_stmt)
    })
}
pub unsafe fn DefineOpFamily(arg_stmt: *mut CreateOpFamilyStmt) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DefineOpFamily(arg_stmt: *mut CreateOpFamilyStmt) -> ObjectAddress;
        }
        DefineOpFamily(arg_stmt)
    })
}
pub unsafe fn AlterOpFamily(arg_stmt: *mut AlterOpFamilyStmt) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AlterOpFamily(arg_stmt: *mut AlterOpFamilyStmt) -> Oid;
        }
        AlterOpFamily(arg_stmt)
    })
}
pub unsafe fn RemoveOpClassById(arg_opclassOid: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RemoveOpClassById(arg_opclassOid: Oid);
        }
        RemoveOpClassById(arg_opclassOid)
    })
}
pub unsafe fn RemoveOpFamilyById(arg_opfamilyOid: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RemoveOpFamilyById(arg_opfamilyOid: Oid);
        }
        RemoveOpFamilyById(arg_opfamilyOid)
    })
}
pub unsafe fn RemoveAmOpEntryById(arg_entryOid: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RemoveAmOpEntryById(arg_entryOid: Oid);
        }
        RemoveAmOpEntryById(arg_entryOid)
    })
}
pub unsafe fn RemoveAmProcEntryById(arg_entryOid: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RemoveAmProcEntryById(arg_entryOid: Oid);
        }
        RemoveAmProcEntryById(arg_entryOid)
    })
}
pub unsafe fn IsThereOpClassInNamespace(
    arg_opcname: *const ::std::os::raw::c_char,
    arg_opcmethod: Oid,
    arg_opcnamespace: Oid,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn IsThereOpClassInNamespace(
                arg_opcname: *const ::std::os::raw::c_char,
                arg_opcmethod: Oid,
                arg_opcnamespace: Oid,
            );
        }
        IsThereOpClassInNamespace(arg_opcname, arg_opcmethod, arg_opcnamespace)
    })
}
pub unsafe fn IsThereOpFamilyInNamespace(
    arg_opfname: *const ::std::os::raw::c_char,
    arg_opfmethod: Oid,
    arg_opfnamespace: Oid,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn IsThereOpFamilyInNamespace(
                arg_opfname: *const ::std::os::raw::c_char,
                arg_opfmethod: Oid,
                arg_opfnamespace: Oid,
            );
        }
        IsThereOpFamilyInNamespace(arg_opfname, arg_opfmethod, arg_opfnamespace)
    })
}
pub unsafe fn get_opclass_oid(
    arg_amID: Oid,
    arg_opclassname: *mut List,
    arg_missing_ok: bool,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_opclass_oid(
                arg_amID: Oid,
                arg_opclassname: *mut List,
                arg_missing_ok: bool,
            ) -> Oid;
        }
        get_opclass_oid(arg_amID, arg_opclassname, arg_missing_ok)
    })
}
pub unsafe fn get_opfamily_oid(
    arg_amID: Oid,
    arg_opfamilyname: *mut List,
    arg_missing_ok: bool,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_opfamily_oid(
                arg_amID: Oid,
                arg_opfamilyname: *mut List,
                arg_missing_ok: bool,
            ) -> Oid;
        }
        get_opfamily_oid(arg_amID, arg_opfamilyname, arg_missing_ok)
    })
}
pub unsafe fn DefineTSParser(arg_names: *mut List, arg_parameters: *mut List) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DefineTSParser(arg_names: *mut List, arg_parameters: *mut List) -> ObjectAddress;
        }
        DefineTSParser(arg_names, arg_parameters)
    })
}
pub unsafe fn RemoveTSParserById(arg_prsId: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RemoveTSParserById(arg_prsId: Oid);
        }
        RemoveTSParserById(arg_prsId)
    })
}
pub unsafe fn DefineTSDictionary(arg_names: *mut List, arg_parameters: *mut List) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DefineTSDictionary(arg_names: *mut List, arg_parameters: *mut List)
                -> ObjectAddress;
        }
        DefineTSDictionary(arg_names, arg_parameters)
    })
}
pub unsafe fn RemoveTSDictionaryById(arg_dictId: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RemoveTSDictionaryById(arg_dictId: Oid);
        }
        RemoveTSDictionaryById(arg_dictId)
    })
}
pub unsafe fn AlterTSDictionary(arg_stmt: *mut AlterTSDictionaryStmt) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AlterTSDictionary(arg_stmt: *mut AlterTSDictionaryStmt) -> ObjectAddress;
        }
        AlterTSDictionary(arg_stmt)
    })
}
pub unsafe fn DefineTSTemplate(arg_names: *mut List, arg_parameters: *mut List) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DefineTSTemplate(arg_names: *mut List, arg_parameters: *mut List) -> ObjectAddress;
        }
        DefineTSTemplate(arg_names, arg_parameters)
    })
}
pub unsafe fn RemoveTSTemplateById(arg_tmplId: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RemoveTSTemplateById(arg_tmplId: Oid);
        }
        RemoveTSTemplateById(arg_tmplId)
    })
}
pub unsafe fn DefineTSConfiguration(
    arg_names: *mut List,
    arg_parameters: *mut List,
    arg_copied: *mut ObjectAddress,
) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DefineTSConfiguration(
                arg_names: *mut List,
                arg_parameters: *mut List,
                arg_copied: *mut ObjectAddress,
            ) -> ObjectAddress;
        }
        DefineTSConfiguration(arg_names, arg_parameters, arg_copied)
    })
}
pub unsafe fn RemoveTSConfigurationById(arg_cfgId: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RemoveTSConfigurationById(arg_cfgId: Oid);
        }
        RemoveTSConfigurationById(arg_cfgId)
    })
}
pub unsafe fn AlterTSConfiguration(arg_stmt: *mut AlterTSConfigurationStmt) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AlterTSConfiguration(arg_stmt: *mut AlterTSConfigurationStmt) -> ObjectAddress;
        }
        AlterTSConfiguration(arg_stmt)
    })
}
pub unsafe fn serialize_deflist(arg_deflist: *mut List) -> *mut text {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn serialize_deflist(arg_deflist: *mut List) -> *mut text;
        }
        serialize_deflist(arg_deflist)
    })
}
pub unsafe fn deserialize_deflist(arg_txt: Datum) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn deserialize_deflist(arg_txt: Datum) -> *mut List;
        }
        deserialize_deflist(arg_txt)
    })
}
pub unsafe fn AlterForeignServerOwner(
    arg_name: *const ::std::os::raw::c_char,
    arg_newOwnerId: Oid,
) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AlterForeignServerOwner(
                arg_name: *const ::std::os::raw::c_char,
                arg_newOwnerId: Oid,
            ) -> ObjectAddress;
        }
        AlterForeignServerOwner(arg_name, arg_newOwnerId)
    })
}
pub unsafe fn AlterForeignServerOwner_oid(arg_arg1: Oid, arg_newOwnerId: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AlterForeignServerOwner_oid(arg_arg1: Oid, arg_newOwnerId: Oid);
        }
        AlterForeignServerOwner_oid(arg_arg1, arg_newOwnerId)
    })
}
pub unsafe fn AlterForeignDataWrapperOwner(
    arg_name: *const ::std::os::raw::c_char,
    arg_newOwnerId: Oid,
) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AlterForeignDataWrapperOwner(
                arg_name: *const ::std::os::raw::c_char,
                arg_newOwnerId: Oid,
            ) -> ObjectAddress;
        }
        AlterForeignDataWrapperOwner(arg_name, arg_newOwnerId)
    })
}
pub unsafe fn AlterForeignDataWrapperOwner_oid(arg_fwdId: Oid, arg_newOwnerId: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AlterForeignDataWrapperOwner_oid(arg_fwdId: Oid, arg_newOwnerId: Oid);
        }
        AlterForeignDataWrapperOwner_oid(arg_fwdId, arg_newOwnerId)
    })
}
pub unsafe fn CreateForeignDataWrapper(arg_stmt: *mut CreateFdwStmt) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateForeignDataWrapper(arg_stmt: *mut CreateFdwStmt) -> ObjectAddress;
        }
        CreateForeignDataWrapper(arg_stmt)
    })
}
pub unsafe fn AlterForeignDataWrapper(arg_stmt: *mut AlterFdwStmt) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AlterForeignDataWrapper(arg_stmt: *mut AlterFdwStmt) -> ObjectAddress;
        }
        AlterForeignDataWrapper(arg_stmt)
    })
}
pub unsafe fn RemoveForeignDataWrapperById(arg_fdwId: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RemoveForeignDataWrapperById(arg_fdwId: Oid);
        }
        RemoveForeignDataWrapperById(arg_fdwId)
    })
}
pub unsafe fn CreateForeignServer(arg_stmt: *mut CreateForeignServerStmt) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateForeignServer(arg_stmt: *mut CreateForeignServerStmt) -> ObjectAddress;
        }
        CreateForeignServer(arg_stmt)
    })
}
pub unsafe fn AlterForeignServer(arg_stmt: *mut AlterForeignServerStmt) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AlterForeignServer(arg_stmt: *mut AlterForeignServerStmt) -> ObjectAddress;
        }
        AlterForeignServer(arg_stmt)
    })
}
pub unsafe fn RemoveForeignServerById(arg_srvId: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RemoveForeignServerById(arg_srvId: Oid);
        }
        RemoveForeignServerById(arg_srvId)
    })
}
pub unsafe fn CreateUserMapping(arg_stmt: *mut CreateUserMappingStmt) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateUserMapping(arg_stmt: *mut CreateUserMappingStmt) -> ObjectAddress;
        }
        CreateUserMapping(arg_stmt)
    })
}
pub unsafe fn AlterUserMapping(arg_stmt: *mut AlterUserMappingStmt) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AlterUserMapping(arg_stmt: *mut AlterUserMappingStmt) -> ObjectAddress;
        }
        AlterUserMapping(arg_stmt)
    })
}
pub unsafe fn RemoveUserMapping(arg_stmt: *mut DropUserMappingStmt) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RemoveUserMapping(arg_stmt: *mut DropUserMappingStmt) -> Oid;
        }
        RemoveUserMapping(arg_stmt)
    })
}
pub unsafe fn RemoveUserMappingById(arg_umId: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RemoveUserMappingById(arg_umId: Oid);
        }
        RemoveUserMappingById(arg_umId)
    })
}
pub unsafe fn CreateForeignTable(arg_stmt: *mut CreateForeignTableStmt, arg_relid: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateForeignTable(arg_stmt: *mut CreateForeignTableStmt, arg_relid: Oid);
        }
        CreateForeignTable(arg_stmt, arg_relid)
    })
}
pub unsafe fn ImportForeignSchema(arg_stmt: *mut ImportForeignSchemaStmt) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ImportForeignSchema(arg_stmt: *mut ImportForeignSchemaStmt);
        }
        ImportForeignSchema(arg_stmt)
    })
}
pub unsafe fn transformGenericOptions(
    arg_catalogId: Oid,
    arg_oldOptions: Datum,
    arg_options: *mut List,
    arg_fdwvalidator: Oid,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn transformGenericOptions(
                arg_catalogId: Oid,
                arg_oldOptions: Datum,
                arg_options: *mut List,
                arg_fdwvalidator: Oid,
            ) -> Datum;
        }
        transformGenericOptions(arg_catalogId, arg_oldOptions, arg_options, arg_fdwvalidator)
    })
}
pub unsafe fn CreateAccessMethod(arg_stmt: *mut CreateAmStmt) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateAccessMethod(arg_stmt: *mut CreateAmStmt) -> ObjectAddress;
        }
        CreateAccessMethod(arg_stmt)
    })
}
pub unsafe fn RemoveAccessMethodById(arg_amOid: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RemoveAccessMethodById(arg_amOid: Oid);
        }
        RemoveAccessMethodById(arg_amOid)
    })
}
pub unsafe fn get_index_am_oid(
    arg_amname: *const ::std::os::raw::c_char,
    arg_missing_ok: bool,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_index_am_oid(
                arg_amname: *const ::std::os::raw::c_char,
                arg_missing_ok: bool,
            ) -> Oid;
        }
        get_index_am_oid(arg_amname, arg_missing_ok)
    })
}
pub unsafe fn get_table_am_oid(
    arg_amname: *const ::std::os::raw::c_char,
    arg_missing_ok: bool,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_table_am_oid(
                arg_amname: *const ::std::os::raw::c_char,
                arg_missing_ok: bool,
            ) -> Oid;
        }
        get_table_am_oid(arg_amname, arg_missing_ok)
    })
}
pub unsafe fn get_am_oid(arg_amname: *const ::std::os::raw::c_char, arg_missing_ok: bool) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_am_oid(arg_amname: *const ::std::os::raw::c_char, arg_missing_ok: bool) -> Oid;
        }
        get_am_oid(arg_amname, arg_missing_ok)
    })
}
pub unsafe fn get_am_name(arg_amOid: Oid) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_am_name(arg_amOid: Oid) -> *mut ::std::os::raw::c_char;
        }
        get_am_name(arg_amOid)
    })
}
pub unsafe fn defGetString(arg_def: *mut DefElem) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn defGetString(arg_def: *mut DefElem) -> *mut ::std::os::raw::c_char;
        }
        defGetString(arg_def)
    })
}
pub unsafe fn defGetNumeric(arg_def: *mut DefElem) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn defGetNumeric(arg_def: *mut DefElem) -> f64;
        }
        defGetNumeric(arg_def)
    })
}
pub unsafe fn defGetBoolean(arg_def: *mut DefElem) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn defGetBoolean(arg_def: *mut DefElem) -> bool;
        }
        defGetBoolean(arg_def)
    })
}
pub unsafe fn defGetInt32(arg_def: *mut DefElem) -> int32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn defGetInt32(arg_def: *mut DefElem) -> int32;
        }
        defGetInt32(arg_def)
    })
}
pub unsafe fn defGetInt64(arg_def: *mut DefElem) -> int64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn defGetInt64(arg_def: *mut DefElem) -> int64;
        }
        defGetInt64(arg_def)
    })
}
pub unsafe fn defGetQualifiedName(arg_def: *mut DefElem) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn defGetQualifiedName(arg_def: *mut DefElem) -> *mut List;
        }
        defGetQualifiedName(arg_def)
    })
}
pub unsafe fn defGetTypeName(arg_def: *mut DefElem) -> *mut TypeName {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn defGetTypeName(arg_def: *mut DefElem) -> *mut TypeName;
        }
        defGetTypeName(arg_def)
    })
}
pub unsafe fn defGetTypeLength(arg_def: *mut DefElem) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn defGetTypeLength(arg_def: *mut DefElem) -> ::std::os::raw::c_int;
        }
        defGetTypeLength(arg_def)
    })
}
pub unsafe fn defGetStringList(arg_def: *mut DefElem) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn defGetStringList(arg_def: *mut DefElem) -> *mut List;
        }
        defGetStringList(arg_def)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FormData_pg_event_trigger {
    pub oid: Oid,
    pub evtname: NameData,
    pub evtevent: NameData,
    pub evtowner: Oid,
    pub evtfoid: Oid,
    pub evtenabled: ::std::os::raw::c_char,
}
impl Default for FormData_pg_event_trigger {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type Form_pg_event_trigger = *mut FormData_pg_event_trigger;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InternalGrant {
    pub is_grant: bool,
    pub objtype: ObjectType,
    pub objects: *mut List,
    pub all_privs: bool,
    pub privileges: AclMode,
    pub col_privs: *mut List,
    pub grantees: *mut List,
    pub grant_option: bool,
    pub behavior: DropBehavior,
}
impl Default for InternalGrant {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const CollectedCommandType_SCT_Simple: CollectedCommandType = 0;
pub const CollectedCommandType_SCT_AlterTable: CollectedCommandType = 1;
pub const CollectedCommandType_SCT_Grant: CollectedCommandType = 2;
pub const CollectedCommandType_SCT_AlterOpFamily: CollectedCommandType = 3;
pub const CollectedCommandType_SCT_AlterDefaultPrivileges: CollectedCommandType = 4;
pub const CollectedCommandType_SCT_CreateOpClass: CollectedCommandType = 5;
pub const CollectedCommandType_SCT_AlterTSConfig: CollectedCommandType = 6;
pub type CollectedCommandType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CollectedATSubcmd {
    pub address: ObjectAddress,
    pub parsetree: *mut Node,
}
impl Default for CollectedATSubcmd {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CollectedCommand {
    pub type_: CollectedCommandType,
    pub in_extension: bool,
    pub parsetree: *mut Node,
    pub d: CollectedCommand__bindgen_ty_1,
    pub parent: *mut CollectedCommand,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CollectedCommand__bindgen_ty_1 {
    pub simple: CollectedCommand__bindgen_ty_1__bindgen_ty_1,
    pub alterTable: CollectedCommand__bindgen_ty_1__bindgen_ty_2,
    pub grant: CollectedCommand__bindgen_ty_1__bindgen_ty_3,
    pub opfam: CollectedCommand__bindgen_ty_1__bindgen_ty_4,
    pub createopc: CollectedCommand__bindgen_ty_1__bindgen_ty_5,
    pub atscfg: CollectedCommand__bindgen_ty_1__bindgen_ty_6,
    pub defprivs: CollectedCommand__bindgen_ty_1__bindgen_ty_7,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CollectedCommand__bindgen_ty_1__bindgen_ty_1 {
    pub address: ObjectAddress,
    pub secondaryObject: ObjectAddress,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CollectedCommand__bindgen_ty_1__bindgen_ty_2 {
    pub objectId: Oid,
    pub classId: Oid,
    pub subcmds: *mut List,
}
impl Default for CollectedCommand__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CollectedCommand__bindgen_ty_1__bindgen_ty_3 {
    pub istmt: *mut InternalGrant,
}
impl Default for CollectedCommand__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CollectedCommand__bindgen_ty_1__bindgen_ty_4 {
    pub address: ObjectAddress,
    pub operators: *mut List,
    pub procedures: *mut List,
}
impl Default for CollectedCommand__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CollectedCommand__bindgen_ty_1__bindgen_ty_5 {
    pub address: ObjectAddress,
    pub operators: *mut List,
    pub procedures: *mut List,
}
impl Default for CollectedCommand__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CollectedCommand__bindgen_ty_1__bindgen_ty_6 {
    pub address: ObjectAddress,
    pub dictIds: *mut Oid,
    pub ndicts: ::std::os::raw::c_int,
}
impl Default for CollectedCommand__bindgen_ty_1__bindgen_ty_6 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CollectedCommand__bindgen_ty_1__bindgen_ty_7 {
    pub objtype: ObjectType,
}
impl Default for CollectedCommand__bindgen_ty_1__bindgen_ty_7 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for CollectedCommand__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for CollectedCommand {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EventTriggerData {
    pub type_: NodeTag,
    pub event: *const ::std::os::raw::c_char,
    pub parsetree: *mut Node,
    pub tag: CommandTag,
}
impl Default for EventTriggerData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn CreateEventTrigger(arg_stmt: *mut CreateEventTrigStmt) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateEventTrigger(arg_stmt: *mut CreateEventTrigStmt) -> Oid;
        }
        CreateEventTrigger(arg_stmt)
    })
}
pub unsafe fn RemoveEventTriggerById(arg_trigOid: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RemoveEventTriggerById(arg_trigOid: Oid);
        }
        RemoveEventTriggerById(arg_trigOid)
    })
}
pub unsafe fn get_event_trigger_oid(
    arg_trigname: *const ::std::os::raw::c_char,
    arg_missing_ok: bool,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_event_trigger_oid(
                arg_trigname: *const ::std::os::raw::c_char,
                arg_missing_ok: bool,
            ) -> Oid;
        }
        get_event_trigger_oid(arg_trigname, arg_missing_ok)
    })
}
pub unsafe fn AlterEventTrigger(arg_stmt: *mut AlterEventTrigStmt) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AlterEventTrigger(arg_stmt: *mut AlterEventTrigStmt) -> Oid;
        }
        AlterEventTrigger(arg_stmt)
    })
}
pub unsafe fn AlterEventTriggerOwner(
    arg_name: *const ::std::os::raw::c_char,
    arg_newOwnerId: Oid,
) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AlterEventTriggerOwner(
                arg_name: *const ::std::os::raw::c_char,
                arg_newOwnerId: Oid,
            ) -> ObjectAddress;
        }
        AlterEventTriggerOwner(arg_name, arg_newOwnerId)
    })
}
pub unsafe fn AlterEventTriggerOwner_oid(arg_arg1: Oid, arg_newOwnerId: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AlterEventTriggerOwner_oid(arg_arg1: Oid, arg_newOwnerId: Oid);
        }
        AlterEventTriggerOwner_oid(arg_arg1, arg_newOwnerId)
    })
}
pub unsafe fn EventTriggerSupportsObjectType(arg_obtype: ObjectType) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EventTriggerSupportsObjectType(arg_obtype: ObjectType) -> bool;
        }
        EventTriggerSupportsObjectType(arg_obtype)
    })
}
pub unsafe fn EventTriggerSupportsObjectClass(arg_objclass: ObjectClass) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EventTriggerSupportsObjectClass(arg_objclass: ObjectClass) -> bool;
        }
        EventTriggerSupportsObjectClass(arg_objclass)
    })
}
pub unsafe fn EventTriggerDDLCommandStart(arg_parsetree: *mut Node) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EventTriggerDDLCommandStart(arg_parsetree: *mut Node);
        }
        EventTriggerDDLCommandStart(arg_parsetree)
    })
}
pub unsafe fn EventTriggerDDLCommandEnd(arg_parsetree: *mut Node) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EventTriggerDDLCommandEnd(arg_parsetree: *mut Node);
        }
        EventTriggerDDLCommandEnd(arg_parsetree)
    })
}
pub unsafe fn EventTriggerSQLDrop(arg_parsetree: *mut Node) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EventTriggerSQLDrop(arg_parsetree: *mut Node);
        }
        EventTriggerSQLDrop(arg_parsetree)
    })
}
pub unsafe fn EventTriggerTableRewrite(
    arg_parsetree: *mut Node,
    arg_tableOid: Oid,
    arg_reason: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EventTriggerTableRewrite(
                arg_parsetree: *mut Node,
                arg_tableOid: Oid,
                arg_reason: ::std::os::raw::c_int,
            );
        }
        EventTriggerTableRewrite(arg_parsetree, arg_tableOid, arg_reason)
    })
}
pub unsafe fn EventTriggerBeginCompleteQuery() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EventTriggerBeginCompleteQuery() -> bool;
        }
        EventTriggerBeginCompleteQuery()
    })
}
pub unsafe fn EventTriggerEndCompleteQuery() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EventTriggerEndCompleteQuery();
        }
        EventTriggerEndCompleteQuery()
    })
}
pub unsafe fn trackDroppedObjectsNeeded() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn trackDroppedObjectsNeeded() -> bool;
        }
        trackDroppedObjectsNeeded()
    })
}
pub unsafe fn EventTriggerSQLDropAddObject(
    arg_object: *const ObjectAddress,
    arg_original: bool,
    arg_normal: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EventTriggerSQLDropAddObject(
                arg_object: *const ObjectAddress,
                arg_original: bool,
                arg_normal: bool,
            );
        }
        EventTriggerSQLDropAddObject(arg_object, arg_original, arg_normal)
    })
}
pub unsafe fn EventTriggerInhibitCommandCollection() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EventTriggerInhibitCommandCollection();
        }
        EventTriggerInhibitCommandCollection()
    })
}
pub unsafe fn EventTriggerUndoInhibitCommandCollection() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EventTriggerUndoInhibitCommandCollection();
        }
        EventTriggerUndoInhibitCommandCollection()
    })
}
pub unsafe fn EventTriggerCollectSimpleCommand(
    arg_address: ObjectAddress,
    arg_secondaryObject: ObjectAddress,
    arg_parsetree: *mut Node,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EventTriggerCollectSimpleCommand(
                arg_address: ObjectAddress,
                arg_secondaryObject: ObjectAddress,
                arg_parsetree: *mut Node,
            );
        }
        EventTriggerCollectSimpleCommand(arg_address, arg_secondaryObject, arg_parsetree)
    })
}
pub unsafe fn EventTriggerAlterTableStart(arg_parsetree: *mut Node) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EventTriggerAlterTableStart(arg_parsetree: *mut Node);
        }
        EventTriggerAlterTableStart(arg_parsetree)
    })
}
pub unsafe fn EventTriggerAlterTableRelid(arg_objectId: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EventTriggerAlterTableRelid(arg_objectId: Oid);
        }
        EventTriggerAlterTableRelid(arg_objectId)
    })
}
pub unsafe fn EventTriggerCollectAlterTableSubcmd(
    arg_subcmd: *mut Node,
    arg_address: ObjectAddress,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EventTriggerCollectAlterTableSubcmd(
                arg_subcmd: *mut Node,
                arg_address: ObjectAddress,
            );
        }
        EventTriggerCollectAlterTableSubcmd(arg_subcmd, arg_address)
    })
}
pub unsafe fn EventTriggerAlterTableEnd() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EventTriggerAlterTableEnd();
        }
        EventTriggerAlterTableEnd()
    })
}
pub unsafe fn EventTriggerCollectGrant(arg_istmt: *mut InternalGrant) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EventTriggerCollectGrant(arg_istmt: *mut InternalGrant);
        }
        EventTriggerCollectGrant(arg_istmt)
    })
}
pub unsafe fn EventTriggerCollectAlterOpFam(
    arg_stmt: *mut AlterOpFamilyStmt,
    arg_opfamoid: Oid,
    arg_operators: *mut List,
    arg_procedures: *mut List,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EventTriggerCollectAlterOpFam(
                arg_stmt: *mut AlterOpFamilyStmt,
                arg_opfamoid: Oid,
                arg_operators: *mut List,
                arg_procedures: *mut List,
            );
        }
        EventTriggerCollectAlterOpFam(arg_stmt, arg_opfamoid, arg_operators, arg_procedures)
    })
}
pub unsafe fn EventTriggerCollectCreateOpClass(
    arg_stmt: *mut CreateOpClassStmt,
    arg_opcoid: Oid,
    arg_operators: *mut List,
    arg_procedures: *mut List,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EventTriggerCollectCreateOpClass(
                arg_stmt: *mut CreateOpClassStmt,
                arg_opcoid: Oid,
                arg_operators: *mut List,
                arg_procedures: *mut List,
            );
        }
        EventTriggerCollectCreateOpClass(arg_stmt, arg_opcoid, arg_operators, arg_procedures)
    })
}
pub unsafe fn EventTriggerCollectAlterTSConfig(
    arg_stmt: *mut AlterTSConfigurationStmt,
    arg_cfgId: Oid,
    arg_dictIds: *mut Oid,
    arg_ndicts: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EventTriggerCollectAlterTSConfig(
                arg_stmt: *mut AlterTSConfigurationStmt,
                arg_cfgId: Oid,
                arg_dictIds: *mut Oid,
                arg_ndicts: ::std::os::raw::c_int,
            );
        }
        EventTriggerCollectAlterTSConfig(arg_stmt, arg_cfgId, arg_dictIds, arg_ndicts)
    })
}
pub unsafe fn EventTriggerCollectAlterDefPrivs(arg_stmt: *mut AlterDefaultPrivilegesStmt) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EventTriggerCollectAlterDefPrivs(arg_stmt: *mut AlterDefaultPrivilegesStmt);
        }
        EventTriggerCollectAlterDefPrivs(arg_stmt)
    })
}
pub const ExplainFormat_EXPLAIN_FORMAT_TEXT: ExplainFormat = 0;
pub const ExplainFormat_EXPLAIN_FORMAT_XML: ExplainFormat = 1;
pub const ExplainFormat_EXPLAIN_FORMAT_JSON: ExplainFormat = 2;
pub const ExplainFormat_EXPLAIN_FORMAT_YAML: ExplainFormat = 3;
pub type ExplainFormat = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExplainWorkersState {
    pub num_workers: ::std::os::raw::c_int,
    pub worker_inited: *mut bool,
    pub worker_str: *mut StringInfoData,
    pub worker_state_save: *mut ::std::os::raw::c_int,
    pub prev_str: StringInfo,
}
impl Default for ExplainWorkersState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExplainState {
    pub str_: StringInfo,
    pub verbose: bool,
    pub analyze: bool,
    pub costs: bool,
    pub buffers: bool,
    pub wal: bool,
    pub timing: bool,
    pub summary: bool,
    pub settings: bool,
    pub format: ExplainFormat,
    pub indent: ::std::os::raw::c_int,
    pub grouping_stack: *mut List,
    pub pstmt: *mut PlannedStmt,
    pub rtable: *mut List,
    pub rtable_names: *mut List,
    pub deparse_cxt: *mut List,
    pub printed_subplans: *mut Bitmapset,
    pub hide_workers: bool,
    pub workers_state: *mut ExplainWorkersState,
}
impl Default for ExplainState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ExplainOneQuery_hook_type = ::std::option::Option<
    unsafe extern "C" fn(
        query: *mut Query,
        cursorOptions: ::std::os::raw::c_int,
        into: *mut IntoClause,
        es: *mut ExplainState,
        queryString: *const ::std::os::raw::c_char,
        params: ParamListInfo,
        queryEnv: *mut QueryEnvironment,
    ),
>;
extern "C" {
    pub static mut ExplainOneQuery_hook: ExplainOneQuery_hook_type;
}
pub type explain_get_index_name_hook_type =
    ::std::option::Option<unsafe extern "C" fn(indexId: Oid) -> *const ::std::os::raw::c_char>;
extern "C" {
    pub static mut explain_get_index_name_hook: explain_get_index_name_hook_type;
}
pub unsafe fn ExplainQuery(
    arg_pstate: *mut ParseState,
    arg_stmt: *mut ExplainStmt,
    arg_params: ParamListInfo,
    arg_dest: *mut DestReceiver,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExplainQuery(
                arg_pstate: *mut ParseState,
                arg_stmt: *mut ExplainStmt,
                arg_params: ParamListInfo,
                arg_dest: *mut DestReceiver,
            );
        }
        ExplainQuery(arg_pstate, arg_stmt, arg_params, arg_dest)
    })
}
pub unsafe fn NewExplainState() -> *mut ExplainState {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn NewExplainState() -> *mut ExplainState;
        }
        NewExplainState()
    })
}
pub unsafe fn ExplainResultDesc(arg_stmt: *mut ExplainStmt) -> TupleDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExplainResultDesc(arg_stmt: *mut ExplainStmt) -> TupleDesc;
        }
        ExplainResultDesc(arg_stmt)
    })
}
pub unsafe fn ExplainOneUtility(
    arg_utilityStmt: *mut Node,
    arg_into: *mut IntoClause,
    arg_es: *mut ExplainState,
    arg_queryString: *const ::std::os::raw::c_char,
    arg_params: ParamListInfo,
    arg_queryEnv: *mut QueryEnvironment,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExplainOneUtility(
                arg_utilityStmt: *mut Node,
                arg_into: *mut IntoClause,
                arg_es: *mut ExplainState,
                arg_queryString: *const ::std::os::raw::c_char,
                arg_params: ParamListInfo,
                arg_queryEnv: *mut QueryEnvironment,
            );
        }
        ExplainOneUtility(
            arg_utilityStmt,
            arg_into,
            arg_es,
            arg_queryString,
            arg_params,
            arg_queryEnv,
        )
    })
}
pub unsafe fn ExplainOnePlan(
    arg_plannedstmt: *mut PlannedStmt,
    arg_into: *mut IntoClause,
    arg_es: *mut ExplainState,
    arg_queryString: *const ::std::os::raw::c_char,
    arg_params: ParamListInfo,
    arg_queryEnv: *mut QueryEnvironment,
    arg_planduration: *const instr_time,
    arg_bufusage: *const BufferUsage,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExplainOnePlan(
                arg_plannedstmt: *mut PlannedStmt,
                arg_into: *mut IntoClause,
                arg_es: *mut ExplainState,
                arg_queryString: *const ::std::os::raw::c_char,
                arg_params: ParamListInfo,
                arg_queryEnv: *mut QueryEnvironment,
                arg_planduration: *const instr_time,
                arg_bufusage: *const BufferUsage,
            );
        }
        ExplainOnePlan(
            arg_plannedstmt,
            arg_into,
            arg_es,
            arg_queryString,
            arg_params,
            arg_queryEnv,
            arg_planduration,
            arg_bufusage,
        )
    })
}
pub unsafe fn ExplainPrintPlan(arg_es: *mut ExplainState, arg_queryDesc: *mut QueryDesc) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExplainPrintPlan(arg_es: *mut ExplainState, arg_queryDesc: *mut QueryDesc);
        }
        ExplainPrintPlan(arg_es, arg_queryDesc)
    })
}
pub unsafe fn ExplainPrintTriggers(arg_es: *mut ExplainState, arg_queryDesc: *mut QueryDesc) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExplainPrintTriggers(arg_es: *mut ExplainState, arg_queryDesc: *mut QueryDesc);
        }
        ExplainPrintTriggers(arg_es, arg_queryDesc)
    })
}
pub unsafe fn ExplainPrintJITSummary(arg_es: *mut ExplainState, arg_queryDesc: *mut QueryDesc) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExplainPrintJITSummary(arg_es: *mut ExplainState, arg_queryDesc: *mut QueryDesc);
        }
        ExplainPrintJITSummary(arg_es, arg_queryDesc)
    })
}
pub unsafe fn ExplainQueryText(arg_es: *mut ExplainState, arg_queryDesc: *mut QueryDesc) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExplainQueryText(arg_es: *mut ExplainState, arg_queryDesc: *mut QueryDesc);
        }
        ExplainQueryText(arg_es, arg_queryDesc)
    })
}
pub unsafe fn ExplainBeginOutput(arg_es: *mut ExplainState) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExplainBeginOutput(arg_es: *mut ExplainState);
        }
        ExplainBeginOutput(arg_es)
    })
}
pub unsafe fn ExplainEndOutput(arg_es: *mut ExplainState) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExplainEndOutput(arg_es: *mut ExplainState);
        }
        ExplainEndOutput(arg_es)
    })
}
pub unsafe fn ExplainSeparatePlans(arg_es: *mut ExplainState) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExplainSeparatePlans(arg_es: *mut ExplainState);
        }
        ExplainSeparatePlans(arg_es)
    })
}
pub unsafe fn ExplainPropertyList(
    arg_qlabel: *const ::std::os::raw::c_char,
    arg_data: *mut List,
    arg_es: *mut ExplainState,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExplainPropertyList(
                arg_qlabel: *const ::std::os::raw::c_char,
                arg_data: *mut List,
                arg_es: *mut ExplainState,
            );
        }
        ExplainPropertyList(arg_qlabel, arg_data, arg_es)
    })
}
pub unsafe fn ExplainPropertyListNested(
    arg_qlabel: *const ::std::os::raw::c_char,
    arg_data: *mut List,
    arg_es: *mut ExplainState,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExplainPropertyListNested(
                arg_qlabel: *const ::std::os::raw::c_char,
                arg_data: *mut List,
                arg_es: *mut ExplainState,
            );
        }
        ExplainPropertyListNested(arg_qlabel, arg_data, arg_es)
    })
}
pub unsafe fn ExplainPropertyText(
    arg_qlabel: *const ::std::os::raw::c_char,
    arg_value: *const ::std::os::raw::c_char,
    arg_es: *mut ExplainState,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExplainPropertyText(
                arg_qlabel: *const ::std::os::raw::c_char,
                arg_value: *const ::std::os::raw::c_char,
                arg_es: *mut ExplainState,
            );
        }
        ExplainPropertyText(arg_qlabel, arg_value, arg_es)
    })
}
pub unsafe fn ExplainPropertyInteger(
    arg_qlabel: *const ::std::os::raw::c_char,
    arg_unit: *const ::std::os::raw::c_char,
    arg_value: int64,
    arg_es: *mut ExplainState,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExplainPropertyInteger(
                arg_qlabel: *const ::std::os::raw::c_char,
                arg_unit: *const ::std::os::raw::c_char,
                arg_value: int64,
                arg_es: *mut ExplainState,
            );
        }
        ExplainPropertyInteger(arg_qlabel, arg_unit, arg_value, arg_es)
    })
}
pub unsafe fn ExplainPropertyUInteger(
    arg_qlabel: *const ::std::os::raw::c_char,
    arg_unit: *const ::std::os::raw::c_char,
    arg_value: uint64,
    arg_es: *mut ExplainState,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExplainPropertyUInteger(
                arg_qlabel: *const ::std::os::raw::c_char,
                arg_unit: *const ::std::os::raw::c_char,
                arg_value: uint64,
                arg_es: *mut ExplainState,
            );
        }
        ExplainPropertyUInteger(arg_qlabel, arg_unit, arg_value, arg_es)
    })
}
pub unsafe fn ExplainPropertyFloat(
    arg_qlabel: *const ::std::os::raw::c_char,
    arg_unit: *const ::std::os::raw::c_char,
    arg_value: f64,
    arg_ndigits: ::std::os::raw::c_int,
    arg_es: *mut ExplainState,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExplainPropertyFloat(
                arg_qlabel: *const ::std::os::raw::c_char,
                arg_unit: *const ::std::os::raw::c_char,
                arg_value: f64,
                arg_ndigits: ::std::os::raw::c_int,
                arg_es: *mut ExplainState,
            );
        }
        ExplainPropertyFloat(arg_qlabel, arg_unit, arg_value, arg_ndigits, arg_es)
    })
}
pub unsafe fn ExplainPropertyBool(
    arg_qlabel: *const ::std::os::raw::c_char,
    arg_value: bool,
    arg_es: *mut ExplainState,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExplainPropertyBool(
                arg_qlabel: *const ::std::os::raw::c_char,
                arg_value: bool,
                arg_es: *mut ExplainState,
            );
        }
        ExplainPropertyBool(arg_qlabel, arg_value, arg_es)
    })
}
pub unsafe fn ExplainOpenGroup(
    arg_objtype: *const ::std::os::raw::c_char,
    arg_labelname: *const ::std::os::raw::c_char,
    arg_labeled: bool,
    arg_es: *mut ExplainState,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExplainOpenGroup(
                arg_objtype: *const ::std::os::raw::c_char,
                arg_labelname: *const ::std::os::raw::c_char,
                arg_labeled: bool,
                arg_es: *mut ExplainState,
            );
        }
        ExplainOpenGroup(arg_objtype, arg_labelname, arg_labeled, arg_es)
    })
}
pub unsafe fn ExplainCloseGroup(
    arg_objtype: *const ::std::os::raw::c_char,
    arg_labelname: *const ::std::os::raw::c_char,
    arg_labeled: bool,
    arg_es: *mut ExplainState,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExplainCloseGroup(
                arg_objtype: *const ::std::os::raw::c_char,
                arg_labelname: *const ::std::os::raw::c_char,
                arg_labeled: bool,
                arg_es: *mut ExplainState,
            );
        }
        ExplainCloseGroup(arg_objtype, arg_labelname, arg_labeled, arg_es)
    })
}
pub unsafe fn CreateProceduralLanguage(arg_stmt: *mut CreatePLangStmt) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateProceduralLanguage(arg_stmt: *mut CreatePLangStmt) -> ObjectAddress;
        }
        CreateProceduralLanguage(arg_stmt)
    })
}
pub unsafe fn DropProceduralLanguageById(arg_langOid: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DropProceduralLanguageById(arg_langOid: Oid);
        }
        DropProceduralLanguageById(arg_langOid)
    })
}
pub unsafe fn get_language_oid(
    arg_langname: *const ::std::os::raw::c_char,
    arg_missing_ok: bool,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_language_oid(
                arg_langname: *const ::std::os::raw::c_char,
                arg_missing_ok: bool,
            ) -> Oid;
        }
        get_language_oid(arg_langname, arg_missing_ok)
    })
}
pub unsafe fn DefineRelation(
    arg_stmt: *mut CreateStmt,
    arg_relkind: ::std::os::raw::c_char,
    arg_ownerId: Oid,
    arg_typaddress: *mut ObjectAddress,
    arg_queryString: *const ::std::os::raw::c_char,
) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DefineRelation(
                arg_stmt: *mut CreateStmt,
                arg_relkind: ::std::os::raw::c_char,
                arg_ownerId: Oid,
                arg_typaddress: *mut ObjectAddress,
                arg_queryString: *const ::std::os::raw::c_char,
            ) -> ObjectAddress;
        }
        DefineRelation(arg_stmt, arg_relkind, arg_ownerId, arg_typaddress, arg_queryString)
    })
}
pub unsafe fn RemoveRelations(arg_drop: *mut DropStmt) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RemoveRelations(arg_drop: *mut DropStmt);
        }
        RemoveRelations(arg_drop)
    })
}
pub unsafe fn AlterTableLookupRelation(
    arg_stmt: *mut AlterTableStmt,
    arg_lockmode: LOCKMODE,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AlterTableLookupRelation(
                arg_stmt: *mut AlterTableStmt,
                arg_lockmode: LOCKMODE,
            ) -> Oid;
        }
        AlterTableLookupRelation(arg_stmt, arg_lockmode)
    })
}
pub unsafe fn AlterTable(
    arg_stmt: *mut AlterTableStmt,
    arg_lockmode: LOCKMODE,
    arg_context: *mut AlterTableUtilityContext,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AlterTable(
                arg_stmt: *mut AlterTableStmt,
                arg_lockmode: LOCKMODE,
                arg_context: *mut AlterTableUtilityContext,
            );
        }
        AlterTable(arg_stmt, arg_lockmode, arg_context)
    })
}
pub unsafe fn AlterTableGetLockLevel(arg_cmds: *mut List) -> LOCKMODE {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AlterTableGetLockLevel(arg_cmds: *mut List) -> LOCKMODE;
        }
        AlterTableGetLockLevel(arg_cmds)
    })
}
pub unsafe fn ATExecChangeOwner(
    arg_relationOid: Oid,
    arg_newOwnerId: Oid,
    arg_recursing: bool,
    arg_lockmode: LOCKMODE,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ATExecChangeOwner(
                arg_relationOid: Oid,
                arg_newOwnerId: Oid,
                arg_recursing: bool,
                arg_lockmode: LOCKMODE,
            );
        }
        ATExecChangeOwner(arg_relationOid, arg_newOwnerId, arg_recursing, arg_lockmode)
    })
}
pub unsafe fn AlterTableInternal(arg_relid: Oid, arg_cmds: *mut List, arg_recurse: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AlterTableInternal(arg_relid: Oid, arg_cmds: *mut List, arg_recurse: bool);
        }
        AlterTableInternal(arg_relid, arg_cmds, arg_recurse)
    })
}
pub unsafe fn AlterTableMoveAll(arg_stmt: *mut AlterTableMoveAllStmt) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AlterTableMoveAll(arg_stmt: *mut AlterTableMoveAllStmt) -> Oid;
        }
        AlterTableMoveAll(arg_stmt)
    })
}
pub unsafe fn AlterTableNamespace(
    arg_stmt: *mut AlterObjectSchemaStmt,
    arg_oldschema: *mut Oid,
) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AlterTableNamespace(
                arg_stmt: *mut AlterObjectSchemaStmt,
                arg_oldschema: *mut Oid,
            ) -> ObjectAddress;
        }
        AlterTableNamespace(arg_stmt, arg_oldschema)
    })
}
pub unsafe fn AlterTableNamespaceInternal(
    arg_rel: Relation,
    arg_oldNspOid: Oid,
    arg_nspOid: Oid,
    arg_objsMoved: *mut ObjectAddresses,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AlterTableNamespaceInternal(
                arg_rel: Relation,
                arg_oldNspOid: Oid,
                arg_nspOid: Oid,
                arg_objsMoved: *mut ObjectAddresses,
            );
        }
        AlterTableNamespaceInternal(arg_rel, arg_oldNspOid, arg_nspOid, arg_objsMoved)
    })
}
pub unsafe fn AlterRelationNamespaceInternal(
    arg_classRel: Relation,
    arg_relOid: Oid,
    arg_oldNspOid: Oid,
    arg_newNspOid: Oid,
    arg_hasDependEntry: bool,
    arg_objsMoved: *mut ObjectAddresses,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AlterRelationNamespaceInternal(
                arg_classRel: Relation,
                arg_relOid: Oid,
                arg_oldNspOid: Oid,
                arg_newNspOid: Oid,
                arg_hasDependEntry: bool,
                arg_objsMoved: *mut ObjectAddresses,
            );
        }
        AlterRelationNamespaceInternal(
            arg_classRel,
            arg_relOid,
            arg_oldNspOid,
            arg_newNspOid,
            arg_hasDependEntry,
            arg_objsMoved,
        )
    })
}
pub unsafe fn CheckTableNotInUse(arg_rel: Relation, arg_stmt: *const ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CheckTableNotInUse(arg_rel: Relation, arg_stmt: *const ::std::os::raw::c_char);
        }
        CheckTableNotInUse(arg_rel, arg_stmt)
    })
}
pub unsafe fn ExecuteTruncate(arg_stmt: *mut TruncateStmt) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecuteTruncate(arg_stmt: *mut TruncateStmt);
        }
        ExecuteTruncate(arg_stmt)
    })
}
pub unsafe fn ExecuteTruncateGuts(
    arg_explicit_rels: *mut List,
    arg_relids: *mut List,
    arg_relids_logged: *mut List,
    arg_behavior: DropBehavior,
    arg_restart_seqs: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecuteTruncateGuts(
                arg_explicit_rels: *mut List,
                arg_relids: *mut List,
                arg_relids_logged: *mut List,
                arg_behavior: DropBehavior,
                arg_restart_seqs: bool,
            );
        }
        ExecuteTruncateGuts(
            arg_explicit_rels,
            arg_relids,
            arg_relids_logged,
            arg_behavior,
            arg_restart_seqs,
        )
    })
}
pub unsafe fn SetRelationHasSubclass(arg_relationId: Oid, arg_relhassubclass: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SetRelationHasSubclass(arg_relationId: Oid, arg_relhassubclass: bool);
        }
        SetRelationHasSubclass(arg_relationId, arg_relhassubclass)
    })
}
pub unsafe fn renameatt(arg_stmt: *mut RenameStmt) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn renameatt(arg_stmt: *mut RenameStmt) -> ObjectAddress;
        }
        renameatt(arg_stmt)
    })
}
pub unsafe fn RenameConstraint(arg_stmt: *mut RenameStmt) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RenameConstraint(arg_stmt: *mut RenameStmt) -> ObjectAddress;
        }
        RenameConstraint(arg_stmt)
    })
}
pub unsafe fn RenameRelation(arg_stmt: *mut RenameStmt) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RenameRelation(arg_stmt: *mut RenameStmt) -> ObjectAddress;
        }
        RenameRelation(arg_stmt)
    })
}
pub unsafe fn RenameRelationInternal(
    arg_myrelid: Oid,
    arg_newrelname: *const ::std::os::raw::c_char,
    arg_is_internal: bool,
    arg_is_index: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RenameRelationInternal(
                arg_myrelid: Oid,
                arg_newrelname: *const ::std::os::raw::c_char,
                arg_is_internal: bool,
                arg_is_index: bool,
            );
        }
        RenameRelationInternal(arg_myrelid, arg_newrelname, arg_is_internal, arg_is_index)
    })
}
pub unsafe fn ResetRelRewrite(arg_myrelid: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ResetRelRewrite(arg_myrelid: Oid);
        }
        ResetRelRewrite(arg_myrelid)
    })
}
pub unsafe fn find_composite_type_dependencies(
    arg_typeOid: Oid,
    arg_origRelation: Relation,
    arg_origTypeName: *const ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn find_composite_type_dependencies(
                arg_typeOid: Oid,
                arg_origRelation: Relation,
                arg_origTypeName: *const ::std::os::raw::c_char,
            );
        }
        find_composite_type_dependencies(arg_typeOid, arg_origRelation, arg_origTypeName)
    })
}
pub unsafe fn check_of_type(arg_typetuple: HeapTuple) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn check_of_type(arg_typetuple: HeapTuple);
        }
        check_of_type(arg_typetuple)
    })
}
pub unsafe fn register_on_commit_action(arg_relid: Oid, arg_action: OnCommitAction) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn register_on_commit_action(arg_relid: Oid, arg_action: OnCommitAction);
        }
        register_on_commit_action(arg_relid, arg_action)
    })
}
pub unsafe fn remove_on_commit_action(arg_relid: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn remove_on_commit_action(arg_relid: Oid);
        }
        remove_on_commit_action(arg_relid)
    })
}
pub unsafe fn PreCommit_on_commit_actions() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PreCommit_on_commit_actions();
        }
        PreCommit_on_commit_actions()
    })
}
pub unsafe fn AtEOXact_on_commit_actions(arg_isCommit: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AtEOXact_on_commit_actions(arg_isCommit: bool);
        }
        AtEOXact_on_commit_actions(arg_isCommit)
    })
}
pub unsafe fn AtEOSubXact_on_commit_actions(
    arg_isCommit: bool,
    arg_mySubid: SubTransactionId,
    arg_parentSubid: SubTransactionId,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AtEOSubXact_on_commit_actions(
                arg_isCommit: bool,
                arg_mySubid: SubTransactionId,
                arg_parentSubid: SubTransactionId,
            );
        }
        AtEOSubXact_on_commit_actions(arg_isCommit, arg_mySubid, arg_parentSubid)
    })
}
pub unsafe fn RangeVarCallbackOwnsTable(
    arg_relation: *const RangeVar,
    arg_relId: Oid,
    arg_oldRelId: Oid,
    arg_arg: *mut ::std::os::raw::c_void,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RangeVarCallbackOwnsTable(
                arg_relation: *const RangeVar,
                arg_relId: Oid,
                arg_oldRelId: Oid,
                arg_arg: *mut ::std::os::raw::c_void,
            );
        }
        RangeVarCallbackOwnsTable(arg_relation, arg_relId, arg_oldRelId, arg_arg)
    })
}
pub unsafe fn RangeVarCallbackOwnsRelation(
    arg_relation: *const RangeVar,
    arg_relId: Oid,
    arg_oldRelId: Oid,
    arg_arg: *mut ::std::os::raw::c_void,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RangeVarCallbackOwnsRelation(
                arg_relation: *const RangeVar,
                arg_relId: Oid,
                arg_oldRelId: Oid,
                arg_arg: *mut ::std::os::raw::c_void,
            );
        }
        RangeVarCallbackOwnsRelation(arg_relation, arg_relId, arg_oldRelId, arg_arg)
    })
}
pub unsafe fn PartConstraintImpliedByRelConstraint(
    arg_scanrel: Relation,
    arg_partConstraint: *mut List,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PartConstraintImpliedByRelConstraint(
                arg_scanrel: Relation,
                arg_partConstraint: *mut List,
            ) -> bool;
        }
        PartConstraintImpliedByRelConstraint(arg_scanrel, arg_partConstraint)
    })
}
pub type TriggerEvent = uint32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TriggerData {
    pub type_: NodeTag,
    pub tg_event: TriggerEvent,
    pub tg_relation: Relation,
    pub tg_trigtuple: HeapTuple,
    pub tg_newtuple: HeapTuple,
    pub tg_trigger: *mut Trigger,
    pub tg_trigslot: *mut TupleTableSlot,
    pub tg_newslot: *mut TupleTableSlot,
    pub tg_oldtable: *mut Tuplestorestate,
    pub tg_newtable: *mut Tuplestorestate,
    pub tg_updatedcols: *const Bitmapset,
}
impl Default for TriggerData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AfterTriggersTableData {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TransitionCaptureState {
    pub tcs_delete_old_table: bool,
    pub tcs_update_old_table: bool,
    pub tcs_update_new_table: bool,
    pub tcs_insert_new_table: bool,
    pub tcs_map: *mut TupleConversionMap,
    pub tcs_original_insert_tuple: *mut TupleTableSlot,
    pub tcs_private: *mut AfterTriggersTableData,
}
impl Default for TransitionCaptureState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut SessionReplicationRole: ::std::os::raw::c_int;
}
pub unsafe fn CreateTrigger(
    arg_stmt: *mut CreateTrigStmt,
    arg_queryString: *const ::std::os::raw::c_char,
    arg_relOid: Oid,
    arg_refRelOid: Oid,
    arg_constraintOid: Oid,
    arg_indexOid: Oid,
    arg_funcoid: Oid,
    arg_parentTriggerOid: Oid,
    arg_whenClause: *mut Node,
    arg_isInternal: bool,
    arg_in_partition: bool,
) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateTrigger(
                arg_stmt: *mut CreateTrigStmt,
                arg_queryString: *const ::std::os::raw::c_char,
                arg_relOid: Oid,
                arg_refRelOid: Oid,
                arg_constraintOid: Oid,
                arg_indexOid: Oid,
                arg_funcoid: Oid,
                arg_parentTriggerOid: Oid,
                arg_whenClause: *mut Node,
                arg_isInternal: bool,
                arg_in_partition: bool,
            ) -> ObjectAddress;
        }
        CreateTrigger(
            arg_stmt,
            arg_queryString,
            arg_relOid,
            arg_refRelOid,
            arg_constraintOid,
            arg_indexOid,
            arg_funcoid,
            arg_parentTriggerOid,
            arg_whenClause,
            arg_isInternal,
            arg_in_partition,
        )
    })
}
pub unsafe fn CreateTriggerFiringOn(
    arg_stmt: *mut CreateTrigStmt,
    arg_queryString: *const ::std::os::raw::c_char,
    arg_relOid: Oid,
    arg_refRelOid: Oid,
    arg_constraintOid: Oid,
    arg_indexOid: Oid,
    arg_funcoid: Oid,
    arg_parentTriggerOid: Oid,
    arg_whenClause: *mut Node,
    arg_isInternal: bool,
    arg_in_partition: bool,
    arg_trigger_fires_when: ::std::os::raw::c_char,
) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateTriggerFiringOn(
                arg_stmt: *mut CreateTrigStmt,
                arg_queryString: *const ::std::os::raw::c_char,
                arg_relOid: Oid,
                arg_refRelOid: Oid,
                arg_constraintOid: Oid,
                arg_indexOid: Oid,
                arg_funcoid: Oid,
                arg_parentTriggerOid: Oid,
                arg_whenClause: *mut Node,
                arg_isInternal: bool,
                arg_in_partition: bool,
                arg_trigger_fires_when: ::std::os::raw::c_char,
            ) -> ObjectAddress;
        }
        CreateTriggerFiringOn(
            arg_stmt,
            arg_queryString,
            arg_relOid,
            arg_refRelOid,
            arg_constraintOid,
            arg_indexOid,
            arg_funcoid,
            arg_parentTriggerOid,
            arg_whenClause,
            arg_isInternal,
            arg_in_partition,
            arg_trigger_fires_when,
        )
    })
}
pub unsafe fn RemoveTriggerById(arg_trigOid: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RemoveTriggerById(arg_trigOid: Oid);
        }
        RemoveTriggerById(arg_trigOid)
    })
}
pub unsafe fn get_trigger_oid(
    arg_relid: Oid,
    arg_name: *const ::std::os::raw::c_char,
    arg_missing_ok: bool,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_trigger_oid(
                arg_relid: Oid,
                arg_name: *const ::std::os::raw::c_char,
                arg_missing_ok: bool,
            ) -> Oid;
        }
        get_trigger_oid(arg_relid, arg_name, arg_missing_ok)
    })
}
pub unsafe fn renametrig(arg_stmt: *mut RenameStmt) -> ObjectAddress {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn renametrig(arg_stmt: *mut RenameStmt) -> ObjectAddress;
        }
        renametrig(arg_stmt)
    })
}
pub unsafe fn EnableDisableTrigger(
    arg_rel: Relation,
    arg_tgname: *const ::std::os::raw::c_char,
    arg_fires_when: ::std::os::raw::c_char,
    arg_skip_system: bool,
    arg_lockmode: LOCKMODE,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EnableDisableTrigger(
                arg_rel: Relation,
                arg_tgname: *const ::std::os::raw::c_char,
                arg_fires_when: ::std::os::raw::c_char,
                arg_skip_system: bool,
                arg_lockmode: LOCKMODE,
            );
        }
        EnableDisableTrigger(arg_rel, arg_tgname, arg_fires_when, arg_skip_system, arg_lockmode)
    })
}
pub unsafe fn RelationBuildTriggers(arg_relation: Relation) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationBuildTriggers(arg_relation: Relation);
        }
        RelationBuildTriggers(arg_relation)
    })
}
pub unsafe fn CopyTriggerDesc(arg_trigdesc: *mut TriggerDesc) -> *mut TriggerDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CopyTriggerDesc(arg_trigdesc: *mut TriggerDesc) -> *mut TriggerDesc;
        }
        CopyTriggerDesc(arg_trigdesc)
    })
}
pub unsafe fn FindTriggerIncompatibleWithInheritance(
    arg_trigdesc: *mut TriggerDesc,
) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FindTriggerIncompatibleWithInheritance(
                arg_trigdesc: *mut TriggerDesc,
            ) -> *const ::std::os::raw::c_char;
        }
        FindTriggerIncompatibleWithInheritance(arg_trigdesc)
    })
}
pub unsafe fn MakeTransitionCaptureState(
    arg_trigdesc: *mut TriggerDesc,
    arg_relid: Oid,
    arg_cmdType: CmdType,
) -> *mut TransitionCaptureState {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MakeTransitionCaptureState(
                arg_trigdesc: *mut TriggerDesc,
                arg_relid: Oid,
                arg_cmdType: CmdType,
            ) -> *mut TransitionCaptureState;
        }
        MakeTransitionCaptureState(arg_trigdesc, arg_relid, arg_cmdType)
    })
}
pub unsafe fn FreeTriggerDesc(arg_trigdesc: *mut TriggerDesc) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FreeTriggerDesc(arg_trigdesc: *mut TriggerDesc);
        }
        FreeTriggerDesc(arg_trigdesc)
    })
}
pub unsafe fn ExecBSInsertTriggers(arg_estate: *mut EState, arg_relinfo: *mut ResultRelInfo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecBSInsertTriggers(arg_estate: *mut EState, arg_relinfo: *mut ResultRelInfo);
        }
        ExecBSInsertTriggers(arg_estate, arg_relinfo)
    })
}
pub unsafe fn ExecASInsertTriggers(
    arg_estate: *mut EState,
    arg_relinfo: *mut ResultRelInfo,
    arg_transition_capture: *mut TransitionCaptureState,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecASInsertTriggers(
                arg_estate: *mut EState,
                arg_relinfo: *mut ResultRelInfo,
                arg_transition_capture: *mut TransitionCaptureState,
            );
        }
        ExecASInsertTriggers(arg_estate, arg_relinfo, arg_transition_capture)
    })
}
pub unsafe fn ExecBRInsertTriggers(
    arg_estate: *mut EState,
    arg_relinfo: *mut ResultRelInfo,
    arg_slot: *mut TupleTableSlot,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecBRInsertTriggers(
                arg_estate: *mut EState,
                arg_relinfo: *mut ResultRelInfo,
                arg_slot: *mut TupleTableSlot,
            ) -> bool;
        }
        ExecBRInsertTriggers(arg_estate, arg_relinfo, arg_slot)
    })
}
pub unsafe fn ExecARInsertTriggers(
    arg_estate: *mut EState,
    arg_relinfo: *mut ResultRelInfo,
    arg_slot: *mut TupleTableSlot,
    arg_recheckIndexes: *mut List,
    arg_transition_capture: *mut TransitionCaptureState,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecARInsertTriggers(
                arg_estate: *mut EState,
                arg_relinfo: *mut ResultRelInfo,
                arg_slot: *mut TupleTableSlot,
                arg_recheckIndexes: *mut List,
                arg_transition_capture: *mut TransitionCaptureState,
            );
        }
        ExecARInsertTriggers(
            arg_estate,
            arg_relinfo,
            arg_slot,
            arg_recheckIndexes,
            arg_transition_capture,
        )
    })
}
pub unsafe fn ExecIRInsertTriggers(
    arg_estate: *mut EState,
    arg_relinfo: *mut ResultRelInfo,
    arg_slot: *mut TupleTableSlot,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecIRInsertTriggers(
                arg_estate: *mut EState,
                arg_relinfo: *mut ResultRelInfo,
                arg_slot: *mut TupleTableSlot,
            ) -> bool;
        }
        ExecIRInsertTriggers(arg_estate, arg_relinfo, arg_slot)
    })
}
pub unsafe fn ExecBSDeleteTriggers(arg_estate: *mut EState, arg_relinfo: *mut ResultRelInfo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecBSDeleteTriggers(arg_estate: *mut EState, arg_relinfo: *mut ResultRelInfo);
        }
        ExecBSDeleteTriggers(arg_estate, arg_relinfo)
    })
}
pub unsafe fn ExecASDeleteTriggers(
    arg_estate: *mut EState,
    arg_relinfo: *mut ResultRelInfo,
    arg_transition_capture: *mut TransitionCaptureState,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecASDeleteTriggers(
                arg_estate: *mut EState,
                arg_relinfo: *mut ResultRelInfo,
                arg_transition_capture: *mut TransitionCaptureState,
            );
        }
        ExecASDeleteTriggers(arg_estate, arg_relinfo, arg_transition_capture)
    })
}
pub unsafe fn ExecBRDeleteTriggers(
    arg_estate: *mut EState,
    arg_epqstate: *mut EPQState,
    arg_relinfo: *mut ResultRelInfo,
    arg_tupleid: ItemPointer,
    arg_fdw_trigtuple: HeapTuple,
    arg_epqslot: *mut *mut TupleTableSlot,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecBRDeleteTriggers(
                arg_estate: *mut EState,
                arg_epqstate: *mut EPQState,
                arg_relinfo: *mut ResultRelInfo,
                arg_tupleid: ItemPointer,
                arg_fdw_trigtuple: HeapTuple,
                arg_epqslot: *mut *mut TupleTableSlot,
            ) -> bool;
        }
        ExecBRDeleteTriggers(
            arg_estate,
            arg_epqstate,
            arg_relinfo,
            arg_tupleid,
            arg_fdw_trigtuple,
            arg_epqslot,
        )
    })
}
pub unsafe fn ExecARDeleteTriggers(
    arg_estate: *mut EState,
    arg_relinfo: *mut ResultRelInfo,
    arg_tupleid: ItemPointer,
    arg_fdw_trigtuple: HeapTuple,
    arg_transition_capture: *mut TransitionCaptureState,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecARDeleteTriggers(
                arg_estate: *mut EState,
                arg_relinfo: *mut ResultRelInfo,
                arg_tupleid: ItemPointer,
                arg_fdw_trigtuple: HeapTuple,
                arg_transition_capture: *mut TransitionCaptureState,
            );
        }
        ExecARDeleteTriggers(
            arg_estate,
            arg_relinfo,
            arg_tupleid,
            arg_fdw_trigtuple,
            arg_transition_capture,
        )
    })
}
pub unsafe fn ExecIRDeleteTriggers(
    arg_estate: *mut EState,
    arg_relinfo: *mut ResultRelInfo,
    arg_trigtuple: HeapTuple,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecIRDeleteTriggers(
                arg_estate: *mut EState,
                arg_relinfo: *mut ResultRelInfo,
                arg_trigtuple: HeapTuple,
            ) -> bool;
        }
        ExecIRDeleteTriggers(arg_estate, arg_relinfo, arg_trigtuple)
    })
}
pub unsafe fn ExecBSUpdateTriggers(arg_estate: *mut EState, arg_relinfo: *mut ResultRelInfo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecBSUpdateTriggers(arg_estate: *mut EState, arg_relinfo: *mut ResultRelInfo);
        }
        ExecBSUpdateTriggers(arg_estate, arg_relinfo)
    })
}
pub unsafe fn ExecASUpdateTriggers(
    arg_estate: *mut EState,
    arg_relinfo: *mut ResultRelInfo,
    arg_transition_capture: *mut TransitionCaptureState,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecASUpdateTriggers(
                arg_estate: *mut EState,
                arg_relinfo: *mut ResultRelInfo,
                arg_transition_capture: *mut TransitionCaptureState,
            );
        }
        ExecASUpdateTriggers(arg_estate, arg_relinfo, arg_transition_capture)
    })
}
pub unsafe fn ExecBRUpdateTriggers(
    arg_estate: *mut EState,
    arg_epqstate: *mut EPQState,
    arg_relinfo: *mut ResultRelInfo,
    arg_tupleid: ItemPointer,
    arg_fdw_trigtuple: HeapTuple,
    arg_slot: *mut TupleTableSlot,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecBRUpdateTriggers(
                arg_estate: *mut EState,
                arg_epqstate: *mut EPQState,
                arg_relinfo: *mut ResultRelInfo,
                arg_tupleid: ItemPointer,
                arg_fdw_trigtuple: HeapTuple,
                arg_slot: *mut TupleTableSlot,
            ) -> bool;
        }
        ExecBRUpdateTriggers(
            arg_estate,
            arg_epqstate,
            arg_relinfo,
            arg_tupleid,
            arg_fdw_trigtuple,
            arg_slot,
        )
    })
}
pub unsafe fn ExecARUpdateTriggers(
    arg_estate: *mut EState,
    arg_relinfo: *mut ResultRelInfo,
    arg_tupleid: ItemPointer,
    arg_fdw_trigtuple: HeapTuple,
    arg_slot: *mut TupleTableSlot,
    arg_recheckIndexes: *mut List,
    arg_transition_capture: *mut TransitionCaptureState,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecARUpdateTriggers(
                arg_estate: *mut EState,
                arg_relinfo: *mut ResultRelInfo,
                arg_tupleid: ItemPointer,
                arg_fdw_trigtuple: HeapTuple,
                arg_slot: *mut TupleTableSlot,
                arg_recheckIndexes: *mut List,
                arg_transition_capture: *mut TransitionCaptureState,
            );
        }
        ExecARUpdateTriggers(
            arg_estate,
            arg_relinfo,
            arg_tupleid,
            arg_fdw_trigtuple,
            arg_slot,
            arg_recheckIndexes,
            arg_transition_capture,
        )
    })
}
pub unsafe fn ExecIRUpdateTriggers(
    arg_estate: *mut EState,
    arg_relinfo: *mut ResultRelInfo,
    arg_trigtuple: HeapTuple,
    arg_slot: *mut TupleTableSlot,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecIRUpdateTriggers(
                arg_estate: *mut EState,
                arg_relinfo: *mut ResultRelInfo,
                arg_trigtuple: HeapTuple,
                arg_slot: *mut TupleTableSlot,
            ) -> bool;
        }
        ExecIRUpdateTriggers(arg_estate, arg_relinfo, arg_trigtuple, arg_slot)
    })
}
pub unsafe fn ExecBSTruncateTriggers(arg_estate: *mut EState, arg_relinfo: *mut ResultRelInfo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecBSTruncateTriggers(arg_estate: *mut EState, arg_relinfo: *mut ResultRelInfo);
        }
        ExecBSTruncateTriggers(arg_estate, arg_relinfo)
    })
}
pub unsafe fn ExecASTruncateTriggers(arg_estate: *mut EState, arg_relinfo: *mut ResultRelInfo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecASTruncateTriggers(arg_estate: *mut EState, arg_relinfo: *mut ResultRelInfo);
        }
        ExecASTruncateTriggers(arg_estate, arg_relinfo)
    })
}
pub unsafe fn AfterTriggerBeginXact() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AfterTriggerBeginXact();
        }
        AfterTriggerBeginXact()
    })
}
pub unsafe fn AfterTriggerBeginQuery() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AfterTriggerBeginQuery();
        }
        AfterTriggerBeginQuery()
    })
}
pub unsafe fn AfterTriggerEndQuery(arg_estate: *mut EState) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AfterTriggerEndQuery(arg_estate: *mut EState);
        }
        AfterTriggerEndQuery(arg_estate)
    })
}
pub unsafe fn AfterTriggerFireDeferred() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AfterTriggerFireDeferred();
        }
        AfterTriggerFireDeferred()
    })
}
pub unsafe fn AfterTriggerEndXact(arg_isCommit: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AfterTriggerEndXact(arg_isCommit: bool);
        }
        AfterTriggerEndXact(arg_isCommit)
    })
}
pub unsafe fn AfterTriggerBeginSubXact() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AfterTriggerBeginSubXact();
        }
        AfterTriggerBeginSubXact()
    })
}
pub unsafe fn AfterTriggerEndSubXact(arg_isCommit: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AfterTriggerEndSubXact(arg_isCommit: bool);
        }
        AfterTriggerEndSubXact(arg_isCommit)
    })
}
pub unsafe fn AfterTriggerSetState(arg_stmt: *mut ConstraintsSetStmt) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AfterTriggerSetState(arg_stmt: *mut ConstraintsSetStmt);
        }
        AfterTriggerSetState(arg_stmt)
    })
}
pub unsafe fn AfterTriggerPendingOnRel(arg_relid: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AfterTriggerPendingOnRel(arg_relid: Oid) -> bool;
        }
        AfterTriggerPendingOnRel(arg_relid)
    })
}
pub unsafe fn RI_FKey_pk_upd_check_required(
    arg_trigger: *mut Trigger,
    arg_pk_rel: Relation,
    arg_old_slot: *mut TupleTableSlot,
    arg_new_slot: *mut TupleTableSlot,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RI_FKey_pk_upd_check_required(
                arg_trigger: *mut Trigger,
                arg_pk_rel: Relation,
                arg_old_slot: *mut TupleTableSlot,
                arg_new_slot: *mut TupleTableSlot,
            ) -> bool;
        }
        RI_FKey_pk_upd_check_required(arg_trigger, arg_pk_rel, arg_old_slot, arg_new_slot)
    })
}
pub unsafe fn RI_FKey_fk_upd_check_required(
    arg_trigger: *mut Trigger,
    arg_fk_rel: Relation,
    arg_old_slot: *mut TupleTableSlot,
    arg_new_slot: *mut TupleTableSlot,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RI_FKey_fk_upd_check_required(
                arg_trigger: *mut Trigger,
                arg_fk_rel: Relation,
                arg_old_slot: *mut TupleTableSlot,
                arg_new_slot: *mut TupleTableSlot,
            ) -> bool;
        }
        RI_FKey_fk_upd_check_required(arg_trigger, arg_fk_rel, arg_old_slot, arg_new_slot)
    })
}
pub unsafe fn RI_Initial_Check(
    arg_trigger: *mut Trigger,
    arg_fk_rel: Relation,
    arg_pk_rel: Relation,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RI_Initial_Check(
                arg_trigger: *mut Trigger,
                arg_fk_rel: Relation,
                arg_pk_rel: Relation,
            ) -> bool;
        }
        RI_Initial_Check(arg_trigger, arg_fk_rel, arg_pk_rel)
    })
}
pub unsafe fn RI_PartitionRemove_Check(
    arg_trigger: *mut Trigger,
    arg_fk_rel: Relation,
    arg_pk_rel: Relation,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RI_PartitionRemove_Check(
                arg_trigger: *mut Trigger,
                arg_fk_rel: Relation,
                arg_pk_rel: Relation,
            );
        }
        RI_PartitionRemove_Check(arg_trigger, arg_fk_rel, arg_pk_rel)
    })
}
pub unsafe fn RI_FKey_trigger_type(arg_tgfoid: Oid) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RI_FKey_trigger_type(arg_tgfoid: Oid) -> ::std::os::raw::c_int;
        }
        RI_FKey_trigger_type(arg_tgfoid)
    })
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FormData_pg_statistic {
    pub starelid: Oid,
    pub staattnum: int16,
    pub stainherit: bool,
    pub stanullfrac: float4,
    pub stawidth: int32,
    pub stadistinct: float4,
    pub stakind1: int16,
    pub stakind2: int16,
    pub stakind3: int16,
    pub stakind4: int16,
    pub stakind5: int16,
    pub staop1: Oid,
    pub staop2: Oid,
    pub staop3: Oid,
    pub staop4: Oid,
    pub staop5: Oid,
    pub stacoll1: Oid,
    pub stacoll2: Oid,
    pub stacoll3: Oid,
    pub stacoll4: Oid,
    pub stacoll5: Oid,
}
pub type Form_pg_statistic = *mut FormData_pg_statistic;
pub type VacAttrStatsP = *mut VacAttrStats;
pub type AnalyzeAttrFetchFunc = ::std::option::Option<
    unsafe extern "C" fn(
        stats: VacAttrStatsP,
        rownum: ::std::os::raw::c_int,
        isNull: *mut bool,
    ) -> Datum,
>;
pub type AnalyzeAttrComputeStatsFunc = ::std::option::Option<
    unsafe extern "C" fn(
        stats: VacAttrStatsP,
        fetchfunc: AnalyzeAttrFetchFunc,
        samplerows: ::std::os::raw::c_int,
        totalrows: f64,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VacAttrStats {
    pub attr: Form_pg_attribute,
    pub attrtypid: Oid,
    pub attrtypmod: int32,
    pub attrtype: Form_pg_type,
    pub attrcollid: Oid,
    pub anl_context: MemoryContext,
    pub compute_stats: AnalyzeAttrComputeStatsFunc,
    pub minrows: ::std::os::raw::c_int,
    pub extra_data: *mut ::std::os::raw::c_void,
    pub stats_valid: bool,
    pub stanullfrac: float4,
    pub stawidth: int32,
    pub stadistinct: float4,
    pub stakind: [int16; 5usize],
    pub staop: [Oid; 5usize],
    pub stacoll: [Oid; 5usize],
    pub numnumbers: [::std::os::raw::c_int; 5usize],
    pub stanumbers: [*mut float4; 5usize],
    pub numvalues: [::std::os::raw::c_int; 5usize],
    pub stavalues: [*mut Datum; 5usize],
    pub statypid: [Oid; 5usize],
    pub statyplen: [int16; 5usize],
    pub statypbyval: [bool; 5usize],
    pub statypalign: [::std::os::raw::c_char; 5usize],
    pub tupattnum: ::std::os::raw::c_int,
    pub rows: *mut HeapTuple,
    pub tupDesc: TupleDesc,
    pub exprvals: *mut Datum,
    pub exprnulls: *mut bool,
    pub rowstride: ::std::os::raw::c_int,
}
impl Default for VacAttrStats {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const VacuumOption_VACOPT_VACUUM: VacuumOption = 1;
pub const VacuumOption_VACOPT_ANALYZE: VacuumOption = 2;
pub const VacuumOption_VACOPT_VERBOSE: VacuumOption = 4;
pub const VacuumOption_VACOPT_FREEZE: VacuumOption = 8;
pub const VacuumOption_VACOPT_FULL: VacuumOption = 16;
pub const VacuumOption_VACOPT_SKIP_LOCKED: VacuumOption = 32;
pub const VacuumOption_VACOPT_SKIPTOAST: VacuumOption = 64;
pub const VacuumOption_VACOPT_DISABLE_PAGE_SKIPPING: VacuumOption = 128;
pub type VacuumOption = ::std::os::raw::c_uint;
pub const VacOptTernaryValue_VACOPT_TERNARY_DEFAULT: VacOptTernaryValue = 0;
pub const VacOptTernaryValue_VACOPT_TERNARY_DISABLED: VacOptTernaryValue = 1;
pub const VacOptTernaryValue_VACOPT_TERNARY_ENABLED: VacOptTernaryValue = 2;
pub type VacOptTernaryValue = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VacuumParams {
    pub options: ::std::os::raw::c_int,
    pub freeze_min_age: ::std::os::raw::c_int,
    pub freeze_table_age: ::std::os::raw::c_int,
    pub multixact_freeze_min_age: ::std::os::raw::c_int,
    pub multixact_freeze_table_age: ::std::os::raw::c_int,
    pub is_wraparound: bool,
    pub log_min_duration: ::std::os::raw::c_int,
    pub index_cleanup: VacOptTernaryValue,
    pub truncate: VacOptTernaryValue,
    pub nworkers: ::std::os::raw::c_int,
}
impl Default for VacuumParams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut default_statistics_target: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut vacuum_freeze_min_age: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut vacuum_freeze_table_age: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut vacuum_multixact_freeze_min_age: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut vacuum_multixact_freeze_table_age: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut VacuumSharedCostBalance: *mut pg_atomic_uint32;
}
extern "C" {
    pub static mut VacuumActiveNWorkers: *mut pg_atomic_uint32;
}
extern "C" {
    pub static mut VacuumCostBalanceLocal: ::std::os::raw::c_int;
}
pub unsafe fn ExecVacuum(
    arg_pstate: *mut ParseState,
    arg_vacstmt: *mut VacuumStmt,
    arg_isTopLevel: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExecVacuum(
                arg_pstate: *mut ParseState,
                arg_vacstmt: *mut VacuumStmt,
                arg_isTopLevel: bool,
            );
        }
        ExecVacuum(arg_pstate, arg_vacstmt, arg_isTopLevel)
    })
}
pub unsafe fn vacuum(
    arg_relations: *mut List,
    arg_params: *mut VacuumParams,
    arg_bstrategy: BufferAccessStrategy,
    arg_isTopLevel: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn vacuum(
                arg_relations: *mut List,
                arg_params: *mut VacuumParams,
                arg_bstrategy: BufferAccessStrategy,
                arg_isTopLevel: bool,
            );
        }
        vacuum(arg_relations, arg_params, arg_bstrategy, arg_isTopLevel)
    })
}
pub unsafe fn vac_open_indexes(
    arg_relation: Relation,
    arg_lockmode: LOCKMODE,
    arg_nindexes: *mut ::std::os::raw::c_int,
    arg_Irel: *mut *mut Relation,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn vac_open_indexes(
                arg_relation: Relation,
                arg_lockmode: LOCKMODE,
                arg_nindexes: *mut ::std::os::raw::c_int,
                arg_Irel: *mut *mut Relation,
            );
        }
        vac_open_indexes(arg_relation, arg_lockmode, arg_nindexes, arg_Irel)
    })
}
pub unsafe fn vac_close_indexes(
    arg_nindexes: ::std::os::raw::c_int,
    arg_Irel: *mut Relation,
    arg_lockmode: LOCKMODE,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn vac_close_indexes(
                arg_nindexes: ::std::os::raw::c_int,
                arg_Irel: *mut Relation,
                arg_lockmode: LOCKMODE,
            );
        }
        vac_close_indexes(arg_nindexes, arg_Irel, arg_lockmode)
    })
}
pub unsafe fn vac_estimate_reltuples(
    arg_relation: Relation,
    arg_total_pages: BlockNumber,
    arg_scanned_pages: BlockNumber,
    arg_scanned_tuples: f64,
) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn vac_estimate_reltuples(
                arg_relation: Relation,
                arg_total_pages: BlockNumber,
                arg_scanned_pages: BlockNumber,
                arg_scanned_tuples: f64,
            ) -> f64;
        }
        vac_estimate_reltuples(arg_relation, arg_total_pages, arg_scanned_pages, arg_scanned_tuples)
    })
}
pub unsafe fn vac_update_relstats(
    arg_relation: Relation,
    arg_num_pages: BlockNumber,
    arg_num_tuples: f64,
    arg_num_all_visible_pages: BlockNumber,
    arg_hasindex: bool,
    arg_frozenxid: TransactionId,
    arg_minmulti: MultiXactId,
    arg_in_outer_xact: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn vac_update_relstats(
                arg_relation: Relation,
                arg_num_pages: BlockNumber,
                arg_num_tuples: f64,
                arg_num_all_visible_pages: BlockNumber,
                arg_hasindex: bool,
                arg_frozenxid: TransactionId,
                arg_minmulti: MultiXactId,
                arg_in_outer_xact: bool,
            );
        }
        vac_update_relstats(
            arg_relation,
            arg_num_pages,
            arg_num_tuples,
            arg_num_all_visible_pages,
            arg_hasindex,
            arg_frozenxid,
            arg_minmulti,
            arg_in_outer_xact,
        )
    })
}
pub unsafe fn vacuum_set_xid_limits(
    arg_rel: Relation,
    arg_freeze_min_age: ::std::os::raw::c_int,
    arg_freeze_table_age: ::std::os::raw::c_int,
    arg_multixact_freeze_min_age: ::std::os::raw::c_int,
    arg_multixact_freeze_table_age: ::std::os::raw::c_int,
    arg_oldestXmin: *mut TransactionId,
    arg_freezeLimit: *mut TransactionId,
    arg_xidFullScanLimit: *mut TransactionId,
    arg_multiXactCutoff: *mut MultiXactId,
    arg_mxactFullScanLimit: *mut MultiXactId,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn vacuum_set_xid_limits(
                arg_rel: Relation,
                arg_freeze_min_age: ::std::os::raw::c_int,
                arg_freeze_table_age: ::std::os::raw::c_int,
                arg_multixact_freeze_min_age: ::std::os::raw::c_int,
                arg_multixact_freeze_table_age: ::std::os::raw::c_int,
                arg_oldestXmin: *mut TransactionId,
                arg_freezeLimit: *mut TransactionId,
                arg_xidFullScanLimit: *mut TransactionId,
                arg_multiXactCutoff: *mut MultiXactId,
                arg_mxactFullScanLimit: *mut MultiXactId,
            );
        }
        vacuum_set_xid_limits(
            arg_rel,
            arg_freeze_min_age,
            arg_freeze_table_age,
            arg_multixact_freeze_min_age,
            arg_multixact_freeze_table_age,
            arg_oldestXmin,
            arg_freezeLimit,
            arg_xidFullScanLimit,
            arg_multiXactCutoff,
            arg_mxactFullScanLimit,
        )
    })
}
pub unsafe fn vac_update_datfrozenxid() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn vac_update_datfrozenxid();
        }
        vac_update_datfrozenxid()
    })
}
pub unsafe fn vacuum_delay_point() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn vacuum_delay_point();
        }
        vacuum_delay_point()
    })
}
pub unsafe fn vacuum_is_relation_owner(
    arg_relid: Oid,
    arg_reltuple: Form_pg_class,
    arg_options: ::std::os::raw::c_int,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn vacuum_is_relation_owner(
                arg_relid: Oid,
                arg_reltuple: Form_pg_class,
                arg_options: ::std::os::raw::c_int,
            ) -> bool;
        }
        vacuum_is_relation_owner(arg_relid, arg_reltuple, arg_options)
    })
}
pub unsafe fn vacuum_open_relation(
    arg_relid: Oid,
    arg_relation: *mut RangeVar,
    arg_options: ::std::os::raw::c_int,
    arg_verbose: bool,
    arg_lmode: LOCKMODE,
) -> Relation {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn vacuum_open_relation(
                arg_relid: Oid,
                arg_relation: *mut RangeVar,
                arg_options: ::std::os::raw::c_int,
                arg_verbose: bool,
                arg_lmode: LOCKMODE,
            ) -> Relation;
        }
        vacuum_open_relation(arg_relid, arg_relation, arg_options, arg_verbose, arg_lmode)
    })
}
pub unsafe fn analyze_rel(
    arg_relid: Oid,
    arg_relation: *mut RangeVar,
    arg_params: *mut VacuumParams,
    arg_va_cols: *mut List,
    arg_in_outer_xact: bool,
    arg_bstrategy: BufferAccessStrategy,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn analyze_rel(
                arg_relid: Oid,
                arg_relation: *mut RangeVar,
                arg_params: *mut VacuumParams,
                arg_va_cols: *mut List,
                arg_in_outer_xact: bool,
                arg_bstrategy: BufferAccessStrategy,
            );
        }
        analyze_rel(
            arg_relid,
            arg_relation,
            arg_params,
            arg_va_cols,
            arg_in_outer_xact,
            arg_bstrategy,
        )
    })
}
pub unsafe fn std_typanalyze(arg_stats: *mut VacAttrStats) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn std_typanalyze(arg_stats: *mut VacAttrStats) -> bool;
        }
        std_typanalyze(arg_stats)
    })
}
pub unsafe fn anl_random_fract() -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn anl_random_fract() -> f64;
        }
        anl_random_fract()
    })
}
pub unsafe fn anl_init_selection_state(arg_n: ::std::os::raw::c_int) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn anl_init_selection_state(arg_n: ::std::os::raw::c_int) -> f64;
        }
        anl_init_selection_state(arg_n)
    })
}
pub unsafe fn anl_get_next_S(
    arg_t: f64,
    arg_n: ::std::os::raw::c_int,
    arg_stateptr: *mut f64,
) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn anl_get_next_S(
                arg_t: f64,
                arg_n: ::std::os::raw::c_int,
                arg_stateptr: *mut f64,
            ) -> f64;
        }
        anl_get_next_S(arg_t, arg_n, arg_stateptr)
    })
}
pub type ResourceOwner = *mut ResourceOwnerData;
extern "C" {
    pub static mut CurrentResourceOwner: ResourceOwner;
}
extern "C" {
    pub static mut CurTransactionResourceOwner: ResourceOwner;
}
extern "C" {
    pub static mut TopTransactionResourceOwner: ResourceOwner;
}
extern "C" {
    pub static mut AuxProcessResourceOwner: ResourceOwner;
}
pub const ResourceReleasePhase_RESOURCE_RELEASE_BEFORE_LOCKS: ResourceReleasePhase = 0;
pub const ResourceReleasePhase_RESOURCE_RELEASE_LOCKS: ResourceReleasePhase = 1;
pub const ResourceReleasePhase_RESOURCE_RELEASE_AFTER_LOCKS: ResourceReleasePhase = 2;
pub type ResourceReleasePhase = ::std::os::raw::c_uint;
pub type ResourceReleaseCallback = ::std::option::Option<
    unsafe extern "C" fn(
        phase: ResourceReleasePhase,
        isCommit: bool,
        isTopLevel: bool,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
pub unsafe fn ResourceOwnerCreate(
    arg_parent: ResourceOwner,
    arg_name: *const ::std::os::raw::c_char,
) -> ResourceOwner {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ResourceOwnerCreate(
                arg_parent: ResourceOwner,
                arg_name: *const ::std::os::raw::c_char,
            ) -> ResourceOwner;
        }
        ResourceOwnerCreate(arg_parent, arg_name)
    })
}
pub unsafe fn ResourceOwnerRelease(
    arg_owner: ResourceOwner,
    arg_phase: ResourceReleasePhase,
    arg_isCommit: bool,
    arg_isTopLevel: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ResourceOwnerRelease(
                arg_owner: ResourceOwner,
                arg_phase: ResourceReleasePhase,
                arg_isCommit: bool,
                arg_isTopLevel: bool,
            );
        }
        ResourceOwnerRelease(arg_owner, arg_phase, arg_isCommit, arg_isTopLevel)
    })
}
pub unsafe fn ResourceOwnerReleaseAllPlanCacheRefs(arg_owner: ResourceOwner) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ResourceOwnerReleaseAllPlanCacheRefs(arg_owner: ResourceOwner);
        }
        ResourceOwnerReleaseAllPlanCacheRefs(arg_owner)
    })
}
pub unsafe fn ResourceOwnerDelete(arg_owner: ResourceOwner) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ResourceOwnerDelete(arg_owner: ResourceOwner);
        }
        ResourceOwnerDelete(arg_owner)
    })
}
pub unsafe fn ResourceOwnerGetParent(arg_owner: ResourceOwner) -> ResourceOwner {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ResourceOwnerGetParent(arg_owner: ResourceOwner) -> ResourceOwner;
        }
        ResourceOwnerGetParent(arg_owner)
    })
}
pub unsafe fn ResourceOwnerNewParent(arg_owner: ResourceOwner, arg_newparent: ResourceOwner) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ResourceOwnerNewParent(arg_owner: ResourceOwner, arg_newparent: ResourceOwner);
        }
        ResourceOwnerNewParent(arg_owner, arg_newparent)
    })
}
pub unsafe fn RegisterResourceReleaseCallback(
    arg_callback: ResourceReleaseCallback,
    arg_arg: *mut ::std::os::raw::c_void,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RegisterResourceReleaseCallback(
                arg_callback: ResourceReleaseCallback,
                arg_arg: *mut ::std::os::raw::c_void,
            );
        }
        RegisterResourceReleaseCallback(arg_callback, arg_arg)
    })
}
pub unsafe fn UnregisterResourceReleaseCallback(
    arg_callback: ResourceReleaseCallback,
    arg_arg: *mut ::std::os::raw::c_void,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn UnregisterResourceReleaseCallback(
                arg_callback: ResourceReleaseCallback,
                arg_arg: *mut ::std::os::raw::c_void,
            );
        }
        UnregisterResourceReleaseCallback(arg_callback, arg_arg)
    })
}
pub unsafe fn CreateAuxProcessResourceOwner() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateAuxProcessResourceOwner();
        }
        CreateAuxProcessResourceOwner()
    })
}
pub unsafe fn ReleaseAuxProcessResources(arg_isCommit: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReleaseAuxProcessResources(arg_isCommit: bool);
        }
        ReleaseAuxProcessResources(arg_isCommit)
    })
}
pub const PlanCacheMode_PLAN_CACHE_MODE_AUTO: PlanCacheMode = 0;
pub const PlanCacheMode_PLAN_CACHE_MODE_FORCE_GENERIC_PLAN: PlanCacheMode = 1;
pub const PlanCacheMode_PLAN_CACHE_MODE_FORCE_CUSTOM_PLAN: PlanCacheMode = 2;
pub type PlanCacheMode = ::std::os::raw::c_uint;
extern "C" {
    pub static mut plan_cache_mode: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CachedPlanSource {
    pub magic: ::std::os::raw::c_int,
    pub raw_parse_tree: *mut RawStmt,
    pub query_string: *const ::std::os::raw::c_char,
    pub commandTag: CommandTag,
    pub param_types: *mut Oid,
    pub num_params: ::std::os::raw::c_int,
    pub parserSetup: ParserSetupHook,
    pub parserSetupArg: *mut ::std::os::raw::c_void,
    pub cursor_options: ::std::os::raw::c_int,
    pub fixed_result: bool,
    pub resultDesc: TupleDesc,
    pub context: MemoryContext,
    pub query_list: *mut List,
    pub relationOids: *mut List,
    pub invalItems: *mut List,
    pub search_path: *mut OverrideSearchPath,
    pub query_context: MemoryContext,
    pub rewriteRoleId: Oid,
    pub rewriteRowSecurity: bool,
    pub dependsOnRLS: bool,
    pub gplan: *mut CachedPlan,
    pub is_oneshot: bool,
    pub is_complete: bool,
    pub is_saved: bool,
    pub is_valid: bool,
    pub generation: ::std::os::raw::c_int,
    pub node: dlist_node,
    pub generic_cost: f64,
    pub total_custom_cost: f64,
    pub num_custom_plans: ::std::os::raw::c_int,
}
impl Default for CachedPlanSource {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CachedPlan {
    pub magic: ::std::os::raw::c_int,
    pub stmt_list: *mut List,
    pub is_oneshot: bool,
    pub is_saved: bool,
    pub is_valid: bool,
    pub planRoleId: Oid,
    pub dependsOnRole: bool,
    pub saved_xmin: TransactionId,
    pub generation: ::std::os::raw::c_int,
    pub refcount: ::std::os::raw::c_int,
    pub context: MemoryContext,
}
impl Default for CachedPlan {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CachedExpression {
    pub magic: ::std::os::raw::c_int,
    pub expr: *mut Node,
    pub is_valid: bool,
    pub relationOids: *mut List,
    pub invalItems: *mut List,
    pub context: MemoryContext,
    pub node: dlist_node,
}
impl Default for CachedExpression {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn InitPlanCache() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitPlanCache();
        }
        InitPlanCache()
    })
}
pub unsafe fn ResetPlanCache() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ResetPlanCache();
        }
        ResetPlanCache()
    })
}
pub unsafe fn CreateCachedPlan(
    arg_raw_parse_tree: *mut RawStmt,
    arg_query_string: *const ::std::os::raw::c_char,
    arg_commandTag: CommandTag,
) -> *mut CachedPlanSource {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateCachedPlan(
                arg_raw_parse_tree: *mut RawStmt,
                arg_query_string: *const ::std::os::raw::c_char,
                arg_commandTag: CommandTag,
            ) -> *mut CachedPlanSource;
        }
        CreateCachedPlan(arg_raw_parse_tree, arg_query_string, arg_commandTag)
    })
}
pub unsafe fn CreateOneShotCachedPlan(
    arg_raw_parse_tree: *mut RawStmt,
    arg_query_string: *const ::std::os::raw::c_char,
    arg_commandTag: CommandTag,
) -> *mut CachedPlanSource {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateOneShotCachedPlan(
                arg_raw_parse_tree: *mut RawStmt,
                arg_query_string: *const ::std::os::raw::c_char,
                arg_commandTag: CommandTag,
            ) -> *mut CachedPlanSource;
        }
        CreateOneShotCachedPlan(arg_raw_parse_tree, arg_query_string, arg_commandTag)
    })
}
pub unsafe fn CompleteCachedPlan(
    arg_plansource: *mut CachedPlanSource,
    arg_querytree_list: *mut List,
    arg_querytree_context: MemoryContext,
    arg_param_types: *mut Oid,
    arg_num_params: ::std::os::raw::c_int,
    arg_parserSetup: ParserSetupHook,
    arg_parserSetupArg: *mut ::std::os::raw::c_void,
    arg_cursor_options: ::std::os::raw::c_int,
    arg_fixed_result: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CompleteCachedPlan(
                arg_plansource: *mut CachedPlanSource,
                arg_querytree_list: *mut List,
                arg_querytree_context: MemoryContext,
                arg_param_types: *mut Oid,
                arg_num_params: ::std::os::raw::c_int,
                arg_parserSetup: ParserSetupHook,
                arg_parserSetupArg: *mut ::std::os::raw::c_void,
                arg_cursor_options: ::std::os::raw::c_int,
                arg_fixed_result: bool,
            );
        }
        CompleteCachedPlan(
            arg_plansource,
            arg_querytree_list,
            arg_querytree_context,
            arg_param_types,
            arg_num_params,
            arg_parserSetup,
            arg_parserSetupArg,
            arg_cursor_options,
            arg_fixed_result,
        )
    })
}
pub unsafe fn SaveCachedPlan(arg_plansource: *mut CachedPlanSource) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SaveCachedPlan(arg_plansource: *mut CachedPlanSource);
        }
        SaveCachedPlan(arg_plansource)
    })
}
pub unsafe fn DropCachedPlan(arg_plansource: *mut CachedPlanSource) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DropCachedPlan(arg_plansource: *mut CachedPlanSource);
        }
        DropCachedPlan(arg_plansource)
    })
}
pub unsafe fn CachedPlanSetParentContext(
    arg_plansource: *mut CachedPlanSource,
    arg_newcontext: MemoryContext,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CachedPlanSetParentContext(
                arg_plansource: *mut CachedPlanSource,
                arg_newcontext: MemoryContext,
            );
        }
        CachedPlanSetParentContext(arg_plansource, arg_newcontext)
    })
}
pub unsafe fn CopyCachedPlan(arg_plansource: *mut CachedPlanSource) -> *mut CachedPlanSource {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CopyCachedPlan(arg_plansource: *mut CachedPlanSource) -> *mut CachedPlanSource;
        }
        CopyCachedPlan(arg_plansource)
    })
}
pub unsafe fn CachedPlanIsValid(arg_plansource: *mut CachedPlanSource) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CachedPlanIsValid(arg_plansource: *mut CachedPlanSource) -> bool;
        }
        CachedPlanIsValid(arg_plansource)
    })
}
pub unsafe fn CachedPlanGetTargetList(
    arg_plansource: *mut CachedPlanSource,
    arg_queryEnv: *mut QueryEnvironment,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CachedPlanGetTargetList(
                arg_plansource: *mut CachedPlanSource,
                arg_queryEnv: *mut QueryEnvironment,
            ) -> *mut List;
        }
        CachedPlanGetTargetList(arg_plansource, arg_queryEnv)
    })
}
pub unsafe fn GetCachedPlan(
    arg_plansource: *mut CachedPlanSource,
    arg_boundParams: ParamListInfo,
    arg_useResOwner: bool,
    arg_queryEnv: *mut QueryEnvironment,
) -> *mut CachedPlan {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetCachedPlan(
                arg_plansource: *mut CachedPlanSource,
                arg_boundParams: ParamListInfo,
                arg_useResOwner: bool,
                arg_queryEnv: *mut QueryEnvironment,
            ) -> *mut CachedPlan;
        }
        GetCachedPlan(arg_plansource, arg_boundParams, arg_useResOwner, arg_queryEnv)
    })
}
pub unsafe fn ReleaseCachedPlan(arg_plan: *mut CachedPlan, arg_useResOwner: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReleaseCachedPlan(arg_plan: *mut CachedPlan, arg_useResOwner: bool);
        }
        ReleaseCachedPlan(arg_plan, arg_useResOwner)
    })
}
pub unsafe fn CachedPlanAllowsSimpleValidityCheck(
    arg_plansource: *mut CachedPlanSource,
    arg_plan: *mut CachedPlan,
    arg_owner: ResourceOwner,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CachedPlanAllowsSimpleValidityCheck(
                arg_plansource: *mut CachedPlanSource,
                arg_plan: *mut CachedPlan,
                arg_owner: ResourceOwner,
            ) -> bool;
        }
        CachedPlanAllowsSimpleValidityCheck(arg_plansource, arg_plan, arg_owner)
    })
}
pub unsafe fn CachedPlanIsSimplyValid(
    arg_plansource: *mut CachedPlanSource,
    arg_plan: *mut CachedPlan,
    arg_owner: ResourceOwner,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CachedPlanIsSimplyValid(
                arg_plansource: *mut CachedPlanSource,
                arg_plan: *mut CachedPlan,
                arg_owner: ResourceOwner,
            ) -> bool;
        }
        CachedPlanIsSimplyValid(arg_plansource, arg_plan, arg_owner)
    })
}
pub unsafe fn GetCachedExpression(arg_expr: *mut Node) -> *mut CachedExpression {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetCachedExpression(arg_expr: *mut Node) -> *mut CachedExpression;
        }
        GetCachedExpression(arg_expr)
    })
}
pub unsafe fn FreeCachedExpression(arg_cexpr: *mut CachedExpression) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FreeCachedExpression(arg_cexpr: *mut CachedExpression);
        }
        FreeCachedExpression(arg_cexpr)
    })
}
pub const PortalStrategy_PORTAL_ONE_SELECT: PortalStrategy = 0;
pub const PortalStrategy_PORTAL_ONE_RETURNING: PortalStrategy = 1;
pub const PortalStrategy_PORTAL_ONE_MOD_WITH: PortalStrategy = 2;
pub const PortalStrategy_PORTAL_UTIL_SELECT: PortalStrategy = 3;
pub const PortalStrategy_PORTAL_MULTI_QUERY: PortalStrategy = 4;
pub type PortalStrategy = ::std::os::raw::c_uint;
pub const PortalStatus_PORTAL_NEW: PortalStatus = 0;
pub const PortalStatus_PORTAL_DEFINED: PortalStatus = 1;
pub const PortalStatus_PORTAL_READY: PortalStatus = 2;
pub const PortalStatus_PORTAL_ACTIVE: PortalStatus = 3;
pub const PortalStatus_PORTAL_DONE: PortalStatus = 4;
pub const PortalStatus_PORTAL_FAILED: PortalStatus = 5;
pub type PortalStatus = ::std::os::raw::c_uint;
pub type Portal = *mut PortalData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PortalData {
    pub name: *const ::std::os::raw::c_char,
    pub prepStmtName: *const ::std::os::raw::c_char,
    pub portalContext: MemoryContext,
    pub resowner: ResourceOwner,
    pub cleanup: ::std::option::Option<unsafe extern "C" fn(portal: Portal)>,
    pub createSubid: SubTransactionId,
    pub activeSubid: SubTransactionId,
    pub sourceText: *const ::std::os::raw::c_char,
    pub commandTag: CommandTag,
    pub qc: QueryCompletion,
    pub stmts: *mut List,
    pub cplan: *mut CachedPlan,
    pub portalParams: ParamListInfo,
    pub queryEnv: *mut QueryEnvironment,
    pub strategy: PortalStrategy,
    pub cursorOptions: ::std::os::raw::c_int,
    pub run_once: bool,
    pub status: PortalStatus,
    pub portalPinned: bool,
    pub autoHeld: bool,
    pub queryDesc: *mut QueryDesc,
    pub tupDesc: TupleDesc,
    pub formats: *mut int16,
    pub holdStore: *mut Tuplestorestate,
    pub holdContext: MemoryContext,
    pub holdSnapshot: Snapshot,
    pub atStart: bool,
    pub atEnd: bool,
    pub portalPos: uint64,
    pub creation_time: TimestampTz,
    pub visible: bool,
    pub portalSnapshot: Snapshot,
    pub createLevel: ::std::os::raw::c_int,
}
impl Default for PortalData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn EnablePortalManager() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EnablePortalManager();
        }
        EnablePortalManager()
    })
}
pub unsafe fn PreCommit_Portals(arg_isPrepare: bool) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PreCommit_Portals(arg_isPrepare: bool) -> bool;
        }
        PreCommit_Portals(arg_isPrepare)
    })
}
pub unsafe fn AtAbort_Portals() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AtAbort_Portals();
        }
        AtAbort_Portals()
    })
}
pub unsafe fn AtCleanup_Portals() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AtCleanup_Portals();
        }
        AtCleanup_Portals()
    })
}
pub unsafe fn PortalErrorCleanup() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PortalErrorCleanup();
        }
        PortalErrorCleanup()
    })
}
pub unsafe fn AtSubCommit_Portals(
    arg_mySubid: SubTransactionId,
    arg_parentSubid: SubTransactionId,
    arg_parentLevel: ::std::os::raw::c_int,
    arg_parentXactOwner: ResourceOwner,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AtSubCommit_Portals(
                arg_mySubid: SubTransactionId,
                arg_parentSubid: SubTransactionId,
                arg_parentLevel: ::std::os::raw::c_int,
                arg_parentXactOwner: ResourceOwner,
            );
        }
        AtSubCommit_Portals(arg_mySubid, arg_parentSubid, arg_parentLevel, arg_parentXactOwner)
    })
}
pub unsafe fn AtSubAbort_Portals(
    arg_mySubid: SubTransactionId,
    arg_parentSubid: SubTransactionId,
    arg_myXactOwner: ResourceOwner,
    arg_parentXactOwner: ResourceOwner,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AtSubAbort_Portals(
                arg_mySubid: SubTransactionId,
                arg_parentSubid: SubTransactionId,
                arg_myXactOwner: ResourceOwner,
                arg_parentXactOwner: ResourceOwner,
            );
        }
        AtSubAbort_Portals(arg_mySubid, arg_parentSubid, arg_myXactOwner, arg_parentXactOwner)
    })
}
pub unsafe fn AtSubCleanup_Portals(arg_mySubid: SubTransactionId) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AtSubCleanup_Portals(arg_mySubid: SubTransactionId);
        }
        AtSubCleanup_Portals(arg_mySubid)
    })
}
pub unsafe fn CreatePortal(
    arg_name: *const ::std::os::raw::c_char,
    arg_allowDup: bool,
    arg_dupSilent: bool,
) -> Portal {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreatePortal(
                arg_name: *const ::std::os::raw::c_char,
                arg_allowDup: bool,
                arg_dupSilent: bool,
            ) -> Portal;
        }
        CreatePortal(arg_name, arg_allowDup, arg_dupSilent)
    })
}
pub unsafe fn CreateNewPortal() -> Portal {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateNewPortal() -> Portal;
        }
        CreateNewPortal()
    })
}
pub unsafe fn PinPortal(arg_portal: Portal) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PinPortal(arg_portal: Portal);
        }
        PinPortal(arg_portal)
    })
}
pub unsafe fn UnpinPortal(arg_portal: Portal) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn UnpinPortal(arg_portal: Portal);
        }
        UnpinPortal(arg_portal)
    })
}
pub unsafe fn MarkPortalActive(arg_portal: Portal) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MarkPortalActive(arg_portal: Portal);
        }
        MarkPortalActive(arg_portal)
    })
}
pub unsafe fn MarkPortalDone(arg_portal: Portal) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MarkPortalDone(arg_portal: Portal);
        }
        MarkPortalDone(arg_portal)
    })
}
pub unsafe fn MarkPortalFailed(arg_portal: Portal) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MarkPortalFailed(arg_portal: Portal);
        }
        MarkPortalFailed(arg_portal)
    })
}
pub unsafe fn PortalDrop(arg_portal: Portal, arg_isTopCommit: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PortalDrop(arg_portal: Portal, arg_isTopCommit: bool);
        }
        PortalDrop(arg_portal, arg_isTopCommit)
    })
}
pub unsafe fn GetPortalByName(arg_name: *const ::std::os::raw::c_char) -> Portal {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetPortalByName(arg_name: *const ::std::os::raw::c_char) -> Portal;
        }
        GetPortalByName(arg_name)
    })
}
pub unsafe fn PortalDefineQuery(
    arg_portal: Portal,
    arg_prepStmtName: *const ::std::os::raw::c_char,
    arg_sourceText: *const ::std::os::raw::c_char,
    arg_commandTag: CommandTag,
    arg_stmts: *mut List,
    arg_cplan: *mut CachedPlan,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PortalDefineQuery(
                arg_portal: Portal,
                arg_prepStmtName: *const ::std::os::raw::c_char,
                arg_sourceText: *const ::std::os::raw::c_char,
                arg_commandTag: CommandTag,
                arg_stmts: *mut List,
                arg_cplan: *mut CachedPlan,
            );
        }
        PortalDefineQuery(
            arg_portal,
            arg_prepStmtName,
            arg_sourceText,
            arg_commandTag,
            arg_stmts,
            arg_cplan,
        )
    })
}
pub unsafe fn PortalGetPrimaryStmt(arg_portal: Portal) -> *mut PlannedStmt {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PortalGetPrimaryStmt(arg_portal: Portal) -> *mut PlannedStmt;
        }
        PortalGetPrimaryStmt(arg_portal)
    })
}
pub unsafe fn PortalCreateHoldStore(arg_portal: Portal) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PortalCreateHoldStore(arg_portal: Portal);
        }
        PortalCreateHoldStore(arg_portal)
    })
}
pub unsafe fn PortalHashTableDeleteAll() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PortalHashTableDeleteAll();
        }
        PortalHashTableDeleteAll()
    })
}
pub unsafe fn ThereAreNoReadyPortals() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ThereAreNoReadyPortals() -> bool;
        }
        ThereAreNoReadyPortals()
    })
}
pub unsafe fn HoldPinnedPortals() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn HoldPinnedPortals();
        }
        HoldPinnedPortals()
    })
}
pub unsafe fn ForgetPortalSnapshots() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ForgetPortalSnapshots();
        }
        ForgetPortalSnapshots()
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPITupleTable {
    pub tupdesc: TupleDesc,
    pub vals: *mut HeapTuple,
    pub numvals: uint64,
    pub alloced: uint64,
    pub tuptabcxt: MemoryContext,
    pub next: slist_node,
    pub subid: SubTransactionId,
}
impl Default for SPITupleTable {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SPI_plan {
    _unused: [u8; 0],
}
pub type SPIPlanPtr = *mut _SPI_plan;
extern "C" {
    pub static mut SPI_processed: uint64;
}
extern "C" {
    pub static mut SPI_tuptable: *mut SPITupleTable;
}
extern "C" {
    pub static mut SPI_result: ::std::os::raw::c_int;
}
pub unsafe fn SPI_connect() -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_connect() -> ::std::os::raw::c_int;
        }
        SPI_connect()
    })
}
pub unsafe fn SPI_connect_ext(arg_options: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_connect_ext(arg_options: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        SPI_connect_ext(arg_options)
    })
}
pub unsafe fn SPI_finish() -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_finish() -> ::std::os::raw::c_int;
        }
        SPI_finish()
    })
}
pub unsafe fn SPI_execute(
    arg_src: *const ::std::os::raw::c_char,
    arg_read_only: bool,
    arg_tcount: ::std::os::raw::c_long,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_execute(
                arg_src: *const ::std::os::raw::c_char,
                arg_read_only: bool,
                arg_tcount: ::std::os::raw::c_long,
            ) -> ::std::os::raw::c_int;
        }
        SPI_execute(arg_src, arg_read_only, arg_tcount)
    })
}
pub unsafe fn SPI_execute_plan(
    arg_plan: SPIPlanPtr,
    arg_Values: *mut Datum,
    arg_Nulls: *const ::std::os::raw::c_char,
    arg_read_only: bool,
    arg_tcount: ::std::os::raw::c_long,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_execute_plan(
                arg_plan: SPIPlanPtr,
                arg_Values: *mut Datum,
                arg_Nulls: *const ::std::os::raw::c_char,
                arg_read_only: bool,
                arg_tcount: ::std::os::raw::c_long,
            ) -> ::std::os::raw::c_int;
        }
        SPI_execute_plan(arg_plan, arg_Values, arg_Nulls, arg_read_only, arg_tcount)
    })
}
pub unsafe fn SPI_execute_plan_with_paramlist(
    arg_plan: SPIPlanPtr,
    arg_params: ParamListInfo,
    arg_read_only: bool,
    arg_tcount: ::std::os::raw::c_long,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_execute_plan_with_paramlist(
                arg_plan: SPIPlanPtr,
                arg_params: ParamListInfo,
                arg_read_only: bool,
                arg_tcount: ::std::os::raw::c_long,
            ) -> ::std::os::raw::c_int;
        }
        SPI_execute_plan_with_paramlist(arg_plan, arg_params, arg_read_only, arg_tcount)
    })
}
pub unsafe fn SPI_exec(
    arg_src: *const ::std::os::raw::c_char,
    arg_tcount: ::std::os::raw::c_long,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_exec(
                arg_src: *const ::std::os::raw::c_char,
                arg_tcount: ::std::os::raw::c_long,
            ) -> ::std::os::raw::c_int;
        }
        SPI_exec(arg_src, arg_tcount)
    })
}
pub unsafe fn SPI_execp(
    arg_plan: SPIPlanPtr,
    arg_Values: *mut Datum,
    arg_Nulls: *const ::std::os::raw::c_char,
    arg_tcount: ::std::os::raw::c_long,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_execp(
                arg_plan: SPIPlanPtr,
                arg_Values: *mut Datum,
                arg_Nulls: *const ::std::os::raw::c_char,
                arg_tcount: ::std::os::raw::c_long,
            ) -> ::std::os::raw::c_int;
        }
        SPI_execp(arg_plan, arg_Values, arg_Nulls, arg_tcount)
    })
}
pub unsafe fn SPI_execute_snapshot(
    arg_plan: SPIPlanPtr,
    arg_Values: *mut Datum,
    arg_Nulls: *const ::std::os::raw::c_char,
    arg_snapshot: Snapshot,
    arg_crosscheck_snapshot: Snapshot,
    arg_read_only: bool,
    arg_fire_triggers: bool,
    arg_tcount: ::std::os::raw::c_long,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_execute_snapshot(
                arg_plan: SPIPlanPtr,
                arg_Values: *mut Datum,
                arg_Nulls: *const ::std::os::raw::c_char,
                arg_snapshot: Snapshot,
                arg_crosscheck_snapshot: Snapshot,
                arg_read_only: bool,
                arg_fire_triggers: bool,
                arg_tcount: ::std::os::raw::c_long,
            ) -> ::std::os::raw::c_int;
        }
        SPI_execute_snapshot(
            arg_plan,
            arg_Values,
            arg_Nulls,
            arg_snapshot,
            arg_crosscheck_snapshot,
            arg_read_only,
            arg_fire_triggers,
            arg_tcount,
        )
    })
}
pub unsafe fn SPI_execute_with_args(
    arg_src: *const ::std::os::raw::c_char,
    arg_nargs: ::std::os::raw::c_int,
    arg_argtypes: *mut Oid,
    arg_Values: *mut Datum,
    arg_Nulls: *const ::std::os::raw::c_char,
    arg_read_only: bool,
    arg_tcount: ::std::os::raw::c_long,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_execute_with_args(
                arg_src: *const ::std::os::raw::c_char,
                arg_nargs: ::std::os::raw::c_int,
                arg_argtypes: *mut Oid,
                arg_Values: *mut Datum,
                arg_Nulls: *const ::std::os::raw::c_char,
                arg_read_only: bool,
                arg_tcount: ::std::os::raw::c_long,
            ) -> ::std::os::raw::c_int;
        }
        SPI_execute_with_args(
            arg_src,
            arg_nargs,
            arg_argtypes,
            arg_Values,
            arg_Nulls,
            arg_read_only,
            arg_tcount,
        )
    })
}
pub unsafe fn SPI_prepare(
    arg_src: *const ::std::os::raw::c_char,
    arg_nargs: ::std::os::raw::c_int,
    arg_argtypes: *mut Oid,
) -> SPIPlanPtr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_prepare(
                arg_src: *const ::std::os::raw::c_char,
                arg_nargs: ::std::os::raw::c_int,
                arg_argtypes: *mut Oid,
            ) -> SPIPlanPtr;
        }
        SPI_prepare(arg_src, arg_nargs, arg_argtypes)
    })
}
pub unsafe fn SPI_prepare_cursor(
    arg_src: *const ::std::os::raw::c_char,
    arg_nargs: ::std::os::raw::c_int,
    arg_argtypes: *mut Oid,
    arg_cursorOptions: ::std::os::raw::c_int,
) -> SPIPlanPtr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_prepare_cursor(
                arg_src: *const ::std::os::raw::c_char,
                arg_nargs: ::std::os::raw::c_int,
                arg_argtypes: *mut Oid,
                arg_cursorOptions: ::std::os::raw::c_int,
            ) -> SPIPlanPtr;
        }
        SPI_prepare_cursor(arg_src, arg_nargs, arg_argtypes, arg_cursorOptions)
    })
}
pub unsafe fn SPI_prepare_params(
    arg_src: *const ::std::os::raw::c_char,
    arg_parserSetup: ParserSetupHook,
    arg_parserSetupArg: *mut ::std::os::raw::c_void,
    arg_cursorOptions: ::std::os::raw::c_int,
) -> SPIPlanPtr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_prepare_params(
                arg_src: *const ::std::os::raw::c_char,
                arg_parserSetup: ParserSetupHook,
                arg_parserSetupArg: *mut ::std::os::raw::c_void,
                arg_cursorOptions: ::std::os::raw::c_int,
            ) -> SPIPlanPtr;
        }
        SPI_prepare_params(arg_src, arg_parserSetup, arg_parserSetupArg, arg_cursorOptions)
    })
}
pub unsafe fn SPI_keepplan(arg_plan: SPIPlanPtr) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_keepplan(arg_plan: SPIPlanPtr) -> ::std::os::raw::c_int;
        }
        SPI_keepplan(arg_plan)
    })
}
pub unsafe fn SPI_saveplan(arg_plan: SPIPlanPtr) -> SPIPlanPtr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_saveplan(arg_plan: SPIPlanPtr) -> SPIPlanPtr;
        }
        SPI_saveplan(arg_plan)
    })
}
pub unsafe fn SPI_freeplan(arg_plan: SPIPlanPtr) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_freeplan(arg_plan: SPIPlanPtr) -> ::std::os::raw::c_int;
        }
        SPI_freeplan(arg_plan)
    })
}
pub unsafe fn SPI_getargtypeid(arg_plan: SPIPlanPtr, arg_argIndex: ::std::os::raw::c_int) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_getargtypeid(arg_plan: SPIPlanPtr, arg_argIndex: ::std::os::raw::c_int) -> Oid;
        }
        SPI_getargtypeid(arg_plan, arg_argIndex)
    })
}
pub unsafe fn SPI_getargcount(arg_plan: SPIPlanPtr) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_getargcount(arg_plan: SPIPlanPtr) -> ::std::os::raw::c_int;
        }
        SPI_getargcount(arg_plan)
    })
}
pub unsafe fn SPI_is_cursor_plan(arg_plan: SPIPlanPtr) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_is_cursor_plan(arg_plan: SPIPlanPtr) -> bool;
        }
        SPI_is_cursor_plan(arg_plan)
    })
}
pub unsafe fn SPI_plan_is_valid(arg_plan: SPIPlanPtr) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_plan_is_valid(arg_plan: SPIPlanPtr) -> bool;
        }
        SPI_plan_is_valid(arg_plan)
    })
}
pub unsafe fn SPI_result_code_string(
    arg_code: ::std::os::raw::c_int,
) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_result_code_string(
                arg_code: ::std::os::raw::c_int,
            ) -> *const ::std::os::raw::c_char;
        }
        SPI_result_code_string(arg_code)
    })
}
pub unsafe fn SPI_plan_get_plan_sources(arg_plan: SPIPlanPtr) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_plan_get_plan_sources(arg_plan: SPIPlanPtr) -> *mut List;
        }
        SPI_plan_get_plan_sources(arg_plan)
    })
}
pub unsafe fn SPI_plan_get_cached_plan(arg_plan: SPIPlanPtr) -> *mut CachedPlan {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_plan_get_cached_plan(arg_plan: SPIPlanPtr) -> *mut CachedPlan;
        }
        SPI_plan_get_cached_plan(arg_plan)
    })
}
pub unsafe fn SPI_copytuple(arg_tuple: HeapTuple) -> HeapTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_copytuple(arg_tuple: HeapTuple) -> HeapTuple;
        }
        SPI_copytuple(arg_tuple)
    })
}
pub unsafe fn SPI_returntuple(arg_tuple: HeapTuple, arg_tupdesc: TupleDesc) -> HeapTupleHeader {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_returntuple(arg_tuple: HeapTuple, arg_tupdesc: TupleDesc) -> HeapTupleHeader;
        }
        SPI_returntuple(arg_tuple, arg_tupdesc)
    })
}
pub unsafe fn SPI_modifytuple(
    arg_rel: Relation,
    arg_tuple: HeapTuple,
    arg_natts: ::std::os::raw::c_int,
    arg_attnum: *mut ::std::os::raw::c_int,
    arg_Values: *mut Datum,
    arg_Nulls: *const ::std::os::raw::c_char,
) -> HeapTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_modifytuple(
                arg_rel: Relation,
                arg_tuple: HeapTuple,
                arg_natts: ::std::os::raw::c_int,
                arg_attnum: *mut ::std::os::raw::c_int,
                arg_Values: *mut Datum,
                arg_Nulls: *const ::std::os::raw::c_char,
            ) -> HeapTuple;
        }
        SPI_modifytuple(arg_rel, arg_tuple, arg_natts, arg_attnum, arg_Values, arg_Nulls)
    })
}
pub unsafe fn SPI_fnumber(
    arg_tupdesc: TupleDesc,
    arg_fname: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_fnumber(
                arg_tupdesc: TupleDesc,
                arg_fname: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        SPI_fnumber(arg_tupdesc, arg_fname)
    })
}
pub unsafe fn SPI_fname(
    arg_tupdesc: TupleDesc,
    arg_fnumber: ::std::os::raw::c_int,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_fname(
                arg_tupdesc: TupleDesc,
                arg_fnumber: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_char;
        }
        SPI_fname(arg_tupdesc, arg_fnumber)
    })
}
pub unsafe fn SPI_getvalue(
    arg_tuple: HeapTuple,
    arg_tupdesc: TupleDesc,
    arg_fnumber: ::std::os::raw::c_int,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_getvalue(
                arg_tuple: HeapTuple,
                arg_tupdesc: TupleDesc,
                arg_fnumber: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_char;
        }
        SPI_getvalue(arg_tuple, arg_tupdesc, arg_fnumber)
    })
}
pub unsafe fn SPI_getbinval(
    arg_tuple: HeapTuple,
    arg_tupdesc: TupleDesc,
    arg_fnumber: ::std::os::raw::c_int,
    arg_isnull: *mut bool,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_getbinval(
                arg_tuple: HeapTuple,
                arg_tupdesc: TupleDesc,
                arg_fnumber: ::std::os::raw::c_int,
                arg_isnull: *mut bool,
            ) -> Datum;
        }
        SPI_getbinval(arg_tuple, arg_tupdesc, arg_fnumber, arg_isnull)
    })
}
pub unsafe fn SPI_gettype(
    arg_tupdesc: TupleDesc,
    arg_fnumber: ::std::os::raw::c_int,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_gettype(
                arg_tupdesc: TupleDesc,
                arg_fnumber: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_char;
        }
        SPI_gettype(arg_tupdesc, arg_fnumber)
    })
}
pub unsafe fn SPI_gettypeid(arg_tupdesc: TupleDesc, arg_fnumber: ::std::os::raw::c_int) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_gettypeid(arg_tupdesc: TupleDesc, arg_fnumber: ::std::os::raw::c_int) -> Oid;
        }
        SPI_gettypeid(arg_tupdesc, arg_fnumber)
    })
}
pub unsafe fn SPI_getrelname(arg_rel: Relation) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_getrelname(arg_rel: Relation) -> *mut ::std::os::raw::c_char;
        }
        SPI_getrelname(arg_rel)
    })
}
pub unsafe fn SPI_getnspname(arg_rel: Relation) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_getnspname(arg_rel: Relation) -> *mut ::std::os::raw::c_char;
        }
        SPI_getnspname(arg_rel)
    })
}
pub unsafe fn SPI_palloc(arg_size: Size) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_palloc(arg_size: Size) -> *mut ::std::os::raw::c_void;
        }
        SPI_palloc(arg_size)
    })
}
pub unsafe fn SPI_repalloc(
    arg_pointer: *mut ::std::os::raw::c_void,
    arg_size: Size,
) -> *mut ::std::os::raw::c_void {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_repalloc(
                arg_pointer: *mut ::std::os::raw::c_void,
                arg_size: Size,
            ) -> *mut ::std::os::raw::c_void;
        }
        SPI_repalloc(arg_pointer, arg_size)
    })
}
pub unsafe fn SPI_pfree(arg_pointer: *mut ::std::os::raw::c_void) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_pfree(arg_pointer: *mut ::std::os::raw::c_void);
        }
        SPI_pfree(arg_pointer)
    })
}
pub unsafe fn SPI_datumTransfer(
    arg_value: Datum,
    arg_typByVal: bool,
    arg_typLen: ::std::os::raw::c_int,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_datumTransfer(
                arg_value: Datum,
                arg_typByVal: bool,
                arg_typLen: ::std::os::raw::c_int,
            ) -> Datum;
        }
        SPI_datumTransfer(arg_value, arg_typByVal, arg_typLen)
    })
}
pub unsafe fn SPI_freetuple(arg_pointer: HeapTuple) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_freetuple(arg_pointer: HeapTuple);
        }
        SPI_freetuple(arg_pointer)
    })
}
pub unsafe fn SPI_freetuptable(arg_tuptable: *mut SPITupleTable) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_freetuptable(arg_tuptable: *mut SPITupleTable);
        }
        SPI_freetuptable(arg_tuptable)
    })
}
pub unsafe fn SPI_cursor_open(
    arg_name: *const ::std::os::raw::c_char,
    arg_plan: SPIPlanPtr,
    arg_Values: *mut Datum,
    arg_Nulls: *const ::std::os::raw::c_char,
    arg_read_only: bool,
) -> Portal {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_cursor_open(
                arg_name: *const ::std::os::raw::c_char,
                arg_plan: SPIPlanPtr,
                arg_Values: *mut Datum,
                arg_Nulls: *const ::std::os::raw::c_char,
                arg_read_only: bool,
            ) -> Portal;
        }
        SPI_cursor_open(arg_name, arg_plan, arg_Values, arg_Nulls, arg_read_only)
    })
}
pub unsafe fn SPI_cursor_open_with_args(
    arg_name: *const ::std::os::raw::c_char,
    arg_src: *const ::std::os::raw::c_char,
    arg_nargs: ::std::os::raw::c_int,
    arg_argtypes: *mut Oid,
    arg_Values: *mut Datum,
    arg_Nulls: *const ::std::os::raw::c_char,
    arg_read_only: bool,
    arg_cursorOptions: ::std::os::raw::c_int,
) -> Portal {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_cursor_open_with_args(
                arg_name: *const ::std::os::raw::c_char,
                arg_src: *const ::std::os::raw::c_char,
                arg_nargs: ::std::os::raw::c_int,
                arg_argtypes: *mut Oid,
                arg_Values: *mut Datum,
                arg_Nulls: *const ::std::os::raw::c_char,
                arg_read_only: bool,
                arg_cursorOptions: ::std::os::raw::c_int,
            ) -> Portal;
        }
        SPI_cursor_open_with_args(
            arg_name,
            arg_src,
            arg_nargs,
            arg_argtypes,
            arg_Values,
            arg_Nulls,
            arg_read_only,
            arg_cursorOptions,
        )
    })
}
pub unsafe fn SPI_cursor_open_with_paramlist(
    arg_name: *const ::std::os::raw::c_char,
    arg_plan: SPIPlanPtr,
    arg_params: ParamListInfo,
    arg_read_only: bool,
) -> Portal {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_cursor_open_with_paramlist(
                arg_name: *const ::std::os::raw::c_char,
                arg_plan: SPIPlanPtr,
                arg_params: ParamListInfo,
                arg_read_only: bool,
            ) -> Portal;
        }
        SPI_cursor_open_with_paramlist(arg_name, arg_plan, arg_params, arg_read_only)
    })
}
pub unsafe fn SPI_cursor_find(arg_name: *const ::std::os::raw::c_char) -> Portal {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_cursor_find(arg_name: *const ::std::os::raw::c_char) -> Portal;
        }
        SPI_cursor_find(arg_name)
    })
}
pub unsafe fn SPI_cursor_fetch(
    arg_portal: Portal,
    arg_forward: bool,
    arg_count: ::std::os::raw::c_long,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_cursor_fetch(
                arg_portal: Portal,
                arg_forward: bool,
                arg_count: ::std::os::raw::c_long,
            );
        }
        SPI_cursor_fetch(arg_portal, arg_forward, arg_count)
    })
}
pub unsafe fn SPI_cursor_move(
    arg_portal: Portal,
    arg_forward: bool,
    arg_count: ::std::os::raw::c_long,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_cursor_move(
                arg_portal: Portal,
                arg_forward: bool,
                arg_count: ::std::os::raw::c_long,
            );
        }
        SPI_cursor_move(arg_portal, arg_forward, arg_count)
    })
}
pub unsafe fn SPI_scroll_cursor_fetch(
    arg_arg1: Portal,
    arg_direction: FetchDirection,
    arg_count: ::std::os::raw::c_long,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_scroll_cursor_fetch(
                arg_arg1: Portal,
                arg_direction: FetchDirection,
                arg_count: ::std::os::raw::c_long,
            );
        }
        SPI_scroll_cursor_fetch(arg_arg1, arg_direction, arg_count)
    })
}
pub unsafe fn SPI_scroll_cursor_move(
    arg_arg1: Portal,
    arg_direction: FetchDirection,
    arg_count: ::std::os::raw::c_long,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_scroll_cursor_move(
                arg_arg1: Portal,
                arg_direction: FetchDirection,
                arg_count: ::std::os::raw::c_long,
            );
        }
        SPI_scroll_cursor_move(arg_arg1, arg_direction, arg_count)
    })
}
pub unsafe fn SPI_cursor_close(arg_portal: Portal) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_cursor_close(arg_portal: Portal);
        }
        SPI_cursor_close(arg_portal)
    })
}
pub unsafe fn SPI_register_relation(arg_enr: EphemeralNamedRelation) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_register_relation(arg_enr: EphemeralNamedRelation) -> ::std::os::raw::c_int;
        }
        SPI_register_relation(arg_enr)
    })
}
pub unsafe fn SPI_unregister_relation(
    arg_name: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_unregister_relation(
                arg_name: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        SPI_unregister_relation(arg_name)
    })
}
pub unsafe fn SPI_register_trigger_data(arg_tdata: *mut TriggerData) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_register_trigger_data(arg_tdata: *mut TriggerData) -> ::std::os::raw::c_int;
        }
        SPI_register_trigger_data(arg_tdata)
    })
}
pub unsafe fn SPI_start_transaction() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_start_transaction();
        }
        SPI_start_transaction()
    })
}
pub unsafe fn SPI_commit() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_commit();
        }
        SPI_commit()
    })
}
pub unsafe fn SPI_commit_and_chain() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_commit_and_chain();
        }
        SPI_commit_and_chain()
    })
}
pub unsafe fn SPI_rollback() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_rollback();
        }
        SPI_rollback()
    })
}
pub unsafe fn SPI_rollback_and_chain() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_rollback_and_chain();
        }
        SPI_rollback_and_chain()
    })
}
pub unsafe fn SPICleanup() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPICleanup();
        }
        SPICleanup()
    })
}
pub unsafe fn AtEOXact_SPI(arg_isCommit: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AtEOXact_SPI(arg_isCommit: bool);
        }
        AtEOXact_SPI(arg_isCommit)
    })
}
pub unsafe fn AtEOSubXact_SPI(arg_isCommit: bool, arg_mySubid: SubTransactionId) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AtEOSubXact_SPI(arg_isCommit: bool, arg_mySubid: SubTransactionId);
        }
        AtEOSubXact_SPI(arg_isCommit, arg_mySubid)
    })
}
pub unsafe fn SPI_inside_nonatomic_context() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SPI_inside_nonatomic_context() -> bool;
        }
        SPI_inside_nonatomic_context()
    })
}
pub type bgworker_main_type = ::std::option::Option<unsafe extern "C" fn(main_arg: Datum)>;
pub const BgWorkerStartTime_BgWorkerStart_PostmasterStart: BgWorkerStartTime = 0;
pub const BgWorkerStartTime_BgWorkerStart_ConsistentState: BgWorkerStartTime = 1;
pub const BgWorkerStartTime_BgWorkerStart_RecoveryFinished: BgWorkerStartTime = 2;
pub type BgWorkerStartTime = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BackgroundWorker {
    pub bgw_name: [::std::os::raw::c_char; 96usize],
    pub bgw_type: [::std::os::raw::c_char; 96usize],
    pub bgw_flags: ::std::os::raw::c_int,
    pub bgw_start_time: BgWorkerStartTime,
    pub bgw_restart_time: ::std::os::raw::c_int,
    pub bgw_library_name: [::std::os::raw::c_char; 96usize],
    pub bgw_function_name: [::std::os::raw::c_char; 96usize],
    pub bgw_main_arg: Datum,
    pub bgw_extra: [::std::os::raw::c_char; 128usize],
    pub bgw_notify_pid: pid_t,
}
impl Default for BackgroundWorker {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const BgwHandleStatus_BGWH_STARTED: BgwHandleStatus = 0;
pub const BgwHandleStatus_BGWH_NOT_YET_STARTED: BgwHandleStatus = 1;
pub const BgwHandleStatus_BGWH_STOPPED: BgwHandleStatus = 2;
pub const BgwHandleStatus_BGWH_POSTMASTER_DIED: BgwHandleStatus = 3;
pub type BgwHandleStatus = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BackgroundWorkerHandle {
    _unused: [u8; 0],
}
pub unsafe fn RegisterBackgroundWorker(arg_worker: *mut BackgroundWorker) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RegisterBackgroundWorker(arg_worker: *mut BackgroundWorker);
        }
        RegisterBackgroundWorker(arg_worker)
    })
}
pub unsafe fn RegisterDynamicBackgroundWorker(
    arg_worker: *mut BackgroundWorker,
    arg_handle: *mut *mut BackgroundWorkerHandle,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RegisterDynamicBackgroundWorker(
                arg_worker: *mut BackgroundWorker,
                arg_handle: *mut *mut BackgroundWorkerHandle,
            ) -> bool;
        }
        RegisterDynamicBackgroundWorker(arg_worker, arg_handle)
    })
}
pub unsafe fn GetBackgroundWorkerPid(
    arg_handle: *mut BackgroundWorkerHandle,
    arg_pidp: *mut pid_t,
) -> BgwHandleStatus {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetBackgroundWorkerPid(
                arg_handle: *mut BackgroundWorkerHandle,
                arg_pidp: *mut pid_t,
            ) -> BgwHandleStatus;
        }
        GetBackgroundWorkerPid(arg_handle, arg_pidp)
    })
}
pub unsafe fn WaitForBackgroundWorkerStartup(
    arg_handle: *mut BackgroundWorkerHandle,
    arg_pid: *mut pid_t,
) -> BgwHandleStatus {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn WaitForBackgroundWorkerStartup(
                arg_handle: *mut BackgroundWorkerHandle,
                arg_pid: *mut pid_t,
            ) -> BgwHandleStatus;
        }
        WaitForBackgroundWorkerStartup(arg_handle, arg_pid)
    })
}
pub unsafe fn WaitForBackgroundWorkerShutdown(
    arg_arg1: *mut BackgroundWorkerHandle,
) -> BgwHandleStatus {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn WaitForBackgroundWorkerShutdown(
                arg_arg1: *mut BackgroundWorkerHandle,
            ) -> BgwHandleStatus;
        }
        WaitForBackgroundWorkerShutdown(arg_arg1)
    })
}
pub unsafe fn GetBackgroundWorkerTypeByPid(arg_pid: pid_t) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetBackgroundWorkerTypeByPid(arg_pid: pid_t) -> *const ::std::os::raw::c_char;
        }
        GetBackgroundWorkerTypeByPid(arg_pid)
    })
}
pub unsafe fn TerminateBackgroundWorker(arg_handle: *mut BackgroundWorkerHandle) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TerminateBackgroundWorker(arg_handle: *mut BackgroundWorkerHandle);
        }
        TerminateBackgroundWorker(arg_handle)
    })
}
extern "C" {
    pub static mut MyBgworkerEntry: *mut BackgroundWorker;
}
pub unsafe fn BackgroundWorkerInitializeConnection(
    arg_dbname: *const ::std::os::raw::c_char,
    arg_username: *const ::std::os::raw::c_char,
    arg_flags: uint32,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BackgroundWorkerInitializeConnection(
                arg_dbname: *const ::std::os::raw::c_char,
                arg_username: *const ::std::os::raw::c_char,
                arg_flags: uint32,
            );
        }
        BackgroundWorkerInitializeConnection(arg_dbname, arg_username, arg_flags)
    })
}
pub unsafe fn BackgroundWorkerInitializeConnectionByOid(
    arg_dboid: Oid,
    arg_useroid: Oid,
    arg_flags: uint32,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BackgroundWorkerInitializeConnectionByOid(
                arg_dboid: Oid,
                arg_useroid: Oid,
                arg_flags: uint32,
            );
        }
        BackgroundWorkerInitializeConnectionByOid(arg_dboid, arg_useroid, arg_flags)
    })
}
pub unsafe fn BackgroundWorkerBlockSignals() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BackgroundWorkerBlockSignals();
        }
        BackgroundWorkerBlockSignals()
    })
}
pub unsafe fn BackgroundWorkerUnblockSignals() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BackgroundWorkerUnblockSignals();
        }
        BackgroundWorkerUnblockSignals()
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shm_mq {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shm_mq_handle {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shm_mq_iovec {
    pub data: *const ::std::os::raw::c_char,
    pub len: Size,
}
impl Default for shm_mq_iovec {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const shm_mq_result_SHM_MQ_SUCCESS: shm_mq_result = 0;
pub const shm_mq_result_SHM_MQ_WOULD_BLOCK: shm_mq_result = 1;
pub const shm_mq_result_SHM_MQ_DETACHED: shm_mq_result = 2;
pub type shm_mq_result = ::std::os::raw::c_uint;
pub unsafe fn shm_mq_create(
    arg_address: *mut ::std::os::raw::c_void,
    arg_size: Size,
) -> *mut shm_mq {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn shm_mq_create(
                arg_address: *mut ::std::os::raw::c_void,
                arg_size: Size,
            ) -> *mut shm_mq;
        }
        shm_mq_create(arg_address, arg_size)
    })
}
pub unsafe fn shm_mq_set_receiver(arg_mq: *mut shm_mq, arg_arg1: *mut PGPROC) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn shm_mq_set_receiver(arg_mq: *mut shm_mq, arg_arg1: *mut PGPROC);
        }
        shm_mq_set_receiver(arg_mq, arg_arg1)
    })
}
pub unsafe fn shm_mq_set_sender(arg_mq: *mut shm_mq, arg_arg1: *mut PGPROC) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn shm_mq_set_sender(arg_mq: *mut shm_mq, arg_arg1: *mut PGPROC);
        }
        shm_mq_set_sender(arg_mq, arg_arg1)
    })
}
pub unsafe fn shm_mq_get_receiver(arg_arg1: *mut shm_mq) -> *mut PGPROC {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn shm_mq_get_receiver(arg_arg1: *mut shm_mq) -> *mut PGPROC;
        }
        shm_mq_get_receiver(arg_arg1)
    })
}
pub unsafe fn shm_mq_get_sender(arg_arg1: *mut shm_mq) -> *mut PGPROC {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn shm_mq_get_sender(arg_arg1: *mut shm_mq) -> *mut PGPROC;
        }
        shm_mq_get_sender(arg_arg1)
    })
}
pub unsafe fn shm_mq_attach(
    arg_mq: *mut shm_mq,
    arg_seg: *mut dsm_segment,
    arg_handle: *mut BackgroundWorkerHandle,
) -> *mut shm_mq_handle {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn shm_mq_attach(
                arg_mq: *mut shm_mq,
                arg_seg: *mut dsm_segment,
                arg_handle: *mut BackgroundWorkerHandle,
            ) -> *mut shm_mq_handle;
        }
        shm_mq_attach(arg_mq, arg_seg, arg_handle)
    })
}
pub unsafe fn shm_mq_set_handle(
    arg_arg1: *mut shm_mq_handle,
    arg_arg2: *mut BackgroundWorkerHandle,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn shm_mq_set_handle(
                arg_arg1: *mut shm_mq_handle,
                arg_arg2: *mut BackgroundWorkerHandle,
            );
        }
        shm_mq_set_handle(arg_arg1, arg_arg2)
    })
}
pub unsafe fn shm_mq_detach(arg_mqh: *mut shm_mq_handle) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn shm_mq_detach(arg_mqh: *mut shm_mq_handle);
        }
        shm_mq_detach(arg_mqh)
    })
}
pub unsafe fn shm_mq_get_queue(arg_mqh: *mut shm_mq_handle) -> *mut shm_mq {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn shm_mq_get_queue(arg_mqh: *mut shm_mq_handle) -> *mut shm_mq;
        }
        shm_mq_get_queue(arg_mqh)
    })
}
pub unsafe fn shm_mq_send(
    arg_mqh: *mut shm_mq_handle,
    arg_nbytes: Size,
    arg_data: *const ::std::os::raw::c_void,
    arg_nowait: bool,
) -> shm_mq_result {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn shm_mq_send(
                arg_mqh: *mut shm_mq_handle,
                arg_nbytes: Size,
                arg_data: *const ::std::os::raw::c_void,
                arg_nowait: bool,
            ) -> shm_mq_result;
        }
        shm_mq_send(arg_mqh, arg_nbytes, arg_data, arg_nowait)
    })
}
pub unsafe fn shm_mq_sendv(
    arg_mqh: *mut shm_mq_handle,
    arg_iov: *mut shm_mq_iovec,
    arg_iovcnt: ::std::os::raw::c_int,
    arg_nowait: bool,
) -> shm_mq_result {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn shm_mq_sendv(
                arg_mqh: *mut shm_mq_handle,
                arg_iov: *mut shm_mq_iovec,
                arg_iovcnt: ::std::os::raw::c_int,
                arg_nowait: bool,
            ) -> shm_mq_result;
        }
        shm_mq_sendv(arg_mqh, arg_iov, arg_iovcnt, arg_nowait)
    })
}
pub unsafe fn shm_mq_receive(
    arg_mqh: *mut shm_mq_handle,
    arg_nbytesp: *mut Size,
    arg_datap: *mut *mut ::std::os::raw::c_void,
    arg_nowait: bool,
) -> shm_mq_result {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn shm_mq_receive(
                arg_mqh: *mut shm_mq_handle,
                arg_nbytesp: *mut Size,
                arg_datap: *mut *mut ::std::os::raw::c_void,
                arg_nowait: bool,
            ) -> shm_mq_result;
        }
        shm_mq_receive(arg_mqh, arg_nbytesp, arg_datap, arg_nowait)
    })
}
pub unsafe fn shm_mq_wait_for_attach(arg_mqh: *mut shm_mq_handle) -> shm_mq_result {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn shm_mq_wait_for_attach(arg_mqh: *mut shm_mq_handle) -> shm_mq_result;
        }
        shm_mq_wait_for_attach(arg_mqh)
    })
}
extern "C" {
    pub static shm_mq_minimum_size: Size;
}
pub type parallel_worker_main_type =
    ::std::option::Option<unsafe extern "C" fn(seg: *mut dsm_segment, toc: *mut shm_toc)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParallelWorkerInfo {
    pub bgwhandle: *mut BackgroundWorkerHandle,
    pub error_mqh: *mut shm_mq_handle,
    pub pid: int32,
}
impl Default for ParallelWorkerInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParallelContext {
    pub node: dlist_node,
    pub subid: SubTransactionId,
    pub nworkers: ::std::os::raw::c_int,
    pub nworkers_to_launch: ::std::os::raw::c_int,
    pub nworkers_launched: ::std::os::raw::c_int,
    pub library_name: *mut ::std::os::raw::c_char,
    pub function_name: *mut ::std::os::raw::c_char,
    pub error_context_stack: *mut ErrorContextCallback,
    pub estimator: shm_toc_estimator,
    pub seg: *mut dsm_segment,
    pub private_memory: *mut ::std::os::raw::c_void,
    pub toc: *mut shm_toc,
    pub worker: *mut ParallelWorkerInfo,
    pub nknown_attached_workers: ::std::os::raw::c_int,
    pub known_attached_workers: *mut bool,
}
impl Default for ParallelContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParallelWorkerContext {
    pub seg: *mut dsm_segment,
    pub toc: *mut shm_toc,
}
impl Default for ParallelWorkerContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut ParallelMessagePending: bool;
}
extern "C" {
    pub static mut ParallelWorkerNumber: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut InitializingParallelWorker: bool;
}
pub unsafe fn CreateParallelContext(
    arg_library_name: *const ::std::os::raw::c_char,
    arg_function_name: *const ::std::os::raw::c_char,
    arg_nworkers: ::std::os::raw::c_int,
) -> *mut ParallelContext {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateParallelContext(
                arg_library_name: *const ::std::os::raw::c_char,
                arg_function_name: *const ::std::os::raw::c_char,
                arg_nworkers: ::std::os::raw::c_int,
            ) -> *mut ParallelContext;
        }
        CreateParallelContext(arg_library_name, arg_function_name, arg_nworkers)
    })
}
pub unsafe fn InitializeParallelDSM(arg_pcxt: *mut ParallelContext) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitializeParallelDSM(arg_pcxt: *mut ParallelContext);
        }
        InitializeParallelDSM(arg_pcxt)
    })
}
pub unsafe fn ReinitializeParallelDSM(arg_pcxt: *mut ParallelContext) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReinitializeParallelDSM(arg_pcxt: *mut ParallelContext);
        }
        ReinitializeParallelDSM(arg_pcxt)
    })
}
pub unsafe fn ReinitializeParallelWorkers(
    arg_pcxt: *mut ParallelContext,
    arg_nworkers_to_launch: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReinitializeParallelWorkers(
                arg_pcxt: *mut ParallelContext,
                arg_nworkers_to_launch: ::std::os::raw::c_int,
            );
        }
        ReinitializeParallelWorkers(arg_pcxt, arg_nworkers_to_launch)
    })
}
pub unsafe fn LaunchParallelWorkers(arg_pcxt: *mut ParallelContext) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LaunchParallelWorkers(arg_pcxt: *mut ParallelContext);
        }
        LaunchParallelWorkers(arg_pcxt)
    })
}
pub unsafe fn WaitForParallelWorkersToAttach(arg_pcxt: *mut ParallelContext) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn WaitForParallelWorkersToAttach(arg_pcxt: *mut ParallelContext);
        }
        WaitForParallelWorkersToAttach(arg_pcxt)
    })
}
pub unsafe fn WaitForParallelWorkersToFinish(arg_pcxt: *mut ParallelContext) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn WaitForParallelWorkersToFinish(arg_pcxt: *mut ParallelContext);
        }
        WaitForParallelWorkersToFinish(arg_pcxt)
    })
}
pub unsafe fn DestroyParallelContext(arg_pcxt: *mut ParallelContext) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DestroyParallelContext(arg_pcxt: *mut ParallelContext);
        }
        DestroyParallelContext(arg_pcxt)
    })
}
pub unsafe fn ParallelContextActive() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ParallelContextActive() -> bool;
        }
        ParallelContextActive()
    })
}
pub unsafe fn HandleParallelMessageInterrupt() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn HandleParallelMessageInterrupt();
        }
        HandleParallelMessageInterrupt()
    })
}
pub unsafe fn HandleParallelMessages() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn HandleParallelMessages();
        }
        HandleParallelMessages()
    })
}
pub unsafe fn AtEOXact_Parallel(arg_isCommit: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AtEOXact_Parallel(arg_isCommit: bool);
        }
        AtEOXact_Parallel(arg_isCommit)
    })
}
pub unsafe fn AtEOSubXact_Parallel(arg_isCommit: bool, arg_mySubId: SubTransactionId) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AtEOSubXact_Parallel(arg_isCommit: bool, arg_mySubId: SubTransactionId);
        }
        AtEOSubXact_Parallel(arg_isCommit, arg_mySubId)
    })
}
pub unsafe fn ParallelWorkerReportLastRecEnd(arg_last_xlog_end: XLogRecPtr) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ParallelWorkerReportLastRecEnd(arg_last_xlog_end: XLogRecPtr);
        }
        ParallelWorkerReportLastRecEnd(arg_last_xlog_end)
    })
}
pub unsafe fn ParallelWorkerMain(arg_main_arg: Datum) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ParallelWorkerMain(arg_main_arg: Datum);
        }
        ParallelWorkerMain(arg_main_arg)
    })
}
pub type Relids = *mut Bitmapset;
pub const CostSelector_STARTUP_COST: CostSelector = 0;
pub const CostSelector_TOTAL_COST: CostSelector = 1;
pub type CostSelector = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct QualCost {
    pub startup: Cost,
    pub per_tuple: Cost,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AggClauseCosts {
    pub numAggs: ::std::os::raw::c_int,
    pub numOrderedAggs: ::std::os::raw::c_int,
    pub hasNonPartial: bool,
    pub hasNonSerial: bool,
    pub transCost: QualCost,
    pub finalCost: QualCost,
    pub transitionSpace: Size,
}
pub const UpperRelationKind_UPPERREL_SETOP: UpperRelationKind = 0;
pub const UpperRelationKind_UPPERREL_PARTIAL_GROUP_AGG: UpperRelationKind = 1;
pub const UpperRelationKind_UPPERREL_GROUP_AGG: UpperRelationKind = 2;
pub const UpperRelationKind_UPPERREL_WINDOW: UpperRelationKind = 3;
pub const UpperRelationKind_UPPERREL_DISTINCT: UpperRelationKind = 4;
pub const UpperRelationKind_UPPERREL_ORDERED: UpperRelationKind = 5;
pub const UpperRelationKind_UPPERREL_FINAL: UpperRelationKind = 6;
pub type UpperRelationKind = ::std::os::raw::c_uint;
pub const InheritanceKind_INHKIND_NONE: InheritanceKind = 0;
pub const InheritanceKind_INHKIND_INHERITED: InheritanceKind = 1;
pub const InheritanceKind_INHKIND_PARTITIONED: InheritanceKind = 2;
pub type InheritanceKind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PlannerGlobal {
    pub type_: NodeTag,
    pub boundParams: ParamListInfo,
    pub subplans: *mut List,
    pub subroots: *mut List,
    pub rewindPlanIDs: *mut Bitmapset,
    pub finalrtable: *mut List,
    pub finalrowmarks: *mut List,
    pub resultRelations: *mut List,
    pub rootResultRelations: *mut List,
    pub appendRelations: *mut List,
    pub relationOids: *mut List,
    pub invalItems: *mut List,
    pub paramExecTypes: *mut List,
    pub lastPHId: Index,
    pub lastRowMarkId: Index,
    pub lastPlanNodeId: ::std::os::raw::c_int,
    pub transientPlan: bool,
    pub dependsOnRole: bool,
    pub parallelModeOK: bool,
    pub parallelModeNeeded: bool,
    pub maxParallelHazard: ::std::os::raw::c_char,
    pub partition_directory: PartitionDirectory,
}
impl Default for PlannerGlobal {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PlannerInfo {
    pub type_: NodeTag,
    pub parse: *mut Query,
    pub glob: *mut PlannerGlobal,
    pub query_level: Index,
    pub parent_root: *mut PlannerInfo,
    pub plan_params: *mut List,
    pub outer_params: *mut Bitmapset,
    pub simple_rel_array: *mut *mut RelOptInfo,
    pub simple_rel_array_size: ::std::os::raw::c_int,
    pub simple_rte_array: *mut *mut RangeTblEntry,
    pub append_rel_array: *mut *mut AppendRelInfo,
    pub all_baserels: Relids,
    pub nullable_baserels: Relids,
    pub join_rel_list: *mut List,
    pub join_rel_hash: *mut HTAB,
    pub join_rel_level: *mut *mut List,
    pub join_cur_level: ::std::os::raw::c_int,
    pub init_plans: *mut List,
    pub cte_plan_ids: *mut List,
    pub multiexpr_params: *mut List,
    pub eq_classes: *mut List,
    pub ec_merging_done: bool,
    pub canon_pathkeys: *mut List,
    pub left_join_clauses: *mut List,
    pub right_join_clauses: *mut List,
    pub full_join_clauses: *mut List,
    pub join_info_list: *mut List,
    pub append_rel_list: *mut List,
    pub rowMarks: *mut List,
    pub placeholder_list: *mut List,
    pub fkey_list: *mut List,
    pub query_pathkeys: *mut List,
    pub group_pathkeys: *mut List,
    pub window_pathkeys: *mut List,
    pub distinct_pathkeys: *mut List,
    pub sort_pathkeys: *mut List,
    pub part_schemes: *mut List,
    pub initial_rels: *mut List,
    pub upper_rels: [*mut List; 7usize],
    pub upper_targets: [*mut PathTarget; 7usize],
    pub processed_tlist: *mut List,
    pub grouping_map: *mut AttrNumber,
    pub minmax_aggs: *mut List,
    pub planner_cxt: MemoryContext,
    pub total_table_pages: f64,
    pub tuple_fraction: f64,
    pub limit_tuples: f64,
    pub qual_security_level: Index,
    pub inhTargetKind: InheritanceKind,
    pub hasJoinRTEs: bool,
    pub hasLateralRTEs: bool,
    pub hasHavingQual: bool,
    pub hasPseudoConstantQuals: bool,
    pub hasRecursion: bool,
    pub wt_param_id: ::std::os::raw::c_int,
    pub non_recursive_path: *mut Path,
    pub curOuterRels: Relids,
    pub curOuterParams: *mut List,
    pub join_search_private: *mut ::std::os::raw::c_void,
    pub partColsUpdated: bool,
}
impl Default for PlannerInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PartitionSchemeData {
    pub strategy: ::std::os::raw::c_char,
    pub partnatts: int16,
    pub partopfamily: *mut Oid,
    pub partopcintype: *mut Oid,
    pub partcollation: *mut Oid,
    pub parttyplen: *mut int16,
    pub parttypbyval: *mut bool,
    pub partsupfunc: *mut FmgrInfo,
}
impl Default for PartitionSchemeData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PartitionScheme = *mut PartitionSchemeData;
pub const RelOptKind_RELOPT_BASEREL: RelOptKind = 0;
pub const RelOptKind_RELOPT_JOINREL: RelOptKind = 1;
pub const RelOptKind_RELOPT_OTHER_MEMBER_REL: RelOptKind = 2;
pub const RelOptKind_RELOPT_OTHER_JOINREL: RelOptKind = 3;
pub const RelOptKind_RELOPT_UPPER_REL: RelOptKind = 4;
pub const RelOptKind_RELOPT_OTHER_UPPER_REL: RelOptKind = 5;
pub const RelOptKind_RELOPT_DEADREL: RelOptKind = 6;
pub type RelOptKind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RelOptInfo {
    pub type_: NodeTag,
    pub reloptkind: RelOptKind,
    pub relids: Relids,
    pub rows: f64,
    pub consider_startup: bool,
    pub consider_param_startup: bool,
    pub consider_parallel: bool,
    pub reltarget: *mut PathTarget,
    pub pathlist: *mut List,
    pub ppilist: *mut List,
    pub partial_pathlist: *mut List,
    pub cheapest_startup_path: *mut Path,
    pub cheapest_total_path: *mut Path,
    pub cheapest_unique_path: *mut Path,
    pub cheapest_parameterized_paths: *mut List,
    pub direct_lateral_relids: Relids,
    pub lateral_relids: Relids,
    pub relid: Index,
    pub reltablespace: Oid,
    pub rtekind: RTEKind,
    pub min_attr: AttrNumber,
    pub max_attr: AttrNumber,
    pub attr_needed: *mut Relids,
    pub attr_widths: *mut int32,
    pub lateral_vars: *mut List,
    pub lateral_referencers: Relids,
    pub indexlist: *mut List,
    pub statlist: *mut List,
    pub pages: BlockNumber,
    pub tuples: f64,
    pub allvisfrac: f64,
    pub eclass_indexes: *mut Bitmapset,
    pub subroot: *mut PlannerInfo,
    pub subplan_params: *mut List,
    pub rel_parallel_workers: ::std::os::raw::c_int,
    pub serverid: Oid,
    pub userid: Oid,
    pub useridiscurrent: bool,
    pub fdwroutine: *mut FdwRoutine,
    pub fdw_private: *mut ::std::os::raw::c_void,
    pub unique_for_rels: *mut List,
    pub non_unique_for_rels: *mut List,
    pub baserestrictinfo: *mut List,
    pub baserestrictcost: QualCost,
    pub baserestrict_min_security: Index,
    pub joininfo: *mut List,
    pub has_eclass_joins: bool,
    pub consider_partitionwise_join: bool,
    pub top_parent_relids: Relids,
    pub part_scheme: PartitionScheme,
    pub nparts: ::std::os::raw::c_int,
    pub boundinfo: *mut PartitionBoundInfoData,
    pub partbounds_merged: bool,
    pub partition_qual: *mut List,
    pub part_rels: *mut *mut RelOptInfo,
    pub all_partrels: Relids,
    pub partexprs: *mut *mut List,
    pub nullable_partexprs: *mut *mut List,
    pub partitioned_child_rels: *mut List,
}
impl Default for RelOptInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexOptInfo {
    pub type_: NodeTag,
    pub indexoid: Oid,
    pub reltablespace: Oid,
    pub rel: *mut RelOptInfo,
    pub pages: BlockNumber,
    pub tuples: f64,
    pub tree_height: ::std::os::raw::c_int,
    pub ncolumns: ::std::os::raw::c_int,
    pub nkeycolumns: ::std::os::raw::c_int,
    pub indexkeys: *mut ::std::os::raw::c_int,
    pub indexcollations: *mut Oid,
    pub opfamily: *mut Oid,
    pub opcintype: *mut Oid,
    pub sortopfamily: *mut Oid,
    pub reverse_sort: *mut bool,
    pub nulls_first: *mut bool,
    pub opclassoptions: *mut *mut bytea,
    pub canreturn: *mut bool,
    pub relam: Oid,
    pub indexprs: *mut List,
    pub indpred: *mut List,
    pub indextlist: *mut List,
    pub indrestrictinfo: *mut List,
    pub predOK: bool,
    pub unique: bool,
    pub immediate: bool,
    pub hypothetical: bool,
    pub amcanorderbyop: bool,
    pub amoptionalkey: bool,
    pub amsearcharray: bool,
    pub amsearchnulls: bool,
    pub amhasgettuple: bool,
    pub amhasgetbitmap: bool,
    pub amcanparallel: bool,
    pub amcanmarkpos: bool,
    pub amcostestimate: ::std::option::Option<unsafe extern "C" fn()>,
}
impl Default for IndexOptInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForeignKeyOptInfo {
    pub type_: NodeTag,
    pub con_relid: Index,
    pub ref_relid: Index,
    pub nkeys: ::std::os::raw::c_int,
    pub conkey: [AttrNumber; 32usize],
    pub confkey: [AttrNumber; 32usize],
    pub conpfeqop: [Oid; 32usize],
    pub nmatched_ec: ::std::os::raw::c_int,
    pub nmatched_rcols: ::std::os::raw::c_int,
    pub nmatched_ri: ::std::os::raw::c_int,
    pub eclass: [*mut EquivalenceClass; 32usize],
    pub rinfos: [*mut List; 32usize],
}
impl Default for ForeignKeyOptInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StatisticExtInfo {
    pub type_: NodeTag,
    pub statOid: Oid,
    pub rel: *mut RelOptInfo,
    pub kind: ::std::os::raw::c_char,
    pub keys: *mut Bitmapset,
}
impl Default for StatisticExtInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EquivalenceClass {
    pub type_: NodeTag,
    pub ec_opfamilies: *mut List,
    pub ec_collation: Oid,
    pub ec_members: *mut List,
    pub ec_sources: *mut List,
    pub ec_derives: *mut List,
    pub ec_relids: Relids,
    pub ec_has_const: bool,
    pub ec_has_volatile: bool,
    pub ec_below_outer_join: bool,
    pub ec_broken: bool,
    pub ec_sortref: Index,
    pub ec_min_security: Index,
    pub ec_max_security: Index,
    pub ec_merged: *mut EquivalenceClass,
}
impl Default for EquivalenceClass {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EquivalenceMember {
    pub type_: NodeTag,
    pub em_expr: *mut Expr,
    pub em_relids: Relids,
    pub em_nullable_relids: Relids,
    pub em_is_const: bool,
    pub em_is_child: bool,
    pub em_datatype: Oid,
}
impl Default for EquivalenceMember {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PathKey {
    pub type_: NodeTag,
    pub pk_eclass: *mut EquivalenceClass,
    pub pk_opfamily: Oid,
    pub pk_strategy: ::std::os::raw::c_int,
    pub pk_nulls_first: bool,
}
impl Default for PathKey {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PathTarget {
    pub type_: NodeTag,
    pub exprs: *mut List,
    pub sortgrouprefs: *mut Index,
    pub cost: QualCost,
    pub width: ::std::os::raw::c_int,
}
impl Default for PathTarget {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParamPathInfo {
    pub type_: NodeTag,
    pub ppi_req_outer: Relids,
    pub ppi_rows: f64,
    pub ppi_clauses: *mut List,
}
impl Default for ParamPathInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Path {
    pub type_: NodeTag,
    pub pathtype: NodeTag,
    pub parent: *mut RelOptInfo,
    pub pathtarget: *mut PathTarget,
    pub param_info: *mut ParamPathInfo,
    pub parallel_aware: bool,
    pub parallel_safe: bool,
    pub parallel_workers: ::std::os::raw::c_int,
    pub rows: f64,
    pub startup_cost: Cost,
    pub total_cost: Cost,
    pub pathkeys: *mut List,
}
impl Default for Path {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexPath {
    pub path: Path,
    pub indexinfo: *mut IndexOptInfo,
    pub indexclauses: *mut List,
    pub indexorderbys: *mut List,
    pub indexorderbycols: *mut List,
    pub indexscandir: ScanDirection,
    pub indextotalcost: Cost,
    pub indexselectivity: Selectivity,
}
impl Default for IndexPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexClause {
    pub type_: NodeTag,
    pub rinfo: *mut RestrictInfo,
    pub indexquals: *mut List,
    pub lossy: bool,
    pub indexcol: AttrNumber,
    pub indexcols: *mut List,
}
impl Default for IndexClause {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapHeapPath {
    pub path: Path,
    pub bitmapqual: *mut Path,
}
impl Default for BitmapHeapPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapAndPath {
    pub path: Path,
    pub bitmapquals: *mut List,
    pub bitmapselectivity: Selectivity,
}
impl Default for BitmapAndPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitmapOrPath {
    pub path: Path,
    pub bitmapquals: *mut List,
    pub bitmapselectivity: Selectivity,
}
impl Default for BitmapOrPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TidPath {
    pub path: Path,
    pub tidquals: *mut List,
}
impl Default for TidPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubqueryScanPath {
    pub path: Path,
    pub subpath: *mut Path,
}
impl Default for SubqueryScanPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForeignPath {
    pub path: Path,
    pub fdw_outerpath: *mut Path,
    pub fdw_private: *mut List,
}
impl Default for ForeignPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CustomPath {
    pub path: Path,
    pub flags: uint32,
    pub custom_paths: *mut List,
    pub custom_private: *mut List,
    pub methods: *const CustomPathMethods,
}
impl Default for CustomPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AppendPath {
    pub path: Path,
    pub partitioned_rels: *mut List,
    pub subpaths: *mut List,
    pub first_partial_path: ::std::os::raw::c_int,
    pub limit_tuples: f64,
}
impl Default for AppendPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn is_dummy_rel(arg_rel: *mut RelOptInfo) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn is_dummy_rel(arg_rel: *mut RelOptInfo) -> bool;
        }
        is_dummy_rel(arg_rel)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeAppendPath {
    pub path: Path,
    pub partitioned_rels: *mut List,
    pub subpaths: *mut List,
    pub limit_tuples: f64,
}
impl Default for MergeAppendPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GroupResultPath {
    pub path: Path,
    pub quals: *mut List,
}
impl Default for GroupResultPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MaterialPath {
    pub path: Path,
    pub subpath: *mut Path,
}
impl Default for MaterialPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const UniquePathMethod_UNIQUE_PATH_NOOP: UniquePathMethod = 0;
pub const UniquePathMethod_UNIQUE_PATH_HASH: UniquePathMethod = 1;
pub const UniquePathMethod_UNIQUE_PATH_SORT: UniquePathMethod = 2;
pub type UniquePathMethod = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UniquePath {
    pub path: Path,
    pub subpath: *mut Path,
    pub umethod: UniquePathMethod,
    pub in_operators: *mut List,
    pub uniq_exprs: *mut List,
}
impl Default for UniquePath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GatherPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub single_copy: bool,
    pub num_workers: ::std::os::raw::c_int,
}
impl Default for GatherPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GatherMergePath {
    pub path: Path,
    pub subpath: *mut Path,
    pub num_workers: ::std::os::raw::c_int,
}
impl Default for GatherMergePath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JoinPath {
    pub path: Path,
    pub jointype: JoinType,
    pub inner_unique: bool,
    pub outerjoinpath: *mut Path,
    pub innerjoinpath: *mut Path,
    pub joinrestrictinfo: *mut List,
}
impl Default for JoinPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NestPath = JoinPath;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergePath {
    pub jpath: JoinPath,
    pub path_mergeclauses: *mut List,
    pub outersortkeys: *mut List,
    pub innersortkeys: *mut List,
    pub skip_mark_restore: bool,
    pub materialize_inner: bool,
}
impl Default for MergePath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HashPath {
    pub jpath: JoinPath,
    pub path_hashclauses: *mut List,
    pub num_batches: ::std::os::raw::c_int,
    pub inner_rows_total: f64,
}
impl Default for HashPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProjectionPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub dummypp: bool,
}
impl Default for ProjectionPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProjectSetPath {
    pub path: Path,
    pub subpath: *mut Path,
}
impl Default for ProjectSetPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SortPath {
    pub path: Path,
    pub subpath: *mut Path,
}
impl Default for SortPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IncrementalSortPath {
    pub spath: SortPath,
    pub nPresortedCols: ::std::os::raw::c_int,
}
impl Default for IncrementalSortPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GroupPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub groupClause: *mut List,
    pub qual: *mut List,
}
impl Default for GroupPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UpperUniquePath {
    pub path: Path,
    pub subpath: *mut Path,
    pub numkeys: ::std::os::raw::c_int,
}
impl Default for UpperUniquePath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub aggstrategy: AggStrategy,
    pub aggsplit: AggSplit,
    pub numGroups: f64,
    pub transitionSpace: uint64,
    pub groupClause: *mut List,
    pub qual: *mut List,
}
impl Default for AggPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GroupingSetData {
    pub type_: NodeTag,
    pub set: *mut List,
    pub numGroups: f64,
}
impl Default for GroupingSetData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RollupData {
    pub type_: NodeTag,
    pub groupClause: *mut List,
    pub gsets: *mut List,
    pub gsets_data: *mut List,
    pub numGroups: f64,
    pub hashable: bool,
    pub is_hashed: bool,
}
impl Default for RollupData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GroupingSetsPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub aggstrategy: AggStrategy,
    pub rollups: *mut List,
    pub qual: *mut List,
    pub transitionSpace: uint64,
}
impl Default for GroupingSetsPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MinMaxAggPath {
    pub path: Path,
    pub mmaggregates: *mut List,
    pub quals: *mut List,
}
impl Default for MinMaxAggPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowAggPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub winclause: *mut WindowClause,
}
impl Default for WindowAggPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SetOpPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub cmd: SetOpCmd,
    pub strategy: SetOpStrategy,
    pub distinctList: *mut List,
    pub flagColIdx: AttrNumber,
    pub firstFlag: ::std::os::raw::c_int,
    pub numGroups: f64,
}
impl Default for SetOpPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RecursiveUnionPath {
    pub path: Path,
    pub leftpath: *mut Path,
    pub rightpath: *mut Path,
    pub distinctList: *mut List,
    pub wtParam: ::std::os::raw::c_int,
    pub numGroups: f64,
}
impl Default for RecursiveUnionPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LockRowsPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub rowMarks: *mut List,
    pub epqParam: ::std::os::raw::c_int,
}
impl Default for LockRowsPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ModifyTablePath {
    pub path: Path,
    pub operation: CmdType,
    pub canSetTag: bool,
    pub nominalRelation: Index,
    pub rootRelation: Index,
    pub partColsUpdated: bool,
    pub resultRelations: *mut List,
    pub subpaths: *mut List,
    pub subroots: *mut List,
    pub withCheckOptionLists: *mut List,
    pub returningLists: *mut List,
    pub rowMarks: *mut List,
    pub onconflict: *mut OnConflictExpr,
    pub epqParam: ::std::os::raw::c_int,
}
impl Default for ModifyTablePath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LimitPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub limitOffset: *mut Node,
    pub limitCount: *mut Node,
    pub limitOption: LimitOption,
}
impl Default for LimitPath {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RestrictInfo {
    pub type_: NodeTag,
    pub clause: *mut Expr,
    pub is_pushed_down: bool,
    pub outerjoin_delayed: bool,
    pub can_join: bool,
    pub pseudoconstant: bool,
    pub leakproof: bool,
    pub security_level: Index,
    pub clause_relids: Relids,
    pub required_relids: Relids,
    pub outer_relids: Relids,
    pub nullable_relids: Relids,
    pub left_relids: Relids,
    pub right_relids: Relids,
    pub orclause: *mut Expr,
    pub parent_ec: *mut EquivalenceClass,
    pub eval_cost: QualCost,
    pub norm_selec: Selectivity,
    pub outer_selec: Selectivity,
    pub mergeopfamilies: *mut List,
    pub left_ec: *mut EquivalenceClass,
    pub right_ec: *mut EquivalenceClass,
    pub left_em: *mut EquivalenceMember,
    pub right_em: *mut EquivalenceMember,
    pub scansel_cache: *mut List,
    pub outer_is_left: bool,
    pub hashjoinoperator: Oid,
    pub left_bucketsize: Selectivity,
    pub right_bucketsize: Selectivity,
    pub left_mcvfreq: Selectivity,
    pub right_mcvfreq: Selectivity,
}
impl Default for RestrictInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MergeScanSelCache {
    pub opfamily: Oid,
    pub collation: Oid,
    pub strategy: ::std::os::raw::c_int,
    pub nulls_first: bool,
    pub leftstartsel: Selectivity,
    pub leftendsel: Selectivity,
    pub rightstartsel: Selectivity,
    pub rightendsel: Selectivity,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PlaceHolderVar {
    pub xpr: Expr,
    pub phexpr: *mut Expr,
    pub phrels: Relids,
    pub phid: Index,
    pub phlevelsup: Index,
}
impl Default for PlaceHolderVar {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SpecialJoinInfo {
    pub type_: NodeTag,
    pub min_lefthand: Relids,
    pub min_righthand: Relids,
    pub syn_lefthand: Relids,
    pub syn_righthand: Relids,
    pub jointype: JoinType,
    pub lhs_strict: bool,
    pub delay_upper_joins: bool,
    pub semi_can_btree: bool,
    pub semi_can_hash: bool,
    pub semi_operators: *mut List,
    pub semi_rhs_exprs: *mut List,
}
impl Default for SpecialJoinInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AppendRelInfo {
    pub type_: NodeTag,
    pub parent_relid: Index,
    pub child_relid: Index,
    pub parent_reltype: Oid,
    pub child_reltype: Oid,
    pub translated_vars: *mut List,
    pub num_child_cols: ::std::os::raw::c_int,
    pub parent_colnos: *mut AttrNumber,
    pub parent_reloid: Oid,
}
impl Default for AppendRelInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PlaceHolderInfo {
    pub type_: NodeTag,
    pub phid: Index,
    pub ph_var: *mut PlaceHolderVar,
    pub ph_eval_at: Relids,
    pub ph_lateral: Relids,
    pub ph_needed: Relids,
    pub ph_width: int32,
}
impl Default for PlaceHolderInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MinMaxAggInfo {
    pub type_: NodeTag,
    pub aggfnoid: Oid,
    pub aggsortop: Oid,
    pub target: *mut Expr,
    pub subroot: *mut PlannerInfo,
    pub path: *mut Path,
    pub pathcost: Cost,
    pub param: *mut Param,
}
impl Default for MinMaxAggInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PlannerParamItem {
    pub type_: NodeTag,
    pub item: *mut Node,
    pub paramId: ::std::os::raw::c_int,
}
impl Default for PlannerParamItem {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SemiAntiJoinFactors {
    pub outer_match_frac: Selectivity,
    pub match_count: Selectivity,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JoinPathExtraData {
    pub restrictlist: *mut List,
    pub mergeclause_list: *mut List,
    pub inner_unique: bool,
    pub sjinfo: *mut SpecialJoinInfo,
    pub semifactors: SemiAntiJoinFactors,
    pub param_source_rels: Relids,
}
impl Default for JoinPathExtraData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const PartitionwiseAggregateType_PARTITIONWISE_AGGREGATE_NONE: PartitionwiseAggregateType = 0;
pub const PartitionwiseAggregateType_PARTITIONWISE_AGGREGATE_FULL: PartitionwiseAggregateType = 1;
pub const PartitionwiseAggregateType_PARTITIONWISE_AGGREGATE_PARTIAL: PartitionwiseAggregateType =
    2;
pub type PartitionwiseAggregateType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GroupPathExtraData {
    pub flags: ::std::os::raw::c_int,
    pub partial_costs_set: bool,
    pub agg_partial_costs: AggClauseCosts,
    pub agg_final_costs: AggClauseCosts,
    pub target_parallel_safe: bool,
    pub havingQual: *mut Node,
    pub targetList: *mut List,
    pub patype: PartitionwiseAggregateType,
}
impl Default for GroupPathExtraData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FinalPathExtraData {
    pub limit_needed: bool,
    pub limit_tuples: f64,
    pub count_est: int64,
    pub offset_est: int64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct JoinCostWorkspace {
    pub startup_cost: Cost,
    pub total_cost: Cost,
    pub run_cost: Cost,
    pub inner_run_cost: Cost,
    pub inner_rescan_run_cost: Cost,
    pub outer_rows: f64,
    pub inner_rows: f64,
    pub outer_skip_rows: f64,
    pub inner_skip_rows: f64,
    pub numbuckets: ::std::os::raw::c_int,
    pub numbatches: ::std::os::raw::c_int,
    pub inner_rows_total: f64,
}
pub type GetForeignRelSize_function = ::std::option::Option<
    unsafe extern "C" fn(root: *mut PlannerInfo, baserel: *mut RelOptInfo, foreigntableid: Oid),
>;
pub type GetForeignPaths_function = ::std::option::Option<
    unsafe extern "C" fn(root: *mut PlannerInfo, baserel: *mut RelOptInfo, foreigntableid: Oid),
>;
pub type GetForeignPlan_function = ::std::option::Option<
    unsafe extern "C" fn(
        root: *mut PlannerInfo,
        baserel: *mut RelOptInfo,
        foreigntableid: Oid,
        best_path: *mut ForeignPath,
        tlist: *mut List,
        scan_clauses: *mut List,
        outer_plan: *mut Plan,
    ) -> *mut ForeignScan,
>;
pub type BeginForeignScan_function = ::std::option::Option<
    unsafe extern "C" fn(node: *mut ForeignScanState, eflags: ::std::os::raw::c_int),
>;
pub type IterateForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState) -> *mut TupleTableSlot>;
pub type RecheckForeignScan_function = ::std::option::Option<
    unsafe extern "C" fn(node: *mut ForeignScanState, slot: *mut TupleTableSlot) -> bool,
>;
pub type ReScanForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState)>;
pub type EndForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState)>;
pub type GetForeignJoinPaths_function = ::std::option::Option<
    unsafe extern "C" fn(
        root: *mut PlannerInfo,
        joinrel: *mut RelOptInfo,
        outerrel: *mut RelOptInfo,
        innerrel: *mut RelOptInfo,
        jointype: JoinType,
        extra: *mut JoinPathExtraData,
    ),
>;
pub type GetForeignUpperPaths_function = ::std::option::Option<
    unsafe extern "C" fn(
        root: *mut PlannerInfo,
        stage: UpperRelationKind,
        input_rel: *mut RelOptInfo,
        output_rel: *mut RelOptInfo,
        extra: *mut ::std::os::raw::c_void,
    ),
>;
pub type AddForeignUpdateTargets_function = ::std::option::Option<
    unsafe extern "C" fn(
        parsetree: *mut Query,
        target_rte: *mut RangeTblEntry,
        target_relation: Relation,
    ),
>;
pub type PlanForeignModify_function = ::std::option::Option<
    unsafe extern "C" fn(
        root: *mut PlannerInfo,
        plan: *mut ModifyTable,
        resultRelation: Index,
        subplan_index: ::std::os::raw::c_int,
    ) -> *mut List,
>;
pub type BeginForeignModify_function = ::std::option::Option<
    unsafe extern "C" fn(
        mtstate: *mut ModifyTableState,
        rinfo: *mut ResultRelInfo,
        fdw_private: *mut List,
        subplan_index: ::std::os::raw::c_int,
        eflags: ::std::os::raw::c_int,
    ),
>;
pub type ExecForeignInsert_function = ::std::option::Option<
    unsafe extern "C" fn(
        estate: *mut EState,
        rinfo: *mut ResultRelInfo,
        slot: *mut TupleTableSlot,
        planSlot: *mut TupleTableSlot,
    ) -> *mut TupleTableSlot,
>;
pub type ExecForeignUpdate_function = ::std::option::Option<
    unsafe extern "C" fn(
        estate: *mut EState,
        rinfo: *mut ResultRelInfo,
        slot: *mut TupleTableSlot,
        planSlot: *mut TupleTableSlot,
    ) -> *mut TupleTableSlot,
>;
pub type ExecForeignDelete_function = ::std::option::Option<
    unsafe extern "C" fn(
        estate: *mut EState,
        rinfo: *mut ResultRelInfo,
        slot: *mut TupleTableSlot,
        planSlot: *mut TupleTableSlot,
    ) -> *mut TupleTableSlot,
>;
pub type EndForeignModify_function =
    ::std::option::Option<unsafe extern "C" fn(estate: *mut EState, rinfo: *mut ResultRelInfo)>;
pub type BeginForeignInsert_function = ::std::option::Option<
    unsafe extern "C" fn(mtstate: *mut ModifyTableState, rinfo: *mut ResultRelInfo),
>;
pub type EndForeignInsert_function =
    ::std::option::Option<unsafe extern "C" fn(estate: *mut EState, rinfo: *mut ResultRelInfo)>;
pub type IsForeignRelUpdatable_function =
    ::std::option::Option<unsafe extern "C" fn(rel: Relation) -> ::std::os::raw::c_int>;
pub type PlanDirectModify_function = ::std::option::Option<
    unsafe extern "C" fn(
        root: *mut PlannerInfo,
        plan: *mut ModifyTable,
        resultRelation: Index,
        subplan_index: ::std::os::raw::c_int,
    ) -> bool,
>;
pub type BeginDirectModify_function = ::std::option::Option<
    unsafe extern "C" fn(node: *mut ForeignScanState, eflags: ::std::os::raw::c_int),
>;
pub type IterateDirectModify_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState) -> *mut TupleTableSlot>;
pub type EndDirectModify_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState)>;
pub type GetForeignRowMarkType_function = ::std::option::Option<
    unsafe extern "C" fn(rte: *mut RangeTblEntry, strength: LockClauseStrength) -> RowMarkType,
>;
pub type RefetchForeignRow_function = ::std::option::Option<
    unsafe extern "C" fn(
        estate: *mut EState,
        erm: *mut ExecRowMark,
        rowid: Datum,
        slot: *mut TupleTableSlot,
        updated: *mut bool,
    ),
>;
pub type ExplainForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState, es: *mut ExplainState)>;
pub type ExplainForeignModify_function = ::std::option::Option<
    unsafe extern "C" fn(
        mtstate: *mut ModifyTableState,
        rinfo: *mut ResultRelInfo,
        fdw_private: *mut List,
        subplan_index: ::std::os::raw::c_int,
        es: *mut ExplainState,
    ),
>;
pub type ExplainDirectModify_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState, es: *mut ExplainState)>;
pub type AcquireSampleRowsFunc = ::std::option::Option<
    unsafe extern "C" fn(
        relation: Relation,
        elevel: ::std::os::raw::c_int,
        rows: *mut HeapTuple,
        targrows: ::std::os::raw::c_int,
        totalrows: *mut f64,
        totaldeadrows: *mut f64,
    ) -> ::std::os::raw::c_int,
>;
pub type AnalyzeForeignTable_function = ::std::option::Option<
    unsafe extern "C" fn(
        relation: Relation,
        func: *mut AcquireSampleRowsFunc,
        totalpages: *mut BlockNumber,
    ) -> bool,
>;
pub type ImportForeignSchema_function = ::std::option::Option<
    unsafe extern "C" fn(stmt: *mut ImportForeignSchemaStmt, serverOid: Oid) -> *mut List,
>;
pub type EstimateDSMForeignScan_function = ::std::option::Option<
    unsafe extern "C" fn(node: *mut ForeignScanState, pcxt: *mut ParallelContext) -> Size,
>;
pub type InitializeDSMForeignScan_function = ::std::option::Option<
    unsafe extern "C" fn(
        node: *mut ForeignScanState,
        pcxt: *mut ParallelContext,
        coordinate: *mut ::std::os::raw::c_void,
    ),
>;
pub type ReInitializeDSMForeignScan_function = ::std::option::Option<
    unsafe extern "C" fn(
        node: *mut ForeignScanState,
        pcxt: *mut ParallelContext,
        coordinate: *mut ::std::os::raw::c_void,
    ),
>;
pub type InitializeWorkerForeignScan_function = ::std::option::Option<
    unsafe extern "C" fn(
        node: *mut ForeignScanState,
        toc: *mut shm_toc,
        coordinate: *mut ::std::os::raw::c_void,
    ),
>;
pub type ShutdownForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState)>;
pub type IsForeignScanParallelSafe_function = ::std::option::Option<
    unsafe extern "C" fn(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        rte: *mut RangeTblEntry,
    ) -> bool,
>;
pub type ReparameterizeForeignPathByChild_function = ::std::option::Option<
    unsafe extern "C" fn(
        root: *mut PlannerInfo,
        fdw_private: *mut List,
        child_rel: *mut RelOptInfo,
    ) -> *mut List,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FdwRoutine {
    pub type_: NodeTag,
    pub GetForeignRelSize: GetForeignRelSize_function,
    pub GetForeignPaths: GetForeignPaths_function,
    pub GetForeignPlan: GetForeignPlan_function,
    pub BeginForeignScan: BeginForeignScan_function,
    pub IterateForeignScan: IterateForeignScan_function,
    pub ReScanForeignScan: ReScanForeignScan_function,
    pub EndForeignScan: EndForeignScan_function,
    pub GetForeignJoinPaths: GetForeignJoinPaths_function,
    pub GetForeignUpperPaths: GetForeignUpperPaths_function,
    pub AddForeignUpdateTargets: AddForeignUpdateTargets_function,
    pub PlanForeignModify: PlanForeignModify_function,
    pub BeginForeignModify: BeginForeignModify_function,
    pub ExecForeignInsert: ExecForeignInsert_function,
    pub ExecForeignUpdate: ExecForeignUpdate_function,
    pub ExecForeignDelete: ExecForeignDelete_function,
    pub EndForeignModify: EndForeignModify_function,
    pub BeginForeignInsert: BeginForeignInsert_function,
    pub EndForeignInsert: EndForeignInsert_function,
    pub IsForeignRelUpdatable: IsForeignRelUpdatable_function,
    pub PlanDirectModify: PlanDirectModify_function,
    pub BeginDirectModify: BeginDirectModify_function,
    pub IterateDirectModify: IterateDirectModify_function,
    pub EndDirectModify: EndDirectModify_function,
    pub GetForeignRowMarkType: GetForeignRowMarkType_function,
    pub RefetchForeignRow: RefetchForeignRow_function,
    pub RecheckForeignScan: RecheckForeignScan_function,
    pub ExplainForeignScan: ExplainForeignScan_function,
    pub ExplainForeignModify: ExplainForeignModify_function,
    pub ExplainDirectModify: ExplainDirectModify_function,
    pub AnalyzeForeignTable: AnalyzeForeignTable_function,
    pub ImportForeignSchema: ImportForeignSchema_function,
    pub IsForeignScanParallelSafe: IsForeignScanParallelSafe_function,
    pub EstimateDSMForeignScan: EstimateDSMForeignScan_function,
    pub InitializeDSMForeignScan: InitializeDSMForeignScan_function,
    pub ReInitializeDSMForeignScan: ReInitializeDSMForeignScan_function,
    pub InitializeWorkerForeignScan: InitializeWorkerForeignScan_function,
    pub ShutdownForeignScan: ShutdownForeignScan_function,
    pub ReparameterizeForeignPathByChild: ReparameterizeForeignPathByChild_function,
}
impl Default for FdwRoutine {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn GetFdwRoutine(arg_fdwhandler: Oid) -> *mut FdwRoutine {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetFdwRoutine(arg_fdwhandler: Oid) -> *mut FdwRoutine;
        }
        GetFdwRoutine(arg_fdwhandler)
    })
}
pub unsafe fn GetForeignServerIdByRelId(arg_relid: Oid) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetForeignServerIdByRelId(arg_relid: Oid) -> Oid;
        }
        GetForeignServerIdByRelId(arg_relid)
    })
}
pub unsafe fn GetFdwRoutineByServerId(arg_serverid: Oid) -> *mut FdwRoutine {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetFdwRoutineByServerId(arg_serverid: Oid) -> *mut FdwRoutine;
        }
        GetFdwRoutineByServerId(arg_serverid)
    })
}
pub unsafe fn GetFdwRoutineByRelId(arg_relid: Oid) -> *mut FdwRoutine {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetFdwRoutineByRelId(arg_relid: Oid) -> *mut FdwRoutine;
        }
        GetFdwRoutineByRelId(arg_relid)
    })
}
pub unsafe fn GetFdwRoutineForRelation(
    arg_relation: Relation,
    arg_makecopy: bool,
) -> *mut FdwRoutine {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetFdwRoutineForRelation(
                arg_relation: Relation,
                arg_makecopy: bool,
            ) -> *mut FdwRoutine;
        }
        GetFdwRoutineForRelation(arg_relation, arg_makecopy)
    })
}
pub unsafe fn IsImportableForeignTable(
    arg_tablename: *const ::std::os::raw::c_char,
    arg_stmt: *mut ImportForeignSchemaStmt,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn IsImportableForeignTable(
                arg_tablename: *const ::std::os::raw::c_char,
                arg_stmt: *mut ImportForeignSchemaStmt,
            ) -> bool;
        }
        IsImportableForeignTable(arg_tablename, arg_stmt)
    })
}
pub unsafe fn GetExistingLocalJoinPath(arg_joinrel: *mut RelOptInfo) -> *mut Path {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetExistingLocalJoinPath(arg_joinrel: *mut RelOptInfo) -> *mut Path;
        }
        GetExistingLocalJoinPath(arg_joinrel)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForeignDataWrapper {
    pub fdwid: Oid,
    pub owner: Oid,
    pub fdwname: *mut ::std::os::raw::c_char,
    pub fdwhandler: Oid,
    pub fdwvalidator: Oid,
    pub options: *mut List,
}
impl Default for ForeignDataWrapper {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForeignServer {
    pub serverid: Oid,
    pub fdwid: Oid,
    pub owner: Oid,
    pub servername: *mut ::std::os::raw::c_char,
    pub servertype: *mut ::std::os::raw::c_char,
    pub serverversion: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
impl Default for ForeignServer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UserMapping {
    pub umid: Oid,
    pub userid: Oid,
    pub serverid: Oid,
    pub options: *mut List,
}
impl Default for UserMapping {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForeignTable {
    pub relid: Oid,
    pub serverid: Oid,
    pub options: *mut List,
}
impl Default for ForeignTable {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn GetForeignServer(arg_serverid: Oid) -> *mut ForeignServer {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetForeignServer(arg_serverid: Oid) -> *mut ForeignServer;
        }
        GetForeignServer(arg_serverid)
    })
}
pub unsafe fn GetForeignServerExtended(arg_serverid: Oid, arg_flags: bits16) -> *mut ForeignServer {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetForeignServerExtended(arg_serverid: Oid, arg_flags: bits16)
                -> *mut ForeignServer;
        }
        GetForeignServerExtended(arg_serverid, arg_flags)
    })
}
pub unsafe fn GetForeignServerByName(
    arg_name: *const ::std::os::raw::c_char,
    arg_missing_ok: bool,
) -> *mut ForeignServer {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetForeignServerByName(
                arg_name: *const ::std::os::raw::c_char,
                arg_missing_ok: bool,
            ) -> *mut ForeignServer;
        }
        GetForeignServerByName(arg_name, arg_missing_ok)
    })
}
pub unsafe fn GetUserMapping(arg_userid: Oid, arg_serverid: Oid) -> *mut UserMapping {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetUserMapping(arg_userid: Oid, arg_serverid: Oid) -> *mut UserMapping;
        }
        GetUserMapping(arg_userid, arg_serverid)
    })
}
pub unsafe fn GetForeignDataWrapper(arg_fdwid: Oid) -> *mut ForeignDataWrapper {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetForeignDataWrapper(arg_fdwid: Oid) -> *mut ForeignDataWrapper;
        }
        GetForeignDataWrapper(arg_fdwid)
    })
}
pub unsafe fn GetForeignDataWrapperExtended(
    arg_fdwid: Oid,
    arg_flags: bits16,
) -> *mut ForeignDataWrapper {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetForeignDataWrapperExtended(
                arg_fdwid: Oid,
                arg_flags: bits16,
            ) -> *mut ForeignDataWrapper;
        }
        GetForeignDataWrapperExtended(arg_fdwid, arg_flags)
    })
}
pub unsafe fn GetForeignDataWrapperByName(
    arg_name: *const ::std::os::raw::c_char,
    arg_missing_ok: bool,
) -> *mut ForeignDataWrapper {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetForeignDataWrapperByName(
                arg_name: *const ::std::os::raw::c_char,
                arg_missing_ok: bool,
            ) -> *mut ForeignDataWrapper;
        }
        GetForeignDataWrapperByName(arg_name, arg_missing_ok)
    })
}
pub unsafe fn GetForeignTable(arg_relid: Oid) -> *mut ForeignTable {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetForeignTable(arg_relid: Oid) -> *mut ForeignTable;
        }
        GetForeignTable(arg_relid)
    })
}
pub unsafe fn GetForeignColumnOptions(arg_relid: Oid, arg_attnum: AttrNumber) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetForeignColumnOptions(arg_relid: Oid, arg_attnum: AttrNumber) -> *mut List;
        }
        GetForeignColumnOptions(arg_relid, arg_attnum)
    })
}
pub unsafe fn get_foreign_data_wrapper_oid(
    arg_fdwname: *const ::std::os::raw::c_char,
    arg_missing_ok: bool,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_foreign_data_wrapper_oid(
                arg_fdwname: *const ::std::os::raw::c_char,
                arg_missing_ok: bool,
            ) -> Oid;
        }
        get_foreign_data_wrapper_oid(arg_fdwname, arg_missing_ok)
    })
}
pub unsafe fn get_foreign_server_oid(
    arg_servername: *const ::std::os::raw::c_char,
    arg_missing_ok: bool,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_foreign_server_oid(
                arg_servername: *const ::std::os::raw::c_char,
                arg_missing_ok: bool,
            ) -> Oid;
        }
        get_foreign_server_oid(arg_servername, arg_missing_ok)
    })
}
pub type pg_wchar = ::std::os::raw::c_uint;
pub const pg_enc_PG_SQL_ASCII: pg_enc = 0;
pub const pg_enc_PG_EUC_JP: pg_enc = 1;
pub const pg_enc_PG_EUC_CN: pg_enc = 2;
pub const pg_enc_PG_EUC_KR: pg_enc = 3;
pub const pg_enc_PG_EUC_TW: pg_enc = 4;
pub const pg_enc_PG_EUC_JIS_2004: pg_enc = 5;
pub const pg_enc_PG_UTF8: pg_enc = 6;
pub const pg_enc_PG_MULE_INTERNAL: pg_enc = 7;
pub const pg_enc_PG_LATIN1: pg_enc = 8;
pub const pg_enc_PG_LATIN2: pg_enc = 9;
pub const pg_enc_PG_LATIN3: pg_enc = 10;
pub const pg_enc_PG_LATIN4: pg_enc = 11;
pub const pg_enc_PG_LATIN5: pg_enc = 12;
pub const pg_enc_PG_LATIN6: pg_enc = 13;
pub const pg_enc_PG_LATIN7: pg_enc = 14;
pub const pg_enc_PG_LATIN8: pg_enc = 15;
pub const pg_enc_PG_LATIN9: pg_enc = 16;
pub const pg_enc_PG_LATIN10: pg_enc = 17;
pub const pg_enc_PG_WIN1256: pg_enc = 18;
pub const pg_enc_PG_WIN1258: pg_enc = 19;
pub const pg_enc_PG_WIN866: pg_enc = 20;
pub const pg_enc_PG_WIN874: pg_enc = 21;
pub const pg_enc_PG_KOI8R: pg_enc = 22;
pub const pg_enc_PG_WIN1251: pg_enc = 23;
pub const pg_enc_PG_WIN1252: pg_enc = 24;
pub const pg_enc_PG_ISO_8859_5: pg_enc = 25;
pub const pg_enc_PG_ISO_8859_6: pg_enc = 26;
pub const pg_enc_PG_ISO_8859_7: pg_enc = 27;
pub const pg_enc_PG_ISO_8859_8: pg_enc = 28;
pub const pg_enc_PG_WIN1250: pg_enc = 29;
pub const pg_enc_PG_WIN1253: pg_enc = 30;
pub const pg_enc_PG_WIN1254: pg_enc = 31;
pub const pg_enc_PG_WIN1255: pg_enc = 32;
pub const pg_enc_PG_WIN1257: pg_enc = 33;
pub const pg_enc_PG_KOI8U: pg_enc = 34;
pub const pg_enc_PG_SJIS: pg_enc = 35;
pub const pg_enc_PG_BIG5: pg_enc = 36;
pub const pg_enc_PG_GBK: pg_enc = 37;
pub const pg_enc_PG_UHC: pg_enc = 38;
pub const pg_enc_PG_GB18030: pg_enc = 39;
pub const pg_enc_PG_JOHAB: pg_enc = 40;
pub const pg_enc_PG_SHIFT_JIS_2004: pg_enc = 41;
pub const pg_enc__PG_LAST_ENCODING_: pg_enc = 42;
pub type pg_enc = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pg_enc2name {
    pub name: *const ::std::os::raw::c_char,
    pub encoding: pg_enc,
}
impl Default for pg_enc2name {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut pg_enc2name_tbl: [pg_enc2name; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pg_enc2gettext {
    pub encoding: pg_enc,
    pub name: *const ::std::os::raw::c_char,
}
impl Default for pg_enc2gettext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut pg_enc2gettext_tbl: [pg_enc2gettext; 0usize];
}
pub type mb2wchar_with_len_converter = ::std::option::Option<
    unsafe extern "C" fn(
        from: *const ::std::os::raw::c_uchar,
        to: *mut pg_wchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type wchar2mb_with_len_converter = ::std::option::Option<
    unsafe extern "C" fn(
        from: *const pg_wchar,
        to: *mut ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type mblen_converter = ::std::option::Option<
    unsafe extern "C" fn(mbstr: *const ::std::os::raw::c_uchar) -> ::std::os::raw::c_int,
>;
pub type mbdisplaylen_converter = ::std::option::Option<
    unsafe extern "C" fn(mbstr: *const ::std::os::raw::c_uchar) -> ::std::os::raw::c_int,
>;
pub type mbcharacter_incrementer = ::std::option::Option<
    unsafe extern "C" fn(mbstr: *mut ::std::os::raw::c_uchar, len: ::std::os::raw::c_int) -> bool,
>;
pub type mbverifier = ::std::option::Option<
    unsafe extern "C" fn(
        mbstr: *const ::std::os::raw::c_uchar,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pg_wchar_tbl {
    pub mb2wchar_with_len: mb2wchar_with_len_converter,
    pub wchar2mb_with_len: wchar2mb_with_len_converter,
    pub mblen: mblen_converter,
    pub dsplen: mbdisplaylen_converter,
    pub mbverify: mbverifier,
    pub maxmblen: ::std::os::raw::c_int,
}
extern "C" {
    pub static mut pg_wchar_table: [pg_wchar_tbl; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pg_mb_radix_tree {
    pub chars16: *const uint16,
    pub chars32: *const uint32,
    pub b1root: uint32,
    pub b1_lower: uint8,
    pub b1_upper: uint8,
    pub b2root: uint32,
    pub b2_1_lower: uint8,
    pub b2_1_upper: uint8,
    pub b2_2_lower: uint8,
    pub b2_2_upper: uint8,
    pub b3root: uint32,
    pub b3_1_lower: uint8,
    pub b3_1_upper: uint8,
    pub b3_2_lower: uint8,
    pub b3_2_upper: uint8,
    pub b3_3_lower: uint8,
    pub b3_3_upper: uint8,
    pub b4root: uint32,
    pub b4_1_lower: uint8,
    pub b4_1_upper: uint8,
    pub b4_2_lower: uint8,
    pub b4_2_upper: uint8,
    pub b4_3_lower: uint8,
    pub b4_3_upper: uint8,
    pub b4_4_lower: uint8,
    pub b4_4_upper: uint8,
}
impl Default for pg_mb_radix_tree {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pg_utf_to_local_combined {
    pub utf1: uint32,
    pub utf2: uint32,
    pub code: uint32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pg_local_to_utf_combined {
    pub code: uint32,
    pub utf1: uint32,
    pub utf2: uint32,
}
pub type utf_local_conversion_func =
    ::std::option::Option<unsafe extern "C" fn(code: uint32) -> uint32>;
pub unsafe fn pg_char_to_encoding(
    arg_name: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_char_to_encoding(
                arg_name: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        pg_char_to_encoding(arg_name)
    })
}
pub unsafe fn pg_encoding_to_char(
    arg_encoding: ::std::os::raw::c_int,
) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_encoding_to_char(
                arg_encoding: ::std::os::raw::c_int,
            ) -> *const ::std::os::raw::c_char;
        }
        pg_encoding_to_char(arg_encoding)
    })
}
pub unsafe fn pg_valid_server_encoding_id(
    arg_encoding: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_valid_server_encoding_id(
                arg_encoding: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        pg_valid_server_encoding_id(arg_encoding)
    })
}
pub unsafe fn pg_encoding_mblen(
    arg_encoding: ::std::os::raw::c_int,
    arg_mbstr: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_encoding_mblen(
                arg_encoding: ::std::os::raw::c_int,
                arg_mbstr: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        pg_encoding_mblen(arg_encoding, arg_mbstr)
    })
}
pub unsafe fn pg_encoding_mblen_bounded(
    arg_encoding: ::std::os::raw::c_int,
    arg_mbstr: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_encoding_mblen_bounded(
                arg_encoding: ::std::os::raw::c_int,
                arg_mbstr: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        pg_encoding_mblen_bounded(arg_encoding, arg_mbstr)
    })
}
pub unsafe fn pg_encoding_dsplen(
    arg_encoding: ::std::os::raw::c_int,
    arg_mbstr: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_encoding_dsplen(
                arg_encoding: ::std::os::raw::c_int,
                arg_mbstr: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        pg_encoding_dsplen(arg_encoding, arg_mbstr)
    })
}
pub unsafe fn pg_encoding_verifymb(
    arg_encoding: ::std::os::raw::c_int,
    arg_mbstr: *const ::std::os::raw::c_char,
    arg_len: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_encoding_verifymb(
                arg_encoding: ::std::os::raw::c_int,
                arg_mbstr: *const ::std::os::raw::c_char,
                arg_len: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        pg_encoding_verifymb(arg_encoding, arg_mbstr, arg_len)
    })
}
pub unsafe fn pg_encoding_max_length(arg_encoding: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_encoding_max_length(arg_encoding: ::std::os::raw::c_int)
                -> ::std::os::raw::c_int;
        }
        pg_encoding_max_length(arg_encoding)
    })
}
pub unsafe fn pg_valid_client_encoding(
    arg_name: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_valid_client_encoding(
                arg_name: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        pg_valid_client_encoding(arg_name)
    })
}
pub unsafe fn pg_valid_server_encoding(
    arg_name: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_valid_server_encoding(
                arg_name: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        pg_valid_server_encoding(arg_name)
    })
}
pub unsafe fn is_encoding_supported_by_icu(arg_encoding: ::std::os::raw::c_int) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn is_encoding_supported_by_icu(arg_encoding: ::std::os::raw::c_int) -> bool;
        }
        is_encoding_supported_by_icu(arg_encoding)
    })
}
pub unsafe fn get_encoding_name_for_icu(
    arg_encoding: ::std::os::raw::c_int,
) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_encoding_name_for_icu(
                arg_encoding: ::std::os::raw::c_int,
            ) -> *const ::std::os::raw::c_char;
        }
        get_encoding_name_for_icu(arg_encoding)
    })
}
pub unsafe fn unicode_to_utf8(
    arg_c: pg_wchar,
    arg_utf8string: *mut ::std::os::raw::c_uchar,
) -> *mut ::std::os::raw::c_uchar {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn unicode_to_utf8(
                arg_c: pg_wchar,
                arg_utf8string: *mut ::std::os::raw::c_uchar,
            ) -> *mut ::std::os::raw::c_uchar;
        }
        unicode_to_utf8(arg_c, arg_utf8string)
    })
}
pub unsafe fn utf8_to_unicode(arg_c: *const ::std::os::raw::c_uchar) -> pg_wchar {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn utf8_to_unicode(arg_c: *const ::std::os::raw::c_uchar) -> pg_wchar;
        }
        utf8_to_unicode(arg_c)
    })
}
pub unsafe fn pg_utf8_islegal(
    arg_source: *const ::std::os::raw::c_uchar,
    arg_length: ::std::os::raw::c_int,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_utf8_islegal(
                arg_source: *const ::std::os::raw::c_uchar,
                arg_length: ::std::os::raw::c_int,
            ) -> bool;
        }
        pg_utf8_islegal(arg_source, arg_length)
    })
}
pub unsafe fn pg_utf_mblen(arg_s: *const ::std::os::raw::c_uchar) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_utf_mblen(arg_s: *const ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
        }
        pg_utf_mblen(arg_s)
    })
}
pub unsafe fn pg_mule_mblen(arg_s: *const ::std::os::raw::c_uchar) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_mule_mblen(arg_s: *const ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
        }
        pg_mule_mblen(arg_s)
    })
}
pub unsafe fn pg_mb2wchar(
    arg_from: *const ::std::os::raw::c_char,
    arg_to: *mut pg_wchar,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_mb2wchar(
                arg_from: *const ::std::os::raw::c_char,
                arg_to: *mut pg_wchar,
            ) -> ::std::os::raw::c_int;
        }
        pg_mb2wchar(arg_from, arg_to)
    })
}
pub unsafe fn pg_mb2wchar_with_len(
    arg_from: *const ::std::os::raw::c_char,
    arg_to: *mut pg_wchar,
    arg_len: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_mb2wchar_with_len(
                arg_from: *const ::std::os::raw::c_char,
                arg_to: *mut pg_wchar,
                arg_len: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        pg_mb2wchar_with_len(arg_from, arg_to, arg_len)
    })
}
pub unsafe fn pg_encoding_mb2wchar_with_len(
    arg_encoding: ::std::os::raw::c_int,
    arg_from: *const ::std::os::raw::c_char,
    arg_to: *mut pg_wchar,
    arg_len: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_encoding_mb2wchar_with_len(
                arg_encoding: ::std::os::raw::c_int,
                arg_from: *const ::std::os::raw::c_char,
                arg_to: *mut pg_wchar,
                arg_len: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        pg_encoding_mb2wchar_with_len(arg_encoding, arg_from, arg_to, arg_len)
    })
}
pub unsafe fn pg_wchar2mb(
    arg_from: *const pg_wchar,
    arg_to: *mut ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_wchar2mb(
                arg_from: *const pg_wchar,
                arg_to: *mut ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        pg_wchar2mb(arg_from, arg_to)
    })
}
pub unsafe fn pg_wchar2mb_with_len(
    arg_from: *const pg_wchar,
    arg_to: *mut ::std::os::raw::c_char,
    arg_len: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_wchar2mb_with_len(
                arg_from: *const pg_wchar,
                arg_to: *mut ::std::os::raw::c_char,
                arg_len: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        pg_wchar2mb_with_len(arg_from, arg_to, arg_len)
    })
}
pub unsafe fn pg_encoding_wchar2mb_with_len(
    arg_encoding: ::std::os::raw::c_int,
    arg_from: *const pg_wchar,
    arg_to: *mut ::std::os::raw::c_char,
    arg_len: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_encoding_wchar2mb_with_len(
                arg_encoding: ::std::os::raw::c_int,
                arg_from: *const pg_wchar,
                arg_to: *mut ::std::os::raw::c_char,
                arg_len: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        pg_encoding_wchar2mb_with_len(arg_encoding, arg_from, arg_to, arg_len)
    })
}
pub unsafe fn pg_char_and_wchar_strcmp(
    arg_s1: *const ::std::os::raw::c_char,
    arg_s2: *const pg_wchar,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_char_and_wchar_strcmp(
                arg_s1: *const ::std::os::raw::c_char,
                arg_s2: *const pg_wchar,
            ) -> ::std::os::raw::c_int;
        }
        pg_char_and_wchar_strcmp(arg_s1, arg_s2)
    })
}
pub unsafe fn pg_wchar_strncmp(
    arg_s1: *const pg_wchar,
    arg_s2: *const pg_wchar,
    arg_n: usize,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_wchar_strncmp(
                arg_s1: *const pg_wchar,
                arg_s2: *const pg_wchar,
                arg_n: usize,
            ) -> ::std::os::raw::c_int;
        }
        pg_wchar_strncmp(arg_s1, arg_s2, arg_n)
    })
}
pub unsafe fn pg_char_and_wchar_strncmp(
    arg_s1: *const ::std::os::raw::c_char,
    arg_s2: *const pg_wchar,
    arg_n: usize,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_char_and_wchar_strncmp(
                arg_s1: *const ::std::os::raw::c_char,
                arg_s2: *const pg_wchar,
                arg_n: usize,
            ) -> ::std::os::raw::c_int;
        }
        pg_char_and_wchar_strncmp(arg_s1, arg_s2, arg_n)
    })
}
pub unsafe fn pg_wchar_strlen(arg_wstr: *const pg_wchar) -> usize {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_wchar_strlen(arg_wstr: *const pg_wchar) -> usize;
        }
        pg_wchar_strlen(arg_wstr)
    })
}
pub unsafe fn pg_mblen(arg_mbstr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_mblen(arg_mbstr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
        }
        pg_mblen(arg_mbstr)
    })
}
pub unsafe fn pg_dsplen(arg_mbstr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_dsplen(arg_mbstr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
        }
        pg_dsplen(arg_mbstr)
    })
}
pub unsafe fn pg_mbstrlen(arg_mbstr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_mbstrlen(arg_mbstr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
        }
        pg_mbstrlen(arg_mbstr)
    })
}
pub unsafe fn pg_mbstrlen_with_len(
    arg_mbstr: *const ::std::os::raw::c_char,
    arg_len: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_mbstrlen_with_len(
                arg_mbstr: *const ::std::os::raw::c_char,
                arg_len: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        pg_mbstrlen_with_len(arg_mbstr, arg_len)
    })
}
pub unsafe fn pg_mbcliplen(
    arg_mbstr: *const ::std::os::raw::c_char,
    arg_len: ::std::os::raw::c_int,
    arg_limit: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_mbcliplen(
                arg_mbstr: *const ::std::os::raw::c_char,
                arg_len: ::std::os::raw::c_int,
                arg_limit: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        pg_mbcliplen(arg_mbstr, arg_len, arg_limit)
    })
}
pub unsafe fn pg_encoding_mbcliplen(
    arg_encoding: ::std::os::raw::c_int,
    arg_mbstr: *const ::std::os::raw::c_char,
    arg_len: ::std::os::raw::c_int,
    arg_limit: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_encoding_mbcliplen(
                arg_encoding: ::std::os::raw::c_int,
                arg_mbstr: *const ::std::os::raw::c_char,
                arg_len: ::std::os::raw::c_int,
                arg_limit: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        pg_encoding_mbcliplen(arg_encoding, arg_mbstr, arg_len, arg_limit)
    })
}
pub unsafe fn pg_mbcharcliplen(
    arg_mbstr: *const ::std::os::raw::c_char,
    arg_len: ::std::os::raw::c_int,
    arg_limit: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_mbcharcliplen(
                arg_mbstr: *const ::std::os::raw::c_char,
                arg_len: ::std::os::raw::c_int,
                arg_limit: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        pg_mbcharcliplen(arg_mbstr, arg_len, arg_limit)
    })
}
pub unsafe fn pg_database_encoding_max_length() -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_database_encoding_max_length() -> ::std::os::raw::c_int;
        }
        pg_database_encoding_max_length()
    })
}
pub unsafe fn pg_database_encoding_character_incrementer() -> mbcharacter_incrementer {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_database_encoding_character_incrementer() -> mbcharacter_incrementer;
        }
        pg_database_encoding_character_incrementer()
    })
}
pub unsafe fn PrepareClientEncoding(arg_encoding: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PrepareClientEncoding(arg_encoding: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        PrepareClientEncoding(arg_encoding)
    })
}
pub unsafe fn SetClientEncoding(arg_encoding: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SetClientEncoding(arg_encoding: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
        }
        SetClientEncoding(arg_encoding)
    })
}
pub unsafe fn InitializeClientEncoding() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitializeClientEncoding();
        }
        InitializeClientEncoding()
    })
}
pub unsafe fn pg_get_client_encoding() -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_client_encoding() -> ::std::os::raw::c_int;
        }
        pg_get_client_encoding()
    })
}
pub unsafe fn pg_get_client_encoding_name() -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_client_encoding_name() -> *const ::std::os::raw::c_char;
        }
        pg_get_client_encoding_name()
    })
}
pub unsafe fn SetDatabaseEncoding(arg_encoding: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SetDatabaseEncoding(arg_encoding: ::std::os::raw::c_int);
        }
        SetDatabaseEncoding(arg_encoding)
    })
}
pub unsafe fn GetDatabaseEncoding() -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetDatabaseEncoding() -> ::std::os::raw::c_int;
        }
        GetDatabaseEncoding()
    })
}
pub unsafe fn GetDatabaseEncodingName() -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetDatabaseEncodingName() -> *const ::std::os::raw::c_char;
        }
        GetDatabaseEncodingName()
    })
}
pub unsafe fn SetMessageEncoding(arg_encoding: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SetMessageEncoding(arg_encoding: ::std::os::raw::c_int);
        }
        SetMessageEncoding(arg_encoding)
    })
}
pub unsafe fn GetMessageEncoding() -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetMessageEncoding() -> ::std::os::raw::c_int;
        }
        GetMessageEncoding()
    })
}
pub unsafe fn pg_do_encoding_conversion(
    arg_src: *mut ::std::os::raw::c_uchar,
    arg_len: ::std::os::raw::c_int,
    arg_src_encoding: ::std::os::raw::c_int,
    arg_dest_encoding: ::std::os::raw::c_int,
) -> *mut ::std::os::raw::c_uchar {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_do_encoding_conversion(
                arg_src: *mut ::std::os::raw::c_uchar,
                arg_len: ::std::os::raw::c_int,
                arg_src_encoding: ::std::os::raw::c_int,
                arg_dest_encoding: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_uchar;
        }
        pg_do_encoding_conversion(arg_src, arg_len, arg_src_encoding, arg_dest_encoding)
    })
}
pub unsafe fn pg_client_to_server(
    arg_s: *const ::std::os::raw::c_char,
    arg_len: ::std::os::raw::c_int,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_client_to_server(
                arg_s: *const ::std::os::raw::c_char,
                arg_len: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_char;
        }
        pg_client_to_server(arg_s, arg_len)
    })
}
pub unsafe fn pg_server_to_client(
    arg_s: *const ::std::os::raw::c_char,
    arg_len: ::std::os::raw::c_int,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_server_to_client(
                arg_s: *const ::std::os::raw::c_char,
                arg_len: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_char;
        }
        pg_server_to_client(arg_s, arg_len)
    })
}
pub unsafe fn pg_any_to_server(
    arg_s: *const ::std::os::raw::c_char,
    arg_len: ::std::os::raw::c_int,
    arg_encoding: ::std::os::raw::c_int,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_any_to_server(
                arg_s: *const ::std::os::raw::c_char,
                arg_len: ::std::os::raw::c_int,
                arg_encoding: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_char;
        }
        pg_any_to_server(arg_s, arg_len, arg_encoding)
    })
}
pub unsafe fn pg_server_to_any(
    arg_s: *const ::std::os::raw::c_char,
    arg_len: ::std::os::raw::c_int,
    arg_encoding: ::std::os::raw::c_int,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_server_to_any(
                arg_s: *const ::std::os::raw::c_char,
                arg_len: ::std::os::raw::c_int,
                arg_encoding: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_char;
        }
        pg_server_to_any(arg_s, arg_len, arg_encoding)
    })
}
pub unsafe fn pg_unicode_to_server(arg_c: pg_wchar, arg_s: *mut ::std::os::raw::c_uchar) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_unicode_to_server(arg_c: pg_wchar, arg_s: *mut ::std::os::raw::c_uchar);
        }
        pg_unicode_to_server(arg_c, arg_s)
    })
}
pub unsafe fn BIG5toCNS(
    arg_big5: ::std::os::raw::c_ushort,
    arg_lc: *mut ::std::os::raw::c_uchar,
) -> ::std::os::raw::c_ushort {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BIG5toCNS(
                arg_big5: ::std::os::raw::c_ushort,
                arg_lc: *mut ::std::os::raw::c_uchar,
            ) -> ::std::os::raw::c_ushort;
        }
        BIG5toCNS(arg_big5, arg_lc)
    })
}
pub unsafe fn CNStoBIG5(
    arg_cns: ::std::os::raw::c_ushort,
    arg_lc: ::std::os::raw::c_uchar,
) -> ::std::os::raw::c_ushort {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CNStoBIG5(
                arg_cns: ::std::os::raw::c_ushort,
                arg_lc: ::std::os::raw::c_uchar,
            ) -> ::std::os::raw::c_ushort;
        }
        CNStoBIG5(arg_cns, arg_lc)
    })
}
pub unsafe fn UtfToLocal(
    arg_utf: *const ::std::os::raw::c_uchar,
    arg_len: ::std::os::raw::c_int,
    arg_iso: *mut ::std::os::raw::c_uchar,
    arg_map: *const pg_mb_radix_tree,
    arg_cmap: *const pg_utf_to_local_combined,
    arg_cmapsize: ::std::os::raw::c_int,
    arg_conv_func: utf_local_conversion_func,
    arg_encoding: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn UtfToLocal(
                arg_utf: *const ::std::os::raw::c_uchar,
                arg_len: ::std::os::raw::c_int,
                arg_iso: *mut ::std::os::raw::c_uchar,
                arg_map: *const pg_mb_radix_tree,
                arg_cmap: *const pg_utf_to_local_combined,
                arg_cmapsize: ::std::os::raw::c_int,
                arg_conv_func: utf_local_conversion_func,
                arg_encoding: ::std::os::raw::c_int,
            );
        }
        UtfToLocal(
            arg_utf,
            arg_len,
            arg_iso,
            arg_map,
            arg_cmap,
            arg_cmapsize,
            arg_conv_func,
            arg_encoding,
        )
    })
}
pub unsafe fn LocalToUtf(
    arg_iso: *const ::std::os::raw::c_uchar,
    arg_len: ::std::os::raw::c_int,
    arg_utf: *mut ::std::os::raw::c_uchar,
    arg_map: *const pg_mb_radix_tree,
    arg_cmap: *const pg_local_to_utf_combined,
    arg_cmapsize: ::std::os::raw::c_int,
    arg_conv_func: utf_local_conversion_func,
    arg_encoding: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LocalToUtf(
                arg_iso: *const ::std::os::raw::c_uchar,
                arg_len: ::std::os::raw::c_int,
                arg_utf: *mut ::std::os::raw::c_uchar,
                arg_map: *const pg_mb_radix_tree,
                arg_cmap: *const pg_local_to_utf_combined,
                arg_cmapsize: ::std::os::raw::c_int,
                arg_conv_func: utf_local_conversion_func,
                arg_encoding: ::std::os::raw::c_int,
            );
        }
        LocalToUtf(
            arg_iso,
            arg_len,
            arg_utf,
            arg_map,
            arg_cmap,
            arg_cmapsize,
            arg_conv_func,
            arg_encoding,
        )
    })
}
pub unsafe fn pg_verifymbstr(
    arg_mbstr: *const ::std::os::raw::c_char,
    arg_len: ::std::os::raw::c_int,
    arg_noError: bool,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_verifymbstr(
                arg_mbstr: *const ::std::os::raw::c_char,
                arg_len: ::std::os::raw::c_int,
                arg_noError: bool,
            ) -> bool;
        }
        pg_verifymbstr(arg_mbstr, arg_len, arg_noError)
    })
}
pub unsafe fn pg_verify_mbstr(
    arg_encoding: ::std::os::raw::c_int,
    arg_mbstr: *const ::std::os::raw::c_char,
    arg_len: ::std::os::raw::c_int,
    arg_noError: bool,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_verify_mbstr(
                arg_encoding: ::std::os::raw::c_int,
                arg_mbstr: *const ::std::os::raw::c_char,
                arg_len: ::std::os::raw::c_int,
                arg_noError: bool,
            ) -> bool;
        }
        pg_verify_mbstr(arg_encoding, arg_mbstr, arg_len, arg_noError)
    })
}
pub unsafe fn pg_verify_mbstr_len(
    arg_encoding: ::std::os::raw::c_int,
    arg_mbstr: *const ::std::os::raw::c_char,
    arg_len: ::std::os::raw::c_int,
    arg_noError: bool,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_verify_mbstr_len(
                arg_encoding: ::std::os::raw::c_int,
                arg_mbstr: *const ::std::os::raw::c_char,
                arg_len: ::std::os::raw::c_int,
                arg_noError: bool,
            ) -> ::std::os::raw::c_int;
        }
        pg_verify_mbstr_len(arg_encoding, arg_mbstr, arg_len, arg_noError)
    })
}
pub unsafe fn check_encoding_conversion_args(
    arg_src_encoding: ::std::os::raw::c_int,
    arg_dest_encoding: ::std::os::raw::c_int,
    arg_len: ::std::os::raw::c_int,
    arg_expected_src_encoding: ::std::os::raw::c_int,
    arg_expected_dest_encoding: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn check_encoding_conversion_args(
                arg_src_encoding: ::std::os::raw::c_int,
                arg_dest_encoding: ::std::os::raw::c_int,
                arg_len: ::std::os::raw::c_int,
                arg_expected_src_encoding: ::std::os::raw::c_int,
                arg_expected_dest_encoding: ::std::os::raw::c_int,
            );
        }
        check_encoding_conversion_args(
            arg_src_encoding,
            arg_dest_encoding,
            arg_len,
            arg_expected_src_encoding,
            arg_expected_dest_encoding,
        )
    })
}
pub unsafe fn report_invalid_encoding(
    arg_encoding: ::std::os::raw::c_int,
    arg_mbstr: *const ::std::os::raw::c_char,
    arg_len: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn report_invalid_encoding(
                arg_encoding: ::std::os::raw::c_int,
                arg_mbstr: *const ::std::os::raw::c_char,
                arg_len: ::std::os::raw::c_int,
            );
        }
        report_invalid_encoding(arg_encoding, arg_mbstr, arg_len)
    })
}
pub unsafe fn report_untranslatable_char(
    arg_src_encoding: ::std::os::raw::c_int,
    arg_dest_encoding: ::std::os::raw::c_int,
    arg_mbstr: *const ::std::os::raw::c_char,
    arg_len: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn report_untranslatable_char(
                arg_src_encoding: ::std::os::raw::c_int,
                arg_dest_encoding: ::std::os::raw::c_int,
                arg_mbstr: *const ::std::os::raw::c_char,
                arg_len: ::std::os::raw::c_int,
            );
        }
        report_untranslatable_char(arg_src_encoding, arg_dest_encoding, arg_mbstr, arg_len)
    })
}
pub unsafe fn local2local(
    arg_l: *const ::std::os::raw::c_uchar,
    arg_p: *mut ::std::os::raw::c_uchar,
    arg_len: ::std::os::raw::c_int,
    arg_src_encoding: ::std::os::raw::c_int,
    arg_dest_encoding: ::std::os::raw::c_int,
    arg_tab: *const ::std::os::raw::c_uchar,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn local2local(
                arg_l: *const ::std::os::raw::c_uchar,
                arg_p: *mut ::std::os::raw::c_uchar,
                arg_len: ::std::os::raw::c_int,
                arg_src_encoding: ::std::os::raw::c_int,
                arg_dest_encoding: ::std::os::raw::c_int,
                arg_tab: *const ::std::os::raw::c_uchar,
            );
        }
        local2local(arg_l, arg_p, arg_len, arg_src_encoding, arg_dest_encoding, arg_tab)
    })
}
pub unsafe fn latin2mic(
    arg_l: *const ::std::os::raw::c_uchar,
    arg_p: *mut ::std::os::raw::c_uchar,
    arg_len: ::std::os::raw::c_int,
    arg_lc: ::std::os::raw::c_int,
    arg_encoding: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn latin2mic(
                arg_l: *const ::std::os::raw::c_uchar,
                arg_p: *mut ::std::os::raw::c_uchar,
                arg_len: ::std::os::raw::c_int,
                arg_lc: ::std::os::raw::c_int,
                arg_encoding: ::std::os::raw::c_int,
            );
        }
        latin2mic(arg_l, arg_p, arg_len, arg_lc, arg_encoding)
    })
}
pub unsafe fn mic2latin(
    arg_mic: *const ::std::os::raw::c_uchar,
    arg_p: *mut ::std::os::raw::c_uchar,
    arg_len: ::std::os::raw::c_int,
    arg_lc: ::std::os::raw::c_int,
    arg_encoding: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn mic2latin(
                arg_mic: *const ::std::os::raw::c_uchar,
                arg_p: *mut ::std::os::raw::c_uchar,
                arg_len: ::std::os::raw::c_int,
                arg_lc: ::std::os::raw::c_int,
                arg_encoding: ::std::os::raw::c_int,
            );
        }
        mic2latin(arg_mic, arg_p, arg_len, arg_lc, arg_encoding)
    })
}
pub unsafe fn latin2mic_with_table(
    arg_l: *const ::std::os::raw::c_uchar,
    arg_p: *mut ::std::os::raw::c_uchar,
    arg_len: ::std::os::raw::c_int,
    arg_lc: ::std::os::raw::c_int,
    arg_encoding: ::std::os::raw::c_int,
    arg_tab: *const ::std::os::raw::c_uchar,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn latin2mic_with_table(
                arg_l: *const ::std::os::raw::c_uchar,
                arg_p: *mut ::std::os::raw::c_uchar,
                arg_len: ::std::os::raw::c_int,
                arg_lc: ::std::os::raw::c_int,
                arg_encoding: ::std::os::raw::c_int,
                arg_tab: *const ::std::os::raw::c_uchar,
            );
        }
        latin2mic_with_table(arg_l, arg_p, arg_len, arg_lc, arg_encoding, arg_tab)
    })
}
pub unsafe fn mic2latin_with_table(
    arg_mic: *const ::std::os::raw::c_uchar,
    arg_p: *mut ::std::os::raw::c_uchar,
    arg_len: ::std::os::raw::c_int,
    arg_lc: ::std::os::raw::c_int,
    arg_encoding: ::std::os::raw::c_int,
    arg_tab: *const ::std::os::raw::c_uchar,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn mic2latin_with_table(
                arg_mic: *const ::std::os::raw::c_uchar,
                arg_p: *mut ::std::os::raw::c_uchar,
                arg_len: ::std::os::raw::c_int,
                arg_lc: ::std::os::raw::c_int,
                arg_encoding: ::std::os::raw::c_int,
                arg_tab: *const ::std::os::raw::c_uchar,
            );
        }
        mic2latin_with_table(arg_mic, arg_p, arg_len, arg_lc, arg_encoding, arg_tab)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExtensibleNode {
    pub type_: NodeTag,
    pub extnodename: *const ::std::os::raw::c_char,
}
impl Default for ExtensibleNode {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExtensibleNodeMethods {
    pub extnodename: *const ::std::os::raw::c_char,
    pub node_size: Size,
    pub nodeCopy: ::std::option::Option<
        unsafe extern "C" fn(newnode: *mut ExtensibleNode, oldnode: *const ExtensibleNode),
    >,
    pub nodeEqual: ::std::option::Option<
        unsafe extern "C" fn(a: *const ExtensibleNode, b: *const ExtensibleNode) -> bool,
    >,
    pub nodeOut: ::std::option::Option<
        unsafe extern "C" fn(str_: *mut StringInfoData, node: *const ExtensibleNode),
    >,
    pub nodeRead: ::std::option::Option<unsafe extern "C" fn(node: *mut ExtensibleNode)>,
}
impl Default for ExtensibleNodeMethods {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn RegisterExtensibleNodeMethods(arg_method: *const ExtensibleNodeMethods) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RegisterExtensibleNodeMethods(arg_method: *const ExtensibleNodeMethods);
        }
        RegisterExtensibleNodeMethods(arg_method)
    })
}
pub unsafe fn GetExtensibleNodeMethods(
    arg_name: *const ::std::os::raw::c_char,
    arg_missing_ok: bool,
) -> *const ExtensibleNodeMethods {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetExtensibleNodeMethods(
                arg_name: *const ::std::os::raw::c_char,
                arg_missing_ok: bool,
            ) -> *const ExtensibleNodeMethods;
        }
        GetExtensibleNodeMethods(arg_name, arg_missing_ok)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CustomPathMethods {
    pub CustomName: *const ::std::os::raw::c_char,
    pub PlanCustomPath: ::std::option::Option<
        unsafe extern "C" fn(
            root: *mut PlannerInfo,
            rel: *mut RelOptInfo,
            best_path: *mut CustomPath,
            tlist: *mut List,
            clauses: *mut List,
            custom_plans: *mut List,
        ) -> *mut Plan,
    >,
    pub ReparameterizeCustomPathByChild: ::std::option::Option<
        unsafe extern "C" fn(
            root: *mut PlannerInfo,
            custom_private: *mut List,
            child_rel: *mut RelOptInfo,
        ) -> *mut List,
    >,
}
impl Default for CustomPathMethods {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CustomScanMethods {
    pub CustomName: *const ::std::os::raw::c_char,
    pub CreateCustomScanState:
        ::std::option::Option<unsafe extern "C" fn(cscan: *mut CustomScan) -> *mut Node>,
}
impl Default for CustomScanMethods {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CustomExecMethods {
    pub CustomName: *const ::std::os::raw::c_char,
    pub BeginCustomScan: ::std::option::Option<
        unsafe extern "C" fn(
            node: *mut CustomScanState,
            estate: *mut EState,
            eflags: ::std::os::raw::c_int,
        ),
    >,
    pub ExecCustomScan: ::std::option::Option<
        unsafe extern "C" fn(node: *mut CustomScanState) -> *mut TupleTableSlot,
    >,
    pub EndCustomScan: ::std::option::Option<unsafe extern "C" fn(node: *mut CustomScanState)>,
    pub ReScanCustomScan: ::std::option::Option<unsafe extern "C" fn(node: *mut CustomScanState)>,
    pub MarkPosCustomScan: ::std::option::Option<unsafe extern "C" fn(node: *mut CustomScanState)>,
    pub RestrPosCustomScan: ::std::option::Option<unsafe extern "C" fn(node: *mut CustomScanState)>,
    pub EstimateDSMCustomScan: ::std::option::Option<
        unsafe extern "C" fn(node: *mut CustomScanState, pcxt: *mut ParallelContext) -> Size,
    >,
    pub InitializeDSMCustomScan: ::std::option::Option<
        unsafe extern "C" fn(
            node: *mut CustomScanState,
            pcxt: *mut ParallelContext,
            coordinate: *mut ::std::os::raw::c_void,
        ),
    >,
    pub ReInitializeDSMCustomScan: ::std::option::Option<
        unsafe extern "C" fn(
            node: *mut CustomScanState,
            pcxt: *mut ParallelContext,
            coordinate: *mut ::std::os::raw::c_void,
        ),
    >,
    pub InitializeWorkerCustomScan: ::std::option::Option<
        unsafe extern "C" fn(
            node: *mut CustomScanState,
            toc: *mut shm_toc,
            coordinate: *mut ::std::os::raw::c_void,
        ),
    >,
    pub ShutdownCustomScan: ::std::option::Option<unsafe extern "C" fn(node: *mut CustomScanState)>,
    pub ExplainCustomScan: ::std::option::Option<
        unsafe extern "C" fn(
            node: *mut CustomScanState,
            ancestors: *mut List,
            es: *mut ExplainState,
        ),
    >,
}
impl Default for CustomExecMethods {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn RegisterCustomScanMethods(arg_methods: *const CustomScanMethods) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RegisterCustomScanMethods(arg_methods: *const CustomScanMethods);
        }
        RegisterCustomScanMethods(arg_methods)
    })
}
pub unsafe fn GetCustomScanMethods(
    arg_CustomName: *const ::std::os::raw::c_char,
    arg_missing_ok: bool,
) -> *const CustomScanMethods {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetCustomScanMethods(
                arg_CustomName: *const ::std::os::raw::c_char,
                arg_missing_ok: bool,
            ) -> *const CustomScanMethods;
        }
        GetCustomScanMethods(arg_CustomName, arg_missing_ok)
    })
}
pub unsafe fn makeA_Expr(
    arg_kind: A_Expr_Kind,
    arg_name: *mut List,
    arg_lexpr: *mut Node,
    arg_rexpr: *mut Node,
    arg_location: ::std::os::raw::c_int,
) -> *mut A_Expr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeA_Expr(
                arg_kind: A_Expr_Kind,
                arg_name: *mut List,
                arg_lexpr: *mut Node,
                arg_rexpr: *mut Node,
                arg_location: ::std::os::raw::c_int,
            ) -> *mut A_Expr;
        }
        makeA_Expr(arg_kind, arg_name, arg_lexpr, arg_rexpr, arg_location)
    })
}
pub unsafe fn makeSimpleA_Expr(
    arg_kind: A_Expr_Kind,
    arg_name: *mut ::std::os::raw::c_char,
    arg_lexpr: *mut Node,
    arg_rexpr: *mut Node,
    arg_location: ::std::os::raw::c_int,
) -> *mut A_Expr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeSimpleA_Expr(
                arg_kind: A_Expr_Kind,
                arg_name: *mut ::std::os::raw::c_char,
                arg_lexpr: *mut Node,
                arg_rexpr: *mut Node,
                arg_location: ::std::os::raw::c_int,
            ) -> *mut A_Expr;
        }
        makeSimpleA_Expr(arg_kind, arg_name, arg_lexpr, arg_rexpr, arg_location)
    })
}
pub unsafe fn makeVar(
    arg_varno: Index,
    arg_varattno: AttrNumber,
    arg_vartype: Oid,
    arg_vartypmod: int32,
    arg_varcollid: Oid,
    arg_varlevelsup: Index,
) -> *mut Var {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeVar(
                arg_varno: Index,
                arg_varattno: AttrNumber,
                arg_vartype: Oid,
                arg_vartypmod: int32,
                arg_varcollid: Oid,
                arg_varlevelsup: Index,
            ) -> *mut Var;
        }
        makeVar(arg_varno, arg_varattno, arg_vartype, arg_vartypmod, arg_varcollid, arg_varlevelsup)
    })
}
pub unsafe fn makeVarFromTargetEntry(arg_varno: Index, arg_tle: *mut TargetEntry) -> *mut Var {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeVarFromTargetEntry(arg_varno: Index, arg_tle: *mut TargetEntry) -> *mut Var;
        }
        makeVarFromTargetEntry(arg_varno, arg_tle)
    })
}
pub unsafe fn makeWholeRowVar(
    arg_rte: *mut RangeTblEntry,
    arg_varno: Index,
    arg_varlevelsup: Index,
    arg_allowScalar: bool,
) -> *mut Var {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeWholeRowVar(
                arg_rte: *mut RangeTblEntry,
                arg_varno: Index,
                arg_varlevelsup: Index,
                arg_allowScalar: bool,
            ) -> *mut Var;
        }
        makeWholeRowVar(arg_rte, arg_varno, arg_varlevelsup, arg_allowScalar)
    })
}
pub unsafe fn makeTargetEntry(
    arg_expr: *mut Expr,
    arg_resno: AttrNumber,
    arg_resname: *mut ::std::os::raw::c_char,
    arg_resjunk: bool,
) -> *mut TargetEntry {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeTargetEntry(
                arg_expr: *mut Expr,
                arg_resno: AttrNumber,
                arg_resname: *mut ::std::os::raw::c_char,
                arg_resjunk: bool,
            ) -> *mut TargetEntry;
        }
        makeTargetEntry(arg_expr, arg_resno, arg_resname, arg_resjunk)
    })
}
pub unsafe fn flatCopyTargetEntry(arg_src_tle: *mut TargetEntry) -> *mut TargetEntry {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn flatCopyTargetEntry(arg_src_tle: *mut TargetEntry) -> *mut TargetEntry;
        }
        flatCopyTargetEntry(arg_src_tle)
    })
}
pub unsafe fn makeFromExpr(arg_fromlist: *mut List, arg_quals: *mut Node) -> *mut FromExpr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeFromExpr(arg_fromlist: *mut List, arg_quals: *mut Node) -> *mut FromExpr;
        }
        makeFromExpr(arg_fromlist, arg_quals)
    })
}
pub unsafe fn makeConst(
    arg_consttype: Oid,
    arg_consttypmod: int32,
    arg_constcollid: Oid,
    arg_constlen: ::std::os::raw::c_int,
    arg_constvalue: Datum,
    arg_constisnull: bool,
    arg_constbyval: bool,
) -> *mut Const {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeConst(
                arg_consttype: Oid,
                arg_consttypmod: int32,
                arg_constcollid: Oid,
                arg_constlen: ::std::os::raw::c_int,
                arg_constvalue: Datum,
                arg_constisnull: bool,
                arg_constbyval: bool,
            ) -> *mut Const;
        }
        makeConst(
            arg_consttype,
            arg_consttypmod,
            arg_constcollid,
            arg_constlen,
            arg_constvalue,
            arg_constisnull,
            arg_constbyval,
        )
    })
}
pub unsafe fn makeNullConst(
    arg_consttype: Oid,
    arg_consttypmod: int32,
    arg_constcollid: Oid,
) -> *mut Const {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeNullConst(
                arg_consttype: Oid,
                arg_consttypmod: int32,
                arg_constcollid: Oid,
            ) -> *mut Const;
        }
        makeNullConst(arg_consttype, arg_consttypmod, arg_constcollid)
    })
}
pub unsafe fn makeBoolConst(arg_value: bool, arg_isnull: bool) -> *mut Node {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeBoolConst(arg_value: bool, arg_isnull: bool) -> *mut Node;
        }
        makeBoolConst(arg_value, arg_isnull)
    })
}
pub unsafe fn makeBoolExpr(
    arg_boolop: BoolExprType,
    arg_args: *mut List,
    arg_location: ::std::os::raw::c_int,
) -> *mut Expr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeBoolExpr(
                arg_boolop: BoolExprType,
                arg_args: *mut List,
                arg_location: ::std::os::raw::c_int,
            ) -> *mut Expr;
        }
        makeBoolExpr(arg_boolop, arg_args, arg_location)
    })
}
pub unsafe fn makeAlias(
    arg_aliasname: *const ::std::os::raw::c_char,
    arg_colnames: *mut List,
) -> *mut Alias {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeAlias(
                arg_aliasname: *const ::std::os::raw::c_char,
                arg_colnames: *mut List,
            ) -> *mut Alias;
        }
        makeAlias(arg_aliasname, arg_colnames)
    })
}
pub unsafe fn makeRelabelType(
    arg_arg: *mut Expr,
    arg_rtype: Oid,
    arg_rtypmod: int32,
    arg_rcollid: Oid,
    arg_rformat: CoercionForm,
) -> *mut RelabelType {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeRelabelType(
                arg_arg: *mut Expr,
                arg_rtype: Oid,
                arg_rtypmod: int32,
                arg_rcollid: Oid,
                arg_rformat: CoercionForm,
            ) -> *mut RelabelType;
        }
        makeRelabelType(arg_arg, arg_rtype, arg_rtypmod, arg_rcollid, arg_rformat)
    })
}
pub unsafe fn makeRangeVar(
    arg_schemaname: *mut ::std::os::raw::c_char,
    arg_relname: *mut ::std::os::raw::c_char,
    arg_location: ::std::os::raw::c_int,
) -> *mut RangeVar {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeRangeVar(
                arg_schemaname: *mut ::std::os::raw::c_char,
                arg_relname: *mut ::std::os::raw::c_char,
                arg_location: ::std::os::raw::c_int,
            ) -> *mut RangeVar;
        }
        makeRangeVar(arg_schemaname, arg_relname, arg_location)
    })
}
pub unsafe fn makeTypeName(arg_typnam: *mut ::std::os::raw::c_char) -> *mut TypeName {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeTypeName(arg_typnam: *mut ::std::os::raw::c_char) -> *mut TypeName;
        }
        makeTypeName(arg_typnam)
    })
}
pub unsafe fn makeTypeNameFromNameList(arg_names: *mut List) -> *mut TypeName {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeTypeNameFromNameList(arg_names: *mut List) -> *mut TypeName;
        }
        makeTypeNameFromNameList(arg_names)
    })
}
pub unsafe fn makeTypeNameFromOid(arg_typeOid: Oid, arg_typmod: int32) -> *mut TypeName {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeTypeNameFromOid(arg_typeOid: Oid, arg_typmod: int32) -> *mut TypeName;
        }
        makeTypeNameFromOid(arg_typeOid, arg_typmod)
    })
}
pub unsafe fn makeColumnDef(
    arg_colname: *const ::std::os::raw::c_char,
    arg_typeOid: Oid,
    arg_typmod: int32,
    arg_collOid: Oid,
) -> *mut ColumnDef {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeColumnDef(
                arg_colname: *const ::std::os::raw::c_char,
                arg_typeOid: Oid,
                arg_typmod: int32,
                arg_collOid: Oid,
            ) -> *mut ColumnDef;
        }
        makeColumnDef(arg_colname, arg_typeOid, arg_typmod, arg_collOid)
    })
}
pub unsafe fn makeFuncExpr(
    arg_funcid: Oid,
    arg_rettype: Oid,
    arg_args: *mut List,
    arg_funccollid: Oid,
    arg_inputcollid: Oid,
    arg_fformat: CoercionForm,
) -> *mut FuncExpr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeFuncExpr(
                arg_funcid: Oid,
                arg_rettype: Oid,
                arg_args: *mut List,
                arg_funccollid: Oid,
                arg_inputcollid: Oid,
                arg_fformat: CoercionForm,
            ) -> *mut FuncExpr;
        }
        makeFuncExpr(
            arg_funcid,
            arg_rettype,
            arg_args,
            arg_funccollid,
            arg_inputcollid,
            arg_fformat,
        )
    })
}
pub unsafe fn makeFuncCall(
    arg_name: *mut List,
    arg_args: *mut List,
    arg_location: ::std::os::raw::c_int,
) -> *mut FuncCall {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeFuncCall(
                arg_name: *mut List,
                arg_args: *mut List,
                arg_location: ::std::os::raw::c_int,
            ) -> *mut FuncCall;
        }
        makeFuncCall(arg_name, arg_args, arg_location)
    })
}
pub unsafe fn make_opclause(
    arg_opno: Oid,
    arg_opresulttype: Oid,
    arg_opretset: bool,
    arg_leftop: *mut Expr,
    arg_rightop: *mut Expr,
    arg_opcollid: Oid,
    arg_inputcollid: Oid,
) -> *mut Expr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_opclause(
                arg_opno: Oid,
                arg_opresulttype: Oid,
                arg_opretset: bool,
                arg_leftop: *mut Expr,
                arg_rightop: *mut Expr,
                arg_opcollid: Oid,
                arg_inputcollid: Oid,
            ) -> *mut Expr;
        }
        make_opclause(
            arg_opno,
            arg_opresulttype,
            arg_opretset,
            arg_leftop,
            arg_rightop,
            arg_opcollid,
            arg_inputcollid,
        )
    })
}
pub unsafe fn make_andclause(arg_andclauses: *mut List) -> *mut Expr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_andclause(arg_andclauses: *mut List) -> *mut Expr;
        }
        make_andclause(arg_andclauses)
    })
}
pub unsafe fn make_orclause(arg_orclauses: *mut List) -> *mut Expr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_orclause(arg_orclauses: *mut List) -> *mut Expr;
        }
        make_orclause(arg_orclauses)
    })
}
pub unsafe fn make_notclause(arg_notclause: *mut Expr) -> *mut Expr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_notclause(arg_notclause: *mut Expr) -> *mut Expr;
        }
        make_notclause(arg_notclause)
    })
}
pub unsafe fn make_and_qual(arg_qual1: *mut Node, arg_qual2: *mut Node) -> *mut Node {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_and_qual(arg_qual1: *mut Node, arg_qual2: *mut Node) -> *mut Node;
        }
        make_and_qual(arg_qual1, arg_qual2)
    })
}
pub unsafe fn make_ands_explicit(arg_andclauses: *mut List) -> *mut Expr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_ands_explicit(arg_andclauses: *mut List) -> *mut Expr;
        }
        make_ands_explicit(arg_andclauses)
    })
}
pub unsafe fn make_ands_implicit(arg_clause: *mut Expr) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_ands_implicit(arg_clause: *mut Expr) -> *mut List;
        }
        make_ands_implicit(arg_clause)
    })
}
pub unsafe fn makeIndexInfo(
    arg_numattrs: ::std::os::raw::c_int,
    arg_numkeyattrs: ::std::os::raw::c_int,
    arg_amoid: Oid,
    arg_expressions: *mut List,
    arg_predicates: *mut List,
    arg_unique: bool,
    arg_isready: bool,
    arg_concurrent: bool,
) -> *mut IndexInfo {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeIndexInfo(
                arg_numattrs: ::std::os::raw::c_int,
                arg_numkeyattrs: ::std::os::raw::c_int,
                arg_amoid: Oid,
                arg_expressions: *mut List,
                arg_predicates: *mut List,
                arg_unique: bool,
                arg_isready: bool,
                arg_concurrent: bool,
            ) -> *mut IndexInfo;
        }
        makeIndexInfo(
            arg_numattrs,
            arg_numkeyattrs,
            arg_amoid,
            arg_expressions,
            arg_predicates,
            arg_unique,
            arg_isready,
            arg_concurrent,
        )
    })
}
pub unsafe fn makeDefElem(
    arg_name: *mut ::std::os::raw::c_char,
    arg_arg: *mut Node,
    arg_location: ::std::os::raw::c_int,
) -> *mut DefElem {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeDefElem(
                arg_name: *mut ::std::os::raw::c_char,
                arg_arg: *mut Node,
                arg_location: ::std::os::raw::c_int,
            ) -> *mut DefElem;
        }
        makeDefElem(arg_name, arg_arg, arg_location)
    })
}
pub unsafe fn makeDefElemExtended(
    arg_nameSpace: *mut ::std::os::raw::c_char,
    arg_name: *mut ::std::os::raw::c_char,
    arg_arg: *mut Node,
    arg_defaction: DefElemAction,
    arg_location: ::std::os::raw::c_int,
) -> *mut DefElem {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeDefElemExtended(
                arg_nameSpace: *mut ::std::os::raw::c_char,
                arg_name: *mut ::std::os::raw::c_char,
                arg_arg: *mut Node,
                arg_defaction: DefElemAction,
                arg_location: ::std::os::raw::c_int,
            ) -> *mut DefElem;
        }
        makeDefElemExtended(arg_nameSpace, arg_name, arg_arg, arg_defaction, arg_location)
    })
}
pub unsafe fn makeGroupingSet(
    arg_kind: GroupingSetKind,
    arg_content: *mut List,
    arg_location: ::std::os::raw::c_int,
) -> *mut GroupingSet {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeGroupingSet(
                arg_kind: GroupingSetKind,
                arg_content: *mut List,
                arg_location: ::std::os::raw::c_int,
            ) -> *mut GroupingSet;
        }
        makeGroupingSet(arg_kind, arg_content, arg_location)
    })
}
pub unsafe fn makeVacuumRelation(
    arg_relation: *mut RangeVar,
    arg_oid: Oid,
    arg_va_cols: *mut List,
) -> *mut VacuumRelation {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeVacuumRelation(
                arg_relation: *mut RangeVar,
                arg_oid: Oid,
                arg_va_cols: *mut List,
            ) -> *mut VacuumRelation;
        }
        makeVacuumRelation(arg_relation, arg_oid, arg_va_cols)
    })
}
pub type check_function_callback = ::std::option::Option<
    unsafe extern "C" fn(func_id: Oid, context: *mut ::std::os::raw::c_void) -> bool,
>;
pub unsafe fn exprType(arg_expr: *const Node) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn exprType(arg_expr: *const Node) -> Oid;
        }
        exprType(arg_expr)
    })
}
pub unsafe fn exprTypmod(arg_expr: *const Node) -> int32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn exprTypmod(arg_expr: *const Node) -> int32;
        }
        exprTypmod(arg_expr)
    })
}
pub unsafe fn exprIsLengthCoercion(arg_expr: *const Node, arg_coercedTypmod: *mut int32) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn exprIsLengthCoercion(arg_expr: *const Node, arg_coercedTypmod: *mut int32) -> bool;
        }
        exprIsLengthCoercion(arg_expr, arg_coercedTypmod)
    })
}
pub unsafe fn applyRelabelType(
    arg_arg: *mut Node,
    arg_rtype: Oid,
    arg_rtypmod: int32,
    arg_rcollid: Oid,
    arg_rformat: CoercionForm,
    arg_rlocation: ::std::os::raw::c_int,
    arg_overwrite_ok: bool,
) -> *mut Node {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn applyRelabelType(
                arg_arg: *mut Node,
                arg_rtype: Oid,
                arg_rtypmod: int32,
                arg_rcollid: Oid,
                arg_rformat: CoercionForm,
                arg_rlocation: ::std::os::raw::c_int,
                arg_overwrite_ok: bool,
            ) -> *mut Node;
        }
        applyRelabelType(
            arg_arg,
            arg_rtype,
            arg_rtypmod,
            arg_rcollid,
            arg_rformat,
            arg_rlocation,
            arg_overwrite_ok,
        )
    })
}
pub unsafe fn relabel_to_typmod(arg_expr: *mut Node, arg_typmod: int32) -> *mut Node {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn relabel_to_typmod(arg_expr: *mut Node, arg_typmod: int32) -> *mut Node;
        }
        relabel_to_typmod(arg_expr, arg_typmod)
    })
}
pub unsafe fn strip_implicit_coercions(arg_node: *mut Node) -> *mut Node {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn strip_implicit_coercions(arg_node: *mut Node) -> *mut Node;
        }
        strip_implicit_coercions(arg_node)
    })
}
pub unsafe fn expression_returns_set(arg_clause: *mut Node) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn expression_returns_set(arg_clause: *mut Node) -> bool;
        }
        expression_returns_set(arg_clause)
    })
}
pub unsafe fn exprCollation(arg_expr: *const Node) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn exprCollation(arg_expr: *const Node) -> Oid;
        }
        exprCollation(arg_expr)
    })
}
pub unsafe fn exprInputCollation(arg_expr: *const Node) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn exprInputCollation(arg_expr: *const Node) -> Oid;
        }
        exprInputCollation(arg_expr)
    })
}
pub unsafe fn exprSetCollation(arg_expr: *mut Node, arg_collation: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn exprSetCollation(arg_expr: *mut Node, arg_collation: Oid);
        }
        exprSetCollation(arg_expr, arg_collation)
    })
}
pub unsafe fn exprSetInputCollation(arg_expr: *mut Node, arg_inputcollation: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn exprSetInputCollation(arg_expr: *mut Node, arg_inputcollation: Oid);
        }
        exprSetInputCollation(arg_expr, arg_inputcollation)
    })
}
pub unsafe fn exprLocation(arg_expr: *const Node) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn exprLocation(arg_expr: *const Node) -> ::std::os::raw::c_int;
        }
        exprLocation(arg_expr)
    })
}
pub unsafe fn fix_opfuncids(arg_node: *mut Node) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fix_opfuncids(arg_node: *mut Node);
        }
        fix_opfuncids(arg_node)
    })
}
pub unsafe fn set_opfuncid(arg_opexpr: *mut OpExpr) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn set_opfuncid(arg_opexpr: *mut OpExpr);
        }
        set_opfuncid(arg_opexpr)
    })
}
pub unsafe fn set_sa_opfuncid(arg_opexpr: *mut ScalarArrayOpExpr) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn set_sa_opfuncid(arg_opexpr: *mut ScalarArrayOpExpr);
        }
        set_sa_opfuncid(arg_opexpr)
    })
}
pub unsafe fn check_functions_in_node(
    arg_node: *mut Node,
    arg_checker: check_function_callback,
    arg_context: *mut ::std::os::raw::c_void,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn check_functions_in_node(
                arg_node: *mut Node,
                arg_checker: check_function_callback,
                arg_context: *mut ::std::os::raw::c_void,
            ) -> bool;
        }
        check_functions_in_node(arg_node, arg_checker, arg_context)
    })
}
pub unsafe fn expression_tree_mutator(
    arg_node: *mut Node,
    arg_mutator: ::std::option::Option<unsafe extern "C" fn() -> *mut Node>,
    arg_context: *mut ::std::os::raw::c_void,
) -> *mut Node {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn expression_tree_mutator(
                arg_node: *mut Node,
                arg_mutator: ::std::option::Option<unsafe extern "C" fn() -> *mut Node>,
                arg_context: *mut ::std::os::raw::c_void,
            ) -> *mut Node;
        }
        expression_tree_mutator(arg_node, arg_mutator, arg_context)
    })
}
pub unsafe fn query_tree_mutator(
    arg_query: *mut Query,
    arg_mutator: ::std::option::Option<unsafe extern "C" fn() -> *mut Node>,
    arg_context: *mut ::std::os::raw::c_void,
    arg_flags: ::std::os::raw::c_int,
) -> *mut Query {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn query_tree_mutator(
                arg_query: *mut Query,
                arg_mutator: ::std::option::Option<unsafe extern "C" fn() -> *mut Node>,
                arg_context: *mut ::std::os::raw::c_void,
                arg_flags: ::std::os::raw::c_int,
            ) -> *mut Query;
        }
        query_tree_mutator(arg_query, arg_mutator, arg_context, arg_flags)
    })
}
pub unsafe fn range_table_walker(
    arg_rtable: *mut List,
    arg_walker: ::std::option::Option<unsafe extern "C" fn() -> bool>,
    arg_context: *mut ::std::os::raw::c_void,
    arg_flags: ::std::os::raw::c_int,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_table_walker(
                arg_rtable: *mut List,
                arg_walker: ::std::option::Option<unsafe extern "C" fn() -> bool>,
                arg_context: *mut ::std::os::raw::c_void,
                arg_flags: ::std::os::raw::c_int,
            ) -> bool;
        }
        range_table_walker(arg_rtable, arg_walker, arg_context, arg_flags)
    })
}
pub unsafe fn range_table_mutator(
    arg_rtable: *mut List,
    arg_mutator: ::std::option::Option<unsafe extern "C" fn() -> *mut Node>,
    arg_context: *mut ::std::os::raw::c_void,
    arg_flags: ::std::os::raw::c_int,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_table_mutator(
                arg_rtable: *mut List,
                arg_mutator: ::std::option::Option<unsafe extern "C" fn() -> *mut Node>,
                arg_context: *mut ::std::os::raw::c_void,
                arg_flags: ::std::os::raw::c_int,
            ) -> *mut List;
        }
        range_table_mutator(arg_rtable, arg_mutator, arg_context, arg_flags)
    })
}
pub unsafe fn range_table_entry_walker(
    arg_rte: *mut RangeTblEntry,
    arg_walker: ::std::option::Option<unsafe extern "C" fn() -> bool>,
    arg_context: *mut ::std::os::raw::c_void,
    arg_flags: ::std::os::raw::c_int,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_table_entry_walker(
                arg_rte: *mut RangeTblEntry,
                arg_walker: ::std::option::Option<unsafe extern "C" fn() -> bool>,
                arg_context: *mut ::std::os::raw::c_void,
                arg_flags: ::std::os::raw::c_int,
            ) -> bool;
        }
        range_table_entry_walker(arg_rte, arg_walker, arg_context, arg_flags)
    })
}
pub unsafe fn query_or_expression_tree_walker(
    arg_node: *mut Node,
    arg_walker: ::std::option::Option<unsafe extern "C" fn() -> bool>,
    arg_context: *mut ::std::os::raw::c_void,
    arg_flags: ::std::os::raw::c_int,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn query_or_expression_tree_walker(
                arg_node: *mut Node,
                arg_walker: ::std::option::Option<unsafe extern "C" fn() -> bool>,
                arg_context: *mut ::std::os::raw::c_void,
                arg_flags: ::std::os::raw::c_int,
            ) -> bool;
        }
        query_or_expression_tree_walker(arg_node, arg_walker, arg_context, arg_flags)
    })
}
pub unsafe fn query_or_expression_tree_mutator(
    arg_node: *mut Node,
    arg_mutator: ::std::option::Option<unsafe extern "C" fn() -> *mut Node>,
    arg_context: *mut ::std::os::raw::c_void,
    arg_flags: ::std::os::raw::c_int,
) -> *mut Node {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn query_or_expression_tree_mutator(
                arg_node: *mut Node,
                arg_mutator: ::std::option::Option<unsafe extern "C" fn() -> *mut Node>,
                arg_context: *mut ::std::os::raw::c_void,
                arg_flags: ::std::os::raw::c_int,
            ) -> *mut Node;
        }
        query_or_expression_tree_mutator(arg_node, arg_mutator, arg_context, arg_flags)
    })
}
pub unsafe fn raw_expression_tree_walker(
    arg_node: *mut Node,
    arg_walker: ::std::option::Option<unsafe extern "C" fn() -> bool>,
    arg_context: *mut ::std::os::raw::c_void,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn raw_expression_tree_walker(
                arg_node: *mut Node,
                arg_walker: ::std::option::Option<unsafe extern "C" fn() -> bool>,
                arg_context: *mut ::std::os::raw::c_void,
            ) -> bool;
        }
        raw_expression_tree_walker(arg_node, arg_walker, arg_context)
    })
}
pub unsafe fn planstate_tree_walker(
    arg_planstate: *mut PlanState,
    arg_walker: ::std::option::Option<unsafe extern "C" fn() -> bool>,
    arg_context: *mut ::std::os::raw::c_void,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn planstate_tree_walker(
                arg_planstate: *mut PlanState,
                arg_walker: ::std::option::Option<unsafe extern "C" fn() -> bool>,
                arg_context: *mut ::std::os::raw::c_void,
            ) -> bool;
        }
        planstate_tree_walker(arg_planstate, arg_walker, arg_context)
    })
}
pub unsafe fn print(arg_obj: *const ::std::os::raw::c_void) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn print(arg_obj: *const ::std::os::raw::c_void);
        }
        print(arg_obj)
    })
}
pub unsafe fn pprint(arg_obj: *const ::std::os::raw::c_void) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pprint(arg_obj: *const ::std::os::raw::c_void);
        }
        pprint(arg_obj)
    })
}
pub unsafe fn elog_node_display(
    arg_lev: ::std::os::raw::c_int,
    arg_title: *const ::std::os::raw::c_char,
    arg_obj: *const ::std::os::raw::c_void,
    arg_pretty: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn elog_node_display(
                arg_lev: ::std::os::raw::c_int,
                arg_title: *const ::std::os::raw::c_char,
                arg_obj: *const ::std::os::raw::c_void,
                arg_pretty: bool,
            );
        }
        elog_node_display(arg_lev, arg_title, arg_obj, arg_pretty)
    })
}
pub unsafe fn format_node_dump(
    arg_dump: *const ::std::os::raw::c_char,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn format_node_dump(
                arg_dump: *const ::std::os::raw::c_char,
            ) -> *mut ::std::os::raw::c_char;
        }
        format_node_dump(arg_dump)
    })
}
pub unsafe fn pretty_format_node_dump(
    arg_dump: *const ::std::os::raw::c_char,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pretty_format_node_dump(
                arg_dump: *const ::std::os::raw::c_char,
            ) -> *mut ::std::os::raw::c_char;
        }
        pretty_format_node_dump(arg_dump)
    })
}
pub unsafe fn print_rt(arg_rtable: *const List) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn print_rt(arg_rtable: *const List);
        }
        print_rt(arg_rtable)
    })
}
pub unsafe fn print_expr(arg_expr: *const Node, arg_rtable: *const List) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn print_expr(arg_expr: *const Node, arg_rtable: *const List);
        }
        print_expr(arg_expr, arg_rtable)
    })
}
pub unsafe fn print_pathkeys(arg_pathkeys: *const List, arg_rtable: *const List) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn print_pathkeys(arg_pathkeys: *const List, arg_rtable: *const List);
        }
        print_pathkeys(arg_pathkeys, arg_rtable)
    })
}
pub unsafe fn print_tl(arg_tlist: *const List, arg_rtable: *const List) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn print_tl(arg_tlist: *const List, arg_rtable: *const List);
        }
        print_tl(arg_tlist, arg_rtable)
    })
}
pub unsafe fn print_slot(arg_slot: *mut TupleTableSlot) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn print_slot(arg_slot: *mut TupleTableSlot);
        }
        print_slot(arg_slot)
    })
}
pub const ReplicationKind_REPLICATION_KIND_PHYSICAL: ReplicationKind = 0;
pub const ReplicationKind_REPLICATION_KIND_LOGICAL: ReplicationKind = 1;
pub type ReplicationKind = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IdentifySystemCmd {
    pub type_: NodeTag,
}
impl Default for IdentifySystemCmd {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BaseBackupCmd {
    pub type_: NodeTag,
    pub options: *mut List,
}
impl Default for BaseBackupCmd {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CreateReplicationSlotCmd {
    pub type_: NodeTag,
    pub slotname: *mut ::std::os::raw::c_char,
    pub kind: ReplicationKind,
    pub plugin: *mut ::std::os::raw::c_char,
    pub temporary: bool,
    pub options: *mut List,
}
impl Default for CreateReplicationSlotCmd {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DropReplicationSlotCmd {
    pub type_: NodeTag,
    pub slotname: *mut ::std::os::raw::c_char,
    pub wait: bool,
}
impl Default for DropReplicationSlotCmd {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StartReplicationCmd {
    pub type_: NodeTag,
    pub kind: ReplicationKind,
    pub slotname: *mut ::std::os::raw::c_char,
    pub timeline: TimeLineID,
    pub startpoint: XLogRecPtr,
    pub options: *mut List,
}
impl Default for StartReplicationCmd {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TimeLineHistoryCmd {
    pub type_: NodeTag,
    pub timeline: TimeLineID,
}
impl Default for TimeLineHistoryCmd {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SQLCmd {
    pub type_: NodeTag,
}
impl Default for SQLCmd {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SupportRequestSimplify {
    pub type_: NodeTag,
    pub root: *mut PlannerInfo,
    pub fcall: *mut FuncExpr,
}
impl Default for SupportRequestSimplify {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SupportRequestSelectivity {
    pub type_: NodeTag,
    pub root: *mut PlannerInfo,
    pub funcid: Oid,
    pub args: *mut List,
    pub inputcollid: Oid,
    pub is_join: bool,
    pub varRelid: ::std::os::raw::c_int,
    pub jointype: JoinType,
    pub sjinfo: *mut SpecialJoinInfo,
    pub selectivity: Selectivity,
}
impl Default for SupportRequestSelectivity {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SupportRequestCost {
    pub type_: NodeTag,
    pub root: *mut PlannerInfo,
    pub funcid: Oid,
    pub node: *mut Node,
    pub startup: Cost,
    pub per_tuple: Cost,
}
impl Default for SupportRequestCost {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SupportRequestRows {
    pub type_: NodeTag,
    pub root: *mut PlannerInfo,
    pub funcid: Oid,
    pub node: *mut Node,
    pub rows: f64,
}
impl Default for SupportRequestRows {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SupportRequestIndexCondition {
    pub type_: NodeTag,
    pub root: *mut PlannerInfo,
    pub funcid: Oid,
    pub node: *mut Node,
    pub indexarg: ::std::os::raw::c_int,
    pub index: *mut IndexOptInfo,
    pub indexcol: ::std::os::raw::c_int,
    pub opfamily: Oid,
    pub indexcollation: Oid,
    pub lossy: bool,
}
impl Default for SupportRequestIndexCondition {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn make_append_rel_info(
    arg_parentrel: Relation,
    arg_childrel: Relation,
    arg_parentRTindex: Index,
    arg_childRTindex: Index,
) -> *mut AppendRelInfo {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_append_rel_info(
                arg_parentrel: Relation,
                arg_childrel: Relation,
                arg_parentRTindex: Index,
                arg_childRTindex: Index,
            ) -> *mut AppendRelInfo;
        }
        make_append_rel_info(arg_parentrel, arg_childrel, arg_parentRTindex, arg_childRTindex)
    })
}
pub unsafe fn adjust_appendrel_attrs(
    arg_root: *mut PlannerInfo,
    arg_node: *mut Node,
    arg_nappinfos: ::std::os::raw::c_int,
    arg_appinfos: *mut *mut AppendRelInfo,
) -> *mut Node {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn adjust_appendrel_attrs(
                arg_root: *mut PlannerInfo,
                arg_node: *mut Node,
                arg_nappinfos: ::std::os::raw::c_int,
                arg_appinfos: *mut *mut AppendRelInfo,
            ) -> *mut Node;
        }
        adjust_appendrel_attrs(arg_root, arg_node, arg_nappinfos, arg_appinfos)
    })
}
pub unsafe fn adjust_appendrel_attrs_multilevel(
    arg_root: *mut PlannerInfo,
    arg_node: *mut Node,
    arg_child_relids: Relids,
    arg_top_parent_relids: Relids,
) -> *mut Node {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn adjust_appendrel_attrs_multilevel(
                arg_root: *mut PlannerInfo,
                arg_node: *mut Node,
                arg_child_relids: Relids,
                arg_top_parent_relids: Relids,
            ) -> *mut Node;
        }
        adjust_appendrel_attrs_multilevel(
            arg_root,
            arg_node,
            arg_child_relids,
            arg_top_parent_relids,
        )
    })
}
pub unsafe fn adjust_child_relids(
    arg_relids: Relids,
    arg_nappinfos: ::std::os::raw::c_int,
    arg_appinfos: *mut *mut AppendRelInfo,
) -> Relids {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn adjust_child_relids(
                arg_relids: Relids,
                arg_nappinfos: ::std::os::raw::c_int,
                arg_appinfos: *mut *mut AppendRelInfo,
            ) -> Relids;
        }
        adjust_child_relids(arg_relids, arg_nappinfos, arg_appinfos)
    })
}
pub unsafe fn adjust_child_relids_multilevel(
    arg_root: *mut PlannerInfo,
    arg_relids: Relids,
    arg_child_relids: Relids,
    arg_top_parent_relids: Relids,
) -> Relids {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn adjust_child_relids_multilevel(
                arg_root: *mut PlannerInfo,
                arg_relids: Relids,
                arg_child_relids: Relids,
                arg_top_parent_relids: Relids,
            ) -> Relids;
        }
        adjust_child_relids_multilevel(
            arg_root,
            arg_relids,
            arg_child_relids,
            arg_top_parent_relids,
        )
    })
}
pub unsafe fn find_appinfos_by_relids(
    arg_root: *mut PlannerInfo,
    arg_relids: Relids,
    arg_nappinfos: *mut ::std::os::raw::c_int,
) -> *mut *mut AppendRelInfo {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn find_appinfos_by_relids(
                arg_root: *mut PlannerInfo,
                arg_relids: Relids,
                arg_nappinfos: *mut ::std::os::raw::c_int,
            ) -> *mut *mut AppendRelInfo;
        }
        find_appinfos_by_relids(arg_root, arg_relids, arg_nappinfos)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowFuncLists {
    pub numWindowFuncs: ::std::os::raw::c_int,
    pub maxWinRef: Index,
    pub windowFuncs: *mut *mut List,
}
impl Default for WindowFuncLists {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn contain_agg_clause(arg_clause: *mut Node) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn contain_agg_clause(arg_clause: *mut Node) -> bool;
        }
        contain_agg_clause(arg_clause)
    })
}
pub unsafe fn get_agg_clause_costs(
    arg_root: *mut PlannerInfo,
    arg_clause: *mut Node,
    arg_aggsplit: AggSplit,
    arg_costs: *mut AggClauseCosts,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_agg_clause_costs(
                arg_root: *mut PlannerInfo,
                arg_clause: *mut Node,
                arg_aggsplit: AggSplit,
                arg_costs: *mut AggClauseCosts,
            );
        }
        get_agg_clause_costs(arg_root, arg_clause, arg_aggsplit, arg_costs)
    })
}
pub unsafe fn contain_window_function(arg_clause: *mut Node) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn contain_window_function(arg_clause: *mut Node) -> bool;
        }
        contain_window_function(arg_clause)
    })
}
pub unsafe fn find_window_functions(
    arg_clause: *mut Node,
    arg_maxWinRef: Index,
) -> *mut WindowFuncLists {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn find_window_functions(
                arg_clause: *mut Node,
                arg_maxWinRef: Index,
            ) -> *mut WindowFuncLists;
        }
        find_window_functions(arg_clause, arg_maxWinRef)
    })
}
pub unsafe fn expression_returns_set_rows(
    arg_root: *mut PlannerInfo,
    arg_clause: *mut Node,
) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn expression_returns_set_rows(
                arg_root: *mut PlannerInfo,
                arg_clause: *mut Node,
            ) -> f64;
        }
        expression_returns_set_rows(arg_root, arg_clause)
    })
}
pub unsafe fn contain_subplans(arg_clause: *mut Node) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn contain_subplans(arg_clause: *mut Node) -> bool;
        }
        contain_subplans(arg_clause)
    })
}
pub unsafe fn max_parallel_hazard(arg_parse: *mut Query) -> ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn max_parallel_hazard(arg_parse: *mut Query) -> ::std::os::raw::c_char;
        }
        max_parallel_hazard(arg_parse)
    })
}
pub unsafe fn is_parallel_safe(arg_root: *mut PlannerInfo, arg_node: *mut Node) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn is_parallel_safe(arg_root: *mut PlannerInfo, arg_node: *mut Node) -> bool;
        }
        is_parallel_safe(arg_root, arg_node)
    })
}
pub unsafe fn contain_nonstrict_functions(arg_clause: *mut Node) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn contain_nonstrict_functions(arg_clause: *mut Node) -> bool;
        }
        contain_nonstrict_functions(arg_clause)
    })
}
pub unsafe fn contain_exec_param(arg_clause: *mut Node, arg_param_ids: *mut List) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn contain_exec_param(arg_clause: *mut Node, arg_param_ids: *mut List) -> bool;
        }
        contain_exec_param(arg_clause, arg_param_ids)
    })
}
pub unsafe fn contain_leaked_vars(arg_clause: *mut Node) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn contain_leaked_vars(arg_clause: *mut Node) -> bool;
        }
        contain_leaked_vars(arg_clause)
    })
}
pub unsafe fn find_nonnullable_rels(arg_clause: *mut Node) -> Relids {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn find_nonnullable_rels(arg_clause: *mut Node) -> Relids;
        }
        find_nonnullable_rels(arg_clause)
    })
}
pub unsafe fn find_nonnullable_vars(arg_clause: *mut Node) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn find_nonnullable_vars(arg_clause: *mut Node) -> *mut List;
        }
        find_nonnullable_vars(arg_clause)
    })
}
pub unsafe fn find_forced_null_vars(arg_clause: *mut Node) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn find_forced_null_vars(arg_clause: *mut Node) -> *mut List;
        }
        find_forced_null_vars(arg_clause)
    })
}
pub unsafe fn find_forced_null_var(arg_clause: *mut Node) -> *mut Var {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn find_forced_null_var(arg_clause: *mut Node) -> *mut Var;
        }
        find_forced_null_var(arg_clause)
    })
}
pub unsafe fn is_pseudo_constant_clause(arg_clause: *mut Node) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn is_pseudo_constant_clause(arg_clause: *mut Node) -> bool;
        }
        is_pseudo_constant_clause(arg_clause)
    })
}
pub unsafe fn is_pseudo_constant_clause_relids(arg_clause: *mut Node, arg_relids: Relids) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn is_pseudo_constant_clause_relids(arg_clause: *mut Node, arg_relids: Relids) -> bool;
        }
        is_pseudo_constant_clause_relids(arg_clause, arg_relids)
    })
}
pub unsafe fn NumRelids(arg_clause: *mut Node) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn NumRelids(arg_clause: *mut Node) -> ::std::os::raw::c_int;
        }
        NumRelids(arg_clause)
    })
}
pub unsafe fn NumRelids_new(
    arg_root: *mut PlannerInfo,
    arg_clause: *mut Node,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn NumRelids_new(
                arg_root: *mut PlannerInfo,
                arg_clause: *mut Node,
            ) -> ::std::os::raw::c_int;
        }
        NumRelids_new(arg_root, arg_clause)
    })
}
pub unsafe fn CommuteOpExpr(arg_clause: *mut OpExpr) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CommuteOpExpr(arg_clause: *mut OpExpr);
        }
        CommuteOpExpr(arg_clause)
    })
}
pub unsafe fn inline_set_returning_function(
    arg_root: *mut PlannerInfo,
    arg_rte: *mut RangeTblEntry,
) -> *mut Query {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inline_set_returning_function(
                arg_root: *mut PlannerInfo,
                arg_rte: *mut RangeTblEntry,
            ) -> *mut Query;
        }
        inline_set_returning_function(arg_root, arg_rte)
    })
}
pub const ConstraintExclusionType_CONSTRAINT_EXCLUSION_OFF: ConstraintExclusionType = 0;
pub const ConstraintExclusionType_CONSTRAINT_EXCLUSION_ON: ConstraintExclusionType = 1;
pub const ConstraintExclusionType_CONSTRAINT_EXCLUSION_PARTITION: ConstraintExclusionType = 2;
pub type ConstraintExclusionType = ::std::os::raw::c_uint;
extern "C" {
    pub static mut disable_cost: Cost;
}
extern "C" {
    pub static mut max_parallel_workers_per_gather: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut enable_seqscan: bool;
}
extern "C" {
    pub static mut enable_indexscan: bool;
}
extern "C" {
    pub static mut enable_indexonlyscan: bool;
}
extern "C" {
    pub static mut enable_bitmapscan: bool;
}
extern "C" {
    pub static mut enable_tidscan: bool;
}
extern "C" {
    pub static mut enable_sort: bool;
}
extern "C" {
    pub static mut enable_incremental_sort: bool;
}
extern "C" {
    pub static mut enable_hashagg: bool;
}
extern "C" {
    pub static mut enable_nestloop: bool;
}
extern "C" {
    pub static mut enable_material: bool;
}
extern "C" {
    pub static mut enable_mergejoin: bool;
}
extern "C" {
    pub static mut enable_hashjoin: bool;
}
extern "C" {
    pub static mut enable_gathermerge: bool;
}
extern "C" {
    pub static mut enable_partitionwise_join: bool;
}
extern "C" {
    pub static mut enable_partitionwise_aggregate: bool;
}
extern "C" {
    pub static mut enable_parallel_append: bool;
}
extern "C" {
    pub static mut enable_parallel_hash: bool;
}
extern "C" {
    pub static mut enable_partition_pruning: bool;
}
extern "C" {
    pub static mut constraint_exclusion: ::std::os::raw::c_int;
}
pub unsafe fn index_pages_fetched(
    arg_tuples_fetched: f64,
    arg_pages: BlockNumber,
    arg_index_pages: f64,
    arg_root: *mut PlannerInfo,
) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_pages_fetched(
                arg_tuples_fetched: f64,
                arg_pages: BlockNumber,
                arg_index_pages: f64,
                arg_root: *mut PlannerInfo,
            ) -> f64;
        }
        index_pages_fetched(arg_tuples_fetched, arg_pages, arg_index_pages, arg_root)
    })
}
pub unsafe fn cost_seqscan(
    arg_path: *mut Path,
    arg_root: *mut PlannerInfo,
    arg_baserel: *mut RelOptInfo,
    arg_param_info: *mut ParamPathInfo,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cost_seqscan(
                arg_path: *mut Path,
                arg_root: *mut PlannerInfo,
                arg_baserel: *mut RelOptInfo,
                arg_param_info: *mut ParamPathInfo,
            );
        }
        cost_seqscan(arg_path, arg_root, arg_baserel, arg_param_info)
    })
}
pub unsafe fn cost_samplescan(
    arg_path: *mut Path,
    arg_root: *mut PlannerInfo,
    arg_baserel: *mut RelOptInfo,
    arg_param_info: *mut ParamPathInfo,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cost_samplescan(
                arg_path: *mut Path,
                arg_root: *mut PlannerInfo,
                arg_baserel: *mut RelOptInfo,
                arg_param_info: *mut ParamPathInfo,
            );
        }
        cost_samplescan(arg_path, arg_root, arg_baserel, arg_param_info)
    })
}
pub unsafe fn cost_index(
    arg_path: *mut IndexPath,
    arg_root: *mut PlannerInfo,
    arg_loop_count: f64,
    arg_partial_path: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cost_index(
                arg_path: *mut IndexPath,
                arg_root: *mut PlannerInfo,
                arg_loop_count: f64,
                arg_partial_path: bool,
            );
        }
        cost_index(arg_path, arg_root, arg_loop_count, arg_partial_path)
    })
}
pub unsafe fn cost_bitmap_heap_scan(
    arg_path: *mut Path,
    arg_root: *mut PlannerInfo,
    arg_baserel: *mut RelOptInfo,
    arg_param_info: *mut ParamPathInfo,
    arg_bitmapqual: *mut Path,
    arg_loop_count: f64,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cost_bitmap_heap_scan(
                arg_path: *mut Path,
                arg_root: *mut PlannerInfo,
                arg_baserel: *mut RelOptInfo,
                arg_param_info: *mut ParamPathInfo,
                arg_bitmapqual: *mut Path,
                arg_loop_count: f64,
            );
        }
        cost_bitmap_heap_scan(
            arg_path,
            arg_root,
            arg_baserel,
            arg_param_info,
            arg_bitmapqual,
            arg_loop_count,
        )
    })
}
pub unsafe fn cost_bitmap_and_node(arg_path: *mut BitmapAndPath, arg_root: *mut PlannerInfo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cost_bitmap_and_node(arg_path: *mut BitmapAndPath, arg_root: *mut PlannerInfo);
        }
        cost_bitmap_and_node(arg_path, arg_root)
    })
}
pub unsafe fn cost_bitmap_or_node(arg_path: *mut BitmapOrPath, arg_root: *mut PlannerInfo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cost_bitmap_or_node(arg_path: *mut BitmapOrPath, arg_root: *mut PlannerInfo);
        }
        cost_bitmap_or_node(arg_path, arg_root)
    })
}
pub unsafe fn cost_bitmap_tree_node(
    arg_path: *mut Path,
    arg_cost: *mut Cost,
    arg_selec: *mut Selectivity,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cost_bitmap_tree_node(
                arg_path: *mut Path,
                arg_cost: *mut Cost,
                arg_selec: *mut Selectivity,
            );
        }
        cost_bitmap_tree_node(arg_path, arg_cost, arg_selec)
    })
}
pub unsafe fn cost_tidscan(
    arg_path: *mut Path,
    arg_root: *mut PlannerInfo,
    arg_baserel: *mut RelOptInfo,
    arg_tidquals: *mut List,
    arg_param_info: *mut ParamPathInfo,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cost_tidscan(
                arg_path: *mut Path,
                arg_root: *mut PlannerInfo,
                arg_baserel: *mut RelOptInfo,
                arg_tidquals: *mut List,
                arg_param_info: *mut ParamPathInfo,
            );
        }
        cost_tidscan(arg_path, arg_root, arg_baserel, arg_tidquals, arg_param_info)
    })
}
pub unsafe fn cost_subqueryscan(
    arg_path: *mut SubqueryScanPath,
    arg_root: *mut PlannerInfo,
    arg_baserel: *mut RelOptInfo,
    arg_param_info: *mut ParamPathInfo,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cost_subqueryscan(
                arg_path: *mut SubqueryScanPath,
                arg_root: *mut PlannerInfo,
                arg_baserel: *mut RelOptInfo,
                arg_param_info: *mut ParamPathInfo,
            );
        }
        cost_subqueryscan(arg_path, arg_root, arg_baserel, arg_param_info)
    })
}
pub unsafe fn cost_functionscan(
    arg_path: *mut Path,
    arg_root: *mut PlannerInfo,
    arg_baserel: *mut RelOptInfo,
    arg_param_info: *mut ParamPathInfo,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cost_functionscan(
                arg_path: *mut Path,
                arg_root: *mut PlannerInfo,
                arg_baserel: *mut RelOptInfo,
                arg_param_info: *mut ParamPathInfo,
            );
        }
        cost_functionscan(arg_path, arg_root, arg_baserel, arg_param_info)
    })
}
pub unsafe fn cost_valuesscan(
    arg_path: *mut Path,
    arg_root: *mut PlannerInfo,
    arg_baserel: *mut RelOptInfo,
    arg_param_info: *mut ParamPathInfo,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cost_valuesscan(
                arg_path: *mut Path,
                arg_root: *mut PlannerInfo,
                arg_baserel: *mut RelOptInfo,
                arg_param_info: *mut ParamPathInfo,
            );
        }
        cost_valuesscan(arg_path, arg_root, arg_baserel, arg_param_info)
    })
}
pub unsafe fn cost_tablefuncscan(
    arg_path: *mut Path,
    arg_root: *mut PlannerInfo,
    arg_baserel: *mut RelOptInfo,
    arg_param_info: *mut ParamPathInfo,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cost_tablefuncscan(
                arg_path: *mut Path,
                arg_root: *mut PlannerInfo,
                arg_baserel: *mut RelOptInfo,
                arg_param_info: *mut ParamPathInfo,
            );
        }
        cost_tablefuncscan(arg_path, arg_root, arg_baserel, arg_param_info)
    })
}
pub unsafe fn cost_ctescan(
    arg_path: *mut Path,
    arg_root: *mut PlannerInfo,
    arg_baserel: *mut RelOptInfo,
    arg_param_info: *mut ParamPathInfo,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cost_ctescan(
                arg_path: *mut Path,
                arg_root: *mut PlannerInfo,
                arg_baserel: *mut RelOptInfo,
                arg_param_info: *mut ParamPathInfo,
            );
        }
        cost_ctescan(arg_path, arg_root, arg_baserel, arg_param_info)
    })
}
pub unsafe fn cost_namedtuplestorescan(
    arg_path: *mut Path,
    arg_root: *mut PlannerInfo,
    arg_baserel: *mut RelOptInfo,
    arg_param_info: *mut ParamPathInfo,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cost_namedtuplestorescan(
                arg_path: *mut Path,
                arg_root: *mut PlannerInfo,
                arg_baserel: *mut RelOptInfo,
                arg_param_info: *mut ParamPathInfo,
            );
        }
        cost_namedtuplestorescan(arg_path, arg_root, arg_baserel, arg_param_info)
    })
}
pub unsafe fn cost_resultscan(
    arg_path: *mut Path,
    arg_root: *mut PlannerInfo,
    arg_baserel: *mut RelOptInfo,
    arg_param_info: *mut ParamPathInfo,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cost_resultscan(
                arg_path: *mut Path,
                arg_root: *mut PlannerInfo,
                arg_baserel: *mut RelOptInfo,
                arg_param_info: *mut ParamPathInfo,
            );
        }
        cost_resultscan(arg_path, arg_root, arg_baserel, arg_param_info)
    })
}
pub unsafe fn cost_recursive_union(
    arg_runion: *mut Path,
    arg_nrterm: *mut Path,
    arg_rterm: *mut Path,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cost_recursive_union(
                arg_runion: *mut Path,
                arg_nrterm: *mut Path,
                arg_rterm: *mut Path,
            );
        }
        cost_recursive_union(arg_runion, arg_nrterm, arg_rterm)
    })
}
pub unsafe fn cost_sort(
    arg_path: *mut Path,
    arg_root: *mut PlannerInfo,
    arg_pathkeys: *mut List,
    arg_input_cost: Cost,
    arg_tuples: f64,
    arg_width: ::std::os::raw::c_int,
    arg_comparison_cost: Cost,
    arg_sort_mem: ::std::os::raw::c_int,
    arg_limit_tuples: f64,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cost_sort(
                arg_path: *mut Path,
                arg_root: *mut PlannerInfo,
                arg_pathkeys: *mut List,
                arg_input_cost: Cost,
                arg_tuples: f64,
                arg_width: ::std::os::raw::c_int,
                arg_comparison_cost: Cost,
                arg_sort_mem: ::std::os::raw::c_int,
                arg_limit_tuples: f64,
            );
        }
        cost_sort(
            arg_path,
            arg_root,
            arg_pathkeys,
            arg_input_cost,
            arg_tuples,
            arg_width,
            arg_comparison_cost,
            arg_sort_mem,
            arg_limit_tuples,
        )
    })
}
pub unsafe fn cost_incremental_sort(
    arg_path: *mut Path,
    arg_root: *mut PlannerInfo,
    arg_pathkeys: *mut List,
    arg_presorted_keys: ::std::os::raw::c_int,
    arg_input_startup_cost: Cost,
    arg_input_total_cost: Cost,
    arg_input_tuples: f64,
    arg_width: ::std::os::raw::c_int,
    arg_comparison_cost: Cost,
    arg_sort_mem: ::std::os::raw::c_int,
    arg_limit_tuples: f64,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cost_incremental_sort(
                arg_path: *mut Path,
                arg_root: *mut PlannerInfo,
                arg_pathkeys: *mut List,
                arg_presorted_keys: ::std::os::raw::c_int,
                arg_input_startup_cost: Cost,
                arg_input_total_cost: Cost,
                arg_input_tuples: f64,
                arg_width: ::std::os::raw::c_int,
                arg_comparison_cost: Cost,
                arg_sort_mem: ::std::os::raw::c_int,
                arg_limit_tuples: f64,
            );
        }
        cost_incremental_sort(
            arg_path,
            arg_root,
            arg_pathkeys,
            arg_presorted_keys,
            arg_input_startup_cost,
            arg_input_total_cost,
            arg_input_tuples,
            arg_width,
            arg_comparison_cost,
            arg_sort_mem,
            arg_limit_tuples,
        )
    })
}
pub unsafe fn cost_append(arg_path: *mut AppendPath) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cost_append(arg_path: *mut AppendPath);
        }
        cost_append(arg_path)
    })
}
pub unsafe fn cost_merge_append(
    arg_path: *mut Path,
    arg_root: *mut PlannerInfo,
    arg_pathkeys: *mut List,
    arg_n_streams: ::std::os::raw::c_int,
    arg_input_startup_cost: Cost,
    arg_input_total_cost: Cost,
    arg_tuples: f64,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cost_merge_append(
                arg_path: *mut Path,
                arg_root: *mut PlannerInfo,
                arg_pathkeys: *mut List,
                arg_n_streams: ::std::os::raw::c_int,
                arg_input_startup_cost: Cost,
                arg_input_total_cost: Cost,
                arg_tuples: f64,
            );
        }
        cost_merge_append(
            arg_path,
            arg_root,
            arg_pathkeys,
            arg_n_streams,
            arg_input_startup_cost,
            arg_input_total_cost,
            arg_tuples,
        )
    })
}
pub unsafe fn cost_material(
    arg_path: *mut Path,
    arg_input_startup_cost: Cost,
    arg_input_total_cost: Cost,
    arg_tuples: f64,
    arg_width: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cost_material(
                arg_path: *mut Path,
                arg_input_startup_cost: Cost,
                arg_input_total_cost: Cost,
                arg_tuples: f64,
                arg_width: ::std::os::raw::c_int,
            );
        }
        cost_material(arg_path, arg_input_startup_cost, arg_input_total_cost, arg_tuples, arg_width)
    })
}
pub unsafe fn cost_agg(
    arg_path: *mut Path,
    arg_root: *mut PlannerInfo,
    arg_aggstrategy: AggStrategy,
    arg_aggcosts: *const AggClauseCosts,
    arg_numGroupCols: ::std::os::raw::c_int,
    arg_numGroups: f64,
    arg_quals: *mut List,
    arg_input_startup_cost: Cost,
    arg_input_total_cost: Cost,
    arg_input_tuples: f64,
    arg_input_width: f64,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cost_agg(
                arg_path: *mut Path,
                arg_root: *mut PlannerInfo,
                arg_aggstrategy: AggStrategy,
                arg_aggcosts: *const AggClauseCosts,
                arg_numGroupCols: ::std::os::raw::c_int,
                arg_numGroups: f64,
                arg_quals: *mut List,
                arg_input_startup_cost: Cost,
                arg_input_total_cost: Cost,
                arg_input_tuples: f64,
                arg_input_width: f64,
            );
        }
        cost_agg(
            arg_path,
            arg_root,
            arg_aggstrategy,
            arg_aggcosts,
            arg_numGroupCols,
            arg_numGroups,
            arg_quals,
            arg_input_startup_cost,
            arg_input_total_cost,
            arg_input_tuples,
            arg_input_width,
        )
    })
}
pub unsafe fn cost_windowagg(
    arg_path: *mut Path,
    arg_root: *mut PlannerInfo,
    arg_windowFuncs: *mut List,
    arg_numPartCols: ::std::os::raw::c_int,
    arg_numOrderCols: ::std::os::raw::c_int,
    arg_input_startup_cost: Cost,
    arg_input_total_cost: Cost,
    arg_input_tuples: f64,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cost_windowagg(
                arg_path: *mut Path,
                arg_root: *mut PlannerInfo,
                arg_windowFuncs: *mut List,
                arg_numPartCols: ::std::os::raw::c_int,
                arg_numOrderCols: ::std::os::raw::c_int,
                arg_input_startup_cost: Cost,
                arg_input_total_cost: Cost,
                arg_input_tuples: f64,
            );
        }
        cost_windowagg(
            arg_path,
            arg_root,
            arg_windowFuncs,
            arg_numPartCols,
            arg_numOrderCols,
            arg_input_startup_cost,
            arg_input_total_cost,
            arg_input_tuples,
        )
    })
}
pub unsafe fn cost_group(
    arg_path: *mut Path,
    arg_root: *mut PlannerInfo,
    arg_numGroupCols: ::std::os::raw::c_int,
    arg_numGroups: f64,
    arg_quals: *mut List,
    arg_input_startup_cost: Cost,
    arg_input_total_cost: Cost,
    arg_input_tuples: f64,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cost_group(
                arg_path: *mut Path,
                arg_root: *mut PlannerInfo,
                arg_numGroupCols: ::std::os::raw::c_int,
                arg_numGroups: f64,
                arg_quals: *mut List,
                arg_input_startup_cost: Cost,
                arg_input_total_cost: Cost,
                arg_input_tuples: f64,
            );
        }
        cost_group(
            arg_path,
            arg_root,
            arg_numGroupCols,
            arg_numGroups,
            arg_quals,
            arg_input_startup_cost,
            arg_input_total_cost,
            arg_input_tuples,
        )
    })
}
pub unsafe fn initial_cost_nestloop(
    arg_root: *mut PlannerInfo,
    arg_workspace: *mut JoinCostWorkspace,
    arg_jointype: JoinType,
    arg_outer_path: *mut Path,
    arg_inner_path: *mut Path,
    arg_extra: *mut JoinPathExtraData,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn initial_cost_nestloop(
                arg_root: *mut PlannerInfo,
                arg_workspace: *mut JoinCostWorkspace,
                arg_jointype: JoinType,
                arg_outer_path: *mut Path,
                arg_inner_path: *mut Path,
                arg_extra: *mut JoinPathExtraData,
            );
        }
        initial_cost_nestloop(
            arg_root,
            arg_workspace,
            arg_jointype,
            arg_outer_path,
            arg_inner_path,
            arg_extra,
        )
    })
}
pub unsafe fn final_cost_nestloop(
    arg_root: *mut PlannerInfo,
    arg_path: *mut NestPath,
    arg_workspace: *mut JoinCostWorkspace,
    arg_extra: *mut JoinPathExtraData,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn final_cost_nestloop(
                arg_root: *mut PlannerInfo,
                arg_path: *mut NestPath,
                arg_workspace: *mut JoinCostWorkspace,
                arg_extra: *mut JoinPathExtraData,
            );
        }
        final_cost_nestloop(arg_root, arg_path, arg_workspace, arg_extra)
    })
}
pub unsafe fn initial_cost_mergejoin(
    arg_root: *mut PlannerInfo,
    arg_workspace: *mut JoinCostWorkspace,
    arg_jointype: JoinType,
    arg_mergeclauses: *mut List,
    arg_outer_path: *mut Path,
    arg_inner_path: *mut Path,
    arg_outersortkeys: *mut List,
    arg_innersortkeys: *mut List,
    arg_extra: *mut JoinPathExtraData,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn initial_cost_mergejoin(
                arg_root: *mut PlannerInfo,
                arg_workspace: *mut JoinCostWorkspace,
                arg_jointype: JoinType,
                arg_mergeclauses: *mut List,
                arg_outer_path: *mut Path,
                arg_inner_path: *mut Path,
                arg_outersortkeys: *mut List,
                arg_innersortkeys: *mut List,
                arg_extra: *mut JoinPathExtraData,
            );
        }
        initial_cost_mergejoin(
            arg_root,
            arg_workspace,
            arg_jointype,
            arg_mergeclauses,
            arg_outer_path,
            arg_inner_path,
            arg_outersortkeys,
            arg_innersortkeys,
            arg_extra,
        )
    })
}
pub unsafe fn final_cost_mergejoin(
    arg_root: *mut PlannerInfo,
    arg_path: *mut MergePath,
    arg_workspace: *mut JoinCostWorkspace,
    arg_extra: *mut JoinPathExtraData,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn final_cost_mergejoin(
                arg_root: *mut PlannerInfo,
                arg_path: *mut MergePath,
                arg_workspace: *mut JoinCostWorkspace,
                arg_extra: *mut JoinPathExtraData,
            );
        }
        final_cost_mergejoin(arg_root, arg_path, arg_workspace, arg_extra)
    })
}
pub unsafe fn initial_cost_hashjoin(
    arg_root: *mut PlannerInfo,
    arg_workspace: *mut JoinCostWorkspace,
    arg_jointype: JoinType,
    arg_hashclauses: *mut List,
    arg_outer_path: *mut Path,
    arg_inner_path: *mut Path,
    arg_extra: *mut JoinPathExtraData,
    arg_parallel_hash: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn initial_cost_hashjoin(
                arg_root: *mut PlannerInfo,
                arg_workspace: *mut JoinCostWorkspace,
                arg_jointype: JoinType,
                arg_hashclauses: *mut List,
                arg_outer_path: *mut Path,
                arg_inner_path: *mut Path,
                arg_extra: *mut JoinPathExtraData,
                arg_parallel_hash: bool,
            );
        }
        initial_cost_hashjoin(
            arg_root,
            arg_workspace,
            arg_jointype,
            arg_hashclauses,
            arg_outer_path,
            arg_inner_path,
            arg_extra,
            arg_parallel_hash,
        )
    })
}
pub unsafe fn final_cost_hashjoin(
    arg_root: *mut PlannerInfo,
    arg_path: *mut HashPath,
    arg_workspace: *mut JoinCostWorkspace,
    arg_extra: *mut JoinPathExtraData,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn final_cost_hashjoin(
                arg_root: *mut PlannerInfo,
                arg_path: *mut HashPath,
                arg_workspace: *mut JoinCostWorkspace,
                arg_extra: *mut JoinPathExtraData,
            );
        }
        final_cost_hashjoin(arg_root, arg_path, arg_workspace, arg_extra)
    })
}
pub unsafe fn cost_gather(
    arg_path: *mut GatherPath,
    arg_root: *mut PlannerInfo,
    arg_baserel: *mut RelOptInfo,
    arg_param_info: *mut ParamPathInfo,
    arg_rows: *mut f64,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cost_gather(
                arg_path: *mut GatherPath,
                arg_root: *mut PlannerInfo,
                arg_baserel: *mut RelOptInfo,
                arg_param_info: *mut ParamPathInfo,
                arg_rows: *mut f64,
            );
        }
        cost_gather(arg_path, arg_root, arg_baserel, arg_param_info, arg_rows)
    })
}
pub unsafe fn cost_gather_merge(
    arg_path: *mut GatherMergePath,
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_param_info: *mut ParamPathInfo,
    arg_input_startup_cost: Cost,
    arg_input_total_cost: Cost,
    arg_rows: *mut f64,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cost_gather_merge(
                arg_path: *mut GatherMergePath,
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_param_info: *mut ParamPathInfo,
                arg_input_startup_cost: Cost,
                arg_input_total_cost: Cost,
                arg_rows: *mut f64,
            );
        }
        cost_gather_merge(
            arg_path,
            arg_root,
            arg_rel,
            arg_param_info,
            arg_input_startup_cost,
            arg_input_total_cost,
            arg_rows,
        )
    })
}
pub unsafe fn cost_subplan(
    arg_root: *mut PlannerInfo,
    arg_subplan: *mut SubPlan,
    arg_plan: *mut Plan,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cost_subplan(
                arg_root: *mut PlannerInfo,
                arg_subplan: *mut SubPlan,
                arg_plan: *mut Plan,
            );
        }
        cost_subplan(arg_root, arg_subplan, arg_plan)
    })
}
pub unsafe fn cost_qual_eval(
    arg_cost: *mut QualCost,
    arg_quals: *mut List,
    arg_root: *mut PlannerInfo,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cost_qual_eval(
                arg_cost: *mut QualCost,
                arg_quals: *mut List,
                arg_root: *mut PlannerInfo,
            );
        }
        cost_qual_eval(arg_cost, arg_quals, arg_root)
    })
}
pub unsafe fn cost_qual_eval_node(
    arg_cost: *mut QualCost,
    arg_qual: *mut Node,
    arg_root: *mut PlannerInfo,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cost_qual_eval_node(
                arg_cost: *mut QualCost,
                arg_qual: *mut Node,
                arg_root: *mut PlannerInfo,
            );
        }
        cost_qual_eval_node(arg_cost, arg_qual, arg_root)
    })
}
pub unsafe fn compute_semi_anti_join_factors(
    arg_root: *mut PlannerInfo,
    arg_joinrel: *mut RelOptInfo,
    arg_outerrel: *mut RelOptInfo,
    arg_innerrel: *mut RelOptInfo,
    arg_jointype: JoinType,
    arg_sjinfo: *mut SpecialJoinInfo,
    arg_restrictlist: *mut List,
    arg_semifactors: *mut SemiAntiJoinFactors,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn compute_semi_anti_join_factors(
                arg_root: *mut PlannerInfo,
                arg_joinrel: *mut RelOptInfo,
                arg_outerrel: *mut RelOptInfo,
                arg_innerrel: *mut RelOptInfo,
                arg_jointype: JoinType,
                arg_sjinfo: *mut SpecialJoinInfo,
                arg_restrictlist: *mut List,
                arg_semifactors: *mut SemiAntiJoinFactors,
            );
        }
        compute_semi_anti_join_factors(
            arg_root,
            arg_joinrel,
            arg_outerrel,
            arg_innerrel,
            arg_jointype,
            arg_sjinfo,
            arg_restrictlist,
            arg_semifactors,
        )
    })
}
pub unsafe fn set_baserel_size_estimates(arg_root: *mut PlannerInfo, arg_rel: *mut RelOptInfo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn set_baserel_size_estimates(arg_root: *mut PlannerInfo, arg_rel: *mut RelOptInfo);
        }
        set_baserel_size_estimates(arg_root, arg_rel)
    })
}
pub unsafe fn get_parameterized_baserel_size(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_param_clauses: *mut List,
) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_parameterized_baserel_size(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_param_clauses: *mut List,
            ) -> f64;
        }
        get_parameterized_baserel_size(arg_root, arg_rel, arg_param_clauses)
    })
}
pub unsafe fn get_parameterized_joinrel_size(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_outer_path: *mut Path,
    arg_inner_path: *mut Path,
    arg_sjinfo: *mut SpecialJoinInfo,
    arg_restrict_clauses: *mut List,
) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_parameterized_joinrel_size(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_outer_path: *mut Path,
                arg_inner_path: *mut Path,
                arg_sjinfo: *mut SpecialJoinInfo,
                arg_restrict_clauses: *mut List,
            ) -> f64;
        }
        get_parameterized_joinrel_size(
            arg_root,
            arg_rel,
            arg_outer_path,
            arg_inner_path,
            arg_sjinfo,
            arg_restrict_clauses,
        )
    })
}
pub unsafe fn set_joinrel_size_estimates(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_outer_rel: *mut RelOptInfo,
    arg_inner_rel: *mut RelOptInfo,
    arg_sjinfo: *mut SpecialJoinInfo,
    arg_restrictlist: *mut List,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn set_joinrel_size_estimates(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_outer_rel: *mut RelOptInfo,
                arg_inner_rel: *mut RelOptInfo,
                arg_sjinfo: *mut SpecialJoinInfo,
                arg_restrictlist: *mut List,
            );
        }
        set_joinrel_size_estimates(
            arg_root,
            arg_rel,
            arg_outer_rel,
            arg_inner_rel,
            arg_sjinfo,
            arg_restrictlist,
        )
    })
}
pub unsafe fn set_subquery_size_estimates(arg_root: *mut PlannerInfo, arg_rel: *mut RelOptInfo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn set_subquery_size_estimates(arg_root: *mut PlannerInfo, arg_rel: *mut RelOptInfo);
        }
        set_subquery_size_estimates(arg_root, arg_rel)
    })
}
pub unsafe fn set_function_size_estimates(arg_root: *mut PlannerInfo, arg_rel: *mut RelOptInfo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn set_function_size_estimates(arg_root: *mut PlannerInfo, arg_rel: *mut RelOptInfo);
        }
        set_function_size_estimates(arg_root, arg_rel)
    })
}
pub unsafe fn set_values_size_estimates(arg_root: *mut PlannerInfo, arg_rel: *mut RelOptInfo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn set_values_size_estimates(arg_root: *mut PlannerInfo, arg_rel: *mut RelOptInfo);
        }
        set_values_size_estimates(arg_root, arg_rel)
    })
}
pub unsafe fn set_cte_size_estimates(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_cte_rows: f64,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn set_cte_size_estimates(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_cte_rows: f64,
            );
        }
        set_cte_size_estimates(arg_root, arg_rel, arg_cte_rows)
    })
}
pub unsafe fn set_tablefunc_size_estimates(arg_root: *mut PlannerInfo, arg_rel: *mut RelOptInfo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn set_tablefunc_size_estimates(arg_root: *mut PlannerInfo, arg_rel: *mut RelOptInfo);
        }
        set_tablefunc_size_estimates(arg_root, arg_rel)
    })
}
pub unsafe fn set_namedtuplestore_size_estimates(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn set_namedtuplestore_size_estimates(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
            );
        }
        set_namedtuplestore_size_estimates(arg_root, arg_rel)
    })
}
pub unsafe fn set_result_size_estimates(arg_root: *mut PlannerInfo, arg_rel: *mut RelOptInfo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn set_result_size_estimates(arg_root: *mut PlannerInfo, arg_rel: *mut RelOptInfo);
        }
        set_result_size_estimates(arg_root, arg_rel)
    })
}
pub unsafe fn set_foreign_size_estimates(arg_root: *mut PlannerInfo, arg_rel: *mut RelOptInfo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn set_foreign_size_estimates(arg_root: *mut PlannerInfo, arg_rel: *mut RelOptInfo);
        }
        set_foreign_size_estimates(arg_root, arg_rel)
    })
}
pub unsafe fn set_pathtarget_cost_width(
    arg_root: *mut PlannerInfo,
    arg_target: *mut PathTarget,
) -> *mut PathTarget {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn set_pathtarget_cost_width(
                arg_root: *mut PlannerInfo,
                arg_target: *mut PathTarget,
            ) -> *mut PathTarget;
        }
        set_pathtarget_cost_width(arg_root, arg_target)
    })
}
pub unsafe fn compute_bitmap_pages(
    arg_root: *mut PlannerInfo,
    arg_baserel: *mut RelOptInfo,
    arg_bitmapqual: *mut Path,
    arg_loop_count: ::std::os::raw::c_int,
    arg_cost: *mut Cost,
    arg_tuple: *mut f64,
) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn compute_bitmap_pages(
                arg_root: *mut PlannerInfo,
                arg_baserel: *mut RelOptInfo,
                arg_bitmapqual: *mut Path,
                arg_loop_count: ::std::os::raw::c_int,
                arg_cost: *mut Cost,
                arg_tuple: *mut f64,
            ) -> f64;
        }
        compute_bitmap_pages(
            arg_root,
            arg_baserel,
            arg_bitmapqual,
            arg_loop_count,
            arg_cost,
            arg_tuple,
        )
    })
}
pub unsafe fn clause_selectivity(
    arg_root: *mut PlannerInfo,
    arg_clause: *mut Node,
    arg_varRelid: ::std::os::raw::c_int,
    arg_jointype: JoinType,
    arg_sjinfo: *mut SpecialJoinInfo,
) -> Selectivity {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn clause_selectivity(
                arg_root: *mut PlannerInfo,
                arg_clause: *mut Node,
                arg_varRelid: ::std::os::raw::c_int,
                arg_jointype: JoinType,
                arg_sjinfo: *mut SpecialJoinInfo,
            ) -> Selectivity;
        }
        clause_selectivity(arg_root, arg_clause, arg_varRelid, arg_jointype, arg_sjinfo)
    })
}
pub unsafe fn clauselist_selectivity_simple(
    arg_root: *mut PlannerInfo,
    arg_clauses: *mut List,
    arg_varRelid: ::std::os::raw::c_int,
    arg_jointype: JoinType,
    arg_sjinfo: *mut SpecialJoinInfo,
    arg_estimatedclauses: *mut Bitmapset,
) -> Selectivity {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn clauselist_selectivity_simple(
                arg_root: *mut PlannerInfo,
                arg_clauses: *mut List,
                arg_varRelid: ::std::os::raw::c_int,
                arg_jointype: JoinType,
                arg_sjinfo: *mut SpecialJoinInfo,
                arg_estimatedclauses: *mut Bitmapset,
            ) -> Selectivity;
        }
        clauselist_selectivity_simple(
            arg_root,
            arg_clauses,
            arg_varRelid,
            arg_jointype,
            arg_sjinfo,
            arg_estimatedclauses,
        )
    })
}
pub unsafe fn clauselist_selectivity(
    arg_root: *mut PlannerInfo,
    arg_clauses: *mut List,
    arg_varRelid: ::std::os::raw::c_int,
    arg_jointype: JoinType,
    arg_sjinfo: *mut SpecialJoinInfo,
) -> Selectivity {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn clauselist_selectivity(
                arg_root: *mut PlannerInfo,
                arg_clauses: *mut List,
                arg_varRelid: ::std::os::raw::c_int,
                arg_jointype: JoinType,
                arg_sjinfo: *mut SpecialJoinInfo,
            ) -> Selectivity;
        }
        clauselist_selectivity(arg_root, arg_clauses, arg_varRelid, arg_jointype, arg_sjinfo)
    })
}
extern "C" {
    pub static mut seq_page_cost: f64;
}
extern "C" {
    pub static mut random_page_cost: f64;
}
extern "C" {
    pub static mut cpu_tuple_cost: f64;
}
extern "C" {
    pub static mut cpu_index_tuple_cost: f64;
}
extern "C" {
    pub static mut cpu_operator_cost: f64;
}
extern "C" {
    pub static mut parallel_tuple_cost: f64;
}
extern "C" {
    pub static mut parallel_setup_cost: f64;
}
extern "C" {
    pub static mut effective_cache_size: ::std::os::raw::c_int;
}
pub unsafe fn clamp_row_est(arg_nrows: f64) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn clamp_row_est(arg_nrows: f64) -> f64;
        }
        clamp_row_est(arg_nrows)
    })
}
pub unsafe fn is_pseudo_constant_for_index(
    arg_expr: *mut Node,
    arg_index: *mut IndexOptInfo,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn is_pseudo_constant_for_index(
                arg_expr: *mut Node,
                arg_index: *mut IndexOptInfo,
            ) -> bool;
        }
        is_pseudo_constant_for_index(arg_expr, arg_index)
    })
}
pub unsafe fn is_pseudo_constant_for_index_new(
    arg_root: *mut PlannerInfo,
    arg_expr: *mut Node,
    arg_index: *mut IndexOptInfo,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn is_pseudo_constant_for_index_new(
                arg_root: *mut PlannerInfo,
                arg_expr: *mut Node,
                arg_index: *mut IndexOptInfo,
            ) -> bool;
        }
        is_pseudo_constant_for_index_new(arg_root, arg_expr, arg_index)
    })
}
pub const ForceParallelMode_FORCE_PARALLEL_OFF: ForceParallelMode = 0;
pub const ForceParallelMode_FORCE_PARALLEL_ON: ForceParallelMode = 1;
pub const ForceParallelMode_FORCE_PARALLEL_REGRESS: ForceParallelMode = 2;
pub type ForceParallelMode = ::std::os::raw::c_uint;
extern "C" {
    pub static mut force_parallel_mode: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut parallel_leader_participation: bool;
}
pub unsafe fn planner(
    arg_parse: *mut Query,
    arg_query_string: *const ::std::os::raw::c_char,
    arg_cursorOptions: ::std::os::raw::c_int,
    arg_boundParams: *mut ParamListInfoData,
) -> *mut PlannedStmt {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn planner(
                arg_parse: *mut Query,
                arg_query_string: *const ::std::os::raw::c_char,
                arg_cursorOptions: ::std::os::raw::c_int,
                arg_boundParams: *mut ParamListInfoData,
            ) -> *mut PlannedStmt;
        }
        planner(arg_parse, arg_query_string, arg_cursorOptions, arg_boundParams)
    })
}
pub unsafe fn expression_planner(arg_expr: *mut Expr) -> *mut Expr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn expression_planner(arg_expr: *mut Expr) -> *mut Expr;
        }
        expression_planner(arg_expr)
    })
}
pub unsafe fn expression_planner_with_deps(
    arg_expr: *mut Expr,
    arg_relationOids: *mut *mut List,
    arg_invalItems: *mut *mut List,
) -> *mut Expr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn expression_planner_with_deps(
                arg_expr: *mut Expr,
                arg_relationOids: *mut *mut List,
                arg_invalItems: *mut *mut List,
            ) -> *mut Expr;
        }
        expression_planner_with_deps(arg_expr, arg_relationOids, arg_invalItems)
    })
}
pub unsafe fn plan_cluster_use_sort(arg_tableOid: Oid, arg_indexOid: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn plan_cluster_use_sort(arg_tableOid: Oid, arg_indexOid: Oid) -> bool;
        }
        plan_cluster_use_sort(arg_tableOid, arg_indexOid)
    })
}
pub unsafe fn plan_create_index_workers(
    arg_tableOid: Oid,
    arg_indexOid: Oid,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn plan_create_index_workers(
                arg_tableOid: Oid,
                arg_indexOid: Oid,
            ) -> ::std::os::raw::c_int;
        }
        plan_create_index_workers(arg_tableOid, arg_indexOid)
    })
}
pub unsafe fn extract_query_dependencies(
    arg_query: *mut Node,
    arg_relationOids: *mut *mut List,
    arg_invalItems: *mut *mut List,
    arg_hasRowSecurity: *mut bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn extract_query_dependencies(
                arg_query: *mut Node,
                arg_relationOids: *mut *mut List,
                arg_invalItems: *mut *mut List,
                arg_hasRowSecurity: *mut bool,
            );
        }
        extract_query_dependencies(arg_query, arg_relationOids, arg_invalItems, arg_hasRowSecurity)
    })
}
pub unsafe fn negate_clause(arg_node: *mut Node) -> *mut Node {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn negate_clause(arg_node: *mut Node) -> *mut Node;
        }
        negate_clause(arg_node)
    })
}
pub unsafe fn canonicalize_qual(arg_qual: *mut Expr, arg_is_check: bool) -> *mut Expr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn canonicalize_qual(arg_qual: *mut Expr, arg_is_check: bool) -> *mut Expr;
        }
        canonicalize_qual(arg_qual, arg_is_check)
    })
}
pub unsafe fn contain_mutable_functions(arg_clause: *mut Node) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn contain_mutable_functions(arg_clause: *mut Node) -> bool;
        }
        contain_mutable_functions(arg_clause)
    })
}
pub unsafe fn contain_volatile_functions(arg_clause: *mut Node) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn contain_volatile_functions(arg_clause: *mut Node) -> bool;
        }
        contain_volatile_functions(arg_clause)
    })
}
pub unsafe fn contain_volatile_functions_not_nextval(arg_clause: *mut Node) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn contain_volatile_functions_not_nextval(arg_clause: *mut Node) -> bool;
        }
        contain_volatile_functions_not_nextval(arg_clause)
    })
}
pub unsafe fn eval_const_expressions(arg_root: *mut PlannerInfo, arg_node: *mut Node) -> *mut Node {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn eval_const_expressions(arg_root: *mut PlannerInfo, arg_node: *mut Node)
                -> *mut Node;
        }
        eval_const_expressions(arg_root, arg_node)
    })
}
pub unsafe fn estimate_expression_value(
    arg_root: *mut PlannerInfo,
    arg_node: *mut Node,
) -> *mut Node {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn estimate_expression_value(
                arg_root: *mut PlannerInfo,
                arg_node: *mut Node,
            ) -> *mut Node;
        }
        estimate_expression_value(arg_root, arg_node)
    })
}
pub unsafe fn evaluate_expr(
    arg_expr: *mut Expr,
    arg_result_type: Oid,
    arg_result_typmod: int32,
    arg_result_collation: Oid,
) -> *mut Expr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn evaluate_expr(
                arg_expr: *mut Expr,
                arg_result_type: Oid,
                arg_result_typmod: int32,
                arg_result_collation: Oid,
            ) -> *mut Expr;
        }
        evaluate_expr(arg_expr, arg_result_type, arg_result_typmod, arg_result_collation)
    })
}
pub unsafe fn expand_function_arguments(
    arg_args: *mut List,
    arg_result_type: Oid,
    arg_func_tuple: *mut HeapTupleData,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn expand_function_arguments(
                arg_args: *mut List,
                arg_result_type: Oid,
                arg_func_tuple: *mut HeapTupleData,
            ) -> *mut List;
        }
        expand_function_arguments(arg_args, arg_result_type, arg_func_tuple)
    })
}
pub unsafe fn predicate_implied_by(
    arg_predicate_list: *mut List,
    arg_clause_list: *mut List,
    arg_weak: bool,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn predicate_implied_by(
                arg_predicate_list: *mut List,
                arg_clause_list: *mut List,
                arg_weak: bool,
            ) -> bool;
        }
        predicate_implied_by(arg_predicate_list, arg_clause_list, arg_weak)
    })
}
pub unsafe fn predicate_refuted_by(
    arg_predicate_list: *mut List,
    arg_clause_list: *mut List,
    arg_weak: bool,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn predicate_refuted_by(
                arg_predicate_list: *mut List,
                arg_clause_list: *mut List,
                arg_weak: bool,
            ) -> bool;
        }
        predicate_refuted_by(arg_predicate_list, arg_clause_list, arg_weak)
    })
}
pub unsafe fn count_nonjunk_tlist_entries(arg_tlist: *mut List) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn count_nonjunk_tlist_entries(arg_tlist: *mut List) -> ::std::os::raw::c_int;
        }
        count_nonjunk_tlist_entries(arg_tlist)
    })
}
pub unsafe fn get_sortgroupref_tle(
    arg_sortref: Index,
    arg_targetList: *mut List,
) -> *mut TargetEntry {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_sortgroupref_tle(
                arg_sortref: Index,
                arg_targetList: *mut List,
            ) -> *mut TargetEntry;
        }
        get_sortgroupref_tle(arg_sortref, arg_targetList)
    })
}
pub unsafe fn get_sortgroupclause_tle(
    arg_sgClause: *mut SortGroupClause,
    arg_targetList: *mut List,
) -> *mut TargetEntry {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_sortgroupclause_tle(
                arg_sgClause: *mut SortGroupClause,
                arg_targetList: *mut List,
            ) -> *mut TargetEntry;
        }
        get_sortgroupclause_tle(arg_sgClause, arg_targetList)
    })
}
pub unsafe fn get_sortgroupclause_expr(
    arg_sgClause: *mut SortGroupClause,
    arg_targetList: *mut List,
) -> *mut Node {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_sortgroupclause_expr(
                arg_sgClause: *mut SortGroupClause,
                arg_targetList: *mut List,
            ) -> *mut Node;
        }
        get_sortgroupclause_expr(arg_sgClause, arg_targetList)
    })
}
pub unsafe fn get_sortgrouplist_exprs(
    arg_sgClauses: *mut List,
    arg_targetList: *mut List,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_sortgrouplist_exprs(
                arg_sgClauses: *mut List,
                arg_targetList: *mut List,
            ) -> *mut List;
        }
        get_sortgrouplist_exprs(arg_sgClauses, arg_targetList)
    })
}
pub unsafe fn get_sortgroupref_clause(
    arg_sortref: Index,
    arg_clauses: *mut List,
) -> *mut SortGroupClause {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_sortgroupref_clause(
                arg_sortref: Index,
                arg_clauses: *mut List,
            ) -> *mut SortGroupClause;
        }
        get_sortgroupref_clause(arg_sortref, arg_clauses)
    })
}
pub unsafe fn get_sortgroupref_clause_noerr(
    arg_sortref: Index,
    arg_clauses: *mut List,
) -> *mut SortGroupClause {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_sortgroupref_clause_noerr(
                arg_sortref: Index,
                arg_clauses: *mut List,
            ) -> *mut SortGroupClause;
        }
        get_sortgroupref_clause_noerr(arg_sortref, arg_clauses)
    })
}
pub unsafe fn pull_varnos(arg_node: *mut Node) -> *mut Bitmapset {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pull_varnos(arg_node: *mut Node) -> *mut Bitmapset;
        }
        pull_varnos(arg_node)
    })
}
pub unsafe fn pull_varnos_of_level(
    arg_node: *mut Node,
    arg_levelsup: ::std::os::raw::c_int,
) -> *mut Bitmapset {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pull_varnos_of_level(
                arg_node: *mut Node,
                arg_levelsup: ::std::os::raw::c_int,
            ) -> *mut Bitmapset;
        }
        pull_varnos_of_level(arg_node, arg_levelsup)
    })
}
pub unsafe fn pull_varnos_new(arg_root: *mut PlannerInfo, arg_node: *mut Node) -> *mut Bitmapset {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pull_varnos_new(arg_root: *mut PlannerInfo, arg_node: *mut Node) -> *mut Bitmapset;
        }
        pull_varnos_new(arg_root, arg_node)
    })
}
pub unsafe fn pull_varnos_of_level_new(
    arg_root: *mut PlannerInfo,
    arg_node: *mut Node,
    arg_levelsup: ::std::os::raw::c_int,
) -> *mut Bitmapset {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pull_varnos_of_level_new(
                arg_root: *mut PlannerInfo,
                arg_node: *mut Node,
                arg_levelsup: ::std::os::raw::c_int,
            ) -> *mut Bitmapset;
        }
        pull_varnos_of_level_new(arg_root, arg_node, arg_levelsup)
    })
}
pub unsafe fn pull_varattnos(
    arg_node: *mut Node,
    arg_varno: Index,
    arg_varattnos: *mut *mut Bitmapset,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pull_varattnos(
                arg_node: *mut Node,
                arg_varno: Index,
                arg_varattnos: *mut *mut Bitmapset,
            );
        }
        pull_varattnos(arg_node, arg_varno, arg_varattnos)
    })
}
pub unsafe fn pull_vars_of_level(
    arg_node: *mut Node,
    arg_levelsup: ::std::os::raw::c_int,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pull_vars_of_level(
                arg_node: *mut Node,
                arg_levelsup: ::std::os::raw::c_int,
            ) -> *mut List;
        }
        pull_vars_of_level(arg_node, arg_levelsup)
    })
}
pub unsafe fn contain_var_clause(arg_node: *mut Node) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn contain_var_clause(arg_node: *mut Node) -> bool;
        }
        contain_var_clause(arg_node)
    })
}
pub unsafe fn contain_vars_of_level(
    arg_node: *mut Node,
    arg_levelsup: ::std::os::raw::c_int,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn contain_vars_of_level(
                arg_node: *mut Node,
                arg_levelsup: ::std::os::raw::c_int,
            ) -> bool;
        }
        contain_vars_of_level(arg_node, arg_levelsup)
    })
}
pub unsafe fn locate_var_of_level(
    arg_node: *mut Node,
    arg_levelsup: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn locate_var_of_level(
                arg_node: *mut Node,
                arg_levelsup: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        locate_var_of_level(arg_node, arg_levelsup)
    })
}
pub unsafe fn pull_var_clause(arg_node: *mut Node, arg_flags: ::std::os::raw::c_int) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pull_var_clause(arg_node: *mut Node, arg_flags: ::std::os::raw::c_int) -> *mut List;
        }
        pull_var_clause(arg_node, arg_flags)
    })
}
pub unsafe fn flatten_join_alias_vars(arg_query: *mut Query, arg_node: *mut Node) -> *mut Node {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn flatten_join_alias_vars(arg_query: *mut Query, arg_node: *mut Node) -> *mut Node;
        }
        flatten_join_alias_vars(arg_query, arg_node)
    })
}
pub unsafe fn compare_path_costs(
    arg_path1: *mut Path,
    arg_path2: *mut Path,
    arg_criterion: CostSelector,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn compare_path_costs(
                arg_path1: *mut Path,
                arg_path2: *mut Path,
                arg_criterion: CostSelector,
            ) -> ::std::os::raw::c_int;
        }
        compare_path_costs(arg_path1, arg_path2, arg_criterion)
    })
}
pub unsafe fn compare_fractional_path_costs(
    arg_path1: *mut Path,
    arg_path2: *mut Path,
    arg_fraction: f64,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn compare_fractional_path_costs(
                arg_path1: *mut Path,
                arg_path2: *mut Path,
                arg_fraction: f64,
            ) -> ::std::os::raw::c_int;
        }
        compare_fractional_path_costs(arg_path1, arg_path2, arg_fraction)
    })
}
pub unsafe fn set_cheapest(arg_parent_rel: *mut RelOptInfo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn set_cheapest(arg_parent_rel: *mut RelOptInfo);
        }
        set_cheapest(arg_parent_rel)
    })
}
pub unsafe fn add_path(arg_parent_rel: *mut RelOptInfo, arg_new_path: *mut Path) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn add_path(arg_parent_rel: *mut RelOptInfo, arg_new_path: *mut Path);
        }
        add_path(arg_parent_rel, arg_new_path)
    })
}
pub unsafe fn add_path_precheck(
    arg_parent_rel: *mut RelOptInfo,
    arg_startup_cost: Cost,
    arg_total_cost: Cost,
    arg_pathkeys: *mut List,
    arg_required_outer: Relids,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn add_path_precheck(
                arg_parent_rel: *mut RelOptInfo,
                arg_startup_cost: Cost,
                arg_total_cost: Cost,
                arg_pathkeys: *mut List,
                arg_required_outer: Relids,
            ) -> bool;
        }
        add_path_precheck(
            arg_parent_rel,
            arg_startup_cost,
            arg_total_cost,
            arg_pathkeys,
            arg_required_outer,
        )
    })
}
pub unsafe fn add_partial_path(arg_parent_rel: *mut RelOptInfo, arg_new_path: *mut Path) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn add_partial_path(arg_parent_rel: *mut RelOptInfo, arg_new_path: *mut Path);
        }
        add_partial_path(arg_parent_rel, arg_new_path)
    })
}
pub unsafe fn add_partial_path_precheck(
    arg_parent_rel: *mut RelOptInfo,
    arg_total_cost: Cost,
    arg_pathkeys: *mut List,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn add_partial_path_precheck(
                arg_parent_rel: *mut RelOptInfo,
                arg_total_cost: Cost,
                arg_pathkeys: *mut List,
            ) -> bool;
        }
        add_partial_path_precheck(arg_parent_rel, arg_total_cost, arg_pathkeys)
    })
}
pub unsafe fn create_seqscan_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_required_outer: Relids,
    arg_parallel_workers: ::std::os::raw::c_int,
) -> *mut Path {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_seqscan_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_required_outer: Relids,
                arg_parallel_workers: ::std::os::raw::c_int,
            ) -> *mut Path;
        }
        create_seqscan_path(arg_root, arg_rel, arg_required_outer, arg_parallel_workers)
    })
}
pub unsafe fn create_samplescan_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_required_outer: Relids,
) -> *mut Path {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_samplescan_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_required_outer: Relids,
            ) -> *mut Path;
        }
        create_samplescan_path(arg_root, arg_rel, arg_required_outer)
    })
}
pub unsafe fn create_index_path(
    arg_root: *mut PlannerInfo,
    arg_index: *mut IndexOptInfo,
    arg_indexclauses: *mut List,
    arg_indexorderbys: *mut List,
    arg_indexorderbycols: *mut List,
    arg_pathkeys: *mut List,
    arg_indexscandir: ScanDirection,
    arg_indexonly: bool,
    arg_required_outer: Relids,
    arg_loop_count: f64,
    arg_partial_path: bool,
) -> *mut IndexPath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_index_path(
                arg_root: *mut PlannerInfo,
                arg_index: *mut IndexOptInfo,
                arg_indexclauses: *mut List,
                arg_indexorderbys: *mut List,
                arg_indexorderbycols: *mut List,
                arg_pathkeys: *mut List,
                arg_indexscandir: ScanDirection,
                arg_indexonly: bool,
                arg_required_outer: Relids,
                arg_loop_count: f64,
                arg_partial_path: bool,
            ) -> *mut IndexPath;
        }
        create_index_path(
            arg_root,
            arg_index,
            arg_indexclauses,
            arg_indexorderbys,
            arg_indexorderbycols,
            arg_pathkeys,
            arg_indexscandir,
            arg_indexonly,
            arg_required_outer,
            arg_loop_count,
            arg_partial_path,
        )
    })
}
pub unsafe fn create_bitmap_heap_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_bitmapqual: *mut Path,
    arg_required_outer: Relids,
    arg_loop_count: f64,
    arg_parallel_degree: ::std::os::raw::c_int,
) -> *mut BitmapHeapPath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_bitmap_heap_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_bitmapqual: *mut Path,
                arg_required_outer: Relids,
                arg_loop_count: f64,
                arg_parallel_degree: ::std::os::raw::c_int,
            ) -> *mut BitmapHeapPath;
        }
        create_bitmap_heap_path(
            arg_root,
            arg_rel,
            arg_bitmapqual,
            arg_required_outer,
            arg_loop_count,
            arg_parallel_degree,
        )
    })
}
pub unsafe fn create_bitmap_and_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_bitmapquals: *mut List,
) -> *mut BitmapAndPath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_bitmap_and_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_bitmapquals: *mut List,
            ) -> *mut BitmapAndPath;
        }
        create_bitmap_and_path(arg_root, arg_rel, arg_bitmapquals)
    })
}
pub unsafe fn create_bitmap_or_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_bitmapquals: *mut List,
) -> *mut BitmapOrPath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_bitmap_or_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_bitmapquals: *mut List,
            ) -> *mut BitmapOrPath;
        }
        create_bitmap_or_path(arg_root, arg_rel, arg_bitmapquals)
    })
}
pub unsafe fn create_tidscan_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_tidquals: *mut List,
    arg_required_outer: Relids,
) -> *mut TidPath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_tidscan_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_tidquals: *mut List,
                arg_required_outer: Relids,
            ) -> *mut TidPath;
        }
        create_tidscan_path(arg_root, arg_rel, arg_tidquals, arg_required_outer)
    })
}
pub unsafe fn create_append_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_subpaths: *mut List,
    arg_partial_subpaths: *mut List,
    arg_pathkeys: *mut List,
    arg_required_outer: Relids,
    arg_parallel_workers: ::std::os::raw::c_int,
    arg_parallel_aware: bool,
    arg_partitioned_rels: *mut List,
    arg_rows: f64,
) -> *mut AppendPath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_append_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_subpaths: *mut List,
                arg_partial_subpaths: *mut List,
                arg_pathkeys: *mut List,
                arg_required_outer: Relids,
                arg_parallel_workers: ::std::os::raw::c_int,
                arg_parallel_aware: bool,
                arg_partitioned_rels: *mut List,
                arg_rows: f64,
            ) -> *mut AppendPath;
        }
        create_append_path(
            arg_root,
            arg_rel,
            arg_subpaths,
            arg_partial_subpaths,
            arg_pathkeys,
            arg_required_outer,
            arg_parallel_workers,
            arg_parallel_aware,
            arg_partitioned_rels,
            arg_rows,
        )
    })
}
pub unsafe fn create_merge_append_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_subpaths: *mut List,
    arg_pathkeys: *mut List,
    arg_required_outer: Relids,
    arg_partitioned_rels: *mut List,
) -> *mut MergeAppendPath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_merge_append_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_subpaths: *mut List,
                arg_pathkeys: *mut List,
                arg_required_outer: Relids,
                arg_partitioned_rels: *mut List,
            ) -> *mut MergeAppendPath;
        }
        create_merge_append_path(
            arg_root,
            arg_rel,
            arg_subpaths,
            arg_pathkeys,
            arg_required_outer,
            arg_partitioned_rels,
        )
    })
}
pub unsafe fn create_group_result_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_target: *mut PathTarget,
    arg_havingqual: *mut List,
) -> *mut GroupResultPath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_group_result_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_target: *mut PathTarget,
                arg_havingqual: *mut List,
            ) -> *mut GroupResultPath;
        }
        create_group_result_path(arg_root, arg_rel, arg_target, arg_havingqual)
    })
}
pub unsafe fn create_material_path(
    arg_rel: *mut RelOptInfo,
    arg_subpath: *mut Path,
) -> *mut MaterialPath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_material_path(
                arg_rel: *mut RelOptInfo,
                arg_subpath: *mut Path,
            ) -> *mut MaterialPath;
        }
        create_material_path(arg_rel, arg_subpath)
    })
}
pub unsafe fn create_unique_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_subpath: *mut Path,
    arg_sjinfo: *mut SpecialJoinInfo,
) -> *mut UniquePath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_unique_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_subpath: *mut Path,
                arg_sjinfo: *mut SpecialJoinInfo,
            ) -> *mut UniquePath;
        }
        create_unique_path(arg_root, arg_rel, arg_subpath, arg_sjinfo)
    })
}
pub unsafe fn create_gather_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_subpath: *mut Path,
    arg_target: *mut PathTarget,
    arg_required_outer: Relids,
    arg_rows: *mut f64,
) -> *mut GatherPath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_gather_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_subpath: *mut Path,
                arg_target: *mut PathTarget,
                arg_required_outer: Relids,
                arg_rows: *mut f64,
            ) -> *mut GatherPath;
        }
        create_gather_path(arg_root, arg_rel, arg_subpath, arg_target, arg_required_outer, arg_rows)
    })
}
pub unsafe fn create_gather_merge_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_subpath: *mut Path,
    arg_target: *mut PathTarget,
    arg_pathkeys: *mut List,
    arg_required_outer: Relids,
    arg_rows: *mut f64,
) -> *mut GatherMergePath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_gather_merge_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_subpath: *mut Path,
                arg_target: *mut PathTarget,
                arg_pathkeys: *mut List,
                arg_required_outer: Relids,
                arg_rows: *mut f64,
            ) -> *mut GatherMergePath;
        }
        create_gather_merge_path(
            arg_root,
            arg_rel,
            arg_subpath,
            arg_target,
            arg_pathkeys,
            arg_required_outer,
            arg_rows,
        )
    })
}
pub unsafe fn create_subqueryscan_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_subpath: *mut Path,
    arg_pathkeys: *mut List,
    arg_required_outer: Relids,
) -> *mut SubqueryScanPath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_subqueryscan_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_subpath: *mut Path,
                arg_pathkeys: *mut List,
                arg_required_outer: Relids,
            ) -> *mut SubqueryScanPath;
        }
        create_subqueryscan_path(arg_root, arg_rel, arg_subpath, arg_pathkeys, arg_required_outer)
    })
}
pub unsafe fn create_functionscan_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_pathkeys: *mut List,
    arg_required_outer: Relids,
) -> *mut Path {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_functionscan_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_pathkeys: *mut List,
                arg_required_outer: Relids,
            ) -> *mut Path;
        }
        create_functionscan_path(arg_root, arg_rel, arg_pathkeys, arg_required_outer)
    })
}
pub unsafe fn create_valuesscan_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_required_outer: Relids,
) -> *mut Path {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_valuesscan_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_required_outer: Relids,
            ) -> *mut Path;
        }
        create_valuesscan_path(arg_root, arg_rel, arg_required_outer)
    })
}
pub unsafe fn create_tablefuncscan_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_required_outer: Relids,
) -> *mut Path {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_tablefuncscan_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_required_outer: Relids,
            ) -> *mut Path;
        }
        create_tablefuncscan_path(arg_root, arg_rel, arg_required_outer)
    })
}
pub unsafe fn create_ctescan_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_required_outer: Relids,
) -> *mut Path {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_ctescan_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_required_outer: Relids,
            ) -> *mut Path;
        }
        create_ctescan_path(arg_root, arg_rel, arg_required_outer)
    })
}
pub unsafe fn create_namedtuplestorescan_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_required_outer: Relids,
) -> *mut Path {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_namedtuplestorescan_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_required_outer: Relids,
            ) -> *mut Path;
        }
        create_namedtuplestorescan_path(arg_root, arg_rel, arg_required_outer)
    })
}
pub unsafe fn create_resultscan_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_required_outer: Relids,
) -> *mut Path {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_resultscan_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_required_outer: Relids,
            ) -> *mut Path;
        }
        create_resultscan_path(arg_root, arg_rel, arg_required_outer)
    })
}
pub unsafe fn create_worktablescan_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_required_outer: Relids,
) -> *mut Path {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_worktablescan_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_required_outer: Relids,
            ) -> *mut Path;
        }
        create_worktablescan_path(arg_root, arg_rel, arg_required_outer)
    })
}
pub unsafe fn create_foreignscan_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_target: *mut PathTarget,
    arg_rows: f64,
    arg_startup_cost: Cost,
    arg_total_cost: Cost,
    arg_pathkeys: *mut List,
    arg_required_outer: Relids,
    arg_fdw_outerpath: *mut Path,
    arg_fdw_private: *mut List,
) -> *mut ForeignPath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_foreignscan_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_target: *mut PathTarget,
                arg_rows: f64,
                arg_startup_cost: Cost,
                arg_total_cost: Cost,
                arg_pathkeys: *mut List,
                arg_required_outer: Relids,
                arg_fdw_outerpath: *mut Path,
                arg_fdw_private: *mut List,
            ) -> *mut ForeignPath;
        }
        create_foreignscan_path(
            arg_root,
            arg_rel,
            arg_target,
            arg_rows,
            arg_startup_cost,
            arg_total_cost,
            arg_pathkeys,
            arg_required_outer,
            arg_fdw_outerpath,
            arg_fdw_private,
        )
    })
}
pub unsafe fn create_foreign_join_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_target: *mut PathTarget,
    arg_rows: f64,
    arg_startup_cost: Cost,
    arg_total_cost: Cost,
    arg_pathkeys: *mut List,
    arg_required_outer: Relids,
    arg_fdw_outerpath: *mut Path,
    arg_fdw_private: *mut List,
) -> *mut ForeignPath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_foreign_join_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_target: *mut PathTarget,
                arg_rows: f64,
                arg_startup_cost: Cost,
                arg_total_cost: Cost,
                arg_pathkeys: *mut List,
                arg_required_outer: Relids,
                arg_fdw_outerpath: *mut Path,
                arg_fdw_private: *mut List,
            ) -> *mut ForeignPath;
        }
        create_foreign_join_path(
            arg_root,
            arg_rel,
            arg_target,
            arg_rows,
            arg_startup_cost,
            arg_total_cost,
            arg_pathkeys,
            arg_required_outer,
            arg_fdw_outerpath,
            arg_fdw_private,
        )
    })
}
pub unsafe fn create_foreign_upper_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_target: *mut PathTarget,
    arg_rows: f64,
    arg_startup_cost: Cost,
    arg_total_cost: Cost,
    arg_pathkeys: *mut List,
    arg_fdw_outerpath: *mut Path,
    arg_fdw_private: *mut List,
) -> *mut ForeignPath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_foreign_upper_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_target: *mut PathTarget,
                arg_rows: f64,
                arg_startup_cost: Cost,
                arg_total_cost: Cost,
                arg_pathkeys: *mut List,
                arg_fdw_outerpath: *mut Path,
                arg_fdw_private: *mut List,
            ) -> *mut ForeignPath;
        }
        create_foreign_upper_path(
            arg_root,
            arg_rel,
            arg_target,
            arg_rows,
            arg_startup_cost,
            arg_total_cost,
            arg_pathkeys,
            arg_fdw_outerpath,
            arg_fdw_private,
        )
    })
}
pub unsafe fn calc_nestloop_required_outer(
    arg_outerrelids: Relids,
    arg_outer_paramrels: Relids,
    arg_innerrelids: Relids,
    arg_inner_paramrels: Relids,
) -> Relids {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn calc_nestloop_required_outer(
                arg_outerrelids: Relids,
                arg_outer_paramrels: Relids,
                arg_innerrelids: Relids,
                arg_inner_paramrels: Relids,
            ) -> Relids;
        }
        calc_nestloop_required_outer(
            arg_outerrelids,
            arg_outer_paramrels,
            arg_innerrelids,
            arg_inner_paramrels,
        )
    })
}
pub unsafe fn calc_non_nestloop_required_outer(
    arg_outer_path: *mut Path,
    arg_inner_path: *mut Path,
) -> Relids {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn calc_non_nestloop_required_outer(
                arg_outer_path: *mut Path,
                arg_inner_path: *mut Path,
            ) -> Relids;
        }
        calc_non_nestloop_required_outer(arg_outer_path, arg_inner_path)
    })
}
pub unsafe fn create_nestloop_path(
    arg_root: *mut PlannerInfo,
    arg_joinrel: *mut RelOptInfo,
    arg_jointype: JoinType,
    arg_workspace: *mut JoinCostWorkspace,
    arg_extra: *mut JoinPathExtraData,
    arg_outer_path: *mut Path,
    arg_inner_path: *mut Path,
    arg_restrict_clauses: *mut List,
    arg_pathkeys: *mut List,
    arg_required_outer: Relids,
) -> *mut NestPath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_nestloop_path(
                arg_root: *mut PlannerInfo,
                arg_joinrel: *mut RelOptInfo,
                arg_jointype: JoinType,
                arg_workspace: *mut JoinCostWorkspace,
                arg_extra: *mut JoinPathExtraData,
                arg_outer_path: *mut Path,
                arg_inner_path: *mut Path,
                arg_restrict_clauses: *mut List,
                arg_pathkeys: *mut List,
                arg_required_outer: Relids,
            ) -> *mut NestPath;
        }
        create_nestloop_path(
            arg_root,
            arg_joinrel,
            arg_jointype,
            arg_workspace,
            arg_extra,
            arg_outer_path,
            arg_inner_path,
            arg_restrict_clauses,
            arg_pathkeys,
            arg_required_outer,
        )
    })
}
pub unsafe fn create_mergejoin_path(
    arg_root: *mut PlannerInfo,
    arg_joinrel: *mut RelOptInfo,
    arg_jointype: JoinType,
    arg_workspace: *mut JoinCostWorkspace,
    arg_extra: *mut JoinPathExtraData,
    arg_outer_path: *mut Path,
    arg_inner_path: *mut Path,
    arg_restrict_clauses: *mut List,
    arg_pathkeys: *mut List,
    arg_required_outer: Relids,
    arg_mergeclauses: *mut List,
    arg_outersortkeys: *mut List,
    arg_innersortkeys: *mut List,
) -> *mut MergePath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_mergejoin_path(
                arg_root: *mut PlannerInfo,
                arg_joinrel: *mut RelOptInfo,
                arg_jointype: JoinType,
                arg_workspace: *mut JoinCostWorkspace,
                arg_extra: *mut JoinPathExtraData,
                arg_outer_path: *mut Path,
                arg_inner_path: *mut Path,
                arg_restrict_clauses: *mut List,
                arg_pathkeys: *mut List,
                arg_required_outer: Relids,
                arg_mergeclauses: *mut List,
                arg_outersortkeys: *mut List,
                arg_innersortkeys: *mut List,
            ) -> *mut MergePath;
        }
        create_mergejoin_path(
            arg_root,
            arg_joinrel,
            arg_jointype,
            arg_workspace,
            arg_extra,
            arg_outer_path,
            arg_inner_path,
            arg_restrict_clauses,
            arg_pathkeys,
            arg_required_outer,
            arg_mergeclauses,
            arg_outersortkeys,
            arg_innersortkeys,
        )
    })
}
pub unsafe fn create_hashjoin_path(
    arg_root: *mut PlannerInfo,
    arg_joinrel: *mut RelOptInfo,
    arg_jointype: JoinType,
    arg_workspace: *mut JoinCostWorkspace,
    arg_extra: *mut JoinPathExtraData,
    arg_outer_path: *mut Path,
    arg_inner_path: *mut Path,
    arg_parallel_hash: bool,
    arg_restrict_clauses: *mut List,
    arg_required_outer: Relids,
    arg_hashclauses: *mut List,
) -> *mut HashPath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_hashjoin_path(
                arg_root: *mut PlannerInfo,
                arg_joinrel: *mut RelOptInfo,
                arg_jointype: JoinType,
                arg_workspace: *mut JoinCostWorkspace,
                arg_extra: *mut JoinPathExtraData,
                arg_outer_path: *mut Path,
                arg_inner_path: *mut Path,
                arg_parallel_hash: bool,
                arg_restrict_clauses: *mut List,
                arg_required_outer: Relids,
                arg_hashclauses: *mut List,
            ) -> *mut HashPath;
        }
        create_hashjoin_path(
            arg_root,
            arg_joinrel,
            arg_jointype,
            arg_workspace,
            arg_extra,
            arg_outer_path,
            arg_inner_path,
            arg_parallel_hash,
            arg_restrict_clauses,
            arg_required_outer,
            arg_hashclauses,
        )
    })
}
pub unsafe fn create_projection_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_subpath: *mut Path,
    arg_target: *mut PathTarget,
) -> *mut ProjectionPath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_projection_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_subpath: *mut Path,
                arg_target: *mut PathTarget,
            ) -> *mut ProjectionPath;
        }
        create_projection_path(arg_root, arg_rel, arg_subpath, arg_target)
    })
}
pub unsafe fn apply_projection_to_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_path: *mut Path,
    arg_target: *mut PathTarget,
) -> *mut Path {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn apply_projection_to_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_path: *mut Path,
                arg_target: *mut PathTarget,
            ) -> *mut Path;
        }
        apply_projection_to_path(arg_root, arg_rel, arg_path, arg_target)
    })
}
pub unsafe fn create_set_projection_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_subpath: *mut Path,
    arg_target: *mut PathTarget,
) -> *mut ProjectSetPath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_set_projection_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_subpath: *mut Path,
                arg_target: *mut PathTarget,
            ) -> *mut ProjectSetPath;
        }
        create_set_projection_path(arg_root, arg_rel, arg_subpath, arg_target)
    })
}
pub unsafe fn create_sort_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_subpath: *mut Path,
    arg_pathkeys: *mut List,
    arg_limit_tuples: f64,
) -> *mut SortPath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_sort_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_subpath: *mut Path,
                arg_pathkeys: *mut List,
                arg_limit_tuples: f64,
            ) -> *mut SortPath;
        }
        create_sort_path(arg_root, arg_rel, arg_subpath, arg_pathkeys, arg_limit_tuples)
    })
}
pub unsafe fn create_incremental_sort_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_subpath: *mut Path,
    arg_pathkeys: *mut List,
    arg_presorted_keys: ::std::os::raw::c_int,
    arg_limit_tuples: f64,
) -> *mut IncrementalSortPath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_incremental_sort_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_subpath: *mut Path,
                arg_pathkeys: *mut List,
                arg_presorted_keys: ::std::os::raw::c_int,
                arg_limit_tuples: f64,
            ) -> *mut IncrementalSortPath;
        }
        create_incremental_sort_path(
            arg_root,
            arg_rel,
            arg_subpath,
            arg_pathkeys,
            arg_presorted_keys,
            arg_limit_tuples,
        )
    })
}
pub unsafe fn create_group_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_subpath: *mut Path,
    arg_groupClause: *mut List,
    arg_qual: *mut List,
    arg_numGroups: f64,
) -> *mut GroupPath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_group_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_subpath: *mut Path,
                arg_groupClause: *mut List,
                arg_qual: *mut List,
                arg_numGroups: f64,
            ) -> *mut GroupPath;
        }
        create_group_path(arg_root, arg_rel, arg_subpath, arg_groupClause, arg_qual, arg_numGroups)
    })
}
pub unsafe fn create_upper_unique_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_subpath: *mut Path,
    arg_numCols: ::std::os::raw::c_int,
    arg_numGroups: f64,
) -> *mut UpperUniquePath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_upper_unique_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_subpath: *mut Path,
                arg_numCols: ::std::os::raw::c_int,
                arg_numGroups: f64,
            ) -> *mut UpperUniquePath;
        }
        create_upper_unique_path(arg_root, arg_rel, arg_subpath, arg_numCols, arg_numGroups)
    })
}
pub unsafe fn create_agg_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_subpath: *mut Path,
    arg_target: *mut PathTarget,
    arg_aggstrategy: AggStrategy,
    arg_aggsplit: AggSplit,
    arg_groupClause: *mut List,
    arg_qual: *mut List,
    arg_aggcosts: *const AggClauseCosts,
    arg_numGroups: f64,
) -> *mut AggPath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_agg_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_subpath: *mut Path,
                arg_target: *mut PathTarget,
                arg_aggstrategy: AggStrategy,
                arg_aggsplit: AggSplit,
                arg_groupClause: *mut List,
                arg_qual: *mut List,
                arg_aggcosts: *const AggClauseCosts,
                arg_numGroups: f64,
            ) -> *mut AggPath;
        }
        create_agg_path(
            arg_root,
            arg_rel,
            arg_subpath,
            arg_target,
            arg_aggstrategy,
            arg_aggsplit,
            arg_groupClause,
            arg_qual,
            arg_aggcosts,
            arg_numGroups,
        )
    })
}
pub unsafe fn create_groupingsets_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_subpath: *mut Path,
    arg_having_qual: *mut List,
    arg_aggstrategy: AggStrategy,
    arg_rollups: *mut List,
    arg_agg_costs: *const AggClauseCosts,
    arg_numGroups: f64,
) -> *mut GroupingSetsPath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_groupingsets_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_subpath: *mut Path,
                arg_having_qual: *mut List,
                arg_aggstrategy: AggStrategy,
                arg_rollups: *mut List,
                arg_agg_costs: *const AggClauseCosts,
                arg_numGroups: f64,
            ) -> *mut GroupingSetsPath;
        }
        create_groupingsets_path(
            arg_root,
            arg_rel,
            arg_subpath,
            arg_having_qual,
            arg_aggstrategy,
            arg_rollups,
            arg_agg_costs,
            arg_numGroups,
        )
    })
}
pub unsafe fn create_minmaxagg_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_target: *mut PathTarget,
    arg_mmaggregates: *mut List,
    arg_quals: *mut List,
) -> *mut MinMaxAggPath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_minmaxagg_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_target: *mut PathTarget,
                arg_mmaggregates: *mut List,
                arg_quals: *mut List,
            ) -> *mut MinMaxAggPath;
        }
        create_minmaxagg_path(arg_root, arg_rel, arg_target, arg_mmaggregates, arg_quals)
    })
}
pub unsafe fn create_windowagg_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_subpath: *mut Path,
    arg_target: *mut PathTarget,
    arg_windowFuncs: *mut List,
    arg_winclause: *mut WindowClause,
) -> *mut WindowAggPath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_windowagg_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_subpath: *mut Path,
                arg_target: *mut PathTarget,
                arg_windowFuncs: *mut List,
                arg_winclause: *mut WindowClause,
            ) -> *mut WindowAggPath;
        }
        create_windowagg_path(
            arg_root,
            arg_rel,
            arg_subpath,
            arg_target,
            arg_windowFuncs,
            arg_winclause,
        )
    })
}
pub unsafe fn create_setop_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_subpath: *mut Path,
    arg_cmd: SetOpCmd,
    arg_strategy: SetOpStrategy,
    arg_distinctList: *mut List,
    arg_flagColIdx: AttrNumber,
    arg_firstFlag: ::std::os::raw::c_int,
    arg_numGroups: f64,
    arg_outputRows: f64,
) -> *mut SetOpPath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_setop_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_subpath: *mut Path,
                arg_cmd: SetOpCmd,
                arg_strategy: SetOpStrategy,
                arg_distinctList: *mut List,
                arg_flagColIdx: AttrNumber,
                arg_firstFlag: ::std::os::raw::c_int,
                arg_numGroups: f64,
                arg_outputRows: f64,
            ) -> *mut SetOpPath;
        }
        create_setop_path(
            arg_root,
            arg_rel,
            arg_subpath,
            arg_cmd,
            arg_strategy,
            arg_distinctList,
            arg_flagColIdx,
            arg_firstFlag,
            arg_numGroups,
            arg_outputRows,
        )
    })
}
pub unsafe fn create_recursiveunion_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_leftpath: *mut Path,
    arg_rightpath: *mut Path,
    arg_target: *mut PathTarget,
    arg_distinctList: *mut List,
    arg_wtParam: ::std::os::raw::c_int,
    arg_numGroups: f64,
) -> *mut RecursiveUnionPath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_recursiveunion_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_leftpath: *mut Path,
                arg_rightpath: *mut Path,
                arg_target: *mut PathTarget,
                arg_distinctList: *mut List,
                arg_wtParam: ::std::os::raw::c_int,
                arg_numGroups: f64,
            ) -> *mut RecursiveUnionPath;
        }
        create_recursiveunion_path(
            arg_root,
            arg_rel,
            arg_leftpath,
            arg_rightpath,
            arg_target,
            arg_distinctList,
            arg_wtParam,
            arg_numGroups,
        )
    })
}
pub unsafe fn create_lockrows_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_subpath: *mut Path,
    arg_rowMarks: *mut List,
    arg_epqParam: ::std::os::raw::c_int,
) -> *mut LockRowsPath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_lockrows_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_subpath: *mut Path,
                arg_rowMarks: *mut List,
                arg_epqParam: ::std::os::raw::c_int,
            ) -> *mut LockRowsPath;
        }
        create_lockrows_path(arg_root, arg_rel, arg_subpath, arg_rowMarks, arg_epqParam)
    })
}
pub unsafe fn create_modifytable_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_operation: CmdType,
    arg_canSetTag: bool,
    arg_nominalRelation: Index,
    arg_rootRelation: Index,
    arg_partColsUpdated: bool,
    arg_resultRelations: *mut List,
    arg_subpaths: *mut List,
    arg_subroots: *mut List,
    arg_withCheckOptionLists: *mut List,
    arg_returningLists: *mut List,
    arg_rowMarks: *mut List,
    arg_onconflict: *mut OnConflictExpr,
    arg_epqParam: ::std::os::raw::c_int,
) -> *mut ModifyTablePath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_modifytable_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_operation: CmdType,
                arg_canSetTag: bool,
                arg_nominalRelation: Index,
                arg_rootRelation: Index,
                arg_partColsUpdated: bool,
                arg_resultRelations: *mut List,
                arg_subpaths: *mut List,
                arg_subroots: *mut List,
                arg_withCheckOptionLists: *mut List,
                arg_returningLists: *mut List,
                arg_rowMarks: *mut List,
                arg_onconflict: *mut OnConflictExpr,
                arg_epqParam: ::std::os::raw::c_int,
            ) -> *mut ModifyTablePath;
        }
        create_modifytable_path(
            arg_root,
            arg_rel,
            arg_operation,
            arg_canSetTag,
            arg_nominalRelation,
            arg_rootRelation,
            arg_partColsUpdated,
            arg_resultRelations,
            arg_subpaths,
            arg_subroots,
            arg_withCheckOptionLists,
            arg_returningLists,
            arg_rowMarks,
            arg_onconflict,
            arg_epqParam,
        )
    })
}
pub unsafe fn create_limit_path(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_subpath: *mut Path,
    arg_limitOffset: *mut Node,
    arg_limitCount: *mut Node,
    arg_limitOption: LimitOption,
    arg_offset_est: int64,
    arg_count_est: int64,
) -> *mut LimitPath {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_limit_path(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_subpath: *mut Path,
                arg_limitOffset: *mut Node,
                arg_limitCount: *mut Node,
                arg_limitOption: LimitOption,
                arg_offset_est: int64,
                arg_count_est: int64,
            ) -> *mut LimitPath;
        }
        create_limit_path(
            arg_root,
            arg_rel,
            arg_subpath,
            arg_limitOffset,
            arg_limitCount,
            arg_limitOption,
            arg_offset_est,
            arg_count_est,
        )
    })
}
pub unsafe fn adjust_limit_rows_costs(
    arg_rows: *mut f64,
    arg_startup_cost: *mut Cost,
    arg_total_cost: *mut Cost,
    arg_offset_est: int64,
    arg_count_est: int64,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn adjust_limit_rows_costs(
                arg_rows: *mut f64,
                arg_startup_cost: *mut Cost,
                arg_total_cost: *mut Cost,
                arg_offset_est: int64,
                arg_count_est: int64,
            );
        }
        adjust_limit_rows_costs(
            arg_rows,
            arg_startup_cost,
            arg_total_cost,
            arg_offset_est,
            arg_count_est,
        )
    })
}
pub unsafe fn reparameterize_path(
    arg_root: *mut PlannerInfo,
    arg_path: *mut Path,
    arg_required_outer: Relids,
    arg_loop_count: f64,
) -> *mut Path {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn reparameterize_path(
                arg_root: *mut PlannerInfo,
                arg_path: *mut Path,
                arg_required_outer: Relids,
                arg_loop_count: f64,
            ) -> *mut Path;
        }
        reparameterize_path(arg_root, arg_path, arg_required_outer, arg_loop_count)
    })
}
pub unsafe fn reparameterize_path_by_child(
    arg_root: *mut PlannerInfo,
    arg_path: *mut Path,
    arg_child_rel: *mut RelOptInfo,
) -> *mut Path {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn reparameterize_path_by_child(
                arg_root: *mut PlannerInfo,
                arg_path: *mut Path,
                arg_child_rel: *mut RelOptInfo,
            ) -> *mut Path;
        }
        reparameterize_path_by_child(arg_root, arg_path, arg_child_rel)
    })
}
pub unsafe fn setup_simple_rel_arrays(arg_root: *mut PlannerInfo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn setup_simple_rel_arrays(arg_root: *mut PlannerInfo);
        }
        setup_simple_rel_arrays(arg_root)
    })
}
pub unsafe fn expand_planner_arrays(
    arg_root: *mut PlannerInfo,
    arg_add_size: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn expand_planner_arrays(
                arg_root: *mut PlannerInfo,
                arg_add_size: ::std::os::raw::c_int,
            );
        }
        expand_planner_arrays(arg_root, arg_add_size)
    })
}
pub unsafe fn build_simple_rel(
    arg_root: *mut PlannerInfo,
    arg_relid: ::std::os::raw::c_int,
    arg_parent: *mut RelOptInfo,
) -> *mut RelOptInfo {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn build_simple_rel(
                arg_root: *mut PlannerInfo,
                arg_relid: ::std::os::raw::c_int,
                arg_parent: *mut RelOptInfo,
            ) -> *mut RelOptInfo;
        }
        build_simple_rel(arg_root, arg_relid, arg_parent)
    })
}
pub unsafe fn find_base_rel(
    arg_root: *mut PlannerInfo,
    arg_relid: ::std::os::raw::c_int,
) -> *mut RelOptInfo {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn find_base_rel(
                arg_root: *mut PlannerInfo,
                arg_relid: ::std::os::raw::c_int,
            ) -> *mut RelOptInfo;
        }
        find_base_rel(arg_root, arg_relid)
    })
}
pub unsafe fn find_join_rel(arg_root: *mut PlannerInfo, arg_relids: Relids) -> *mut RelOptInfo {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn find_join_rel(arg_root: *mut PlannerInfo, arg_relids: Relids) -> *mut RelOptInfo;
        }
        find_join_rel(arg_root, arg_relids)
    })
}
pub unsafe fn build_join_rel(
    arg_root: *mut PlannerInfo,
    arg_joinrelids: Relids,
    arg_outer_rel: *mut RelOptInfo,
    arg_inner_rel: *mut RelOptInfo,
    arg_sjinfo: *mut SpecialJoinInfo,
    arg_restrictlist_ptr: *mut *mut List,
) -> *mut RelOptInfo {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn build_join_rel(
                arg_root: *mut PlannerInfo,
                arg_joinrelids: Relids,
                arg_outer_rel: *mut RelOptInfo,
                arg_inner_rel: *mut RelOptInfo,
                arg_sjinfo: *mut SpecialJoinInfo,
                arg_restrictlist_ptr: *mut *mut List,
            ) -> *mut RelOptInfo;
        }
        build_join_rel(
            arg_root,
            arg_joinrelids,
            arg_outer_rel,
            arg_inner_rel,
            arg_sjinfo,
            arg_restrictlist_ptr,
        )
    })
}
pub unsafe fn min_join_parameterization(
    arg_root: *mut PlannerInfo,
    arg_joinrelids: Relids,
    arg_outer_rel: *mut RelOptInfo,
    arg_inner_rel: *mut RelOptInfo,
) -> Relids {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn min_join_parameterization(
                arg_root: *mut PlannerInfo,
                arg_joinrelids: Relids,
                arg_outer_rel: *mut RelOptInfo,
                arg_inner_rel: *mut RelOptInfo,
            ) -> Relids;
        }
        min_join_parameterization(arg_root, arg_joinrelids, arg_outer_rel, arg_inner_rel)
    })
}
pub unsafe fn fetch_upper_rel(
    arg_root: *mut PlannerInfo,
    arg_kind: UpperRelationKind,
    arg_relids: Relids,
) -> *mut RelOptInfo {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fetch_upper_rel(
                arg_root: *mut PlannerInfo,
                arg_kind: UpperRelationKind,
                arg_relids: Relids,
            ) -> *mut RelOptInfo;
        }
        fetch_upper_rel(arg_root, arg_kind, arg_relids)
    })
}
pub unsafe fn find_childrel_parents(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
) -> Relids {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn find_childrel_parents(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
            ) -> Relids;
        }
        find_childrel_parents(arg_root, arg_rel)
    })
}
pub unsafe fn get_baserel_parampathinfo(
    arg_root: *mut PlannerInfo,
    arg_baserel: *mut RelOptInfo,
    arg_required_outer: Relids,
) -> *mut ParamPathInfo {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_baserel_parampathinfo(
                arg_root: *mut PlannerInfo,
                arg_baserel: *mut RelOptInfo,
                arg_required_outer: Relids,
            ) -> *mut ParamPathInfo;
        }
        get_baserel_parampathinfo(arg_root, arg_baserel, arg_required_outer)
    })
}
pub unsafe fn get_joinrel_parampathinfo(
    arg_root: *mut PlannerInfo,
    arg_joinrel: *mut RelOptInfo,
    arg_outer_path: *mut Path,
    arg_inner_path: *mut Path,
    arg_sjinfo: *mut SpecialJoinInfo,
    arg_required_outer: Relids,
    arg_restrict_clauses: *mut *mut List,
) -> *mut ParamPathInfo {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_joinrel_parampathinfo(
                arg_root: *mut PlannerInfo,
                arg_joinrel: *mut RelOptInfo,
                arg_outer_path: *mut Path,
                arg_inner_path: *mut Path,
                arg_sjinfo: *mut SpecialJoinInfo,
                arg_required_outer: Relids,
                arg_restrict_clauses: *mut *mut List,
            ) -> *mut ParamPathInfo;
        }
        get_joinrel_parampathinfo(
            arg_root,
            arg_joinrel,
            arg_outer_path,
            arg_inner_path,
            arg_sjinfo,
            arg_required_outer,
            arg_restrict_clauses,
        )
    })
}
pub unsafe fn get_appendrel_parampathinfo(
    arg_appendrel: *mut RelOptInfo,
    arg_required_outer: Relids,
) -> *mut ParamPathInfo {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_appendrel_parampathinfo(
                arg_appendrel: *mut RelOptInfo,
                arg_required_outer: Relids,
            ) -> *mut ParamPathInfo;
        }
        get_appendrel_parampathinfo(arg_appendrel, arg_required_outer)
    })
}
pub unsafe fn find_param_path_info(
    arg_rel: *mut RelOptInfo,
    arg_required_outer: Relids,
) -> *mut ParamPathInfo {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn find_param_path_info(
                arg_rel: *mut RelOptInfo,
                arg_required_outer: Relids,
            ) -> *mut ParamPathInfo;
        }
        find_param_path_info(arg_rel, arg_required_outer)
    })
}
pub unsafe fn build_child_join_rel(
    arg_root: *mut PlannerInfo,
    arg_outer_rel: *mut RelOptInfo,
    arg_inner_rel: *mut RelOptInfo,
    arg_parent_joinrel: *mut RelOptInfo,
    arg_restrictlist: *mut List,
    arg_sjinfo: *mut SpecialJoinInfo,
    arg_jointype: JoinType,
) -> *mut RelOptInfo {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn build_child_join_rel(
                arg_root: *mut PlannerInfo,
                arg_outer_rel: *mut RelOptInfo,
                arg_inner_rel: *mut RelOptInfo,
                arg_parent_joinrel: *mut RelOptInfo,
                arg_restrictlist: *mut List,
                arg_sjinfo: *mut SpecialJoinInfo,
                arg_jointype: JoinType,
            ) -> *mut RelOptInfo;
        }
        build_child_join_rel(
            arg_root,
            arg_outer_rel,
            arg_inner_rel,
            arg_parent_joinrel,
            arg_restrictlist,
            arg_sjinfo,
            arg_jointype,
        )
    })
}
extern "C" {
    pub static mut enable_geqo: bool;
}
extern "C" {
    pub static mut geqo_threshold: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut min_parallel_table_scan_size: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut min_parallel_index_scan_size: ::std::os::raw::c_int;
}
pub type set_rel_pathlist_hook_type = ::std::option::Option<
    unsafe extern "C" fn(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        rti: Index,
        rte: *mut RangeTblEntry,
    ),
>;
extern "C" {
    pub static mut set_rel_pathlist_hook: set_rel_pathlist_hook_type;
}
pub type set_join_pathlist_hook_type = ::std::option::Option<
    unsafe extern "C" fn(
        root: *mut PlannerInfo,
        joinrel: *mut RelOptInfo,
        outerrel: *mut RelOptInfo,
        innerrel: *mut RelOptInfo,
        jointype: JoinType,
        extra: *mut JoinPathExtraData,
    ),
>;
extern "C" {
    pub static mut set_join_pathlist_hook: set_join_pathlist_hook_type;
}
pub type join_search_hook_type = ::std::option::Option<
    unsafe extern "C" fn(
        root: *mut PlannerInfo,
        levels_needed: ::std::os::raw::c_int,
        initial_rels: *mut List,
    ) -> *mut RelOptInfo,
>;
extern "C" {
    pub static mut join_search_hook: join_search_hook_type;
}
pub unsafe fn make_one_rel(arg_root: *mut PlannerInfo, arg_joinlist: *mut List) -> *mut RelOptInfo {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_one_rel(arg_root: *mut PlannerInfo, arg_joinlist: *mut List)
                -> *mut RelOptInfo;
        }
        make_one_rel(arg_root, arg_joinlist)
    })
}
pub unsafe fn standard_join_search(
    arg_root: *mut PlannerInfo,
    arg_levels_needed: ::std::os::raw::c_int,
    arg_initial_rels: *mut List,
) -> *mut RelOptInfo {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn standard_join_search(
                arg_root: *mut PlannerInfo,
                arg_levels_needed: ::std::os::raw::c_int,
                arg_initial_rels: *mut List,
            ) -> *mut RelOptInfo;
        }
        standard_join_search(arg_root, arg_levels_needed, arg_initial_rels)
    })
}
pub unsafe fn generate_gather_paths(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_override_rows: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn generate_gather_paths(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_override_rows: bool,
            );
        }
        generate_gather_paths(arg_root, arg_rel, arg_override_rows)
    })
}
pub unsafe fn generate_useful_gather_paths(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_override_rows: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn generate_useful_gather_paths(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_override_rows: bool,
            );
        }
        generate_useful_gather_paths(arg_root, arg_rel, arg_override_rows)
    })
}
pub unsafe fn compute_parallel_worker(
    arg_rel: *mut RelOptInfo,
    arg_heap_pages: f64,
    arg_index_pages: f64,
    arg_max_workers: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn compute_parallel_worker(
                arg_rel: *mut RelOptInfo,
                arg_heap_pages: f64,
                arg_index_pages: f64,
                arg_max_workers: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        compute_parallel_worker(arg_rel, arg_heap_pages, arg_index_pages, arg_max_workers)
    })
}
pub unsafe fn create_partial_bitmap_paths(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_bitmapqual: *mut Path,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_partial_bitmap_paths(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_bitmapqual: *mut Path,
            );
        }
        create_partial_bitmap_paths(arg_root, arg_rel, arg_bitmapqual)
    })
}
pub unsafe fn generate_partitionwise_join_paths(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn generate_partitionwise_join_paths(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
            );
        }
        generate_partitionwise_join_paths(arg_root, arg_rel)
    })
}
pub unsafe fn create_index_paths(arg_root: *mut PlannerInfo, arg_rel: *mut RelOptInfo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_index_paths(arg_root: *mut PlannerInfo, arg_rel: *mut RelOptInfo);
        }
        create_index_paths(arg_root, arg_rel)
    })
}
pub unsafe fn relation_has_unique_index_for(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_restrictlist: *mut List,
    arg_exprlist: *mut List,
    arg_oprlist: *mut List,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn relation_has_unique_index_for(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_restrictlist: *mut List,
                arg_exprlist: *mut List,
                arg_oprlist: *mut List,
            ) -> bool;
        }
        relation_has_unique_index_for(
            arg_root,
            arg_rel,
            arg_restrictlist,
            arg_exprlist,
            arg_oprlist,
        )
    })
}
pub unsafe fn indexcol_is_bool_constant_for_query(
    arg_root: *mut PlannerInfo,
    arg_index: *mut IndexOptInfo,
    arg_indexcol: ::std::os::raw::c_int,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn indexcol_is_bool_constant_for_query(
                arg_root: *mut PlannerInfo,
                arg_index: *mut IndexOptInfo,
                arg_indexcol: ::std::os::raw::c_int,
            ) -> bool;
        }
        indexcol_is_bool_constant_for_query(arg_root, arg_index, arg_indexcol)
    })
}
pub unsafe fn match_index_to_operand(
    arg_operand: *mut Node,
    arg_indexcol: ::std::os::raw::c_int,
    arg_index: *mut IndexOptInfo,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn match_index_to_operand(
                arg_operand: *mut Node,
                arg_indexcol: ::std::os::raw::c_int,
                arg_index: *mut IndexOptInfo,
            ) -> bool;
        }
        match_index_to_operand(arg_operand, arg_indexcol, arg_index)
    })
}
pub unsafe fn check_index_predicates(arg_root: *mut PlannerInfo, arg_rel: *mut RelOptInfo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn check_index_predicates(arg_root: *mut PlannerInfo, arg_rel: *mut RelOptInfo);
        }
        check_index_predicates(arg_root, arg_rel)
    })
}
pub unsafe fn create_tidscan_paths(arg_root: *mut PlannerInfo, arg_rel: *mut RelOptInfo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_tidscan_paths(arg_root: *mut PlannerInfo, arg_rel: *mut RelOptInfo);
        }
        create_tidscan_paths(arg_root, arg_rel)
    })
}
pub unsafe fn add_paths_to_joinrel(
    arg_root: *mut PlannerInfo,
    arg_joinrel: *mut RelOptInfo,
    arg_outerrel: *mut RelOptInfo,
    arg_innerrel: *mut RelOptInfo,
    arg_jointype: JoinType,
    arg_sjinfo: *mut SpecialJoinInfo,
    arg_restrictlist: *mut List,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn add_paths_to_joinrel(
                arg_root: *mut PlannerInfo,
                arg_joinrel: *mut RelOptInfo,
                arg_outerrel: *mut RelOptInfo,
                arg_innerrel: *mut RelOptInfo,
                arg_jointype: JoinType,
                arg_sjinfo: *mut SpecialJoinInfo,
                arg_restrictlist: *mut List,
            );
        }
        add_paths_to_joinrel(
            arg_root,
            arg_joinrel,
            arg_outerrel,
            arg_innerrel,
            arg_jointype,
            arg_sjinfo,
            arg_restrictlist,
        )
    })
}
pub unsafe fn join_search_one_level(arg_root: *mut PlannerInfo, arg_level: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn join_search_one_level(arg_root: *mut PlannerInfo, arg_level: ::std::os::raw::c_int);
        }
        join_search_one_level(arg_root, arg_level)
    })
}
pub unsafe fn make_join_rel(
    arg_root: *mut PlannerInfo,
    arg_rel1: *mut RelOptInfo,
    arg_rel2: *mut RelOptInfo,
) -> *mut RelOptInfo {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_join_rel(
                arg_root: *mut PlannerInfo,
                arg_rel1: *mut RelOptInfo,
                arg_rel2: *mut RelOptInfo,
            ) -> *mut RelOptInfo;
        }
        make_join_rel(arg_root, arg_rel1, arg_rel2)
    })
}
pub unsafe fn have_join_order_restriction(
    arg_root: *mut PlannerInfo,
    arg_rel1: *mut RelOptInfo,
    arg_rel2: *mut RelOptInfo,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn have_join_order_restriction(
                arg_root: *mut PlannerInfo,
                arg_rel1: *mut RelOptInfo,
                arg_rel2: *mut RelOptInfo,
            ) -> bool;
        }
        have_join_order_restriction(arg_root, arg_rel1, arg_rel2)
    })
}
pub unsafe fn have_dangerous_phv(
    arg_root: *mut PlannerInfo,
    arg_outer_relids: Relids,
    arg_inner_params: Relids,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn have_dangerous_phv(
                arg_root: *mut PlannerInfo,
                arg_outer_relids: Relids,
                arg_inner_params: Relids,
            ) -> bool;
        }
        have_dangerous_phv(arg_root, arg_outer_relids, arg_inner_params)
    })
}
pub unsafe fn mark_dummy_rel(arg_rel: *mut RelOptInfo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn mark_dummy_rel(arg_rel: *mut RelOptInfo);
        }
        mark_dummy_rel(arg_rel)
    })
}
pub type ec_matches_callback_type = ::std::option::Option<
    unsafe extern "C" fn(
        root: *mut PlannerInfo,
        rel: *mut RelOptInfo,
        ec: *mut EquivalenceClass,
        em: *mut EquivalenceMember,
        arg: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
pub unsafe fn process_equivalence(
    arg_root: *mut PlannerInfo,
    arg_p_restrictinfo: *mut *mut RestrictInfo,
    arg_below_outer_join: bool,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn process_equivalence(
                arg_root: *mut PlannerInfo,
                arg_p_restrictinfo: *mut *mut RestrictInfo,
                arg_below_outer_join: bool,
            ) -> bool;
        }
        process_equivalence(arg_root, arg_p_restrictinfo, arg_below_outer_join)
    })
}
pub unsafe fn canonicalize_ec_expression(
    arg_expr: *mut Expr,
    arg_req_type: Oid,
    arg_req_collation: Oid,
) -> *mut Expr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn canonicalize_ec_expression(
                arg_expr: *mut Expr,
                arg_req_type: Oid,
                arg_req_collation: Oid,
            ) -> *mut Expr;
        }
        canonicalize_ec_expression(arg_expr, arg_req_type, arg_req_collation)
    })
}
pub unsafe fn reconsider_outer_join_clauses(arg_root: *mut PlannerInfo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn reconsider_outer_join_clauses(arg_root: *mut PlannerInfo);
        }
        reconsider_outer_join_clauses(arg_root)
    })
}
pub unsafe fn get_eclass_for_sort_expr(
    arg_root: *mut PlannerInfo,
    arg_expr: *mut Expr,
    arg_nullable_relids: Relids,
    arg_opfamilies: *mut List,
    arg_opcintype: Oid,
    arg_collation: Oid,
    arg_sortref: Index,
    arg_rel: Relids,
    arg_create_it: bool,
) -> *mut EquivalenceClass {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_eclass_for_sort_expr(
                arg_root: *mut PlannerInfo,
                arg_expr: *mut Expr,
                arg_nullable_relids: Relids,
                arg_opfamilies: *mut List,
                arg_opcintype: Oid,
                arg_collation: Oid,
                arg_sortref: Index,
                arg_rel: Relids,
                arg_create_it: bool,
            ) -> *mut EquivalenceClass;
        }
        get_eclass_for_sort_expr(
            arg_root,
            arg_expr,
            arg_nullable_relids,
            arg_opfamilies,
            arg_opcintype,
            arg_collation,
            arg_sortref,
            arg_rel,
            arg_create_it,
        )
    })
}
pub unsafe fn find_ec_member_matching_expr(
    arg_ec: *mut EquivalenceClass,
    arg_expr: *mut Expr,
    arg_relids: Relids,
) -> *mut EquivalenceMember {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn find_ec_member_matching_expr(
                arg_ec: *mut EquivalenceClass,
                arg_expr: *mut Expr,
                arg_relids: Relids,
            ) -> *mut EquivalenceMember;
        }
        find_ec_member_matching_expr(arg_ec, arg_expr, arg_relids)
    })
}
pub unsafe fn find_computable_ec_member(
    arg_root: *mut PlannerInfo,
    arg_ec: *mut EquivalenceClass,
    arg_exprs: *mut List,
    arg_relids: Relids,
    arg_require_parallel_safe: bool,
) -> *mut EquivalenceMember {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn find_computable_ec_member(
                arg_root: *mut PlannerInfo,
                arg_ec: *mut EquivalenceClass,
                arg_exprs: *mut List,
                arg_relids: Relids,
                arg_require_parallel_safe: bool,
            ) -> *mut EquivalenceMember;
        }
        find_computable_ec_member(
            arg_root,
            arg_ec,
            arg_exprs,
            arg_relids,
            arg_require_parallel_safe,
        )
    })
}
pub unsafe fn find_em_expr_for_rel(
    arg_ec: *mut EquivalenceClass,
    arg_rel: *mut RelOptInfo,
) -> *mut Expr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn find_em_expr_for_rel(
                arg_ec: *mut EquivalenceClass,
                arg_rel: *mut RelOptInfo,
            ) -> *mut Expr;
        }
        find_em_expr_for_rel(arg_ec, arg_rel)
    })
}
pub unsafe fn find_em_expr_usable_for_sorting_rel(
    arg_root: *mut PlannerInfo,
    arg_ec: *mut EquivalenceClass,
    arg_rel: *mut RelOptInfo,
    arg_require_parallel_safe: bool,
) -> *mut Expr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn find_em_expr_usable_for_sorting_rel(
                arg_root: *mut PlannerInfo,
                arg_ec: *mut EquivalenceClass,
                arg_rel: *mut RelOptInfo,
                arg_require_parallel_safe: bool,
            ) -> *mut Expr;
        }
        find_em_expr_usable_for_sorting_rel(arg_root, arg_ec, arg_rel, arg_require_parallel_safe)
    })
}
pub unsafe fn generate_base_implied_equalities(arg_root: *mut PlannerInfo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn generate_base_implied_equalities(arg_root: *mut PlannerInfo);
        }
        generate_base_implied_equalities(arg_root)
    })
}
pub unsafe fn generate_join_implied_equalities(
    arg_root: *mut PlannerInfo,
    arg_join_relids: Relids,
    arg_outer_relids: Relids,
    arg_inner_rel: *mut RelOptInfo,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn generate_join_implied_equalities(
                arg_root: *mut PlannerInfo,
                arg_join_relids: Relids,
                arg_outer_relids: Relids,
                arg_inner_rel: *mut RelOptInfo,
            ) -> *mut List;
        }
        generate_join_implied_equalities(arg_root, arg_join_relids, arg_outer_relids, arg_inner_rel)
    })
}
pub unsafe fn generate_join_implied_equalities_for_ecs(
    arg_root: *mut PlannerInfo,
    arg_eclasses: *mut List,
    arg_join_relids: Relids,
    arg_outer_relids: Relids,
    arg_inner_rel: *mut RelOptInfo,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn generate_join_implied_equalities_for_ecs(
                arg_root: *mut PlannerInfo,
                arg_eclasses: *mut List,
                arg_join_relids: Relids,
                arg_outer_relids: Relids,
                arg_inner_rel: *mut RelOptInfo,
            ) -> *mut List;
        }
        generate_join_implied_equalities_for_ecs(
            arg_root,
            arg_eclasses,
            arg_join_relids,
            arg_outer_relids,
            arg_inner_rel,
        )
    })
}
pub unsafe fn exprs_known_equal(
    arg_root: *mut PlannerInfo,
    arg_item1: *mut Node,
    arg_item2: *mut Node,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn exprs_known_equal(
                arg_root: *mut PlannerInfo,
                arg_item1: *mut Node,
                arg_item2: *mut Node,
            ) -> bool;
        }
        exprs_known_equal(arg_root, arg_item1, arg_item2)
    })
}
pub unsafe fn match_eclasses_to_foreign_key_col(
    arg_root: *mut PlannerInfo,
    arg_fkinfo: *mut ForeignKeyOptInfo,
    arg_colno: ::std::os::raw::c_int,
) -> *mut EquivalenceClass {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn match_eclasses_to_foreign_key_col(
                arg_root: *mut PlannerInfo,
                arg_fkinfo: *mut ForeignKeyOptInfo,
                arg_colno: ::std::os::raw::c_int,
            ) -> *mut EquivalenceClass;
        }
        match_eclasses_to_foreign_key_col(arg_root, arg_fkinfo, arg_colno)
    })
}
pub unsafe fn add_child_rel_equivalences(
    arg_root: *mut PlannerInfo,
    arg_appinfo: *mut AppendRelInfo,
    arg_parent_rel: *mut RelOptInfo,
    arg_child_rel: *mut RelOptInfo,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn add_child_rel_equivalences(
                arg_root: *mut PlannerInfo,
                arg_appinfo: *mut AppendRelInfo,
                arg_parent_rel: *mut RelOptInfo,
                arg_child_rel: *mut RelOptInfo,
            );
        }
        add_child_rel_equivalences(arg_root, arg_appinfo, arg_parent_rel, arg_child_rel)
    })
}
pub unsafe fn add_child_join_rel_equivalences(
    arg_root: *mut PlannerInfo,
    arg_nappinfos: ::std::os::raw::c_int,
    arg_appinfos: *mut *mut AppendRelInfo,
    arg_parent_rel: *mut RelOptInfo,
    arg_child_rel: *mut RelOptInfo,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn add_child_join_rel_equivalences(
                arg_root: *mut PlannerInfo,
                arg_nappinfos: ::std::os::raw::c_int,
                arg_appinfos: *mut *mut AppendRelInfo,
                arg_parent_rel: *mut RelOptInfo,
                arg_child_rel: *mut RelOptInfo,
            );
        }
        add_child_join_rel_equivalences(
            arg_root,
            arg_nappinfos,
            arg_appinfos,
            arg_parent_rel,
            arg_child_rel,
        )
    })
}
pub unsafe fn generate_implied_equalities_for_column(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_callback: ec_matches_callback_type,
    arg_callback_arg: *mut ::std::os::raw::c_void,
    arg_prohibited_rels: Relids,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn generate_implied_equalities_for_column(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_callback: ec_matches_callback_type,
                arg_callback_arg: *mut ::std::os::raw::c_void,
                arg_prohibited_rels: Relids,
            ) -> *mut List;
        }
        generate_implied_equalities_for_column(
            arg_root,
            arg_rel,
            arg_callback,
            arg_callback_arg,
            arg_prohibited_rels,
        )
    })
}
pub unsafe fn have_relevant_eclass_joinclause(
    arg_root: *mut PlannerInfo,
    arg_rel1: *mut RelOptInfo,
    arg_rel2: *mut RelOptInfo,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn have_relevant_eclass_joinclause(
                arg_root: *mut PlannerInfo,
                arg_rel1: *mut RelOptInfo,
                arg_rel2: *mut RelOptInfo,
            ) -> bool;
        }
        have_relevant_eclass_joinclause(arg_root, arg_rel1, arg_rel2)
    })
}
pub unsafe fn has_relevant_eclass_joinclause(
    arg_root: *mut PlannerInfo,
    arg_rel1: *mut RelOptInfo,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_relevant_eclass_joinclause(
                arg_root: *mut PlannerInfo,
                arg_rel1: *mut RelOptInfo,
            ) -> bool;
        }
        has_relevant_eclass_joinclause(arg_root, arg_rel1)
    })
}
pub unsafe fn eclass_useful_for_merging(
    arg_root: *mut PlannerInfo,
    arg_eclass: *mut EquivalenceClass,
    arg_rel: *mut RelOptInfo,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn eclass_useful_for_merging(
                arg_root: *mut PlannerInfo,
                arg_eclass: *mut EquivalenceClass,
                arg_rel: *mut RelOptInfo,
            ) -> bool;
        }
        eclass_useful_for_merging(arg_root, arg_eclass, arg_rel)
    })
}
pub unsafe fn is_redundant_derived_clause(
    arg_rinfo: *mut RestrictInfo,
    arg_clauselist: *mut List,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn is_redundant_derived_clause(
                arg_rinfo: *mut RestrictInfo,
                arg_clauselist: *mut List,
            ) -> bool;
        }
        is_redundant_derived_clause(arg_rinfo, arg_clauselist)
    })
}
pub unsafe fn is_redundant_with_indexclauses(
    arg_rinfo: *mut RestrictInfo,
    arg_indexclauses: *mut List,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn is_redundant_with_indexclauses(
                arg_rinfo: *mut RestrictInfo,
                arg_indexclauses: *mut List,
            ) -> bool;
        }
        is_redundant_with_indexclauses(arg_rinfo, arg_indexclauses)
    })
}
pub const PathKeysComparison_PATHKEYS_EQUAL: PathKeysComparison = 0;
pub const PathKeysComparison_PATHKEYS_BETTER1: PathKeysComparison = 1;
pub const PathKeysComparison_PATHKEYS_BETTER2: PathKeysComparison = 2;
pub const PathKeysComparison_PATHKEYS_DIFFERENT: PathKeysComparison = 3;
pub type PathKeysComparison = ::std::os::raw::c_uint;
pub unsafe fn compare_pathkeys(arg_keys1: *mut List, arg_keys2: *mut List) -> PathKeysComparison {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn compare_pathkeys(arg_keys1: *mut List, arg_keys2: *mut List) -> PathKeysComparison;
        }
        compare_pathkeys(arg_keys1, arg_keys2)
    })
}
pub unsafe fn pathkeys_contained_in(arg_keys1: *mut List, arg_keys2: *mut List) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pathkeys_contained_in(arg_keys1: *mut List, arg_keys2: *mut List) -> bool;
        }
        pathkeys_contained_in(arg_keys1, arg_keys2)
    })
}
pub unsafe fn pathkeys_count_contained_in(
    arg_keys1: *mut List,
    arg_keys2: *mut List,
    arg_n_common: *mut ::std::os::raw::c_int,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pathkeys_count_contained_in(
                arg_keys1: *mut List,
                arg_keys2: *mut List,
                arg_n_common: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        pathkeys_count_contained_in(arg_keys1, arg_keys2, arg_n_common)
    })
}
pub unsafe fn get_cheapest_path_for_pathkeys(
    arg_paths: *mut List,
    arg_pathkeys: *mut List,
    arg_required_outer: Relids,
    arg_cost_criterion: CostSelector,
    arg_require_parallel_safe: bool,
) -> *mut Path {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_cheapest_path_for_pathkeys(
                arg_paths: *mut List,
                arg_pathkeys: *mut List,
                arg_required_outer: Relids,
                arg_cost_criterion: CostSelector,
                arg_require_parallel_safe: bool,
            ) -> *mut Path;
        }
        get_cheapest_path_for_pathkeys(
            arg_paths,
            arg_pathkeys,
            arg_required_outer,
            arg_cost_criterion,
            arg_require_parallel_safe,
        )
    })
}
pub unsafe fn get_cheapest_fractional_path_for_pathkeys(
    arg_paths: *mut List,
    arg_pathkeys: *mut List,
    arg_required_outer: Relids,
    arg_fraction: f64,
) -> *mut Path {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_cheapest_fractional_path_for_pathkeys(
                arg_paths: *mut List,
                arg_pathkeys: *mut List,
                arg_required_outer: Relids,
                arg_fraction: f64,
            ) -> *mut Path;
        }
        get_cheapest_fractional_path_for_pathkeys(
            arg_paths,
            arg_pathkeys,
            arg_required_outer,
            arg_fraction,
        )
    })
}
pub unsafe fn get_cheapest_parallel_safe_total_inner(arg_paths: *mut List) -> *mut Path {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_cheapest_parallel_safe_total_inner(arg_paths: *mut List) -> *mut Path;
        }
        get_cheapest_parallel_safe_total_inner(arg_paths)
    })
}
pub unsafe fn build_index_pathkeys(
    arg_root: *mut PlannerInfo,
    arg_index: *mut IndexOptInfo,
    arg_scandir: ScanDirection,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn build_index_pathkeys(
                arg_root: *mut PlannerInfo,
                arg_index: *mut IndexOptInfo,
                arg_scandir: ScanDirection,
            ) -> *mut List;
        }
        build_index_pathkeys(arg_root, arg_index, arg_scandir)
    })
}
pub unsafe fn build_partition_pathkeys(
    arg_root: *mut PlannerInfo,
    arg_partrel: *mut RelOptInfo,
    arg_scandir: ScanDirection,
    arg_partialkeys: *mut bool,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn build_partition_pathkeys(
                arg_root: *mut PlannerInfo,
                arg_partrel: *mut RelOptInfo,
                arg_scandir: ScanDirection,
                arg_partialkeys: *mut bool,
            ) -> *mut List;
        }
        build_partition_pathkeys(arg_root, arg_partrel, arg_scandir, arg_partialkeys)
    })
}
pub unsafe fn build_expression_pathkey(
    arg_root: *mut PlannerInfo,
    arg_expr: *mut Expr,
    arg_nullable_relids: Relids,
    arg_opno: Oid,
    arg_rel: Relids,
    arg_create_it: bool,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn build_expression_pathkey(
                arg_root: *mut PlannerInfo,
                arg_expr: *mut Expr,
                arg_nullable_relids: Relids,
                arg_opno: Oid,
                arg_rel: Relids,
                arg_create_it: bool,
            ) -> *mut List;
        }
        build_expression_pathkey(
            arg_root,
            arg_expr,
            arg_nullable_relids,
            arg_opno,
            arg_rel,
            arg_create_it,
        )
    })
}
pub unsafe fn convert_subquery_pathkeys(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_subquery_pathkeys: *mut List,
    arg_subquery_tlist: *mut List,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn convert_subquery_pathkeys(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_subquery_pathkeys: *mut List,
                arg_subquery_tlist: *mut List,
            ) -> *mut List;
        }
        convert_subquery_pathkeys(arg_root, arg_rel, arg_subquery_pathkeys, arg_subquery_tlist)
    })
}
pub unsafe fn build_join_pathkeys(
    arg_root: *mut PlannerInfo,
    arg_joinrel: *mut RelOptInfo,
    arg_jointype: JoinType,
    arg_outer_pathkeys: *mut List,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn build_join_pathkeys(
                arg_root: *mut PlannerInfo,
                arg_joinrel: *mut RelOptInfo,
                arg_jointype: JoinType,
                arg_outer_pathkeys: *mut List,
            ) -> *mut List;
        }
        build_join_pathkeys(arg_root, arg_joinrel, arg_jointype, arg_outer_pathkeys)
    })
}
pub unsafe fn make_pathkeys_for_sortclauses(
    arg_root: *mut PlannerInfo,
    arg_sortclauses: *mut List,
    arg_tlist: *mut List,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_pathkeys_for_sortclauses(
                arg_root: *mut PlannerInfo,
                arg_sortclauses: *mut List,
                arg_tlist: *mut List,
            ) -> *mut List;
        }
        make_pathkeys_for_sortclauses(arg_root, arg_sortclauses, arg_tlist)
    })
}
pub unsafe fn initialize_mergeclause_eclasses(
    arg_root: *mut PlannerInfo,
    arg_restrictinfo: *mut RestrictInfo,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn initialize_mergeclause_eclasses(
                arg_root: *mut PlannerInfo,
                arg_restrictinfo: *mut RestrictInfo,
            );
        }
        initialize_mergeclause_eclasses(arg_root, arg_restrictinfo)
    })
}
pub unsafe fn update_mergeclause_eclasses(
    arg_root: *mut PlannerInfo,
    arg_restrictinfo: *mut RestrictInfo,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn update_mergeclause_eclasses(
                arg_root: *mut PlannerInfo,
                arg_restrictinfo: *mut RestrictInfo,
            );
        }
        update_mergeclause_eclasses(arg_root, arg_restrictinfo)
    })
}
pub unsafe fn find_mergeclauses_for_outer_pathkeys(
    arg_root: *mut PlannerInfo,
    arg_pathkeys: *mut List,
    arg_restrictinfos: *mut List,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn find_mergeclauses_for_outer_pathkeys(
                arg_root: *mut PlannerInfo,
                arg_pathkeys: *mut List,
                arg_restrictinfos: *mut List,
            ) -> *mut List;
        }
        find_mergeclauses_for_outer_pathkeys(arg_root, arg_pathkeys, arg_restrictinfos)
    })
}
pub unsafe fn select_outer_pathkeys_for_merge(
    arg_root: *mut PlannerInfo,
    arg_mergeclauses: *mut List,
    arg_joinrel: *mut RelOptInfo,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn select_outer_pathkeys_for_merge(
                arg_root: *mut PlannerInfo,
                arg_mergeclauses: *mut List,
                arg_joinrel: *mut RelOptInfo,
            ) -> *mut List;
        }
        select_outer_pathkeys_for_merge(arg_root, arg_mergeclauses, arg_joinrel)
    })
}
pub unsafe fn make_inner_pathkeys_for_merge(
    arg_root: *mut PlannerInfo,
    arg_mergeclauses: *mut List,
    arg_outer_pathkeys: *mut List,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_inner_pathkeys_for_merge(
                arg_root: *mut PlannerInfo,
                arg_mergeclauses: *mut List,
                arg_outer_pathkeys: *mut List,
            ) -> *mut List;
        }
        make_inner_pathkeys_for_merge(arg_root, arg_mergeclauses, arg_outer_pathkeys)
    })
}
pub unsafe fn trim_mergeclauses_for_inner_pathkeys(
    arg_root: *mut PlannerInfo,
    arg_mergeclauses: *mut List,
    arg_pathkeys: *mut List,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn trim_mergeclauses_for_inner_pathkeys(
                arg_root: *mut PlannerInfo,
                arg_mergeclauses: *mut List,
                arg_pathkeys: *mut List,
            ) -> *mut List;
        }
        trim_mergeclauses_for_inner_pathkeys(arg_root, arg_mergeclauses, arg_pathkeys)
    })
}
pub unsafe fn truncate_useless_pathkeys(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_pathkeys: *mut List,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn truncate_useless_pathkeys(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_pathkeys: *mut List,
            ) -> *mut List;
        }
        truncate_useless_pathkeys(arg_root, arg_rel, arg_pathkeys)
    })
}
pub unsafe fn has_useful_pathkeys(arg_root: *mut PlannerInfo, arg_rel: *mut RelOptInfo) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_useful_pathkeys(arg_root: *mut PlannerInfo, arg_rel: *mut RelOptInfo) -> bool;
        }
        has_useful_pathkeys(arg_root, arg_rel)
    })
}
pub unsafe fn make_canonical_pathkey(
    arg_root: *mut PlannerInfo,
    arg_eclass: *mut EquivalenceClass,
    arg_opfamily: Oid,
    arg_strategy: ::std::os::raw::c_int,
    arg_nulls_first: bool,
) -> *mut PathKey {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_canonical_pathkey(
                arg_root: *mut PlannerInfo,
                arg_eclass: *mut EquivalenceClass,
                arg_opfamily: Oid,
                arg_strategy: ::std::os::raw::c_int,
                arg_nulls_first: bool,
            ) -> *mut PathKey;
        }
        make_canonical_pathkey(arg_root, arg_eclass, arg_opfamily, arg_strategy, arg_nulls_first)
    })
}
pub unsafe fn add_paths_to_append_rel(
    arg_root: *mut PlannerInfo,
    arg_rel: *mut RelOptInfo,
    arg_live_childrels: *mut List,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn add_paths_to_append_rel(
                arg_root: *mut PlannerInfo,
                arg_rel: *mut RelOptInfo,
                arg_live_childrels: *mut List,
            );
        }
        add_paths_to_append_rel(arg_root, arg_rel, arg_live_childrels)
    })
}
extern "C" {
    pub static mut cursor_tuple_fraction: f64;
}
pub type query_pathkeys_callback = ::std::option::Option<
    unsafe extern "C" fn(root: *mut PlannerInfo, extra: *mut ::std::os::raw::c_void),
>;
pub unsafe fn query_planner(
    arg_root: *mut PlannerInfo,
    arg_qp_callback: query_pathkeys_callback,
    arg_qp_extra: *mut ::std::os::raw::c_void,
) -> *mut RelOptInfo {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn query_planner(
                arg_root: *mut PlannerInfo,
                arg_qp_callback: query_pathkeys_callback,
                arg_qp_extra: *mut ::std::os::raw::c_void,
            ) -> *mut RelOptInfo;
        }
        query_planner(arg_root, arg_qp_callback, arg_qp_extra)
    })
}
pub unsafe fn preprocess_minmax_aggregates(arg_root: *mut PlannerInfo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn preprocess_minmax_aggregates(arg_root: *mut PlannerInfo);
        }
        preprocess_minmax_aggregates(arg_root)
    })
}
pub unsafe fn create_plan(arg_root: *mut PlannerInfo, arg_best_path: *mut Path) -> *mut Plan {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_plan(arg_root: *mut PlannerInfo, arg_best_path: *mut Path) -> *mut Plan;
        }
        create_plan(arg_root, arg_best_path)
    })
}
pub unsafe fn make_foreignscan(
    arg_qptlist: *mut List,
    arg_qpqual: *mut List,
    arg_scanrelid: Index,
    arg_fdw_exprs: *mut List,
    arg_fdw_private: *mut List,
    arg_fdw_scan_tlist: *mut List,
    arg_fdw_recheck_quals: *mut List,
    arg_outer_plan: *mut Plan,
) -> *mut ForeignScan {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_foreignscan(
                arg_qptlist: *mut List,
                arg_qpqual: *mut List,
                arg_scanrelid: Index,
                arg_fdw_exprs: *mut List,
                arg_fdw_private: *mut List,
                arg_fdw_scan_tlist: *mut List,
                arg_fdw_recheck_quals: *mut List,
                arg_outer_plan: *mut Plan,
            ) -> *mut ForeignScan;
        }
        make_foreignscan(
            arg_qptlist,
            arg_qpqual,
            arg_scanrelid,
            arg_fdw_exprs,
            arg_fdw_private,
            arg_fdw_scan_tlist,
            arg_fdw_recheck_quals,
            arg_outer_plan,
        )
    })
}
pub unsafe fn change_plan_targetlist(
    arg_subplan: *mut Plan,
    arg_tlist: *mut List,
    arg_tlist_parallel_safe: bool,
) -> *mut Plan {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn change_plan_targetlist(
                arg_subplan: *mut Plan,
                arg_tlist: *mut List,
                arg_tlist_parallel_safe: bool,
            ) -> *mut Plan;
        }
        change_plan_targetlist(arg_subplan, arg_tlist, arg_tlist_parallel_safe)
    })
}
pub unsafe fn materialize_finished_plan(arg_subplan: *mut Plan) -> *mut Plan {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn materialize_finished_plan(arg_subplan: *mut Plan) -> *mut Plan;
        }
        materialize_finished_plan(arg_subplan)
    })
}
pub unsafe fn is_projection_capable_path(arg_path: *mut Path) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn is_projection_capable_path(arg_path: *mut Path) -> bool;
        }
        is_projection_capable_path(arg_path)
    })
}
pub unsafe fn is_projection_capable_plan(arg_plan: *mut Plan) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn is_projection_capable_plan(arg_plan: *mut Plan) -> bool;
        }
        is_projection_capable_plan(arg_plan)
    })
}
pub unsafe fn make_sort_from_sortclauses(
    arg_sortcls: *mut List,
    arg_lefttree: *mut Plan,
) -> *mut Sort {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_sort_from_sortclauses(
                arg_sortcls: *mut List,
                arg_lefttree: *mut Plan,
            ) -> *mut Sort;
        }
        make_sort_from_sortclauses(arg_sortcls, arg_lefttree)
    })
}
pub unsafe fn make_agg(
    arg_tlist: *mut List,
    arg_qual: *mut List,
    arg_aggstrategy: AggStrategy,
    arg_aggsplit: AggSplit,
    arg_numGroupCols: ::std::os::raw::c_int,
    arg_grpColIdx: *mut AttrNumber,
    arg_grpOperators: *mut Oid,
    arg_grpCollations: *mut Oid,
    arg_groupingSets: *mut List,
    arg_chain: *mut List,
    arg_dNumGroups: f64,
    arg_transitionSpace: Size,
    arg_lefttree: *mut Plan,
) -> *mut Agg {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_agg(
                arg_tlist: *mut List,
                arg_qual: *mut List,
                arg_aggstrategy: AggStrategy,
                arg_aggsplit: AggSplit,
                arg_numGroupCols: ::std::os::raw::c_int,
                arg_grpColIdx: *mut AttrNumber,
                arg_grpOperators: *mut Oid,
                arg_grpCollations: *mut Oid,
                arg_groupingSets: *mut List,
                arg_chain: *mut List,
                arg_dNumGroups: f64,
                arg_transitionSpace: Size,
                arg_lefttree: *mut Plan,
            ) -> *mut Agg;
        }
        make_agg(
            arg_tlist,
            arg_qual,
            arg_aggstrategy,
            arg_aggsplit,
            arg_numGroupCols,
            arg_grpColIdx,
            arg_grpOperators,
            arg_grpCollations,
            arg_groupingSets,
            arg_chain,
            arg_dNumGroups,
            arg_transitionSpace,
            arg_lefttree,
        )
    })
}
pub unsafe fn make_limit(
    arg_lefttree: *mut Plan,
    arg_limitOffset: *mut Node,
    arg_limitCount: *mut Node,
    arg_limitOption: LimitOption,
    arg_uniqNumCols: ::std::os::raw::c_int,
    arg_uniqColIdx: *mut AttrNumber,
    arg_uniqOperators: *mut Oid,
    arg_uniqCollations: *mut Oid,
) -> *mut Limit {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_limit(
                arg_lefttree: *mut Plan,
                arg_limitOffset: *mut Node,
                arg_limitCount: *mut Node,
                arg_limitOption: LimitOption,
                arg_uniqNumCols: ::std::os::raw::c_int,
                arg_uniqColIdx: *mut AttrNumber,
                arg_uniqOperators: *mut Oid,
                arg_uniqCollations: *mut Oid,
            ) -> *mut Limit;
        }
        make_limit(
            arg_lefttree,
            arg_limitOffset,
            arg_limitCount,
            arg_limitOption,
            arg_uniqNumCols,
            arg_uniqColIdx,
            arg_uniqOperators,
            arg_uniqCollations,
        )
    })
}
extern "C" {
    pub static mut from_collapse_limit: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut join_collapse_limit: ::std::os::raw::c_int;
}
pub unsafe fn add_base_rels_to_query(arg_root: *mut PlannerInfo, arg_jtnode: *mut Node) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn add_base_rels_to_query(arg_root: *mut PlannerInfo, arg_jtnode: *mut Node);
        }
        add_base_rels_to_query(arg_root, arg_jtnode)
    })
}
pub unsafe fn add_other_rels_to_query(arg_root: *mut PlannerInfo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn add_other_rels_to_query(arg_root: *mut PlannerInfo);
        }
        add_other_rels_to_query(arg_root)
    })
}
pub unsafe fn build_base_rel_tlists(arg_root: *mut PlannerInfo, arg_final_tlist: *mut List) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn build_base_rel_tlists(arg_root: *mut PlannerInfo, arg_final_tlist: *mut List);
        }
        build_base_rel_tlists(arg_root, arg_final_tlist)
    })
}
pub unsafe fn add_vars_to_targetlist(
    arg_root: *mut PlannerInfo,
    arg_vars: *mut List,
    arg_where_needed: Relids,
    arg_create_new_ph: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn add_vars_to_targetlist(
                arg_root: *mut PlannerInfo,
                arg_vars: *mut List,
                arg_where_needed: Relids,
                arg_create_new_ph: bool,
            );
        }
        add_vars_to_targetlist(arg_root, arg_vars, arg_where_needed, arg_create_new_ph)
    })
}
pub unsafe fn find_lateral_references(arg_root: *mut PlannerInfo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn find_lateral_references(arg_root: *mut PlannerInfo);
        }
        find_lateral_references(arg_root)
    })
}
pub unsafe fn create_lateral_join_info(arg_root: *mut PlannerInfo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_lateral_join_info(arg_root: *mut PlannerInfo);
        }
        create_lateral_join_info(arg_root)
    })
}
pub unsafe fn deconstruct_jointree(arg_root: *mut PlannerInfo) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn deconstruct_jointree(arg_root: *mut PlannerInfo) -> *mut List;
        }
        deconstruct_jointree(arg_root)
    })
}
pub unsafe fn distribute_restrictinfo_to_rels(
    arg_root: *mut PlannerInfo,
    arg_restrictinfo: *mut RestrictInfo,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn distribute_restrictinfo_to_rels(
                arg_root: *mut PlannerInfo,
                arg_restrictinfo: *mut RestrictInfo,
            );
        }
        distribute_restrictinfo_to_rels(arg_root, arg_restrictinfo)
    })
}
pub unsafe fn process_implied_equality(
    arg_root: *mut PlannerInfo,
    arg_opno: Oid,
    arg_collation: Oid,
    arg_item1: *mut Expr,
    arg_item2: *mut Expr,
    arg_qualscope: Relids,
    arg_nullable_relids: Relids,
    arg_security_level: Index,
    arg_below_outer_join: bool,
    arg_both_const: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn process_implied_equality(
                arg_root: *mut PlannerInfo,
                arg_opno: Oid,
                arg_collation: Oid,
                arg_item1: *mut Expr,
                arg_item2: *mut Expr,
                arg_qualscope: Relids,
                arg_nullable_relids: Relids,
                arg_security_level: Index,
                arg_below_outer_join: bool,
                arg_both_const: bool,
            );
        }
        process_implied_equality(
            arg_root,
            arg_opno,
            arg_collation,
            arg_item1,
            arg_item2,
            arg_qualscope,
            arg_nullable_relids,
            arg_security_level,
            arg_below_outer_join,
            arg_both_const,
        )
    })
}
pub unsafe fn build_implied_join_equality(
    arg_root: *mut PlannerInfo,
    arg_opno: Oid,
    arg_collation: Oid,
    arg_item1: *mut Expr,
    arg_item2: *mut Expr,
    arg_qualscope: Relids,
    arg_nullable_relids: Relids,
    arg_security_level: Index,
) -> *mut RestrictInfo {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn build_implied_join_equality(
                arg_root: *mut PlannerInfo,
                arg_opno: Oid,
                arg_collation: Oid,
                arg_item1: *mut Expr,
                arg_item2: *mut Expr,
                arg_qualscope: Relids,
                arg_nullable_relids: Relids,
                arg_security_level: Index,
            ) -> *mut RestrictInfo;
        }
        build_implied_join_equality(
            arg_root,
            arg_opno,
            arg_collation,
            arg_item1,
            arg_item2,
            arg_qualscope,
            arg_nullable_relids,
            arg_security_level,
        )
    })
}
pub unsafe fn match_foreign_keys_to_quals(arg_root: *mut PlannerInfo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn match_foreign_keys_to_quals(arg_root: *mut PlannerInfo);
        }
        match_foreign_keys_to_quals(arg_root)
    })
}
pub unsafe fn remove_useless_joins(
    arg_root: *mut PlannerInfo,
    arg_joinlist: *mut List,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn remove_useless_joins(
                arg_root: *mut PlannerInfo,
                arg_joinlist: *mut List,
            ) -> *mut List;
        }
        remove_useless_joins(arg_root, arg_joinlist)
    })
}
pub unsafe fn reduce_unique_semijoins(arg_root: *mut PlannerInfo) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn reduce_unique_semijoins(arg_root: *mut PlannerInfo);
        }
        reduce_unique_semijoins(arg_root)
    })
}
pub unsafe fn query_supports_distinctness(arg_query: *mut Query) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn query_supports_distinctness(arg_query: *mut Query) -> bool;
        }
        query_supports_distinctness(arg_query)
    })
}
pub unsafe fn query_is_distinct_for(
    arg_query: *mut Query,
    arg_colnos: *mut List,
    arg_opids: *mut List,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn query_is_distinct_for(
                arg_query: *mut Query,
                arg_colnos: *mut List,
                arg_opids: *mut List,
            ) -> bool;
        }
        query_is_distinct_for(arg_query, arg_colnos, arg_opids)
    })
}
pub unsafe fn innerrel_is_unique(
    arg_root: *mut PlannerInfo,
    arg_joinrelids: Relids,
    arg_outerrelids: Relids,
    arg_innerrel: *mut RelOptInfo,
    arg_jointype: JoinType,
    arg_restrictlist: *mut List,
    arg_force_cache: bool,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn innerrel_is_unique(
                arg_root: *mut PlannerInfo,
                arg_joinrelids: Relids,
                arg_outerrelids: Relids,
                arg_innerrel: *mut RelOptInfo,
                arg_jointype: JoinType,
                arg_restrictlist: *mut List,
                arg_force_cache: bool,
            ) -> bool;
        }
        innerrel_is_unique(
            arg_root,
            arg_joinrelids,
            arg_outerrelids,
            arg_innerrel,
            arg_jointype,
            arg_restrictlist,
            arg_force_cache,
        )
    })
}
pub unsafe fn set_plan_references(arg_root: *mut PlannerInfo, arg_plan: *mut Plan) -> *mut Plan {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn set_plan_references(arg_root: *mut PlannerInfo, arg_plan: *mut Plan) -> *mut Plan;
        }
        set_plan_references(arg_root, arg_plan)
    })
}
pub unsafe fn record_plan_function_dependency(arg_root: *mut PlannerInfo, arg_funcid: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn record_plan_function_dependency(arg_root: *mut PlannerInfo, arg_funcid: Oid);
        }
        record_plan_function_dependency(arg_root, arg_funcid)
    })
}
pub unsafe fn record_plan_type_dependency(arg_root: *mut PlannerInfo, arg_typid: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn record_plan_type_dependency(arg_root: *mut PlannerInfo, arg_typid: Oid);
        }
        record_plan_type_dependency(arg_root, arg_typid)
    })
}
pub unsafe fn extract_query_dependencies_walker(
    arg_node: *mut Node,
    arg_root: *mut PlannerInfo,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn extract_query_dependencies_walker(
                arg_node: *mut Node,
                arg_root: *mut PlannerInfo,
            ) -> bool;
        }
        extract_query_dependencies_walker(arg_node, arg_root)
    })
}
pub type planner_hook_type = ::std::option::Option<
    unsafe extern "C" fn(
        parse: *mut Query,
        query_string: *const ::std::os::raw::c_char,
        cursorOptions: ::std::os::raw::c_int,
        boundParams: ParamListInfo,
    ) -> *mut PlannedStmt,
>;
extern "C" {
    pub static mut planner_hook: planner_hook_type;
}
pub type create_upper_paths_hook_type = ::std::option::Option<
    unsafe extern "C" fn(
        root: *mut PlannerInfo,
        stage: UpperRelationKind,
        input_rel: *mut RelOptInfo,
        output_rel: *mut RelOptInfo,
        extra: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub static mut create_upper_paths_hook: create_upper_paths_hook_type;
}
pub unsafe fn standard_planner(
    arg_parse: *mut Query,
    arg_query_string: *const ::std::os::raw::c_char,
    arg_cursorOptions: ::std::os::raw::c_int,
    arg_boundParams: ParamListInfo,
) -> *mut PlannedStmt {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn standard_planner(
                arg_parse: *mut Query,
                arg_query_string: *const ::std::os::raw::c_char,
                arg_cursorOptions: ::std::os::raw::c_int,
                arg_boundParams: ParamListInfo,
            ) -> *mut PlannedStmt;
        }
        standard_planner(arg_parse, arg_query_string, arg_cursorOptions, arg_boundParams)
    })
}
pub unsafe fn subquery_planner(
    arg_glob: *mut PlannerGlobal,
    arg_parse: *mut Query,
    arg_parent_root: *mut PlannerInfo,
    arg_hasRecursion: bool,
    arg_tuple_fraction: f64,
) -> *mut PlannerInfo {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn subquery_planner(
                arg_glob: *mut PlannerGlobal,
                arg_parse: *mut Query,
                arg_parent_root: *mut PlannerInfo,
                arg_hasRecursion: bool,
                arg_tuple_fraction: f64,
            ) -> *mut PlannerInfo;
        }
        subquery_planner(arg_glob, arg_parse, arg_parent_root, arg_hasRecursion, arg_tuple_fraction)
    })
}
pub unsafe fn select_rowmark_type(
    arg_rte: *mut RangeTblEntry,
    arg_strength: LockClauseStrength,
) -> RowMarkType {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn select_rowmark_type(
                arg_rte: *mut RangeTblEntry,
                arg_strength: LockClauseStrength,
            ) -> RowMarkType;
        }
        select_rowmark_type(arg_rte, arg_strength)
    })
}
pub unsafe fn limit_needed(arg_parse: *mut Query) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn limit_needed(arg_parse: *mut Query) -> bool;
        }
        limit_needed(arg_parse)
    })
}
pub unsafe fn mark_partial_aggref(arg_agg: *mut Aggref, arg_aggsplit: AggSplit) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn mark_partial_aggref(arg_agg: *mut Aggref, arg_aggsplit: AggSplit);
        }
        mark_partial_aggref(arg_agg, arg_aggsplit)
    })
}
pub unsafe fn get_cheapest_fractional_path(
    arg_rel: *mut RelOptInfo,
    arg_tuple_fraction: f64,
) -> *mut Path {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_cheapest_fractional_path(
                arg_rel: *mut RelOptInfo,
                arg_tuple_fraction: f64,
            ) -> *mut Path;
        }
        get_cheapest_fractional_path(arg_rel, arg_tuple_fraction)
    })
}
pub unsafe fn preprocess_phv_expression(
    arg_root: *mut PlannerInfo,
    arg_expr: *mut Expr,
) -> *mut Expr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn preprocess_phv_expression(
                arg_root: *mut PlannerInfo,
                arg_expr: *mut Expr,
            ) -> *mut Expr;
        }
        preprocess_phv_expression(arg_root, arg_expr)
    })
}
pub unsafe fn make_restrictinfo(
    arg_clause: *mut Expr,
    arg_is_pushed_down: bool,
    arg_outerjoin_delayed: bool,
    arg_pseudoconstant: bool,
    arg_security_level: Index,
    arg_required_relids: Relids,
    arg_outer_relids: Relids,
    arg_nullable_relids: Relids,
) -> *mut RestrictInfo {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_restrictinfo(
                arg_clause: *mut Expr,
                arg_is_pushed_down: bool,
                arg_outerjoin_delayed: bool,
                arg_pseudoconstant: bool,
                arg_security_level: Index,
                arg_required_relids: Relids,
                arg_outer_relids: Relids,
                arg_nullable_relids: Relids,
            ) -> *mut RestrictInfo;
        }
        make_restrictinfo(
            arg_clause,
            arg_is_pushed_down,
            arg_outerjoin_delayed,
            arg_pseudoconstant,
            arg_security_level,
            arg_required_relids,
            arg_outer_relids,
            arg_nullable_relids,
        )
    })
}
pub unsafe fn make_restrictinfo_new(
    arg_root: *mut PlannerInfo,
    arg_clause: *mut Expr,
    arg_is_pushed_down: bool,
    arg_outerjoin_delayed: bool,
    arg_pseudoconstant: bool,
    arg_security_level: Index,
    arg_required_relids: Relids,
    arg_outer_relids: Relids,
    arg_nullable_relids: Relids,
) -> *mut RestrictInfo {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_restrictinfo_new(
                arg_root: *mut PlannerInfo,
                arg_clause: *mut Expr,
                arg_is_pushed_down: bool,
                arg_outerjoin_delayed: bool,
                arg_pseudoconstant: bool,
                arg_security_level: Index,
                arg_required_relids: Relids,
                arg_outer_relids: Relids,
                arg_nullable_relids: Relids,
            ) -> *mut RestrictInfo;
        }
        make_restrictinfo_new(
            arg_root,
            arg_clause,
            arg_is_pushed_down,
            arg_outerjoin_delayed,
            arg_pseudoconstant,
            arg_security_level,
            arg_required_relids,
            arg_outer_relids,
            arg_nullable_relids,
        )
    })
}
pub unsafe fn commute_restrictinfo(
    arg_rinfo: *mut RestrictInfo,
    arg_comm_op: Oid,
) -> *mut RestrictInfo {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn commute_restrictinfo(
                arg_rinfo: *mut RestrictInfo,
                arg_comm_op: Oid,
            ) -> *mut RestrictInfo;
        }
        commute_restrictinfo(arg_rinfo, arg_comm_op)
    })
}
pub unsafe fn restriction_is_or_clause(arg_restrictinfo: *mut RestrictInfo) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn restriction_is_or_clause(arg_restrictinfo: *mut RestrictInfo) -> bool;
        }
        restriction_is_or_clause(arg_restrictinfo)
    })
}
pub unsafe fn restriction_is_securely_promotable(
    arg_restrictinfo: *mut RestrictInfo,
    arg_rel: *mut RelOptInfo,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn restriction_is_securely_promotable(
                arg_restrictinfo: *mut RestrictInfo,
                arg_rel: *mut RelOptInfo,
            ) -> bool;
        }
        restriction_is_securely_promotable(arg_restrictinfo, arg_rel)
    })
}
pub unsafe fn get_actual_clauses(arg_restrictinfo_list: *mut List) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_actual_clauses(arg_restrictinfo_list: *mut List) -> *mut List;
        }
        get_actual_clauses(arg_restrictinfo_list)
    })
}
pub unsafe fn extract_actual_clauses(
    arg_restrictinfo_list: *mut List,
    arg_pseudoconstant: bool,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn extract_actual_clauses(
                arg_restrictinfo_list: *mut List,
                arg_pseudoconstant: bool,
            ) -> *mut List;
        }
        extract_actual_clauses(arg_restrictinfo_list, arg_pseudoconstant)
    })
}
pub unsafe fn extract_actual_join_clauses(
    arg_restrictinfo_list: *mut List,
    arg_joinrelids: Relids,
    arg_joinquals: *mut *mut List,
    arg_otherquals: *mut *mut List,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn extract_actual_join_clauses(
                arg_restrictinfo_list: *mut List,
                arg_joinrelids: Relids,
                arg_joinquals: *mut *mut List,
                arg_otherquals: *mut *mut List,
            );
        }
        extract_actual_join_clauses(
            arg_restrictinfo_list,
            arg_joinrelids,
            arg_joinquals,
            arg_otherquals,
        )
    })
}
pub unsafe fn join_clause_is_movable_to(
    arg_rinfo: *mut RestrictInfo,
    arg_baserel: *mut RelOptInfo,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn join_clause_is_movable_to(
                arg_rinfo: *mut RestrictInfo,
                arg_baserel: *mut RelOptInfo,
            ) -> bool;
        }
        join_clause_is_movable_to(arg_rinfo, arg_baserel)
    })
}
pub unsafe fn join_clause_is_movable_into(
    arg_rinfo: *mut RestrictInfo,
    arg_currentrelids: Relids,
    arg_current_and_outer: Relids,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn join_clause_is_movable_into(
                arg_rinfo: *mut RestrictInfo,
                arg_currentrelids: Relids,
                arg_current_and_outer: Relids,
            ) -> bool;
        }
        join_clause_is_movable_into(arg_rinfo, arg_currentrelids, arg_current_and_outer)
    })
}
pub unsafe fn tlist_member(arg_node: *mut Expr, arg_targetlist: *mut List) -> *mut TargetEntry {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tlist_member(arg_node: *mut Expr, arg_targetlist: *mut List) -> *mut TargetEntry;
        }
        tlist_member(arg_node, arg_targetlist)
    })
}
pub unsafe fn tlist_member_ignore_relabel(
    arg_node: *mut Expr,
    arg_targetlist: *mut List,
) -> *mut TargetEntry {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tlist_member_ignore_relabel(
                arg_node: *mut Expr,
                arg_targetlist: *mut List,
            ) -> *mut TargetEntry;
        }
        tlist_member_ignore_relabel(arg_node, arg_targetlist)
    })
}
pub unsafe fn add_to_flat_tlist(arg_tlist: *mut List, arg_exprs: *mut List) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn add_to_flat_tlist(arg_tlist: *mut List, arg_exprs: *mut List) -> *mut List;
        }
        add_to_flat_tlist(arg_tlist, arg_exprs)
    })
}
pub unsafe fn get_tlist_exprs(arg_tlist: *mut List, arg_includeJunk: bool) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_tlist_exprs(arg_tlist: *mut List, arg_includeJunk: bool) -> *mut List;
        }
        get_tlist_exprs(arg_tlist, arg_includeJunk)
    })
}
pub unsafe fn tlist_same_exprs(arg_tlist1: *mut List, arg_tlist2: *mut List) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tlist_same_exprs(arg_tlist1: *mut List, arg_tlist2: *mut List) -> bool;
        }
        tlist_same_exprs(arg_tlist1, arg_tlist2)
    })
}
pub unsafe fn tlist_same_datatypes(
    arg_tlist: *mut List,
    arg_colTypes: *mut List,
    arg_junkOK: bool,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tlist_same_datatypes(
                arg_tlist: *mut List,
                arg_colTypes: *mut List,
                arg_junkOK: bool,
            ) -> bool;
        }
        tlist_same_datatypes(arg_tlist, arg_colTypes, arg_junkOK)
    })
}
pub unsafe fn tlist_same_collations(
    arg_tlist: *mut List,
    arg_colCollations: *mut List,
    arg_junkOK: bool,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tlist_same_collations(
                arg_tlist: *mut List,
                arg_colCollations: *mut List,
                arg_junkOK: bool,
            ) -> bool;
        }
        tlist_same_collations(arg_tlist, arg_colCollations, arg_junkOK)
    })
}
pub unsafe fn apply_tlist_labeling(arg_dest_tlist: *mut List, arg_src_tlist: *mut List) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn apply_tlist_labeling(arg_dest_tlist: *mut List, arg_src_tlist: *mut List);
        }
        apply_tlist_labeling(arg_dest_tlist, arg_src_tlist)
    })
}
pub unsafe fn extract_grouping_ops(arg_groupClause: *mut List) -> *mut Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn extract_grouping_ops(arg_groupClause: *mut List) -> *mut Oid;
        }
        extract_grouping_ops(arg_groupClause)
    })
}
pub unsafe fn extract_grouping_collations(
    arg_groupClause: *mut List,
    arg_tlist: *mut List,
) -> *mut Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn extract_grouping_collations(
                arg_groupClause: *mut List,
                arg_tlist: *mut List,
            ) -> *mut Oid;
        }
        extract_grouping_collations(arg_groupClause, arg_tlist)
    })
}
pub unsafe fn extract_grouping_cols(
    arg_groupClause: *mut List,
    arg_tlist: *mut List,
) -> *mut AttrNumber {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn extract_grouping_cols(
                arg_groupClause: *mut List,
                arg_tlist: *mut List,
            ) -> *mut AttrNumber;
        }
        extract_grouping_cols(arg_groupClause, arg_tlist)
    })
}
pub unsafe fn grouping_is_sortable(arg_groupClause: *mut List) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn grouping_is_sortable(arg_groupClause: *mut List) -> bool;
        }
        grouping_is_sortable(arg_groupClause)
    })
}
pub unsafe fn grouping_is_hashable(arg_groupClause: *mut List) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn grouping_is_hashable(arg_groupClause: *mut List) -> bool;
        }
        grouping_is_hashable(arg_groupClause)
    })
}
pub unsafe fn make_pathtarget_from_tlist(arg_tlist: *mut List) -> *mut PathTarget {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_pathtarget_from_tlist(arg_tlist: *mut List) -> *mut PathTarget;
        }
        make_pathtarget_from_tlist(arg_tlist)
    })
}
pub unsafe fn make_tlist_from_pathtarget(arg_target: *mut PathTarget) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_tlist_from_pathtarget(arg_target: *mut PathTarget) -> *mut List;
        }
        make_tlist_from_pathtarget(arg_target)
    })
}
pub unsafe fn copy_pathtarget(arg_src: *mut PathTarget) -> *mut PathTarget {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn copy_pathtarget(arg_src: *mut PathTarget) -> *mut PathTarget;
        }
        copy_pathtarget(arg_src)
    })
}
pub unsafe fn create_empty_pathtarget() -> *mut PathTarget {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn create_empty_pathtarget() -> *mut PathTarget;
        }
        create_empty_pathtarget()
    })
}
pub unsafe fn add_column_to_pathtarget(
    arg_target: *mut PathTarget,
    arg_expr: *mut Expr,
    arg_sortgroupref: Index,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn add_column_to_pathtarget(
                arg_target: *mut PathTarget,
                arg_expr: *mut Expr,
                arg_sortgroupref: Index,
            );
        }
        add_column_to_pathtarget(arg_target, arg_expr, arg_sortgroupref)
    })
}
pub unsafe fn add_new_column_to_pathtarget(arg_target: *mut PathTarget, arg_expr: *mut Expr) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn add_new_column_to_pathtarget(arg_target: *mut PathTarget, arg_expr: *mut Expr);
        }
        add_new_column_to_pathtarget(arg_target, arg_expr)
    })
}
pub unsafe fn add_new_columns_to_pathtarget(arg_target: *mut PathTarget, arg_exprs: *mut List) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn add_new_columns_to_pathtarget(arg_target: *mut PathTarget, arg_exprs: *mut List);
        }
        add_new_columns_to_pathtarget(arg_target, arg_exprs)
    })
}
pub unsafe fn apply_pathtarget_labeling_to_tlist(
    arg_tlist: *mut List,
    arg_target: *mut PathTarget,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn apply_pathtarget_labeling_to_tlist(
                arg_tlist: *mut List,
                arg_target: *mut PathTarget,
            );
        }
        apply_pathtarget_labeling_to_tlist(arg_tlist, arg_target)
    })
}
pub unsafe fn split_pathtarget_at_srfs(
    arg_root: *mut PlannerInfo,
    arg_target: *mut PathTarget,
    arg_input_target: *mut PathTarget,
    arg_targets: *mut *mut List,
    arg_targets_contain_srfs: *mut *mut List,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn split_pathtarget_at_srfs(
                arg_root: *mut PlannerInfo,
                arg_target: *mut PathTarget,
                arg_input_target: *mut PathTarget,
                arg_targets: *mut *mut List,
                arg_targets_contain_srfs: *mut *mut List,
            );
        }
        split_pathtarget_at_srfs(
            arg_root,
            arg_target,
            arg_input_target,
            arg_targets,
            arg_targets_contain_srfs,
        )
    })
}
pub const FuncDetailCode_FUNCDETAIL_NOTFOUND: FuncDetailCode = 0;
pub const FuncDetailCode_FUNCDETAIL_MULTIPLE: FuncDetailCode = 1;
pub const FuncDetailCode_FUNCDETAIL_NORMAL: FuncDetailCode = 2;
pub const FuncDetailCode_FUNCDETAIL_PROCEDURE: FuncDetailCode = 3;
pub const FuncDetailCode_FUNCDETAIL_AGGREGATE: FuncDetailCode = 4;
pub const FuncDetailCode_FUNCDETAIL_WINDOWFUNC: FuncDetailCode = 5;
pub const FuncDetailCode_FUNCDETAIL_COERCION: FuncDetailCode = 6;
pub type FuncDetailCode = ::std::os::raw::c_uint;
pub unsafe fn ParseFuncOrColumn(
    arg_pstate: *mut ParseState,
    arg_funcname: *mut List,
    arg_fargs: *mut List,
    arg_last_srf: *mut Node,
    arg_fn_: *mut FuncCall,
    arg_proc_call: bool,
    arg_location: ::std::os::raw::c_int,
) -> *mut Node {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ParseFuncOrColumn(
                arg_pstate: *mut ParseState,
                arg_funcname: *mut List,
                arg_fargs: *mut List,
                arg_last_srf: *mut Node,
                arg_fn_: *mut FuncCall,
                arg_proc_call: bool,
                arg_location: ::std::os::raw::c_int,
            ) -> *mut Node;
        }
        ParseFuncOrColumn(
            arg_pstate,
            arg_funcname,
            arg_fargs,
            arg_last_srf,
            arg_fn_,
            arg_proc_call,
            arg_location,
        )
    })
}
pub unsafe fn func_get_detail(
    arg_funcname: *mut List,
    arg_fargs: *mut List,
    arg_fargnames: *mut List,
    arg_nargs: ::std::os::raw::c_int,
    arg_argtypes: *mut Oid,
    arg_expand_variadic: bool,
    arg_expand_defaults: bool,
    arg_funcid: *mut Oid,
    arg_rettype: *mut Oid,
    arg_retset: *mut bool,
    arg_nvargs: *mut ::std::os::raw::c_int,
    arg_vatype: *mut Oid,
    arg_true_typeids: *mut *mut Oid,
    arg_argdefaults: *mut *mut List,
) -> FuncDetailCode {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn func_get_detail(
                arg_funcname: *mut List,
                arg_fargs: *mut List,
                arg_fargnames: *mut List,
                arg_nargs: ::std::os::raw::c_int,
                arg_argtypes: *mut Oid,
                arg_expand_variadic: bool,
                arg_expand_defaults: bool,
                arg_funcid: *mut Oid,
                arg_rettype: *mut Oid,
                arg_retset: *mut bool,
                arg_nvargs: *mut ::std::os::raw::c_int,
                arg_vatype: *mut Oid,
                arg_true_typeids: *mut *mut Oid,
                arg_argdefaults: *mut *mut List,
            ) -> FuncDetailCode;
        }
        func_get_detail(
            arg_funcname,
            arg_fargs,
            arg_fargnames,
            arg_nargs,
            arg_argtypes,
            arg_expand_variadic,
            arg_expand_defaults,
            arg_funcid,
            arg_rettype,
            arg_retset,
            arg_nvargs,
            arg_vatype,
            arg_true_typeids,
            arg_argdefaults,
        )
    })
}
pub unsafe fn func_match_argtypes(
    arg_nargs: ::std::os::raw::c_int,
    arg_input_typeids: *mut Oid,
    arg_raw_candidates: FuncCandidateList,
    arg_candidates: *mut FuncCandidateList,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn func_match_argtypes(
                arg_nargs: ::std::os::raw::c_int,
                arg_input_typeids: *mut Oid,
                arg_raw_candidates: FuncCandidateList,
                arg_candidates: *mut FuncCandidateList,
            ) -> ::std::os::raw::c_int;
        }
        func_match_argtypes(arg_nargs, arg_input_typeids, arg_raw_candidates, arg_candidates)
    })
}
pub unsafe fn func_select_candidate(
    arg_nargs: ::std::os::raw::c_int,
    arg_input_typeids: *mut Oid,
    arg_candidates: FuncCandidateList,
) -> FuncCandidateList {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn func_select_candidate(
                arg_nargs: ::std::os::raw::c_int,
                arg_input_typeids: *mut Oid,
                arg_candidates: FuncCandidateList,
            ) -> FuncCandidateList;
        }
        func_select_candidate(arg_nargs, arg_input_typeids, arg_candidates)
    })
}
pub unsafe fn make_fn_arguments(
    arg_pstate: *mut ParseState,
    arg_fargs: *mut List,
    arg_actual_arg_types: *mut Oid,
    arg_declared_arg_types: *mut Oid,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_fn_arguments(
                arg_pstate: *mut ParseState,
                arg_fargs: *mut List,
                arg_actual_arg_types: *mut Oid,
                arg_declared_arg_types: *mut Oid,
            );
        }
        make_fn_arguments(arg_pstate, arg_fargs, arg_actual_arg_types, arg_declared_arg_types)
    })
}
pub unsafe fn funcname_signature_string(
    arg_funcname: *const ::std::os::raw::c_char,
    arg_nargs: ::std::os::raw::c_int,
    arg_argnames: *mut List,
    arg_argtypes: *const Oid,
) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn funcname_signature_string(
                arg_funcname: *const ::std::os::raw::c_char,
                arg_nargs: ::std::os::raw::c_int,
                arg_argnames: *mut List,
                arg_argtypes: *const Oid,
            ) -> *const ::std::os::raw::c_char;
        }
        funcname_signature_string(arg_funcname, arg_nargs, arg_argnames, arg_argtypes)
    })
}
pub unsafe fn func_signature_string(
    arg_funcname: *mut List,
    arg_nargs: ::std::os::raw::c_int,
    arg_argnames: *mut List,
    arg_argtypes: *const Oid,
) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn func_signature_string(
                arg_funcname: *mut List,
                arg_nargs: ::std::os::raw::c_int,
                arg_argnames: *mut List,
                arg_argtypes: *const Oid,
            ) -> *const ::std::os::raw::c_char;
        }
        func_signature_string(arg_funcname, arg_nargs, arg_argnames, arg_argtypes)
    })
}
pub unsafe fn LookupFuncName(
    arg_funcname: *mut List,
    arg_nargs: ::std::os::raw::c_int,
    arg_argtypes: *const Oid,
    arg_missing_ok: bool,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LookupFuncName(
                arg_funcname: *mut List,
                arg_nargs: ::std::os::raw::c_int,
                arg_argtypes: *const Oid,
                arg_missing_ok: bool,
            ) -> Oid;
        }
        LookupFuncName(arg_funcname, arg_nargs, arg_argtypes, arg_missing_ok)
    })
}
pub unsafe fn LookupFuncWithArgs(
    arg_objtype: ObjectType,
    arg_func: *mut ObjectWithArgs,
    arg_missing_ok: bool,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LookupFuncWithArgs(
                arg_objtype: ObjectType,
                arg_func: *mut ObjectWithArgs,
                arg_missing_ok: bool,
            ) -> Oid;
        }
        LookupFuncWithArgs(arg_objtype, arg_func, arg_missing_ok)
    })
}
pub unsafe fn check_srf_call_placement(
    arg_pstate: *mut ParseState,
    arg_last_srf: *mut Node,
    arg_location: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn check_srf_call_placement(
                arg_pstate: *mut ParseState,
                arg_last_srf: *mut Node,
                arg_location: ::std::os::raw::c_int,
            );
        }
        check_srf_call_placement(arg_pstate, arg_last_srf, arg_location)
    })
}
pub type Operator = HeapTuple;
pub unsafe fn LookupOperName(
    arg_pstate: *mut ParseState,
    arg_opername: *mut List,
    arg_oprleft: Oid,
    arg_oprright: Oid,
    arg_noError: bool,
    arg_location: ::std::os::raw::c_int,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LookupOperName(
                arg_pstate: *mut ParseState,
                arg_opername: *mut List,
                arg_oprleft: Oid,
                arg_oprright: Oid,
                arg_noError: bool,
                arg_location: ::std::os::raw::c_int,
            ) -> Oid;
        }
        LookupOperName(
            arg_pstate,
            arg_opername,
            arg_oprleft,
            arg_oprright,
            arg_noError,
            arg_location,
        )
    })
}
pub unsafe fn LookupOperWithArgs(arg_oper: *mut ObjectWithArgs, arg_noError: bool) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LookupOperWithArgs(arg_oper: *mut ObjectWithArgs, arg_noError: bool) -> Oid;
        }
        LookupOperWithArgs(arg_oper, arg_noError)
    })
}
pub unsafe fn oper(
    arg_pstate: *mut ParseState,
    arg_op: *mut List,
    arg_arg1: Oid,
    arg_arg2: Oid,
    arg_noError: bool,
    arg_location: ::std::os::raw::c_int,
) -> Operator {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn oper(
                arg_pstate: *mut ParseState,
                arg_op: *mut List,
                arg_arg1: Oid,
                arg_arg2: Oid,
                arg_noError: bool,
                arg_location: ::std::os::raw::c_int,
            ) -> Operator;
        }
        oper(arg_pstate, arg_op, arg_arg1, arg_arg2, arg_noError, arg_location)
    })
}
pub unsafe fn right_oper(
    arg_pstate: *mut ParseState,
    arg_op: *mut List,
    arg_arg: Oid,
    arg_noError: bool,
    arg_location: ::std::os::raw::c_int,
) -> Operator {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn right_oper(
                arg_pstate: *mut ParseState,
                arg_op: *mut List,
                arg_arg: Oid,
                arg_noError: bool,
                arg_location: ::std::os::raw::c_int,
            ) -> Operator;
        }
        right_oper(arg_pstate, arg_op, arg_arg, arg_noError, arg_location)
    })
}
pub unsafe fn left_oper(
    arg_pstate: *mut ParseState,
    arg_op: *mut List,
    arg_arg: Oid,
    arg_noError: bool,
    arg_location: ::std::os::raw::c_int,
) -> Operator {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn left_oper(
                arg_pstate: *mut ParseState,
                arg_op: *mut List,
                arg_arg: Oid,
                arg_noError: bool,
                arg_location: ::std::os::raw::c_int,
            ) -> Operator;
        }
        left_oper(arg_pstate, arg_op, arg_arg, arg_noError, arg_location)
    })
}
pub unsafe fn compatible_oper(
    arg_pstate: *mut ParseState,
    arg_op: *mut List,
    arg_arg1: Oid,
    arg_arg2: Oid,
    arg_noError: bool,
    arg_location: ::std::os::raw::c_int,
) -> Operator {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn compatible_oper(
                arg_pstate: *mut ParseState,
                arg_op: *mut List,
                arg_arg1: Oid,
                arg_arg2: Oid,
                arg_noError: bool,
                arg_location: ::std::os::raw::c_int,
            ) -> Operator;
        }
        compatible_oper(arg_pstate, arg_op, arg_arg1, arg_arg2, arg_noError, arg_location)
    })
}
pub unsafe fn get_sort_group_operators(
    arg_argtype: Oid,
    arg_needLT: bool,
    arg_needEQ: bool,
    arg_needGT: bool,
    arg_ltOpr: *mut Oid,
    arg_eqOpr: *mut Oid,
    arg_gtOpr: *mut Oid,
    arg_isHashable: *mut bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_sort_group_operators(
                arg_argtype: Oid,
                arg_needLT: bool,
                arg_needEQ: bool,
                arg_needGT: bool,
                arg_ltOpr: *mut Oid,
                arg_eqOpr: *mut Oid,
                arg_gtOpr: *mut Oid,
                arg_isHashable: *mut bool,
            );
        }
        get_sort_group_operators(
            arg_argtype,
            arg_needLT,
            arg_needEQ,
            arg_needGT,
            arg_ltOpr,
            arg_eqOpr,
            arg_gtOpr,
            arg_isHashable,
        )
    })
}
pub unsafe fn compatible_oper_opid(
    arg_op: *mut List,
    arg_arg1: Oid,
    arg_arg2: Oid,
    arg_noError: bool,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn compatible_oper_opid(
                arg_op: *mut List,
                arg_arg1: Oid,
                arg_arg2: Oid,
                arg_noError: bool,
            ) -> Oid;
        }
        compatible_oper_opid(arg_op, arg_arg1, arg_arg2, arg_noError)
    })
}
pub unsafe fn oprid(arg_op: Operator) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn oprid(arg_op: Operator) -> Oid;
        }
        oprid(arg_op)
    })
}
pub unsafe fn oprfuncid(arg_op: Operator) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn oprfuncid(arg_op: Operator) -> Oid;
        }
        oprfuncid(arg_op)
    })
}
pub unsafe fn make_op(
    arg_pstate: *mut ParseState,
    arg_opname: *mut List,
    arg_ltree: *mut Node,
    arg_rtree: *mut Node,
    arg_last_srf: *mut Node,
    arg_location: ::std::os::raw::c_int,
) -> *mut Expr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_op(
                arg_pstate: *mut ParseState,
                arg_opname: *mut List,
                arg_ltree: *mut Node,
                arg_rtree: *mut Node,
                arg_last_srf: *mut Node,
                arg_location: ::std::os::raw::c_int,
            ) -> *mut Expr;
        }
        make_op(arg_pstate, arg_opname, arg_ltree, arg_rtree, arg_last_srf, arg_location)
    })
}
pub unsafe fn make_scalar_array_op(
    arg_pstate: *mut ParseState,
    arg_opname: *mut List,
    arg_useOr: bool,
    arg_ltree: *mut Node,
    arg_rtree: *mut Node,
    arg_location: ::std::os::raw::c_int,
) -> *mut Expr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_scalar_array_op(
                arg_pstate: *mut ParseState,
                arg_opname: *mut List,
                arg_useOr: bool,
                arg_ltree: *mut Node,
                arg_rtree: *mut Node,
                arg_location: ::std::os::raw::c_int,
            ) -> *mut Expr;
        }
        make_scalar_array_op(arg_pstate, arg_opname, arg_useOr, arg_ltree, arg_rtree, arg_location)
    })
}
pub type Type = HeapTuple;
pub unsafe fn LookupTypeName(
    arg_pstate: *mut ParseState,
    arg_typeName: *const TypeName,
    arg_typmod_p: *mut int32,
    arg_missing_ok: bool,
) -> Type {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LookupTypeName(
                arg_pstate: *mut ParseState,
                arg_typeName: *const TypeName,
                arg_typmod_p: *mut int32,
                arg_missing_ok: bool,
            ) -> Type;
        }
        LookupTypeName(arg_pstate, arg_typeName, arg_typmod_p, arg_missing_ok)
    })
}
pub unsafe fn LookupTypeNameExtended(
    arg_pstate: *mut ParseState,
    arg_typeName: *const TypeName,
    arg_typmod_p: *mut int32,
    arg_temp_ok: bool,
    arg_missing_ok: bool,
) -> Type {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LookupTypeNameExtended(
                arg_pstate: *mut ParseState,
                arg_typeName: *const TypeName,
                arg_typmod_p: *mut int32,
                arg_temp_ok: bool,
                arg_missing_ok: bool,
            ) -> Type;
        }
        LookupTypeNameExtended(arg_pstate, arg_typeName, arg_typmod_p, arg_temp_ok, arg_missing_ok)
    })
}
pub unsafe fn LookupTypeNameOid(
    arg_pstate: *mut ParseState,
    arg_typeName: *const TypeName,
    arg_missing_ok: bool,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LookupTypeNameOid(
                arg_pstate: *mut ParseState,
                arg_typeName: *const TypeName,
                arg_missing_ok: bool,
            ) -> Oid;
        }
        LookupTypeNameOid(arg_pstate, arg_typeName, arg_missing_ok)
    })
}
pub unsafe fn typenameType(
    arg_pstate: *mut ParseState,
    arg_typeName: *const TypeName,
    arg_typmod_p: *mut int32,
) -> Type {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn typenameType(
                arg_pstate: *mut ParseState,
                arg_typeName: *const TypeName,
                arg_typmod_p: *mut int32,
            ) -> Type;
        }
        typenameType(arg_pstate, arg_typeName, arg_typmod_p)
    })
}
pub unsafe fn typenameTypeId(arg_pstate: *mut ParseState, arg_typeName: *const TypeName) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn typenameTypeId(arg_pstate: *mut ParseState, arg_typeName: *const TypeName) -> Oid;
        }
        typenameTypeId(arg_pstate, arg_typeName)
    })
}
pub unsafe fn typenameTypeIdAndMod(
    arg_pstate: *mut ParseState,
    arg_typeName: *const TypeName,
    arg_typeid_p: *mut Oid,
    arg_typmod_p: *mut int32,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn typenameTypeIdAndMod(
                arg_pstate: *mut ParseState,
                arg_typeName: *const TypeName,
                arg_typeid_p: *mut Oid,
                arg_typmod_p: *mut int32,
            );
        }
        typenameTypeIdAndMod(arg_pstate, arg_typeName, arg_typeid_p, arg_typmod_p)
    })
}
pub unsafe fn TypeNameToString(arg_typeName: *const TypeName) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TypeNameToString(arg_typeName: *const TypeName) -> *mut ::std::os::raw::c_char;
        }
        TypeNameToString(arg_typeName)
    })
}
pub unsafe fn TypeNameListToString(arg_typenames: *mut List) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TypeNameListToString(arg_typenames: *mut List) -> *mut ::std::os::raw::c_char;
        }
        TypeNameListToString(arg_typenames)
    })
}
pub unsafe fn LookupCollation(
    arg_pstate: *mut ParseState,
    arg_collnames: *mut List,
    arg_location: ::std::os::raw::c_int,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LookupCollation(
                arg_pstate: *mut ParseState,
                arg_collnames: *mut List,
                arg_location: ::std::os::raw::c_int,
            ) -> Oid;
        }
        LookupCollation(arg_pstate, arg_collnames, arg_location)
    })
}
pub unsafe fn GetColumnDefCollation(
    arg_pstate: *mut ParseState,
    arg_coldef: *mut ColumnDef,
    arg_typeOid: Oid,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetColumnDefCollation(
                arg_pstate: *mut ParseState,
                arg_coldef: *mut ColumnDef,
                arg_typeOid: Oid,
            ) -> Oid;
        }
        GetColumnDefCollation(arg_pstate, arg_coldef, arg_typeOid)
    })
}
pub unsafe fn typeidType(arg_id: Oid) -> Type {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn typeidType(arg_id: Oid) -> Type;
        }
        typeidType(arg_id)
    })
}
pub unsafe fn typeTypeId(arg_tp: Type) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn typeTypeId(arg_tp: Type) -> Oid;
        }
        typeTypeId(arg_tp)
    })
}
pub unsafe fn typeLen(arg_t: Type) -> int16 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn typeLen(arg_t: Type) -> int16;
        }
        typeLen(arg_t)
    })
}
pub unsafe fn typeByVal(arg_t: Type) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn typeByVal(arg_t: Type) -> bool;
        }
        typeByVal(arg_t)
    })
}
pub unsafe fn typeTypeName(arg_t: Type) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn typeTypeName(arg_t: Type) -> *mut ::std::os::raw::c_char;
        }
        typeTypeName(arg_t)
    })
}
pub unsafe fn typeTypeRelid(arg_typ: Type) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn typeTypeRelid(arg_typ: Type) -> Oid;
        }
        typeTypeRelid(arg_typ)
    })
}
pub unsafe fn typeTypeCollation(arg_typ: Type) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn typeTypeCollation(arg_typ: Type) -> Oid;
        }
        typeTypeCollation(arg_typ)
    })
}
pub unsafe fn stringTypeDatum(
    arg_tp: Type,
    arg_string: *mut ::std::os::raw::c_char,
    arg_atttypmod: int32,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn stringTypeDatum(
                arg_tp: Type,
                arg_string: *mut ::std::os::raw::c_char,
                arg_atttypmod: int32,
            ) -> Datum;
        }
        stringTypeDatum(arg_tp, arg_string, arg_atttypmod)
    })
}
pub unsafe fn typeidTypeRelid(arg_type_id: Oid) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn typeidTypeRelid(arg_type_id: Oid) -> Oid;
        }
        typeidTypeRelid(arg_type_id)
    })
}
pub unsafe fn typeOrDomainTypeRelid(arg_type_id: Oid) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn typeOrDomainTypeRelid(arg_type_id: Oid) -> Oid;
        }
        typeOrDomainTypeRelid(arg_type_id)
    })
}
pub unsafe fn typeStringToTypeName(arg_str_: *const ::std::os::raw::c_char) -> *mut TypeName {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn typeStringToTypeName(arg_str_: *const ::std::os::raw::c_char) -> *mut TypeName;
        }
        typeStringToTypeName(arg_str_)
    })
}
pub unsafe fn parseTypeString(
    arg_str_: *const ::std::os::raw::c_char,
    arg_typeid_p: *mut Oid,
    arg_typmod_p: *mut int32,
    arg_missing_ok: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn parseTypeString(
                arg_str_: *const ::std::os::raw::c_char,
                arg_typeid_p: *mut Oid,
                arg_typmod_p: *mut int32,
                arg_missing_ok: bool,
            );
        }
        parseTypeString(arg_str_, arg_typeid_p, arg_typmod_p, arg_missing_ok)
    })
}
pub const BackslashQuoteType_BACKSLASH_QUOTE_OFF: BackslashQuoteType = 0;
pub const BackslashQuoteType_BACKSLASH_QUOTE_ON: BackslashQuoteType = 1;
pub const BackslashQuoteType_BACKSLASH_QUOTE_SAFE_ENCODING: BackslashQuoteType = 2;
pub type BackslashQuoteType = ::std::os::raw::c_uint;
extern "C" {
    pub static mut backslash_quote: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut escape_string_warning: bool;
}
extern "C" {
    pub static mut standard_conforming_strings: bool;
}
pub unsafe fn raw_parser(arg_str_: *const ::std::os::raw::c_char) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn raw_parser(arg_str_: *const ::std::os::raw::c_char) -> *mut List;
        }
        raw_parser(arg_str_)
    })
}
pub unsafe fn SystemFuncName(arg_name: *mut ::std::os::raw::c_char) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SystemFuncName(arg_name: *mut ::std::os::raw::c_char) -> *mut List;
        }
        SystemFuncName(arg_name)
    })
}
pub unsafe fn SystemTypeName(arg_name: *mut ::std::os::raw::c_char) -> *mut TypeName {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SystemTypeName(arg_name: *mut ::std::os::raw::c_char) -> *mut TypeName;
        }
        SystemTypeName(arg_name)
    })
}
pub unsafe fn get_rte_attribute_name(
    arg_rte: *mut RangeTblEntry,
    arg_attnum: AttrNumber,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_rte_attribute_name(
                arg_rte: *mut RangeTblEntry,
                arg_attnum: AttrNumber,
            ) -> *mut ::std::os::raw::c_char;
        }
        get_rte_attribute_name(arg_rte, arg_attnum)
    })
}
pub unsafe fn get_rte_attribute_is_dropped(
    arg_rte: *mut RangeTblEntry,
    arg_attnum: AttrNumber,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_rte_attribute_is_dropped(
                arg_rte: *mut RangeTblEntry,
                arg_attnum: AttrNumber,
            ) -> bool;
        }
        get_rte_attribute_is_dropped(arg_rte, arg_attnum)
    })
}
pub unsafe fn get_tle_by_resno(arg_tlist: *mut List, arg_resno: AttrNumber) -> *mut TargetEntry {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_tle_by_resno(arg_tlist: *mut List, arg_resno: AttrNumber) -> *mut TargetEntry;
        }
        get_tle_by_resno(arg_tlist, arg_resno)
    })
}
pub unsafe fn get_parse_rowmark(arg_qry: *mut Query, arg_rtindex: Index) -> *mut RowMarkClause {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_parse_rowmark(arg_qry: *mut Query, arg_rtindex: Index) -> *mut RowMarkClause;
        }
        get_parse_rowmark(arg_qry, arg_rtindex)
    })
}
extern "C" {
    pub static mut logical_decoding_work_mem: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReorderBufferTupleBuf {
    pub node: slist_node,
    pub tuple: HeapTupleData,
    pub alloc_tuple_size: Size,
}
impl Default for ReorderBufferTupleBuf {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_INSERT: ReorderBufferChangeType = 0;
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_UPDATE: ReorderBufferChangeType = 1;
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_DELETE: ReorderBufferChangeType = 2;
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_MESSAGE: ReorderBufferChangeType = 3;
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT: ReorderBufferChangeType =
    4;
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID:
    ReorderBufferChangeType = 5;
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID: ReorderBufferChangeType =
    6;
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_INTERNAL_SPEC_INSERT:
    ReorderBufferChangeType = 7;
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_INTERNAL_SPEC_CONFIRM:
    ReorderBufferChangeType = 8;
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_TRUNCATE: ReorderBufferChangeType = 9;
pub const ReorderBufferChangeType_REORDER_BUFFER_CHANGE_INTERNAL_SPEC_ABORT:
    ReorderBufferChangeType = 10;
pub type ReorderBufferChangeType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ReorderBufferChange {
    pub lsn: XLogRecPtr,
    pub action: ReorderBufferChangeType,
    pub txn: *mut ReorderBufferTXN,
    pub origin_id: RepOriginId,
    pub data: ReorderBufferChange__bindgen_ty_1,
    pub node: dlist_node,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ReorderBufferChange__bindgen_ty_1 {
    pub tp: ReorderBufferChange__bindgen_ty_1__bindgen_ty_1,
    pub truncate: ReorderBufferChange__bindgen_ty_1__bindgen_ty_2,
    pub msg: ReorderBufferChange__bindgen_ty_1__bindgen_ty_3,
    pub snapshot: Snapshot,
    pub command_id: CommandId,
    pub tuplecid: ReorderBufferChange__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReorderBufferChange__bindgen_ty_1__bindgen_ty_1 {
    pub relnode: RelFileNode,
    pub clear_toast_afterwards: bool,
    pub oldtuple: *mut ReorderBufferTupleBuf,
    pub newtuple: *mut ReorderBufferTupleBuf,
}
impl Default for ReorderBufferChange__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReorderBufferChange__bindgen_ty_1__bindgen_ty_2 {
    pub nrelids: Size,
    pub cascade: bool,
    pub restart_seqs: bool,
    pub relids: *mut Oid,
}
impl Default for ReorderBufferChange__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReorderBufferChange__bindgen_ty_1__bindgen_ty_3 {
    pub prefix: *mut ::std::os::raw::c_char,
    pub message_size: Size,
    pub message: *mut ::std::os::raw::c_char,
}
impl Default for ReorderBufferChange__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ReorderBufferChange__bindgen_ty_1__bindgen_ty_4 {
    pub node: RelFileNode,
    pub tid: ItemPointerData,
    pub cmin: CommandId,
    pub cmax: CommandId,
    pub combocid: CommandId,
}
impl Default for ReorderBufferChange__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ReorderBufferChange {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReorderBufferTXN {
    pub txn_flags: bits32,
    pub xid: TransactionId,
    pub toplevel_xid: TransactionId,
    pub first_lsn: XLogRecPtr,
    pub final_lsn: XLogRecPtr,
    pub end_lsn: XLogRecPtr,
    pub restart_decoding_lsn: XLogRecPtr,
    pub origin_id: RepOriginId,
    pub origin_lsn: XLogRecPtr,
    pub commit_time: TimestampTz,
    pub base_snapshot: Snapshot,
    pub base_snapshot_lsn: XLogRecPtr,
    pub base_snapshot_node: dlist_node,
    pub nentries: uint64,
    pub nentries_mem: uint64,
    pub changes: dlist_head,
    pub tuplecids: dlist_head,
    pub ntuplecids: uint64,
    pub tuplecid_hash: *mut HTAB,
    pub toast_hash: *mut HTAB,
    pub subtxns: dlist_head,
    pub nsubtxns: uint32,
    pub ninvalidations: uint32,
    pub invalidations: *mut SharedInvalidationMessage,
    pub node: dlist_node,
    pub size: Size,
}
impl Default for ReorderBufferTXN {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ReorderBufferApplyChangeCB = ::std::option::Option<
    unsafe extern "C" fn(
        rb: *mut ReorderBuffer,
        txn: *mut ReorderBufferTXN,
        relation: Relation,
        change: *mut ReorderBufferChange,
    ),
>;
pub type ReorderBufferApplyTruncateCB = ::std::option::Option<
    unsafe extern "C" fn(
        rb: *mut ReorderBuffer,
        txn: *mut ReorderBufferTXN,
        nrelations: ::std::os::raw::c_int,
        relations: *mut Relation,
        change: *mut ReorderBufferChange,
    ),
>;
pub type ReorderBufferBeginCB =
    ::std::option::Option<unsafe extern "C" fn(rb: *mut ReorderBuffer, txn: *mut ReorderBufferTXN)>;
pub type ReorderBufferCommitCB = ::std::option::Option<
    unsafe extern "C" fn(
        rb: *mut ReorderBuffer,
        txn: *mut ReorderBufferTXN,
        commit_lsn: XLogRecPtr,
    ),
>;
pub type ReorderBufferMessageCB = ::std::option::Option<
    unsafe extern "C" fn(
        rb: *mut ReorderBuffer,
        txn: *mut ReorderBufferTXN,
        message_lsn: XLogRecPtr,
        transactional: bool,
        prefix: *const ::std::os::raw::c_char,
        sz: Size,
        message: *const ::std::os::raw::c_char,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReorderBuffer {
    pub by_txn: *mut HTAB,
    pub toplevel_by_lsn: dlist_head,
    pub txns_by_base_snapshot_lsn: dlist_head,
    pub by_txn_last_xid: TransactionId,
    pub by_txn_last_txn: *mut ReorderBufferTXN,
    pub begin: ReorderBufferBeginCB,
    pub apply_change: ReorderBufferApplyChangeCB,
    pub apply_truncate: ReorderBufferApplyTruncateCB,
    pub commit: ReorderBufferCommitCB,
    pub message: ReorderBufferMessageCB,
    pub private_data: *mut ::std::os::raw::c_void,
    pub output_rewrites: bool,
    pub context: MemoryContext,
    pub change_context: MemoryContext,
    pub txn_context: MemoryContext,
    pub tup_context: MemoryContext,
    pub current_restart_decoding_lsn: XLogRecPtr,
    pub outbuf: *mut ::std::os::raw::c_char,
    pub outbufsize: Size,
    pub size: Size,
}
impl Default for ReorderBuffer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn ReorderBufferAllocate() -> *mut ReorderBuffer {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReorderBufferAllocate() -> *mut ReorderBuffer;
        }
        ReorderBufferAllocate()
    })
}
pub unsafe fn ReorderBufferFree(arg_arg1: *mut ReorderBuffer) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReorderBufferFree(arg_arg1: *mut ReorderBuffer);
        }
        ReorderBufferFree(arg_arg1)
    })
}
pub unsafe fn ReorderBufferGetTupleBuf(
    arg_arg1: *mut ReorderBuffer,
    arg_tuple_len: Size,
) -> *mut ReorderBufferTupleBuf {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReorderBufferGetTupleBuf(
                arg_arg1: *mut ReorderBuffer,
                arg_tuple_len: Size,
            ) -> *mut ReorderBufferTupleBuf;
        }
        ReorderBufferGetTupleBuf(arg_arg1, arg_tuple_len)
    })
}
pub unsafe fn ReorderBufferReturnTupleBuf(
    arg_arg1: *mut ReorderBuffer,
    arg_tuple: *mut ReorderBufferTupleBuf,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReorderBufferReturnTupleBuf(
                arg_arg1: *mut ReorderBuffer,
                arg_tuple: *mut ReorderBufferTupleBuf,
            );
        }
        ReorderBufferReturnTupleBuf(arg_arg1, arg_tuple)
    })
}
pub unsafe fn ReorderBufferGetChange(arg_arg1: *mut ReorderBuffer) -> *mut ReorderBufferChange {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReorderBufferGetChange(arg_arg1: *mut ReorderBuffer) -> *mut ReorderBufferChange;
        }
        ReorderBufferGetChange(arg_arg1)
    })
}
pub unsafe fn ReorderBufferReturnChange(
    arg_arg1: *mut ReorderBuffer,
    arg_arg2: *mut ReorderBufferChange,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReorderBufferReturnChange(
                arg_arg1: *mut ReorderBuffer,
                arg_arg2: *mut ReorderBufferChange,
            );
        }
        ReorderBufferReturnChange(arg_arg1, arg_arg2)
    })
}
pub unsafe fn ReorderBufferGetRelids(
    arg_arg1: *mut ReorderBuffer,
    arg_nrelids: ::std::os::raw::c_int,
) -> *mut Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReorderBufferGetRelids(
                arg_arg1: *mut ReorderBuffer,
                arg_nrelids: ::std::os::raw::c_int,
            ) -> *mut Oid;
        }
        ReorderBufferGetRelids(arg_arg1, arg_nrelids)
    })
}
pub unsafe fn ReorderBufferReturnRelids(arg_arg1: *mut ReorderBuffer, arg_relids: *mut Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReorderBufferReturnRelids(arg_arg1: *mut ReorderBuffer, arg_relids: *mut Oid);
        }
        ReorderBufferReturnRelids(arg_arg1, arg_relids)
    })
}
pub unsafe fn ReorderBufferQueueChange(
    arg_arg1: *mut ReorderBuffer,
    arg_arg2: TransactionId,
    arg_lsn: XLogRecPtr,
    arg_arg3: *mut ReorderBufferChange,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReorderBufferQueueChange(
                arg_arg1: *mut ReorderBuffer,
                arg_arg2: TransactionId,
                arg_lsn: XLogRecPtr,
                arg_arg3: *mut ReorderBufferChange,
            );
        }
        ReorderBufferQueueChange(arg_arg1, arg_arg2, arg_lsn, arg_arg3)
    })
}
pub unsafe fn ReorderBufferQueueMessage(
    arg_arg1: *mut ReorderBuffer,
    arg_arg2: TransactionId,
    arg_snapshot: Snapshot,
    arg_lsn: XLogRecPtr,
    arg_transactional: bool,
    arg_prefix: *const ::std::os::raw::c_char,
    arg_message_size: Size,
    arg_message: *const ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReorderBufferQueueMessage(
                arg_arg1: *mut ReorderBuffer,
                arg_arg2: TransactionId,
                arg_snapshot: Snapshot,
                arg_lsn: XLogRecPtr,
                arg_transactional: bool,
                arg_prefix: *const ::std::os::raw::c_char,
                arg_message_size: Size,
                arg_message: *const ::std::os::raw::c_char,
            );
        }
        ReorderBufferQueueMessage(
            arg_arg1,
            arg_arg2,
            arg_snapshot,
            arg_lsn,
            arg_transactional,
            arg_prefix,
            arg_message_size,
            arg_message,
        )
    })
}
pub unsafe fn ReorderBufferCommit(
    arg_arg1: *mut ReorderBuffer,
    arg_arg2: TransactionId,
    arg_commit_lsn: XLogRecPtr,
    arg_end_lsn: XLogRecPtr,
    arg_commit_time: TimestampTz,
    arg_origin_id: RepOriginId,
    arg_origin_lsn: XLogRecPtr,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReorderBufferCommit(
                arg_arg1: *mut ReorderBuffer,
                arg_arg2: TransactionId,
                arg_commit_lsn: XLogRecPtr,
                arg_end_lsn: XLogRecPtr,
                arg_commit_time: TimestampTz,
                arg_origin_id: RepOriginId,
                arg_origin_lsn: XLogRecPtr,
            );
        }
        ReorderBufferCommit(
            arg_arg1,
            arg_arg2,
            arg_commit_lsn,
            arg_end_lsn,
            arg_commit_time,
            arg_origin_id,
            arg_origin_lsn,
        )
    })
}
pub unsafe fn ReorderBufferAssignChild(
    arg_arg1: *mut ReorderBuffer,
    arg_arg2: TransactionId,
    arg_arg3: TransactionId,
    arg_commit_lsn: XLogRecPtr,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReorderBufferAssignChild(
                arg_arg1: *mut ReorderBuffer,
                arg_arg2: TransactionId,
                arg_arg3: TransactionId,
                arg_commit_lsn: XLogRecPtr,
            );
        }
        ReorderBufferAssignChild(arg_arg1, arg_arg2, arg_arg3, arg_commit_lsn)
    })
}
pub unsafe fn ReorderBufferCommitChild(
    arg_arg1: *mut ReorderBuffer,
    arg_arg2: TransactionId,
    arg_arg3: TransactionId,
    arg_commit_lsn: XLogRecPtr,
    arg_end_lsn: XLogRecPtr,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReorderBufferCommitChild(
                arg_arg1: *mut ReorderBuffer,
                arg_arg2: TransactionId,
                arg_arg3: TransactionId,
                arg_commit_lsn: XLogRecPtr,
                arg_end_lsn: XLogRecPtr,
            );
        }
        ReorderBufferCommitChild(arg_arg1, arg_arg2, arg_arg3, arg_commit_lsn, arg_end_lsn)
    })
}
pub unsafe fn ReorderBufferAbort(
    arg_arg1: *mut ReorderBuffer,
    arg_arg2: TransactionId,
    arg_lsn: XLogRecPtr,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReorderBufferAbort(
                arg_arg1: *mut ReorderBuffer,
                arg_arg2: TransactionId,
                arg_lsn: XLogRecPtr,
            );
        }
        ReorderBufferAbort(arg_arg1, arg_arg2, arg_lsn)
    })
}
pub unsafe fn ReorderBufferAbortOld(arg_arg1: *mut ReorderBuffer, arg_xid: TransactionId) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReorderBufferAbortOld(arg_arg1: *mut ReorderBuffer, arg_xid: TransactionId);
        }
        ReorderBufferAbortOld(arg_arg1, arg_xid)
    })
}
pub unsafe fn ReorderBufferForget(
    arg_arg1: *mut ReorderBuffer,
    arg_arg2: TransactionId,
    arg_lsn: XLogRecPtr,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReorderBufferForget(
                arg_arg1: *mut ReorderBuffer,
                arg_arg2: TransactionId,
                arg_lsn: XLogRecPtr,
            );
        }
        ReorderBufferForget(arg_arg1, arg_arg2, arg_lsn)
    })
}
pub unsafe fn ReorderBufferSetBaseSnapshot(
    arg_arg1: *mut ReorderBuffer,
    arg_arg2: TransactionId,
    arg_lsn: XLogRecPtr,
    arg_snap: *mut SnapshotData,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReorderBufferSetBaseSnapshot(
                arg_arg1: *mut ReorderBuffer,
                arg_arg2: TransactionId,
                arg_lsn: XLogRecPtr,
                arg_snap: *mut SnapshotData,
            );
        }
        ReorderBufferSetBaseSnapshot(arg_arg1, arg_arg2, arg_lsn, arg_snap)
    })
}
pub unsafe fn ReorderBufferAddSnapshot(
    arg_arg1: *mut ReorderBuffer,
    arg_arg2: TransactionId,
    arg_lsn: XLogRecPtr,
    arg_snap: *mut SnapshotData,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReorderBufferAddSnapshot(
                arg_arg1: *mut ReorderBuffer,
                arg_arg2: TransactionId,
                arg_lsn: XLogRecPtr,
                arg_snap: *mut SnapshotData,
            );
        }
        ReorderBufferAddSnapshot(arg_arg1, arg_arg2, arg_lsn, arg_snap)
    })
}
pub unsafe fn ReorderBufferAddNewCommandId(
    arg_arg1: *mut ReorderBuffer,
    arg_arg2: TransactionId,
    arg_lsn: XLogRecPtr,
    arg_cid: CommandId,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReorderBufferAddNewCommandId(
                arg_arg1: *mut ReorderBuffer,
                arg_arg2: TransactionId,
                arg_lsn: XLogRecPtr,
                arg_cid: CommandId,
            );
        }
        ReorderBufferAddNewCommandId(arg_arg1, arg_arg2, arg_lsn, arg_cid)
    })
}
pub unsafe fn ReorderBufferAddNewTupleCids(
    arg_arg1: *mut ReorderBuffer,
    arg_arg2: TransactionId,
    arg_lsn: XLogRecPtr,
    arg_node: RelFileNode,
    arg_pt: ItemPointerData,
    arg_cmin: CommandId,
    arg_cmax: CommandId,
    arg_combocid: CommandId,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReorderBufferAddNewTupleCids(
                arg_arg1: *mut ReorderBuffer,
                arg_arg2: TransactionId,
                arg_lsn: XLogRecPtr,
                arg_node: RelFileNode,
                arg_pt: ItemPointerData,
                arg_cmin: CommandId,
                arg_cmax: CommandId,
                arg_combocid: CommandId,
            );
        }
        ReorderBufferAddNewTupleCids(
            arg_arg1,
            arg_arg2,
            arg_lsn,
            arg_node,
            arg_pt,
            arg_cmin,
            arg_cmax,
            arg_combocid,
        )
    })
}
pub unsafe fn ReorderBufferAddInvalidations(
    arg_arg1: *mut ReorderBuffer,
    arg_arg2: TransactionId,
    arg_lsn: XLogRecPtr,
    arg_nmsgs: Size,
    arg_msgs: *mut SharedInvalidationMessage,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReorderBufferAddInvalidations(
                arg_arg1: *mut ReorderBuffer,
                arg_arg2: TransactionId,
                arg_lsn: XLogRecPtr,
                arg_nmsgs: Size,
                arg_msgs: *mut SharedInvalidationMessage,
            );
        }
        ReorderBufferAddInvalidations(arg_arg1, arg_arg2, arg_lsn, arg_nmsgs, arg_msgs)
    })
}
pub unsafe fn ReorderBufferImmediateInvalidation(
    arg_arg1: *mut ReorderBuffer,
    arg_ninvalidations: uint32,
    arg_invalidations: *mut SharedInvalidationMessage,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReorderBufferImmediateInvalidation(
                arg_arg1: *mut ReorderBuffer,
                arg_ninvalidations: uint32,
                arg_invalidations: *mut SharedInvalidationMessage,
            );
        }
        ReorderBufferImmediateInvalidation(arg_arg1, arg_ninvalidations, arg_invalidations)
    })
}
pub unsafe fn ReorderBufferProcessXid(
    arg_arg1: *mut ReorderBuffer,
    arg_xid: TransactionId,
    arg_lsn: XLogRecPtr,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReorderBufferProcessXid(
                arg_arg1: *mut ReorderBuffer,
                arg_xid: TransactionId,
                arg_lsn: XLogRecPtr,
            );
        }
        ReorderBufferProcessXid(arg_arg1, arg_xid, arg_lsn)
    })
}
pub unsafe fn ReorderBufferXidSetCatalogChanges(
    arg_arg1: *mut ReorderBuffer,
    arg_xid: TransactionId,
    arg_lsn: XLogRecPtr,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReorderBufferXidSetCatalogChanges(
                arg_arg1: *mut ReorderBuffer,
                arg_xid: TransactionId,
                arg_lsn: XLogRecPtr,
            );
        }
        ReorderBufferXidSetCatalogChanges(arg_arg1, arg_xid, arg_lsn)
    })
}
pub unsafe fn ReorderBufferXidHasCatalogChanges(
    arg_arg1: *mut ReorderBuffer,
    arg_xid: TransactionId,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReorderBufferXidHasCatalogChanges(
                arg_arg1: *mut ReorderBuffer,
                arg_xid: TransactionId,
            ) -> bool;
        }
        ReorderBufferXidHasCatalogChanges(arg_arg1, arg_xid)
    })
}
pub unsafe fn ReorderBufferXidHasBaseSnapshot(
    arg_arg1: *mut ReorderBuffer,
    arg_xid: TransactionId,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReorderBufferXidHasBaseSnapshot(
                arg_arg1: *mut ReorderBuffer,
                arg_xid: TransactionId,
            ) -> bool;
        }
        ReorderBufferXidHasBaseSnapshot(arg_arg1, arg_xid)
    })
}
pub unsafe fn ReorderBufferGetOldestTXN(arg_arg1: *mut ReorderBuffer) -> *mut ReorderBufferTXN {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReorderBufferGetOldestTXN(arg_arg1: *mut ReorderBuffer) -> *mut ReorderBufferTXN;
        }
        ReorderBufferGetOldestTXN(arg_arg1)
    })
}
pub unsafe fn ReorderBufferGetOldestXmin(arg_rb: *mut ReorderBuffer) -> TransactionId {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReorderBufferGetOldestXmin(arg_rb: *mut ReorderBuffer) -> TransactionId;
        }
        ReorderBufferGetOldestXmin(arg_rb)
    })
}
pub unsafe fn ReorderBufferSetRestartPoint(arg_arg1: *mut ReorderBuffer, arg_ptr: XLogRecPtr) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReorderBufferSetRestartPoint(arg_arg1: *mut ReorderBuffer, arg_ptr: XLogRecPtr);
        }
        ReorderBufferSetRestartPoint(arg_arg1, arg_ptr)
    })
}
pub unsafe fn StartupReorderBuffer() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn StartupReorderBuffer();
        }
        StartupReorderBuffer()
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LogicalDecodingContext {
    _unused: [u8; 0],
}
pub const OutputPluginOutputType_OUTPUT_PLUGIN_BINARY_OUTPUT: OutputPluginOutputType = 0;
pub const OutputPluginOutputType_OUTPUT_PLUGIN_TEXTUAL_OUTPUT: OutputPluginOutputType = 1;
pub type OutputPluginOutputType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OutputPluginOptions {
    pub output_type: OutputPluginOutputType,
    pub receive_rewrites: bool,
}
impl Default for OutputPluginOptions {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type LogicalOutputPluginInit =
    ::std::option::Option<unsafe extern "C" fn(cb: *mut OutputPluginCallbacks)>;
pub type LogicalDecodeStartupCB = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut LogicalDecodingContext,
        options: *mut OutputPluginOptions,
        is_init: bool,
    ),
>;
pub type LogicalDecodeBeginCB = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut LogicalDecodingContext, txn: *mut ReorderBufferTXN),
>;
pub type LogicalDecodeChangeCB = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut LogicalDecodingContext,
        txn: *mut ReorderBufferTXN,
        relation: Relation,
        change: *mut ReorderBufferChange,
    ),
>;
pub type LogicalDecodeTruncateCB = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut LogicalDecodingContext,
        txn: *mut ReorderBufferTXN,
        nrelations: ::std::os::raw::c_int,
        relations: *mut Relation,
        change: *mut ReorderBufferChange,
    ),
>;
pub type LogicalDecodeCommitCB = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut LogicalDecodingContext,
        txn: *mut ReorderBufferTXN,
        commit_lsn: XLogRecPtr,
    ),
>;
pub type LogicalDecodeMessageCB = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut LogicalDecodingContext,
        txn: *mut ReorderBufferTXN,
        message_lsn: XLogRecPtr,
        transactional: bool,
        prefix: *const ::std::os::raw::c_char,
        message_size: Size,
        message: *const ::std::os::raw::c_char,
    ),
>;
pub type LogicalDecodeFilterByOriginCB = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut LogicalDecodingContext, origin_id: RepOriginId) -> bool,
>;
pub type LogicalDecodeShutdownCB =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut LogicalDecodingContext)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct OutputPluginCallbacks {
    pub startup_cb: LogicalDecodeStartupCB,
    pub begin_cb: LogicalDecodeBeginCB,
    pub change_cb: LogicalDecodeChangeCB,
    pub truncate_cb: LogicalDecodeTruncateCB,
    pub commit_cb: LogicalDecodeCommitCB,
    pub message_cb: LogicalDecodeMessageCB,
    pub filter_by_origin_cb: LogicalDecodeFilterByOriginCB,
    pub shutdown_cb: LogicalDecodeShutdownCB,
}
pub unsafe fn OutputPluginPrepareWrite(arg_ctx: *mut LogicalDecodingContext, arg_last_write: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn OutputPluginPrepareWrite(arg_ctx: *mut LogicalDecodingContext, arg_last_write: bool);
        }
        OutputPluginPrepareWrite(arg_ctx, arg_last_write)
    })
}
pub unsafe fn OutputPluginWrite(arg_ctx: *mut LogicalDecodingContext, arg_last_write: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn OutputPluginWrite(arg_ctx: *mut LogicalDecodingContext, arg_last_write: bool);
        }
        OutputPluginWrite(arg_ctx, arg_last_write)
    })
}
pub unsafe fn OutputPluginUpdateProgress(arg_ctx: *mut LogicalDecodingContext) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn OutputPluginUpdateProgress(arg_ctx: *mut LogicalDecodingContext);
        }
        OutputPluginUpdateProgress(arg_ctx)
    })
}
pub unsafe fn QueryRewrite(arg_parsetree: *mut Query) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn QueryRewrite(arg_parsetree: *mut Query) -> *mut List;
        }
        QueryRewrite(arg_parsetree)
    })
}
pub unsafe fn AcquireRewriteLocks(
    arg_parsetree: *mut Query,
    arg_forExecute: bool,
    arg_forUpdatePushedDown: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AcquireRewriteLocks(
                arg_parsetree: *mut Query,
                arg_forExecute: bool,
                arg_forUpdatePushedDown: bool,
            );
        }
        AcquireRewriteLocks(arg_parsetree, arg_forExecute, arg_forUpdatePushedDown)
    })
}
pub unsafe fn build_column_default(
    arg_rel: Relation,
    arg_attrno: ::std::os::raw::c_int,
) -> *mut Node {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn build_column_default(
                arg_rel: Relation,
                arg_attrno: ::std::os::raw::c_int,
            ) -> *mut Node;
        }
        build_column_default(arg_rel, arg_attrno)
    })
}
pub unsafe fn rewriteTargetListUD(
    arg_parsetree: *mut Query,
    arg_target_rte: *mut RangeTblEntry,
    arg_target_relation: Relation,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn rewriteTargetListUD(
                arg_parsetree: *mut Query,
                arg_target_rte: *mut RangeTblEntry,
                arg_target_relation: Relation,
            );
        }
        rewriteTargetListUD(arg_parsetree, arg_target_rte, arg_target_relation)
    })
}
pub unsafe fn fill_extraUpdatedCols(
    arg_target_rte: *mut RangeTblEntry,
    arg_target_relation: Relation,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fill_extraUpdatedCols(
                arg_target_rte: *mut RangeTblEntry,
                arg_target_relation: Relation,
            );
        }
        fill_extraUpdatedCols(arg_target_rte, arg_target_relation)
    })
}
pub unsafe fn get_view_query(arg_view: Relation) -> *mut Query {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_view_query(arg_view: Relation) -> *mut Query;
        }
        get_view_query(arg_view)
    })
}
pub unsafe fn view_query_is_auto_updatable(
    arg_viewquery: *mut Query,
    arg_check_cols: bool,
) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn view_query_is_auto_updatable(
                arg_viewquery: *mut Query,
                arg_check_cols: bool,
            ) -> *const ::std::os::raw::c_char;
        }
        view_query_is_auto_updatable(arg_viewquery, arg_check_cols)
    })
}
pub unsafe fn relation_is_updatable(
    arg_reloid: Oid,
    arg_outer_reloids: *mut List,
    arg_include_triggers: bool,
    arg_include_cols: *mut Bitmapset,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn relation_is_updatable(
                arg_reloid: Oid,
                arg_outer_reloids: *mut List,
                arg_include_triggers: bool,
                arg_include_cols: *mut Bitmapset,
            ) -> ::std::os::raw::c_int;
        }
        relation_is_updatable(arg_reloid, arg_outer_reloids, arg_include_triggers, arg_include_cols)
    })
}
extern "C" {
    pub static mut old_snapshot_threshold: ::std::os::raw::c_int;
}
pub unsafe fn SnapMgrShmemSize() -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SnapMgrShmemSize() -> Size;
        }
        SnapMgrShmemSize()
    })
}
pub unsafe fn SnapMgrInit() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SnapMgrInit();
        }
        SnapMgrInit()
    })
}
pub unsafe fn GetSnapshotCurrentTimestamp() -> TimestampTz {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetSnapshotCurrentTimestamp() -> TimestampTz;
        }
        GetSnapshotCurrentTimestamp()
    })
}
pub unsafe fn GetOldSnapshotThresholdTimestamp() -> TimestampTz {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetOldSnapshotThresholdTimestamp() -> TimestampTz;
        }
        GetOldSnapshotThresholdTimestamp()
    })
}
extern "C" {
    pub static mut FirstSnapshotSet: bool;
}
extern "C" {
    pub static mut TransactionXmin: TransactionId;
}
extern "C" {
    pub static mut RecentXmin: TransactionId;
}
extern "C" {
    pub static mut RecentGlobalXmin: TransactionId;
}
extern "C" {
    pub static mut RecentGlobalDataXmin: TransactionId;
}
extern "C" {
    pub static mut SnapshotSelfData: SnapshotData;
}
extern "C" {
    pub static mut SnapshotAnyData: SnapshotData;
}
extern "C" {
    pub static mut CatalogSnapshotData: SnapshotData;
}
pub unsafe fn GetTransactionSnapshot() -> Snapshot {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetTransactionSnapshot() -> Snapshot;
        }
        GetTransactionSnapshot()
    })
}
pub unsafe fn GetLatestSnapshot() -> Snapshot {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetLatestSnapshot() -> Snapshot;
        }
        GetLatestSnapshot()
    })
}
pub unsafe fn SnapshotSetCommandId(arg_curcid: CommandId) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SnapshotSetCommandId(arg_curcid: CommandId);
        }
        SnapshotSetCommandId(arg_curcid)
    })
}
pub unsafe fn GetOldestSnapshot() -> Snapshot {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetOldestSnapshot() -> Snapshot;
        }
        GetOldestSnapshot()
    })
}
pub unsafe fn GetCatalogSnapshot(arg_relid: Oid) -> Snapshot {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetCatalogSnapshot(arg_relid: Oid) -> Snapshot;
        }
        GetCatalogSnapshot(arg_relid)
    })
}
pub unsafe fn GetNonHistoricCatalogSnapshot(arg_relid: Oid) -> Snapshot {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetNonHistoricCatalogSnapshot(arg_relid: Oid) -> Snapshot;
        }
        GetNonHistoricCatalogSnapshot(arg_relid)
    })
}
pub unsafe fn InvalidateCatalogSnapshot() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InvalidateCatalogSnapshot();
        }
        InvalidateCatalogSnapshot()
    })
}
pub unsafe fn InvalidateCatalogSnapshotConditionally() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InvalidateCatalogSnapshotConditionally();
        }
        InvalidateCatalogSnapshotConditionally()
    })
}
pub unsafe fn PushActiveSnapshot(arg_snapshot: Snapshot) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PushActiveSnapshot(arg_snapshot: Snapshot);
        }
        PushActiveSnapshot(arg_snapshot)
    })
}
pub unsafe fn PushActiveSnapshotWithLevel(
    arg_snapshot: Snapshot,
    arg_snap_level: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PushActiveSnapshotWithLevel(
                arg_snapshot: Snapshot,
                arg_snap_level: ::std::os::raw::c_int,
            );
        }
        PushActiveSnapshotWithLevel(arg_snapshot, arg_snap_level)
    })
}
pub unsafe fn PushCopiedSnapshot(arg_snapshot: Snapshot) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PushCopiedSnapshot(arg_snapshot: Snapshot);
        }
        PushCopiedSnapshot(arg_snapshot)
    })
}
pub unsafe fn UpdateActiveSnapshotCommandId() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn UpdateActiveSnapshotCommandId();
        }
        UpdateActiveSnapshotCommandId()
    })
}
pub unsafe fn PopActiveSnapshot() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PopActiveSnapshot();
        }
        PopActiveSnapshot()
    })
}
pub unsafe fn GetActiveSnapshot() -> Snapshot {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetActiveSnapshot() -> Snapshot;
        }
        GetActiveSnapshot()
    })
}
pub unsafe fn ActiveSnapshotSet() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ActiveSnapshotSet() -> bool;
        }
        ActiveSnapshotSet()
    })
}
pub unsafe fn RegisterSnapshot(arg_snapshot: Snapshot) -> Snapshot {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RegisterSnapshot(arg_snapshot: Snapshot) -> Snapshot;
        }
        RegisterSnapshot(arg_snapshot)
    })
}
pub unsafe fn UnregisterSnapshot(arg_snapshot: Snapshot) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn UnregisterSnapshot(arg_snapshot: Snapshot);
        }
        UnregisterSnapshot(arg_snapshot)
    })
}
pub unsafe fn RegisterSnapshotOnOwner(
    arg_snapshot: Snapshot,
    arg_owner: ResourceOwner,
) -> Snapshot {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RegisterSnapshotOnOwner(
                arg_snapshot: Snapshot,
                arg_owner: ResourceOwner,
            ) -> Snapshot;
        }
        RegisterSnapshotOnOwner(arg_snapshot, arg_owner)
    })
}
pub unsafe fn UnregisterSnapshotFromOwner(arg_snapshot: Snapshot, arg_owner: ResourceOwner) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn UnregisterSnapshotFromOwner(arg_snapshot: Snapshot, arg_owner: ResourceOwner);
        }
        UnregisterSnapshotFromOwner(arg_snapshot, arg_owner)
    })
}
pub unsafe fn GetFullRecentGlobalXmin() -> FullTransactionId {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetFullRecentGlobalXmin() -> FullTransactionId;
        }
        GetFullRecentGlobalXmin()
    })
}
pub unsafe fn AtSubCommit_Snapshot(arg_level: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AtSubCommit_Snapshot(arg_level: ::std::os::raw::c_int);
        }
        AtSubCommit_Snapshot(arg_level)
    })
}
pub unsafe fn AtSubAbort_Snapshot(arg_level: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AtSubAbort_Snapshot(arg_level: ::std::os::raw::c_int);
        }
        AtSubAbort_Snapshot(arg_level)
    })
}
pub unsafe fn AtEOXact_Snapshot(arg_isCommit: bool, arg_resetXmin: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AtEOXact_Snapshot(arg_isCommit: bool, arg_resetXmin: bool);
        }
        AtEOXact_Snapshot(arg_isCommit, arg_resetXmin)
    })
}
pub unsafe fn ImportSnapshot(arg_idstr: *const ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ImportSnapshot(arg_idstr: *const ::std::os::raw::c_char);
        }
        ImportSnapshot(arg_idstr)
    })
}
pub unsafe fn XactHasExportedSnapshots() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XactHasExportedSnapshots() -> bool;
        }
        XactHasExportedSnapshots()
    })
}
pub unsafe fn DeleteAllExportedSnapshotFiles() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DeleteAllExportedSnapshotFiles();
        }
        DeleteAllExportedSnapshotFiles()
    })
}
pub unsafe fn ThereAreNoPriorRegisteredSnapshots() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ThereAreNoPriorRegisteredSnapshots() -> bool;
        }
        ThereAreNoPriorRegisteredSnapshots()
    })
}
pub unsafe fn TransactionIdLimitedForOldSnapshots(
    arg_recentXmin: TransactionId,
    arg_relation: Relation,
) -> TransactionId {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TransactionIdLimitedForOldSnapshots(
                arg_recentXmin: TransactionId,
                arg_relation: Relation,
            ) -> TransactionId;
        }
        TransactionIdLimitedForOldSnapshots(arg_recentXmin, arg_relation)
    })
}
pub unsafe fn MaintainOldSnapshotTimeMapping(arg_whenTaken: TimestampTz, arg_xmin: TransactionId) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MaintainOldSnapshotTimeMapping(arg_whenTaken: TimestampTz, arg_xmin: TransactionId);
        }
        MaintainOldSnapshotTimeMapping(arg_whenTaken, arg_xmin)
    })
}
pub unsafe fn ExportSnapshot(arg_snapshot: Snapshot) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExportSnapshot(arg_snapshot: Snapshot) -> *mut ::std::os::raw::c_char;
        }
        ExportSnapshot(arg_snapshot)
    })
}
pub unsafe fn HistoricSnapshotGetTupleCids() -> *mut HTAB {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn HistoricSnapshotGetTupleCids() -> *mut HTAB;
        }
        HistoricSnapshotGetTupleCids()
    })
}
pub unsafe fn SetupHistoricSnapshot(arg_snapshot_now: Snapshot, arg_tuplecids: *mut HTAB) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SetupHistoricSnapshot(arg_snapshot_now: Snapshot, arg_tuplecids: *mut HTAB);
        }
        SetupHistoricSnapshot(arg_snapshot_now, arg_tuplecids)
    })
}
pub unsafe fn TeardownHistoricSnapshot(arg_is_error: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TeardownHistoricSnapshot(arg_is_error: bool);
        }
        TeardownHistoricSnapshot(arg_is_error)
    })
}
pub unsafe fn HistoricSnapshotActive() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn HistoricSnapshotActive() -> bool;
        }
        HistoricSnapshotActive()
    })
}
pub unsafe fn EstimateSnapshotSpace(arg_snapshot: Snapshot) -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EstimateSnapshotSpace(arg_snapshot: Snapshot) -> Size;
        }
        EstimateSnapshotSpace(arg_snapshot)
    })
}
pub unsafe fn SerializeSnapshot(
    arg_snapshot: Snapshot,
    arg_start_address: *mut ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SerializeSnapshot(
                arg_snapshot: Snapshot,
                arg_start_address: *mut ::std::os::raw::c_char,
            );
        }
        SerializeSnapshot(arg_snapshot, arg_start_address)
    })
}
pub unsafe fn RestoreSnapshot(arg_start_address: *mut ::std::os::raw::c_char) -> Snapshot {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RestoreSnapshot(arg_start_address: *mut ::std::os::raw::c_char) -> Snapshot;
        }
        RestoreSnapshot(arg_start_address)
    })
}
pub unsafe fn RestoreTransactionSnapshot(
    arg_snapshot: Snapshot,
    arg_master_pgproc: *mut ::std::os::raw::c_void,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RestoreTransactionSnapshot(
                arg_snapshot: Snapshot,
                arg_master_pgproc: *mut ::std::os::raw::c_void,
            );
        }
        RestoreTransactionSnapshot(arg_snapshot, arg_master_pgproc)
    })
}
pub type Block = *mut ::std::os::raw::c_void;
pub const BufferAccessStrategyType_BAS_NORMAL: BufferAccessStrategyType = 0;
pub const BufferAccessStrategyType_BAS_BULKREAD: BufferAccessStrategyType = 1;
pub const BufferAccessStrategyType_BAS_BULKWRITE: BufferAccessStrategyType = 2;
pub const BufferAccessStrategyType_BAS_VACUUM: BufferAccessStrategyType = 3;
pub type BufferAccessStrategyType = ::std::os::raw::c_uint;
pub const ReadBufferMode_RBM_NORMAL: ReadBufferMode = 0;
pub const ReadBufferMode_RBM_ZERO_AND_LOCK: ReadBufferMode = 1;
pub const ReadBufferMode_RBM_ZERO_AND_CLEANUP_LOCK: ReadBufferMode = 2;
pub const ReadBufferMode_RBM_ZERO_ON_ERROR: ReadBufferMode = 3;
pub const ReadBufferMode_RBM_NORMAL_NO_LOG: ReadBufferMode = 4;
pub type ReadBufferMode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PrefetchBufferResult {
    pub recent_buffer: Buffer,
    pub initiated_io: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WritebackContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMgrRelationData {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut zero_damaged_pages: bool;
}
extern "C" {
    pub static mut bgwriter_lru_maxpages: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut bgwriter_lru_multiplier: f64;
}
extern "C" {
    pub static mut track_io_timing: bool;
}
extern "C" {
    pub static mut effective_io_concurrency: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut maintenance_io_concurrency: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut checkpoint_flush_after: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut backend_flush_after: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut bgwriter_flush_after: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut BufferBlocks: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut NLocBuffer: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut LocalBufferBlockPointers: *mut Block;
}
extern "C" {
    pub static mut LocalRefCount: *mut int32;
}
pub unsafe fn PrefetchSharedBuffer(
    arg_smgr_reln: *mut SMgrRelationData,
    arg_forkNum: ForkNumber,
    arg_blockNum: BlockNumber,
) -> PrefetchBufferResult {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PrefetchSharedBuffer(
                arg_smgr_reln: *mut SMgrRelationData,
                arg_forkNum: ForkNumber,
                arg_blockNum: BlockNumber,
            ) -> PrefetchBufferResult;
        }
        PrefetchSharedBuffer(arg_smgr_reln, arg_forkNum, arg_blockNum)
    })
}
pub unsafe fn PrefetchBuffer(
    arg_reln: Relation,
    arg_forkNum: ForkNumber,
    arg_blockNum: BlockNumber,
) -> PrefetchBufferResult {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PrefetchBuffer(
                arg_reln: Relation,
                arg_forkNum: ForkNumber,
                arg_blockNum: BlockNumber,
            ) -> PrefetchBufferResult;
        }
        PrefetchBuffer(arg_reln, arg_forkNum, arg_blockNum)
    })
}
pub unsafe fn ReadBuffer(arg_reln: Relation, arg_blockNum: BlockNumber) -> Buffer {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReadBuffer(arg_reln: Relation, arg_blockNum: BlockNumber) -> Buffer;
        }
        ReadBuffer(arg_reln, arg_blockNum)
    })
}
pub unsafe fn ReadBufferExtended(
    arg_reln: Relation,
    arg_forkNum: ForkNumber,
    arg_blockNum: BlockNumber,
    arg_mode: ReadBufferMode,
    arg_strategy: BufferAccessStrategy,
) -> Buffer {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReadBufferExtended(
                arg_reln: Relation,
                arg_forkNum: ForkNumber,
                arg_blockNum: BlockNumber,
                arg_mode: ReadBufferMode,
                arg_strategy: BufferAccessStrategy,
            ) -> Buffer;
        }
        ReadBufferExtended(arg_reln, arg_forkNum, arg_blockNum, arg_mode, arg_strategy)
    })
}
pub unsafe fn ReadBufferWithoutRelcache(
    arg_rnode: RelFileNode,
    arg_forkNum: ForkNumber,
    arg_blockNum: BlockNumber,
    arg_mode: ReadBufferMode,
    arg_strategy: BufferAccessStrategy,
) -> Buffer {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReadBufferWithoutRelcache(
                arg_rnode: RelFileNode,
                arg_forkNum: ForkNumber,
                arg_blockNum: BlockNumber,
                arg_mode: ReadBufferMode,
                arg_strategy: BufferAccessStrategy,
            ) -> Buffer;
        }
        ReadBufferWithoutRelcache(arg_rnode, arg_forkNum, arg_blockNum, arg_mode, arg_strategy)
    })
}
pub unsafe fn ReleaseBuffer(arg_buffer: Buffer) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReleaseBuffer(arg_buffer: Buffer);
        }
        ReleaseBuffer(arg_buffer)
    })
}
pub unsafe fn UnlockReleaseBuffer(arg_buffer: Buffer) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn UnlockReleaseBuffer(arg_buffer: Buffer);
        }
        UnlockReleaseBuffer(arg_buffer)
    })
}
pub unsafe fn MarkBufferDirty(arg_buffer: Buffer) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MarkBufferDirty(arg_buffer: Buffer);
        }
        MarkBufferDirty(arg_buffer)
    })
}
pub unsafe fn IncrBufferRefCount(arg_buffer: Buffer) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn IncrBufferRefCount(arg_buffer: Buffer);
        }
        IncrBufferRefCount(arg_buffer)
    })
}
pub unsafe fn ReleaseAndReadBuffer(
    arg_buffer: Buffer,
    arg_relation: Relation,
    arg_blockNum: BlockNumber,
) -> Buffer {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReleaseAndReadBuffer(
                arg_buffer: Buffer,
                arg_relation: Relation,
                arg_blockNum: BlockNumber,
            ) -> Buffer;
        }
        ReleaseAndReadBuffer(arg_buffer, arg_relation, arg_blockNum)
    })
}
pub unsafe fn InitBufferPool() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitBufferPool();
        }
        InitBufferPool()
    })
}
pub unsafe fn InitBufferPoolAccess() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitBufferPoolAccess();
        }
        InitBufferPoolAccess()
    })
}
pub unsafe fn InitBufferPoolBackend() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitBufferPoolBackend();
        }
        InitBufferPoolBackend()
    })
}
pub unsafe fn AtEOXact_Buffers(arg_isCommit: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AtEOXact_Buffers(arg_isCommit: bool);
        }
        AtEOXact_Buffers(arg_isCommit)
    })
}
pub unsafe fn PrintBufferLeakWarning(arg_buffer: Buffer) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PrintBufferLeakWarning(arg_buffer: Buffer);
        }
        PrintBufferLeakWarning(arg_buffer)
    })
}
pub unsafe fn CheckPointBuffers(arg_flags: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CheckPointBuffers(arg_flags: ::std::os::raw::c_int);
        }
        CheckPointBuffers(arg_flags)
    })
}
pub unsafe fn BufferGetBlockNumber(arg_buffer: Buffer) -> BlockNumber {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BufferGetBlockNumber(arg_buffer: Buffer) -> BlockNumber;
        }
        BufferGetBlockNumber(arg_buffer)
    })
}
pub unsafe fn RelationGetNumberOfBlocksInFork(
    arg_relation: Relation,
    arg_forkNum: ForkNumber,
) -> BlockNumber {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationGetNumberOfBlocksInFork(
                arg_relation: Relation,
                arg_forkNum: ForkNumber,
            ) -> BlockNumber;
        }
        RelationGetNumberOfBlocksInFork(arg_relation, arg_forkNum)
    })
}
pub unsafe fn FlushOneBuffer(arg_buffer: Buffer) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FlushOneBuffer(arg_buffer: Buffer);
        }
        FlushOneBuffer(arg_buffer)
    })
}
pub unsafe fn FlushRelationBuffers(arg_rel: Relation) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FlushRelationBuffers(arg_rel: Relation);
        }
        FlushRelationBuffers(arg_rel)
    })
}
pub unsafe fn FlushRelationsAllBuffers(
    arg_smgrs: *mut *mut SMgrRelationData,
    arg_nrels: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FlushRelationsAllBuffers(
                arg_smgrs: *mut *mut SMgrRelationData,
                arg_nrels: ::std::os::raw::c_int,
            );
        }
        FlushRelationsAllBuffers(arg_smgrs, arg_nrels)
    })
}
pub unsafe fn FlushDatabaseBuffers(arg_dbid: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FlushDatabaseBuffers(arg_dbid: Oid);
        }
        FlushDatabaseBuffers(arg_dbid)
    })
}
pub unsafe fn DropRelFileNodeBuffers(
    arg_rnode: RelFileNodeBackend,
    arg_forkNum: *mut ForkNumber,
    arg_nforks: ::std::os::raw::c_int,
    arg_firstDelBlock: *mut BlockNumber,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DropRelFileNodeBuffers(
                arg_rnode: RelFileNodeBackend,
                arg_forkNum: *mut ForkNumber,
                arg_nforks: ::std::os::raw::c_int,
                arg_firstDelBlock: *mut BlockNumber,
            );
        }
        DropRelFileNodeBuffers(arg_rnode, arg_forkNum, arg_nforks, arg_firstDelBlock)
    })
}
pub unsafe fn DropRelFileNodesAllBuffers(
    arg_rnodes: *mut RelFileNodeBackend,
    arg_nnodes: ::std::os::raw::c_int,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DropRelFileNodesAllBuffers(
                arg_rnodes: *mut RelFileNodeBackend,
                arg_nnodes: ::std::os::raw::c_int,
            );
        }
        DropRelFileNodesAllBuffers(arg_rnodes, arg_nnodes)
    })
}
pub unsafe fn DropDatabaseBuffers(arg_dbid: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DropDatabaseBuffers(arg_dbid: Oid);
        }
        DropDatabaseBuffers(arg_dbid)
    })
}
pub unsafe fn BufferIsPermanent(arg_buffer: Buffer) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BufferIsPermanent(arg_buffer: Buffer) -> bool;
        }
        BufferIsPermanent(arg_buffer)
    })
}
pub unsafe fn BufferGetLSNAtomic(arg_buffer: Buffer) -> XLogRecPtr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BufferGetLSNAtomic(arg_buffer: Buffer) -> XLogRecPtr;
        }
        BufferGetLSNAtomic(arg_buffer)
    })
}
pub unsafe fn BufferShmemSize() -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BufferShmemSize() -> Size;
        }
        BufferShmemSize()
    })
}
pub unsafe fn BufferGetTag(
    arg_buffer: Buffer,
    arg_rnode: *mut RelFileNode,
    arg_forknum: *mut ForkNumber,
    arg_blknum: *mut BlockNumber,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BufferGetTag(
                arg_buffer: Buffer,
                arg_rnode: *mut RelFileNode,
                arg_forknum: *mut ForkNumber,
                arg_blknum: *mut BlockNumber,
            );
        }
        BufferGetTag(arg_buffer, arg_rnode, arg_forknum, arg_blknum)
    })
}
pub unsafe fn MarkBufferDirtyHint(arg_buffer: Buffer, arg_buffer_std: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MarkBufferDirtyHint(arg_buffer: Buffer, arg_buffer_std: bool);
        }
        MarkBufferDirtyHint(arg_buffer, arg_buffer_std)
    })
}
pub unsafe fn UnlockBuffers() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn UnlockBuffers();
        }
        UnlockBuffers()
    })
}
pub unsafe fn LockBuffer(arg_buffer: Buffer, arg_mode: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LockBuffer(arg_buffer: Buffer, arg_mode: ::std::os::raw::c_int);
        }
        LockBuffer(arg_buffer, arg_mode)
    })
}
pub unsafe fn ConditionalLockBuffer(arg_buffer: Buffer) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ConditionalLockBuffer(arg_buffer: Buffer) -> bool;
        }
        ConditionalLockBuffer(arg_buffer)
    })
}
pub unsafe fn LockBufferForCleanup(arg_buffer: Buffer) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LockBufferForCleanup(arg_buffer: Buffer);
        }
        LockBufferForCleanup(arg_buffer)
    })
}
pub unsafe fn ConditionalLockBufferForCleanup(arg_buffer: Buffer) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ConditionalLockBufferForCleanup(arg_buffer: Buffer) -> bool;
        }
        ConditionalLockBufferForCleanup(arg_buffer)
    })
}
pub unsafe fn IsBufferCleanupOK(arg_buffer: Buffer) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn IsBufferCleanupOK(arg_buffer: Buffer) -> bool;
        }
        IsBufferCleanupOK(arg_buffer)
    })
}
pub unsafe fn HoldingBufferPinThatDelaysRecovery() -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn HoldingBufferPinThatDelaysRecovery() -> bool;
        }
        HoldingBufferPinThatDelaysRecovery()
    })
}
pub unsafe fn AbortBufferIO() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AbortBufferIO();
        }
        AbortBufferIO()
    })
}
pub unsafe fn BufmgrCommit() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BufmgrCommit();
        }
        BufmgrCommit()
    })
}
pub unsafe fn BgBufferSync(arg_wb_context: *mut WritebackContext) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BgBufferSync(arg_wb_context: *mut WritebackContext) -> bool;
        }
        BgBufferSync(arg_wb_context)
    })
}
pub unsafe fn AtProcExit_LocalBuffers() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AtProcExit_LocalBuffers();
        }
        AtProcExit_LocalBuffers()
    })
}
pub unsafe fn TestForOldSnapshot_impl(arg_snapshot: Snapshot, arg_relation: Relation) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TestForOldSnapshot_impl(arg_snapshot: Snapshot, arg_relation: Relation);
        }
        TestForOldSnapshot_impl(arg_snapshot, arg_relation)
    })
}
pub unsafe fn GetAccessStrategy(arg_btype: BufferAccessStrategyType) -> BufferAccessStrategy {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetAccessStrategy(arg_btype: BufferAccessStrategyType) -> BufferAccessStrategy;
        }
        GetAccessStrategy(arg_btype)
    })
}
pub unsafe fn FreeAccessStrategy(arg_strategy: BufferAccessStrategy) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FreeAccessStrategy(arg_strategy: BufferAccessStrategy);
        }
        FreeAccessStrategy(arg_strategy)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BufFile {
    _unused: [u8; 0],
}
pub unsafe fn BufFileCreateTemp(arg_interXact: bool) -> *mut BufFile {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BufFileCreateTemp(arg_interXact: bool) -> *mut BufFile;
        }
        BufFileCreateTemp(arg_interXact)
    })
}
pub unsafe fn BufFileClose(arg_file: *mut BufFile) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BufFileClose(arg_file: *mut BufFile);
        }
        BufFileClose(arg_file)
    })
}
pub unsafe fn BufFileRead(
    arg_file: *mut BufFile,
    arg_ptr: *mut ::std::os::raw::c_void,
    arg_size: usize,
) -> usize {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BufFileRead(
                arg_file: *mut BufFile,
                arg_ptr: *mut ::std::os::raw::c_void,
                arg_size: usize,
            ) -> usize;
        }
        BufFileRead(arg_file, arg_ptr, arg_size)
    })
}
pub unsafe fn BufFileWrite(
    arg_file: *mut BufFile,
    arg_ptr: *mut ::std::os::raw::c_void,
    arg_size: usize,
) -> usize {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BufFileWrite(
                arg_file: *mut BufFile,
                arg_ptr: *mut ::std::os::raw::c_void,
                arg_size: usize,
            ) -> usize;
        }
        BufFileWrite(arg_file, arg_ptr, arg_size)
    })
}
pub unsafe fn BufFileSeek(
    arg_file: *mut BufFile,
    arg_fileno: ::std::os::raw::c_int,
    arg_offset: off_t,
    arg_whence: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BufFileSeek(
                arg_file: *mut BufFile,
                arg_fileno: ::std::os::raw::c_int,
                arg_offset: off_t,
                arg_whence: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        BufFileSeek(arg_file, arg_fileno, arg_offset, arg_whence)
    })
}
pub unsafe fn BufFileTell(
    arg_file: *mut BufFile,
    arg_fileno: *mut ::std::os::raw::c_int,
    arg_offset: *mut off_t,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BufFileTell(
                arg_file: *mut BufFile,
                arg_fileno: *mut ::std::os::raw::c_int,
                arg_offset: *mut off_t,
            );
        }
        BufFileTell(arg_file, arg_fileno, arg_offset)
    })
}
pub unsafe fn BufFileSeekBlock(
    arg_file: *mut BufFile,
    arg_blknum: ::std::os::raw::c_long,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BufFileSeekBlock(
                arg_file: *mut BufFile,
                arg_blknum: ::std::os::raw::c_long,
            ) -> ::std::os::raw::c_int;
        }
        BufFileSeekBlock(arg_file, arg_blknum)
    })
}
pub unsafe fn BufFileSize(arg_file: *mut BufFile) -> int64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BufFileSize(arg_file: *mut BufFile) -> int64;
        }
        BufFileSize(arg_file)
    })
}
pub unsafe fn BufFileAppend(
    arg_target: *mut BufFile,
    arg_source: *mut BufFile,
) -> ::std::os::raw::c_long {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BufFileAppend(
                arg_target: *mut BufFile,
                arg_source: *mut BufFile,
            ) -> ::std::os::raw::c_long;
        }
        BufFileAppend(arg_target, arg_source)
    })
}
pub unsafe fn BufFileCreateShared(
    arg_fileset: *mut SharedFileSet,
    arg_name: *const ::std::os::raw::c_char,
) -> *mut BufFile {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BufFileCreateShared(
                arg_fileset: *mut SharedFileSet,
                arg_name: *const ::std::os::raw::c_char,
            ) -> *mut BufFile;
        }
        BufFileCreateShared(arg_fileset, arg_name)
    })
}
pub unsafe fn BufFileExportShared(arg_file: *mut BufFile) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BufFileExportShared(arg_file: *mut BufFile);
        }
        BufFileExportShared(arg_file)
    })
}
pub unsafe fn BufFileOpenShared(
    arg_fileset: *mut SharedFileSet,
    arg_name: *const ::std::os::raw::c_char,
) -> *mut BufFile {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BufFileOpenShared(
                arg_fileset: *mut SharedFileSet,
                arg_name: *const ::std::os::raw::c_char,
            ) -> *mut BufFile;
        }
        BufFileOpenShared(arg_fileset, arg_name)
    })
}
pub unsafe fn BufFileDeleteShared(
    arg_fileset: *mut SharedFileSet,
    arg_name: *const ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BufFileDeleteShared(
                arg_fileset: *mut SharedFileSet,
                arg_name: *const ::std::os::raw::c_char,
            );
        }
        BufFileDeleteShared(arg_fileset, arg_name)
    })
}
pub type pg_on_exit_callback =
    ::std::option::Option<unsafe extern "C" fn(code: ::std::os::raw::c_int, arg: Datum)>;
pub type shmem_startup_hook_type = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub static mut proc_exit_inprogress: bool;
}
extern "C" {
    pub static mut shmem_exit_inprogress: bool;
}
pub unsafe fn proc_exit(arg_code: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn proc_exit(arg_code: ::std::os::raw::c_int);
        }
        proc_exit(arg_code)
    })
}
pub unsafe fn shmem_exit(arg_code: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn shmem_exit(arg_code: ::std::os::raw::c_int);
        }
        shmem_exit(arg_code)
    })
}
pub unsafe fn on_proc_exit(arg_function: pg_on_exit_callback, arg_arg: Datum) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn on_proc_exit(arg_function: pg_on_exit_callback, arg_arg: Datum);
        }
        on_proc_exit(arg_function, arg_arg)
    })
}
pub unsafe fn on_shmem_exit(arg_function: pg_on_exit_callback, arg_arg: Datum) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn on_shmem_exit(arg_function: pg_on_exit_callback, arg_arg: Datum);
        }
        on_shmem_exit(arg_function, arg_arg)
    })
}
pub unsafe fn before_shmem_exit(arg_function: pg_on_exit_callback, arg_arg: Datum) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn before_shmem_exit(arg_function: pg_on_exit_callback, arg_arg: Datum);
        }
        before_shmem_exit(arg_function, arg_arg)
    })
}
pub unsafe fn cancel_before_shmem_exit(arg_function: pg_on_exit_callback, arg_arg: Datum) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cancel_before_shmem_exit(arg_function: pg_on_exit_callback, arg_arg: Datum);
        }
        cancel_before_shmem_exit(arg_function, arg_arg)
    })
}
pub unsafe fn on_exit_reset() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn on_exit_reset();
        }
        on_exit_reset()
    })
}
extern "C" {
    pub static mut shmem_startup_hook: shmem_startup_hook_type;
}
pub unsafe fn CreateSharedMemoryAndSemaphores() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateSharedMemoryAndSemaphores();
        }
        CreateSharedMemoryAndSemaphores()
    })
}
pub const ProcSignalReason_PROCSIG_CATCHUP_INTERRUPT: ProcSignalReason = 0;
pub const ProcSignalReason_PROCSIG_NOTIFY_INTERRUPT: ProcSignalReason = 1;
pub const ProcSignalReason_PROCSIG_PARALLEL_MESSAGE: ProcSignalReason = 2;
pub const ProcSignalReason_PROCSIG_WALSND_INIT_STOPPING: ProcSignalReason = 3;
pub const ProcSignalReason_PROCSIG_BARRIER: ProcSignalReason = 4;
pub const ProcSignalReason_PROCSIG_RECOVERY_CONFLICT_DATABASE: ProcSignalReason = 5;
pub const ProcSignalReason_PROCSIG_RECOVERY_CONFLICT_TABLESPACE: ProcSignalReason = 6;
pub const ProcSignalReason_PROCSIG_RECOVERY_CONFLICT_LOCK: ProcSignalReason = 7;
pub const ProcSignalReason_PROCSIG_RECOVERY_CONFLICT_SNAPSHOT: ProcSignalReason = 8;
pub const ProcSignalReason_PROCSIG_RECOVERY_CONFLICT_BUFFERPIN: ProcSignalReason = 9;
pub const ProcSignalReason_PROCSIG_RECOVERY_CONFLICT_STARTUP_DEADLOCK: ProcSignalReason = 10;
pub const ProcSignalReason_NUM_PROCSIGNALS: ProcSignalReason = 11;
pub type ProcSignalReason = ::std::os::raw::c_uint;
pub const ProcSignalBarrierType_PROCSIGNAL_BARRIER_PLACEHOLDER: ProcSignalBarrierType = 0;
pub type ProcSignalBarrierType = ::std::os::raw::c_uint;
pub unsafe fn ProcSignalShmemSize() -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcSignalShmemSize() -> Size;
        }
        ProcSignalShmemSize()
    })
}
pub unsafe fn ProcSignalShmemInit() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcSignalShmemInit();
        }
        ProcSignalShmemInit()
    })
}
pub unsafe fn ProcSignalInit(arg_pss_idx: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcSignalInit(arg_pss_idx: ::std::os::raw::c_int);
        }
        ProcSignalInit(arg_pss_idx)
    })
}
pub unsafe fn SendProcSignal(
    arg_pid: pid_t,
    arg_reason: ProcSignalReason,
    arg_backendId: BackendId,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SendProcSignal(
                arg_pid: pid_t,
                arg_reason: ProcSignalReason,
                arg_backendId: BackendId,
            ) -> ::std::os::raw::c_int;
        }
        SendProcSignal(arg_pid, arg_reason, arg_backendId)
    })
}
pub unsafe fn EmitProcSignalBarrier(arg_type_: ProcSignalBarrierType) -> uint64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EmitProcSignalBarrier(arg_type_: ProcSignalBarrierType) -> uint64;
        }
        EmitProcSignalBarrier(arg_type_)
    })
}
pub unsafe fn WaitForProcSignalBarrier(arg_generation: uint64) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn WaitForProcSignalBarrier(arg_generation: uint64);
        }
        WaitForProcSignalBarrier(arg_generation)
    })
}
pub unsafe fn ProcessProcSignalBarrier() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcessProcSignalBarrier();
        }
        ProcessProcSignalBarrier()
    })
}
pub unsafe fn procsignal_sigusr1_handler(arg_postgres_signal_arg: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn procsignal_sigusr1_handler(arg_postgres_signal_arg: ::std::os::raw::c_int);
        }
        procsignal_sigusr1_handler(arg_postgres_signal_arg)
    })
}
pub unsafe fn standby_redo(arg_record: *mut XLogReaderState) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn standby_redo(arg_record: *mut XLogReaderState);
        }
        standby_redo(arg_record)
    })
}
pub unsafe fn standby_desc(arg_buf: StringInfo, arg_record: *mut XLogReaderState) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn standby_desc(arg_buf: StringInfo, arg_record: *mut XLogReaderState);
        }
        standby_desc(arg_buf, arg_record)
    })
}
pub unsafe fn standby_identify(arg_info: uint8) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn standby_identify(arg_info: uint8) -> *const ::std::os::raw::c_char;
        }
        standby_identify(arg_info)
    })
}
pub unsafe fn standby_desc_invalidations(
    arg_buf: StringInfo,
    arg_nmsgs: ::std::os::raw::c_int,
    arg_msgs: *mut SharedInvalidationMessage,
    arg_dbId: Oid,
    arg_tsId: Oid,
    arg_relcacheInitFileInval: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn standby_desc_invalidations(
                arg_buf: StringInfo,
                arg_nmsgs: ::std::os::raw::c_int,
                arg_msgs: *mut SharedInvalidationMessage,
                arg_dbId: Oid,
                arg_tsId: Oid,
                arg_relcacheInitFileInval: bool,
            );
        }
        standby_desc_invalidations(
            arg_buf,
            arg_nmsgs,
            arg_msgs,
            arg_dbId,
            arg_tsId,
            arg_relcacheInitFileInval,
        )
    })
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct xl_standby_locks {
    pub nlocks: ::std::os::raw::c_int,
    pub locks: __IncompleteArrayField<xl_standby_lock>,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct xl_running_xacts {
    pub xcnt: ::std::os::raw::c_int,
    pub subxcnt: ::std::os::raw::c_int,
    pub subxid_overflow: bool,
    pub nextXid: TransactionId,
    pub oldestRunningXid: TransactionId,
    pub latestCompletedXid: TransactionId,
    pub xids: __IncompleteArrayField<TransactionId>,
}
#[repr(C)]
pub struct xl_invalidations {
    pub dbId: Oid,
    pub tsId: Oid,
    pub relcacheInitFileInval: bool,
    pub nmsgs: ::std::os::raw::c_int,
    pub msgs: __IncompleteArrayField<SharedInvalidationMessage>,
}
impl Default for xl_invalidations {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut vacuum_defer_cleanup_age: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut max_standby_archive_delay: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut max_standby_streaming_delay: ::std::os::raw::c_int;
}
pub unsafe fn InitRecoveryTransactionEnvironment() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitRecoveryTransactionEnvironment();
        }
        InitRecoveryTransactionEnvironment()
    })
}
pub unsafe fn ShutdownRecoveryTransactionEnvironment() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ShutdownRecoveryTransactionEnvironment();
        }
        ShutdownRecoveryTransactionEnvironment()
    })
}
pub unsafe fn ResolveRecoveryConflictWithSnapshot(
    arg_latestRemovedXid: TransactionId,
    arg_node: RelFileNode,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ResolveRecoveryConflictWithSnapshot(
                arg_latestRemovedXid: TransactionId,
                arg_node: RelFileNode,
            );
        }
        ResolveRecoveryConflictWithSnapshot(arg_latestRemovedXid, arg_node)
    })
}
pub unsafe fn ResolveRecoveryConflictWithTablespace(arg_tsid: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ResolveRecoveryConflictWithTablespace(arg_tsid: Oid);
        }
        ResolveRecoveryConflictWithTablespace(arg_tsid)
    })
}
pub unsafe fn ResolveRecoveryConflictWithDatabase(arg_dbid: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ResolveRecoveryConflictWithDatabase(arg_dbid: Oid);
        }
        ResolveRecoveryConflictWithDatabase(arg_dbid)
    })
}
pub unsafe fn ResolveRecoveryConflictWithLock(arg_locktag: LOCKTAG) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ResolveRecoveryConflictWithLock(arg_locktag: LOCKTAG);
        }
        ResolveRecoveryConflictWithLock(arg_locktag)
    })
}
pub unsafe fn ResolveRecoveryConflictWithBufferPin() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ResolveRecoveryConflictWithBufferPin();
        }
        ResolveRecoveryConflictWithBufferPin()
    })
}
pub unsafe fn CheckRecoveryConflictDeadlock() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CheckRecoveryConflictDeadlock();
        }
        CheckRecoveryConflictDeadlock()
    })
}
pub unsafe fn StandbyDeadLockHandler() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn StandbyDeadLockHandler();
        }
        StandbyDeadLockHandler()
    })
}
pub unsafe fn StandbyTimeoutHandler() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn StandbyTimeoutHandler();
        }
        StandbyTimeoutHandler()
    })
}
pub unsafe fn StandbyLockTimeoutHandler() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn StandbyLockTimeoutHandler();
        }
        StandbyLockTimeoutHandler()
    })
}
pub unsafe fn StandbyAcquireAccessExclusiveLock(
    arg_xid: TransactionId,
    arg_dbOid: Oid,
    arg_relOid: Oid,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn StandbyAcquireAccessExclusiveLock(
                arg_xid: TransactionId,
                arg_dbOid: Oid,
                arg_relOid: Oid,
            );
        }
        StandbyAcquireAccessExclusiveLock(arg_xid, arg_dbOid, arg_relOid)
    })
}
pub unsafe fn StandbyReleaseLockTree(
    arg_xid: TransactionId,
    arg_nsubxids: ::std::os::raw::c_int,
    arg_subxids: *mut TransactionId,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn StandbyReleaseLockTree(
                arg_xid: TransactionId,
                arg_nsubxids: ::std::os::raw::c_int,
                arg_subxids: *mut TransactionId,
            );
        }
        StandbyReleaseLockTree(arg_xid, arg_nsubxids, arg_subxids)
    })
}
pub unsafe fn StandbyReleaseAllLocks() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn StandbyReleaseAllLocks();
        }
        StandbyReleaseAllLocks()
    })
}
pub unsafe fn StandbyReleaseOldLocks(arg_oldxid: TransactionId) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn StandbyReleaseOldLocks(arg_oldxid: TransactionId);
        }
        StandbyReleaseOldLocks(arg_oldxid)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RunningTransactionsData {
    pub xcnt: ::std::os::raw::c_int,
    pub subxcnt: ::std::os::raw::c_int,
    pub subxid_overflow: bool,
    pub nextXid: TransactionId,
    pub oldestRunningXid: TransactionId,
    pub latestCompletedXid: TransactionId,
    pub xids: *mut TransactionId,
}
impl Default for RunningTransactionsData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type RunningTransactions = *mut RunningTransactionsData;
pub unsafe fn LogAccessExclusiveLock(arg_dbOid: Oid, arg_relOid: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LogAccessExclusiveLock(arg_dbOid: Oid, arg_relOid: Oid);
        }
        LogAccessExclusiveLock(arg_dbOid, arg_relOid)
    })
}
pub unsafe fn LogAccessExclusiveLockPrepare() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LogAccessExclusiveLockPrepare();
        }
        LogAccessExclusiveLockPrepare()
    })
}
pub unsafe fn LogStandbySnapshot() -> XLogRecPtr {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LogStandbySnapshot() -> XLogRecPtr;
        }
        LogStandbySnapshot()
    })
}
pub unsafe fn LogStandbyInvalidations(
    arg_nmsgs: ::std::os::raw::c_int,
    arg_msgs: *mut SharedInvalidationMessage,
    arg_relcacheInitFileInval: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn LogStandbyInvalidations(
                arg_nmsgs: ::std::os::raw::c_int,
                arg_msgs: *mut SharedInvalidationMessage,
                arg_relcacheInitFileInval: bool,
            );
        }
        LogStandbyInvalidations(arg_nmsgs, arg_msgs, arg_relcacheInitFileInval)
    })
}
pub unsafe fn ProcArrayShmemSize() -> Size {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcArrayShmemSize() -> Size;
        }
        ProcArrayShmemSize()
    })
}
pub unsafe fn CreateSharedProcArray() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateSharedProcArray();
        }
        CreateSharedProcArray()
    })
}
pub unsafe fn ProcArrayAdd(arg_proc_: *mut PGPROC) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcArrayAdd(arg_proc_: *mut PGPROC);
        }
        ProcArrayAdd(arg_proc_)
    })
}
pub unsafe fn ProcArrayRemove(arg_proc_: *mut PGPROC, arg_latestXid: TransactionId) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcArrayRemove(arg_proc_: *mut PGPROC, arg_latestXid: TransactionId);
        }
        ProcArrayRemove(arg_proc_, arg_latestXid)
    })
}
pub unsafe fn ProcArrayEndTransaction(arg_proc_: *mut PGPROC, arg_latestXid: TransactionId) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcArrayEndTransaction(arg_proc_: *mut PGPROC, arg_latestXid: TransactionId);
        }
        ProcArrayEndTransaction(arg_proc_, arg_latestXid)
    })
}
pub unsafe fn ProcArrayClearTransaction(arg_proc_: *mut PGPROC) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcArrayClearTransaction(arg_proc_: *mut PGPROC);
        }
        ProcArrayClearTransaction(arg_proc_)
    })
}
pub unsafe fn ProcArrayInitRecovery(arg_initializedUptoXID: TransactionId) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcArrayInitRecovery(arg_initializedUptoXID: TransactionId);
        }
        ProcArrayInitRecovery(arg_initializedUptoXID)
    })
}
pub unsafe fn ProcArrayApplyRecoveryInfo(arg_running: RunningTransactions) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcArrayApplyRecoveryInfo(arg_running: RunningTransactions);
        }
        ProcArrayApplyRecoveryInfo(arg_running)
    })
}
pub unsafe fn ProcArrayApplyXidAssignment(
    arg_topxid: TransactionId,
    arg_nsubxids: ::std::os::raw::c_int,
    arg_subxids: *mut TransactionId,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcArrayApplyXidAssignment(
                arg_topxid: TransactionId,
                arg_nsubxids: ::std::os::raw::c_int,
                arg_subxids: *mut TransactionId,
            );
        }
        ProcArrayApplyXidAssignment(arg_topxid, arg_nsubxids, arg_subxids)
    })
}
pub unsafe fn RecordKnownAssignedTransactionIds(arg_xid: TransactionId) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RecordKnownAssignedTransactionIds(arg_xid: TransactionId);
        }
        RecordKnownAssignedTransactionIds(arg_xid)
    })
}
pub unsafe fn ExpireTreeKnownAssignedTransactionIds(
    arg_xid: TransactionId,
    arg_nsubxids: ::std::os::raw::c_int,
    arg_subxids: *mut TransactionId,
    arg_max_xid: TransactionId,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExpireTreeKnownAssignedTransactionIds(
                arg_xid: TransactionId,
                arg_nsubxids: ::std::os::raw::c_int,
                arg_subxids: *mut TransactionId,
                arg_max_xid: TransactionId,
            );
        }
        ExpireTreeKnownAssignedTransactionIds(arg_xid, arg_nsubxids, arg_subxids, arg_max_xid)
    })
}
pub unsafe fn ExpireAllKnownAssignedTransactionIds() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExpireAllKnownAssignedTransactionIds();
        }
        ExpireAllKnownAssignedTransactionIds()
    })
}
pub unsafe fn ExpireOldKnownAssignedTransactionIds(arg_xid: TransactionId) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ExpireOldKnownAssignedTransactionIds(arg_xid: TransactionId);
        }
        ExpireOldKnownAssignedTransactionIds(arg_xid)
    })
}
pub unsafe fn GetMaxSnapshotXidCount() -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetMaxSnapshotXidCount() -> ::std::os::raw::c_int;
        }
        GetMaxSnapshotXidCount()
    })
}
pub unsafe fn GetMaxSnapshotSubxidCount() -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetMaxSnapshotSubxidCount() -> ::std::os::raw::c_int;
        }
        GetMaxSnapshotSubxidCount()
    })
}
pub unsafe fn GetSnapshotData(arg_snapshot: Snapshot) -> Snapshot {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetSnapshotData(arg_snapshot: Snapshot) -> Snapshot;
        }
        GetSnapshotData(arg_snapshot)
    })
}
pub unsafe fn ProcArrayInstallImportedXmin(
    arg_xmin: TransactionId,
    arg_sourcevxid: *mut VirtualTransactionId,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcArrayInstallImportedXmin(
                arg_xmin: TransactionId,
                arg_sourcevxid: *mut VirtualTransactionId,
            ) -> bool;
        }
        ProcArrayInstallImportedXmin(arg_xmin, arg_sourcevxid)
    })
}
pub unsafe fn ProcArrayInstallRestoredXmin(
    arg_xmin: TransactionId,
    arg_proc_: *mut PGPROC,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcArrayInstallRestoredXmin(
                arg_xmin: TransactionId,
                arg_proc_: *mut PGPROC,
            ) -> bool;
        }
        ProcArrayInstallRestoredXmin(arg_xmin, arg_proc_)
    })
}
pub unsafe fn GetRunningTransactionData() -> RunningTransactions {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetRunningTransactionData() -> RunningTransactions;
        }
        GetRunningTransactionData()
    })
}
pub unsafe fn TransactionIdIsInProgress(arg_xid: TransactionId) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TransactionIdIsInProgress(arg_xid: TransactionId) -> bool;
        }
        TransactionIdIsInProgress(arg_xid)
    })
}
pub unsafe fn TransactionIdIsActive(arg_xid: TransactionId) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TransactionIdIsActive(arg_xid: TransactionId) -> bool;
        }
        TransactionIdIsActive(arg_xid)
    })
}
pub unsafe fn GetOldestXmin(arg_rel: Relation, arg_flags: ::std::os::raw::c_int) -> TransactionId {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetOldestXmin(arg_rel: Relation, arg_flags: ::std::os::raw::c_int) -> TransactionId;
        }
        GetOldestXmin(arg_rel, arg_flags)
    })
}
pub unsafe fn GetOldestActiveTransactionId() -> TransactionId {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetOldestActiveTransactionId() -> TransactionId;
        }
        GetOldestActiveTransactionId()
    })
}
pub unsafe fn GetOldestSafeDecodingTransactionId(arg_catalogOnly: bool) -> TransactionId {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetOldestSafeDecodingTransactionId(arg_catalogOnly: bool) -> TransactionId;
        }
        GetOldestSafeDecodingTransactionId(arg_catalogOnly)
    })
}
pub unsafe fn GetVirtualXIDsDelayingChkpt(
    arg_nvxids: *mut ::std::os::raw::c_int,
) -> *mut VirtualTransactionId {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetVirtualXIDsDelayingChkpt(
                arg_nvxids: *mut ::std::os::raw::c_int,
            ) -> *mut VirtualTransactionId;
        }
        GetVirtualXIDsDelayingChkpt(arg_nvxids)
    })
}
pub unsafe fn HaveVirtualXIDsDelayingChkpt(
    arg_vxids: *mut VirtualTransactionId,
    arg_nvxids: ::std::os::raw::c_int,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn HaveVirtualXIDsDelayingChkpt(
                arg_vxids: *mut VirtualTransactionId,
                arg_nvxids: ::std::os::raw::c_int,
            ) -> bool;
        }
        HaveVirtualXIDsDelayingChkpt(arg_vxids, arg_nvxids)
    })
}
pub unsafe fn BackendPidGetProc(arg_pid: ::std::os::raw::c_int) -> *mut PGPROC {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BackendPidGetProc(arg_pid: ::std::os::raw::c_int) -> *mut PGPROC;
        }
        BackendPidGetProc(arg_pid)
    })
}
pub unsafe fn BackendPidGetProcWithLock(arg_pid: ::std::os::raw::c_int) -> *mut PGPROC {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BackendPidGetProcWithLock(arg_pid: ::std::os::raw::c_int) -> *mut PGPROC;
        }
        BackendPidGetProcWithLock(arg_pid)
    })
}
pub unsafe fn BackendXidGetPid(arg_xid: TransactionId) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BackendXidGetPid(arg_xid: TransactionId) -> ::std::os::raw::c_int;
        }
        BackendXidGetPid(arg_xid)
    })
}
pub unsafe fn IsBackendPid(arg_pid: ::std::os::raw::c_int) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn IsBackendPid(arg_pid: ::std::os::raw::c_int) -> bool;
        }
        IsBackendPid(arg_pid)
    })
}
pub unsafe fn GetCurrentVirtualXIDs(
    arg_limitXmin: TransactionId,
    arg_excludeXmin0: bool,
    arg_allDbs: bool,
    arg_excludeVacuum: ::std::os::raw::c_int,
    arg_nvxids: *mut ::std::os::raw::c_int,
) -> *mut VirtualTransactionId {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetCurrentVirtualXIDs(
                arg_limitXmin: TransactionId,
                arg_excludeXmin0: bool,
                arg_allDbs: bool,
                arg_excludeVacuum: ::std::os::raw::c_int,
                arg_nvxids: *mut ::std::os::raw::c_int,
            ) -> *mut VirtualTransactionId;
        }
        GetCurrentVirtualXIDs(
            arg_limitXmin,
            arg_excludeXmin0,
            arg_allDbs,
            arg_excludeVacuum,
            arg_nvxids,
        )
    })
}
pub unsafe fn GetConflictingVirtualXIDs(
    arg_limitXmin: TransactionId,
    arg_dbOid: Oid,
) -> *mut VirtualTransactionId {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetConflictingVirtualXIDs(
                arg_limitXmin: TransactionId,
                arg_dbOid: Oid,
            ) -> *mut VirtualTransactionId;
        }
        GetConflictingVirtualXIDs(arg_limitXmin, arg_dbOid)
    })
}
pub unsafe fn CancelVirtualTransaction(
    arg_vxid: VirtualTransactionId,
    arg_sigmode: ProcSignalReason,
) -> pid_t {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CancelVirtualTransaction(
                arg_vxid: VirtualTransactionId,
                arg_sigmode: ProcSignalReason,
            ) -> pid_t;
        }
        CancelVirtualTransaction(arg_vxid, arg_sigmode)
    })
}
pub unsafe fn SignalVirtualTransaction(
    arg_vxid: VirtualTransactionId,
    arg_sigmode: ProcSignalReason,
    arg_conflictPending: bool,
) -> pid_t {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SignalVirtualTransaction(
                arg_vxid: VirtualTransactionId,
                arg_sigmode: ProcSignalReason,
                arg_conflictPending: bool,
            ) -> pid_t;
        }
        SignalVirtualTransaction(arg_vxid, arg_sigmode, arg_conflictPending)
    })
}
pub unsafe fn MinimumActiveBackends(arg_min: ::std::os::raw::c_int) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn MinimumActiveBackends(arg_min: ::std::os::raw::c_int) -> bool;
        }
        MinimumActiveBackends(arg_min)
    })
}
pub unsafe fn CountDBBackends(arg_databaseid: Oid) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CountDBBackends(arg_databaseid: Oid) -> ::std::os::raw::c_int;
        }
        CountDBBackends(arg_databaseid)
    })
}
pub unsafe fn CountDBConnections(arg_databaseid: Oid) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CountDBConnections(arg_databaseid: Oid) -> ::std::os::raw::c_int;
        }
        CountDBConnections(arg_databaseid)
    })
}
pub unsafe fn CancelDBBackends(
    arg_databaseid: Oid,
    arg_sigmode: ProcSignalReason,
    arg_conflictPending: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CancelDBBackends(
                arg_databaseid: Oid,
                arg_sigmode: ProcSignalReason,
                arg_conflictPending: bool,
            );
        }
        CancelDBBackends(arg_databaseid, arg_sigmode, arg_conflictPending)
    })
}
pub unsafe fn CountUserBackends(arg_roleid: Oid) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CountUserBackends(arg_roleid: Oid) -> ::std::os::raw::c_int;
        }
        CountUserBackends(arg_roleid)
    })
}
pub unsafe fn CountOtherDBBackends(
    arg_databaseId: Oid,
    arg_nbackends: *mut ::std::os::raw::c_int,
    arg_nprepared: *mut ::std::os::raw::c_int,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CountOtherDBBackends(
                arg_databaseId: Oid,
                arg_nbackends: *mut ::std::os::raw::c_int,
                arg_nprepared: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        CountOtherDBBackends(arg_databaseId, arg_nbackends, arg_nprepared)
    })
}
pub unsafe fn TerminateOtherDBBackends(arg_databaseId: Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TerminateOtherDBBackends(arg_databaseId: Oid);
        }
        TerminateOtherDBBackends(arg_databaseId)
    })
}
pub unsafe fn XidCacheRemoveRunningXids(
    arg_xid: TransactionId,
    arg_nxids: ::std::os::raw::c_int,
    arg_xids: *const TransactionId,
    arg_latestXid: TransactionId,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn XidCacheRemoveRunningXids(
                arg_xid: TransactionId,
                arg_nxids: ::std::os::raw::c_int,
                arg_xids: *const TransactionId,
                arg_latestXid: TransactionId,
            );
        }
        XidCacheRemoveRunningXids(arg_xid, arg_nxids, arg_xids, arg_latestXid)
    })
}
pub unsafe fn ProcArraySetReplicationSlotXmin(
    arg_xmin: TransactionId,
    arg_catalog_xmin: TransactionId,
    arg_already_locked: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcArraySetReplicationSlotXmin(
                arg_xmin: TransactionId,
                arg_catalog_xmin: TransactionId,
                arg_already_locked: bool,
            );
        }
        ProcArraySetReplicationSlotXmin(arg_xmin, arg_catalog_xmin, arg_already_locked)
    })
}
pub unsafe fn ProcArrayGetReplicationSlotXmin(
    arg_xmin: *mut TransactionId,
    arg_catalog_xmin: *mut TransactionId,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcArrayGetReplicationSlotXmin(
                arg_xmin: *mut TransactionId,
                arg_catalog_xmin: *mut TransactionId,
            );
        }
        ProcArrayGetReplicationSlotXmin(arg_xmin, arg_catalog_xmin)
    })
}
extern "C" {
    pub static mut whereToSendOutput: CommandDest;
}
extern "C" {
    pub static mut debug_query_string: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static mut max_stack_depth: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut PostAuthDelay: ::std::os::raw::c_int;
}
pub const LogStmtLevel_LOGSTMT_NONE: LogStmtLevel = 0;
pub const LogStmtLevel_LOGSTMT_DDL: LogStmtLevel = 1;
pub const LogStmtLevel_LOGSTMT_MOD: LogStmtLevel = 2;
pub const LogStmtLevel_LOGSTMT_ALL: LogStmtLevel = 3;
pub type LogStmtLevel = ::std::os::raw::c_uint;
extern "C" {
    pub static mut log_statement: ::std::os::raw::c_int;
}
pub unsafe fn pg_parse_query(arg_query_string: *const ::std::os::raw::c_char) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_parse_query(arg_query_string: *const ::std::os::raw::c_char) -> *mut List;
        }
        pg_parse_query(arg_query_string)
    })
}
pub unsafe fn pg_analyze_and_rewrite(
    arg_parsetree: *mut RawStmt,
    arg_query_string: *const ::std::os::raw::c_char,
    arg_paramTypes: *mut Oid,
    arg_numParams: ::std::os::raw::c_int,
    arg_queryEnv: *mut QueryEnvironment,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_analyze_and_rewrite(
                arg_parsetree: *mut RawStmt,
                arg_query_string: *const ::std::os::raw::c_char,
                arg_paramTypes: *mut Oid,
                arg_numParams: ::std::os::raw::c_int,
                arg_queryEnv: *mut QueryEnvironment,
            ) -> *mut List;
        }
        pg_analyze_and_rewrite(
            arg_parsetree,
            arg_query_string,
            arg_paramTypes,
            arg_numParams,
            arg_queryEnv,
        )
    })
}
pub unsafe fn pg_analyze_and_rewrite_params(
    arg_parsetree: *mut RawStmt,
    arg_query_string: *const ::std::os::raw::c_char,
    arg_parserSetup: ParserSetupHook,
    arg_parserSetupArg: *mut ::std::os::raw::c_void,
    arg_queryEnv: *mut QueryEnvironment,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_analyze_and_rewrite_params(
                arg_parsetree: *mut RawStmt,
                arg_query_string: *const ::std::os::raw::c_char,
                arg_parserSetup: ParserSetupHook,
                arg_parserSetupArg: *mut ::std::os::raw::c_void,
                arg_queryEnv: *mut QueryEnvironment,
            ) -> *mut List;
        }
        pg_analyze_and_rewrite_params(
            arg_parsetree,
            arg_query_string,
            arg_parserSetup,
            arg_parserSetupArg,
            arg_queryEnv,
        )
    })
}
pub unsafe fn pg_plan_query(
    arg_querytree: *mut Query,
    arg_query_string: *const ::std::os::raw::c_char,
    arg_cursorOptions: ::std::os::raw::c_int,
    arg_boundParams: ParamListInfo,
) -> *mut PlannedStmt {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_plan_query(
                arg_querytree: *mut Query,
                arg_query_string: *const ::std::os::raw::c_char,
                arg_cursorOptions: ::std::os::raw::c_int,
                arg_boundParams: ParamListInfo,
            ) -> *mut PlannedStmt;
        }
        pg_plan_query(arg_querytree, arg_query_string, arg_cursorOptions, arg_boundParams)
    })
}
pub unsafe fn pg_plan_queries(
    arg_querytrees: *mut List,
    arg_query_string: *const ::std::os::raw::c_char,
    arg_cursorOptions: ::std::os::raw::c_int,
    arg_boundParams: ParamListInfo,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_plan_queries(
                arg_querytrees: *mut List,
                arg_query_string: *const ::std::os::raw::c_char,
                arg_cursorOptions: ::std::os::raw::c_int,
                arg_boundParams: ParamListInfo,
            ) -> *mut List;
        }
        pg_plan_queries(arg_querytrees, arg_query_string, arg_cursorOptions, arg_boundParams)
    })
}
pub unsafe fn check_max_stack_depth(
    arg_newval: *mut ::std::os::raw::c_int,
    arg_extra: *mut *mut ::std::os::raw::c_void,
    arg_source: GucSource,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn check_max_stack_depth(
                arg_newval: *mut ::std::os::raw::c_int,
                arg_extra: *mut *mut ::std::os::raw::c_void,
                arg_source: GucSource,
            ) -> bool;
        }
        check_max_stack_depth(arg_newval, arg_extra, arg_source)
    })
}
pub unsafe fn assign_max_stack_depth(
    arg_newval: ::std::os::raw::c_int,
    arg_extra: *mut ::std::os::raw::c_void,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn assign_max_stack_depth(
                arg_newval: ::std::os::raw::c_int,
                arg_extra: *mut ::std::os::raw::c_void,
            );
        }
        assign_max_stack_depth(arg_newval, arg_extra)
    })
}
pub unsafe fn die(arg_postgres_signal_arg: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn die(arg_postgres_signal_arg: ::std::os::raw::c_int);
        }
        die(arg_postgres_signal_arg)
    })
}
pub unsafe fn quickdie(arg_postgres_signal_arg: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn quickdie(arg_postgres_signal_arg: ::std::os::raw::c_int);
        }
        quickdie(arg_postgres_signal_arg)
    })
}
pub unsafe fn StatementCancelHandler(arg_postgres_signal_arg: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn StatementCancelHandler(arg_postgres_signal_arg: ::std::os::raw::c_int);
        }
        StatementCancelHandler(arg_postgres_signal_arg)
    })
}
pub unsafe fn FloatExceptionHandler(arg_postgres_signal_arg: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn FloatExceptionHandler(arg_postgres_signal_arg: ::std::os::raw::c_int);
        }
        FloatExceptionHandler(arg_postgres_signal_arg)
    })
}
pub unsafe fn RecoveryConflictInterrupt(arg_reason: ProcSignalReason) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RecoveryConflictInterrupt(arg_reason: ProcSignalReason);
        }
        RecoveryConflictInterrupt(arg_reason)
    })
}
pub unsafe fn ProcessClientReadInterrupt(arg_blocked: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcessClientReadInterrupt(arg_blocked: bool);
        }
        ProcessClientReadInterrupt(arg_blocked)
    })
}
pub unsafe fn ProcessClientWriteInterrupt(arg_blocked: bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcessClientWriteInterrupt(arg_blocked: bool);
        }
        ProcessClientWriteInterrupt(arg_blocked)
    })
}
pub unsafe fn process_postgres_switches(
    arg_argc: ::std::os::raw::c_int,
    arg_argv: *mut *mut ::std::os::raw::c_char,
    arg_ctx: GucContext,
    arg_dbname: *mut *const ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn process_postgres_switches(
                arg_argc: ::std::os::raw::c_int,
                arg_argv: *mut *mut ::std::os::raw::c_char,
                arg_ctx: GucContext,
                arg_dbname: *mut *const ::std::os::raw::c_char,
            );
        }
        process_postgres_switches(arg_argc, arg_argv, arg_ctx, arg_dbname)
    })
}
pub unsafe fn PostgresMain(
    arg_argc: ::std::os::raw::c_int,
    arg_argv: *mut *mut ::std::os::raw::c_char,
    arg_dbname: *const ::std::os::raw::c_char,
    arg_username: *const ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PostgresMain(
                arg_argc: ::std::os::raw::c_int,
                arg_argv: *mut *mut ::std::os::raw::c_char,
                arg_dbname: *const ::std::os::raw::c_char,
                arg_username: *const ::std::os::raw::c_char,
            );
        }
        PostgresMain(arg_argc, arg_argv, arg_dbname, arg_username)
    })
}
pub unsafe fn get_stack_depth_rlimit() -> ::std::os::raw::c_long {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_stack_depth_rlimit() -> ::std::os::raw::c_long;
        }
        get_stack_depth_rlimit()
    })
}
pub unsafe fn ResetUsage() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ResetUsage();
        }
        ResetUsage()
    })
}
pub unsafe fn ShowUsage(arg_title: *const ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ShowUsage(arg_title: *const ::std::os::raw::c_char);
        }
        ShowUsage(arg_title)
    })
}
pub unsafe fn check_log_duration(
    arg_msec_str: *mut ::std::os::raw::c_char,
    arg_was_logged: bool,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn check_log_duration(
                arg_msec_str: *mut ::std::os::raw::c_char,
                arg_was_logged: bool,
            ) -> ::std::os::raw::c_int;
        }
        check_log_duration(arg_msec_str, arg_was_logged)
    })
}
pub unsafe fn set_debug_options(
    arg_debug_flag: ::std::os::raw::c_int,
    arg_context: GucContext,
    arg_source: GucSource,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn set_debug_options(
                arg_debug_flag: ::std::os::raw::c_int,
                arg_context: GucContext,
                arg_source: GucSource,
            );
        }
        set_debug_options(arg_debug_flag, arg_context, arg_source)
    })
}
pub unsafe fn set_plan_disabling_options(
    arg_arg: *const ::std::os::raw::c_char,
    arg_context: GucContext,
    arg_source: GucSource,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn set_plan_disabling_options(
                arg_arg: *const ::std::os::raw::c_char,
                arg_context: GucContext,
                arg_source: GucSource,
            ) -> bool;
        }
        set_plan_disabling_options(arg_arg, arg_context, arg_source)
    })
}
pub unsafe fn get_stats_option_name(
    arg_arg: *const ::std::os::raw::c_char,
) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_stats_option_name(
                arg_arg: *const ::std::os::raw::c_char,
            ) -> *const ::std::os::raw::c_char;
        }
        get_stats_option_name(arg_arg)
    })
}
pub const ProcessUtilityContext_PROCESS_UTILITY_TOPLEVEL: ProcessUtilityContext = 0;
pub const ProcessUtilityContext_PROCESS_UTILITY_QUERY: ProcessUtilityContext = 1;
pub const ProcessUtilityContext_PROCESS_UTILITY_QUERY_NONATOMIC: ProcessUtilityContext = 2;
pub const ProcessUtilityContext_PROCESS_UTILITY_SUBCOMMAND: ProcessUtilityContext = 3;
pub type ProcessUtilityContext = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AlterTableUtilityContext {
    pub pstmt: *mut PlannedStmt,
    pub queryString: *const ::std::os::raw::c_char,
    pub relid: Oid,
    pub params: ParamListInfo,
    pub queryEnv: *mut QueryEnvironment,
}
impl Default for AlterTableUtilityContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ProcessUtility_hook_type = ::std::option::Option<
    unsafe extern "C" fn(
        pstmt: *mut PlannedStmt,
        queryString: *const ::std::os::raw::c_char,
        context: ProcessUtilityContext,
        params: ParamListInfo,
        queryEnv: *mut QueryEnvironment,
        dest: *mut DestReceiver,
        qc: *mut QueryCompletion,
    ),
>;
extern "C" {
    pub static mut ProcessUtility_hook: ProcessUtility_hook_type;
}
pub unsafe fn ProcessUtility(
    arg_pstmt: *mut PlannedStmt,
    arg_queryString: *const ::std::os::raw::c_char,
    arg_context: ProcessUtilityContext,
    arg_params: ParamListInfo,
    arg_queryEnv: *mut QueryEnvironment,
    arg_dest: *mut DestReceiver,
    arg_qc: *mut QueryCompletion,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcessUtility(
                arg_pstmt: *mut PlannedStmt,
                arg_queryString: *const ::std::os::raw::c_char,
                arg_context: ProcessUtilityContext,
                arg_params: ParamListInfo,
                arg_queryEnv: *mut QueryEnvironment,
                arg_dest: *mut DestReceiver,
                arg_qc: *mut QueryCompletion,
            );
        }
        ProcessUtility(
            arg_pstmt,
            arg_queryString,
            arg_context,
            arg_params,
            arg_queryEnv,
            arg_dest,
            arg_qc,
        )
    })
}
pub unsafe fn standard_ProcessUtility(
    arg_pstmt: *mut PlannedStmt,
    arg_queryString: *const ::std::os::raw::c_char,
    arg_context: ProcessUtilityContext,
    arg_params: ParamListInfo,
    arg_queryEnv: *mut QueryEnvironment,
    arg_dest: *mut DestReceiver,
    arg_qc: *mut QueryCompletion,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn standard_ProcessUtility(
                arg_pstmt: *mut PlannedStmt,
                arg_queryString: *const ::std::os::raw::c_char,
                arg_context: ProcessUtilityContext,
                arg_params: ParamListInfo,
                arg_queryEnv: *mut QueryEnvironment,
                arg_dest: *mut DestReceiver,
                arg_qc: *mut QueryCompletion,
            );
        }
        standard_ProcessUtility(
            arg_pstmt,
            arg_queryString,
            arg_context,
            arg_params,
            arg_queryEnv,
            arg_dest,
            arg_qc,
        )
    })
}
pub unsafe fn ProcessUtilityForAlterTable(
    arg_stmt: *mut Node,
    arg_context: *mut AlterTableUtilityContext,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ProcessUtilityForAlterTable(
                arg_stmt: *mut Node,
                arg_context: *mut AlterTableUtilityContext,
            );
        }
        ProcessUtilityForAlterTable(arg_stmt, arg_context)
    })
}
pub unsafe fn UtilityReturnsTuples(arg_parsetree: *mut Node) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn UtilityReturnsTuples(arg_parsetree: *mut Node) -> bool;
        }
        UtilityReturnsTuples(arg_parsetree)
    })
}
pub unsafe fn UtilityTupleDescriptor(arg_parsetree: *mut Node) -> TupleDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn UtilityTupleDescriptor(arg_parsetree: *mut Node) -> TupleDesc;
        }
        UtilityTupleDescriptor(arg_parsetree)
    })
}
pub unsafe fn UtilityContainsQuery(arg_parsetree: *mut Node) -> *mut Query {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn UtilityContainsQuery(arg_parsetree: *mut Node) -> *mut Query;
        }
        UtilityContainsQuery(arg_parsetree)
    })
}
pub unsafe fn CreateCommandTag(arg_parsetree: *mut Node) -> CommandTag {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CreateCommandTag(arg_parsetree: *mut Node) -> CommandTag;
        }
        CreateCommandTag(arg_parsetree)
    })
}
pub unsafe fn GetCommandLogLevel(arg_parsetree: *mut Node) -> LogStmtLevel {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetCommandLogLevel(arg_parsetree: *mut Node) -> LogStmtLevel;
        }
        GetCommandLogLevel(arg_parsetree)
    })
}
pub unsafe fn CommandIsReadOnly(arg_pstmt: *mut PlannedStmt) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn CommandIsReadOnly(arg_pstmt: *mut PlannedStmt) -> bool;
        }
        CommandIsReadOnly(arg_pstmt)
    })
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct WordEntry {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl WordEntry {
    #[inline]
    pub fn haspos(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_haspos(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn len(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_len(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn pos(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_pos(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        haspos: uint32,
        len: uint32,
        pos: uint32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let haspos: u32 = unsafe { ::std::mem::transmute(haspos) };
            haspos as u64
        });
        __bindgen_bitfield_unit.set(1usize, 11u8, {
            let len: u32 = unsafe { ::std::mem::transmute(len) };
            len as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let pos: u32 = unsafe { ::std::mem::transmute(pos) };
            pos as u64
        });
        __bindgen_bitfield_unit
    }
}
pub unsafe fn compareWordEntryPos(
    arg_a: *const ::std::os::raw::c_void,
    arg_b: *const ::std::os::raw::c_void,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn compareWordEntryPos(
                arg_a: *const ::std::os::raw::c_void,
                arg_b: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int;
        }
        compareWordEntryPos(arg_a, arg_b)
    })
}
pub type WordEntryPos = uint16;
#[repr(C)]
#[derive(Debug, Default)]
pub struct WordEntryPosVector {
    pub npos: uint16,
    pub pos: __IncompleteArrayField<WordEntryPos>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WordEntryPosVector1 {
    pub npos: uint16,
    pub pos: [WordEntryPos; 1usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct TSVectorData {
    pub vl_len_: int32,
    pub size: int32,
    pub entries: __IncompleteArrayField<WordEntry>,
}
pub type TSVector = *mut TSVectorData;
pub type QueryItemType = int8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct QueryOperand {
    pub type_: QueryItemType,
    pub weight: uint8,
    pub prefix: bool,
    pub valcrc: int32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl QueryOperand {
    #[inline]
    pub fn length(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_length(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn distance(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_distance(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(length: uint32, distance: uint32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let length: u32 = unsafe { ::std::mem::transmute(length) };
            length as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let distance: u32 = unsafe { ::std::mem::transmute(distance) };
            distance as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static tsearch_op_priority: [::std::os::raw::c_int; 4usize];
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct QueryOperator {
    pub type_: QueryItemType,
    pub oper: int8,
    pub distance: int16,
    pub left: uint32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union QueryItem {
    pub type_: QueryItemType,
    pub qoperator: QueryOperator,
    pub qoperand: QueryOperand,
}
impl Default for QueryItem {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct TSQueryData {
    pub vl_len_: int32,
    pub size: int32,
    pub data: __IncompleteArrayField<::std::os::raw::c_char>,
}
pub type TSQuery = *mut TSQueryData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LexDescr {
    pub lexid: ::std::os::raw::c_int,
    pub alias: *mut ::std::os::raw::c_char,
    pub descr: *mut ::std::os::raw::c_char,
}
impl Default for LexDescr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HeadlineWordEntry {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub pos: WordEntryPos,
    pub word: *mut ::std::os::raw::c_char,
    pub item: *mut QueryOperand,
}
impl Default for HeadlineWordEntry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl HeadlineWordEntry {
    #[inline]
    pub fn selected(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_selected(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn replace(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_replace(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn repeated(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_repeated(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unused(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn len(&self) -> uint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_len(&mut self, val: uint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        selected: uint32,
        in_: uint32,
        replace: uint32,
        repeated: uint32,
        skip: uint32,
        unused: uint32,
        type_: uint32,
        len: uint32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let selected: u32 = unsafe { ::std::mem::transmute(selected) };
            selected as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let in_: u32 = unsafe { ::std::mem::transmute(in_) };
            in_ as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let replace: u32 = unsafe { ::std::mem::transmute(replace) };
            replace as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let repeated: u32 = unsafe { ::std::mem::transmute(repeated) };
            repeated as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let skip: u32 = unsafe { ::std::mem::transmute(skip) };
            skip as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let unused: u32 = unsafe { ::std::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let len: u32 = unsafe { ::std::mem::transmute(len) };
            len as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HeadlineParsedText {
    pub words: *mut HeadlineWordEntry,
    pub lenwords: int32,
    pub curwords: int32,
    pub vectorpos: int32,
    pub startsel: *mut ::std::os::raw::c_char,
    pub stopsel: *mut ::std::os::raw::c_char,
    pub fragdelim: *mut ::std::os::raw::c_char,
    pub startsellen: int16,
    pub stopsellen: int16,
    pub fragdelimlen: int16,
}
impl Default for HeadlineParsedText {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn get_tsearch_config_filename(
    arg_basename: *const ::std::os::raw::c_char,
    arg_extension: *const ::std::os::raw::c_char,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_tsearch_config_filename(
                arg_basename: *const ::std::os::raw::c_char,
                arg_extension: *const ::std::os::raw::c_char,
            ) -> *mut ::std::os::raw::c_char;
        }
        get_tsearch_config_filename(arg_basename, arg_extension)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StopList {
    pub len: ::std::os::raw::c_int,
    pub stop: *mut *mut ::std::os::raw::c_char,
}
impl Default for StopList {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn readstoplist(
    arg_fname: *const ::std::os::raw::c_char,
    arg_s: *mut StopList,
    arg_wordop: ::std::option::Option<
        unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char,
    >,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn readstoplist(
                arg_fname: *const ::std::os::raw::c_char,
                arg_s: *mut StopList,
                arg_wordop: ::std::option::Option<
                    unsafe extern "C" fn(
                        arg1: *const ::std::os::raw::c_char,
                    ) -> *mut ::std::os::raw::c_char,
                >,
            );
        }
        readstoplist(arg_fname, arg_s, arg_wordop)
    })
}
pub unsafe fn searchstoplist(arg_s: *mut StopList, arg_key: *mut ::std::os::raw::c_char) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn searchstoplist(arg_s: *mut StopList, arg_key: *mut ::std::os::raw::c_char) -> bool;
        }
        searchstoplist(arg_s, arg_key)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSLexeme {
    pub nvariant: uint16,
    pub flags: uint16,
    pub lexeme: *mut ::std::os::raw::c_char,
}
impl Default for TSLexeme {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DictSubState {
    pub isend: bool,
    pub getnext: bool,
    pub private_state: *mut ::std::os::raw::c_void,
}
impl Default for DictSubState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSVectorParseStateData {
    _unused: [u8; 0],
}
pub type TSVectorParseState = *mut TSVectorParseStateData;
pub unsafe fn init_tsvector_parser(
    arg_input: *mut ::std::os::raw::c_char,
    arg_flags: ::std::os::raw::c_int,
) -> TSVectorParseState {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn init_tsvector_parser(
                arg_input: *mut ::std::os::raw::c_char,
                arg_flags: ::std::os::raw::c_int,
            ) -> TSVectorParseState;
        }
        init_tsvector_parser(arg_input, arg_flags)
    })
}
pub unsafe fn reset_tsvector_parser(
    arg_state: TSVectorParseState,
    arg_input: *mut ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn reset_tsvector_parser(
                arg_state: TSVectorParseState,
                arg_input: *mut ::std::os::raw::c_char,
            );
        }
        reset_tsvector_parser(arg_state, arg_input)
    })
}
pub unsafe fn gettoken_tsvector(
    arg_state: TSVectorParseState,
    arg_token: *mut *mut ::std::os::raw::c_char,
    arg_len: *mut ::std::os::raw::c_int,
    arg_pos: *mut *mut WordEntryPos,
    arg_poslen: *mut ::std::os::raw::c_int,
    arg_endptr: *mut *mut ::std::os::raw::c_char,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gettoken_tsvector(
                arg_state: TSVectorParseState,
                arg_token: *mut *mut ::std::os::raw::c_char,
                arg_len: *mut ::std::os::raw::c_int,
                arg_pos: *mut *mut WordEntryPos,
                arg_poslen: *mut ::std::os::raw::c_int,
                arg_endptr: *mut *mut ::std::os::raw::c_char,
            ) -> bool;
        }
        gettoken_tsvector(arg_state, arg_token, arg_len, arg_pos, arg_poslen, arg_endptr)
    })
}
pub unsafe fn close_tsvector_parser(arg_state: TSVectorParseState) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn close_tsvector_parser(arg_state: TSVectorParseState);
        }
        close_tsvector_parser(arg_state)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSQueryParserStateData {
    _unused: [u8; 0],
}
pub type TSQueryParserState = *mut TSQueryParserStateData;
pub type PushFunction = ::std::option::Option<
    unsafe extern "C" fn(
        opaque: Datum,
        state: TSQueryParserState,
        token: *mut ::std::os::raw::c_char,
        tokenlen: ::std::os::raw::c_int,
        tokenweights: int16,
        prefix: bool,
    ),
>;
pub unsafe fn parse_tsquery(
    arg_buf: *mut ::std::os::raw::c_char,
    arg_pushval: PushFunction,
    arg_opaque: Datum,
    arg_flags: ::std::os::raw::c_int,
) -> TSQuery {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn parse_tsquery(
                arg_buf: *mut ::std::os::raw::c_char,
                arg_pushval: PushFunction,
                arg_opaque: Datum,
                arg_flags: ::std::os::raw::c_int,
            ) -> TSQuery;
        }
        parse_tsquery(arg_buf, arg_pushval, arg_opaque, arg_flags)
    })
}
pub unsafe fn pushValue(
    arg_state: TSQueryParserState,
    arg_strval: *mut ::std::os::raw::c_char,
    arg_lenval: ::std::os::raw::c_int,
    arg_weight: int16,
    arg_prefix: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pushValue(
                arg_state: TSQueryParserState,
                arg_strval: *mut ::std::os::raw::c_char,
                arg_lenval: ::std::os::raw::c_int,
                arg_weight: int16,
                arg_prefix: bool,
            );
        }
        pushValue(arg_state, arg_strval, arg_lenval, arg_weight, arg_prefix)
    })
}
pub unsafe fn pushStop(arg_state: TSQueryParserState) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pushStop(arg_state: TSQueryParserState);
        }
        pushStop(arg_state)
    })
}
pub unsafe fn pushOperator(arg_state: TSQueryParserState, arg_oper: int8, arg_distance: int16) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pushOperator(arg_state: TSQueryParserState, arg_oper: int8, arg_distance: int16);
        }
        pushOperator(arg_state, arg_oper, arg_distance)
    })
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ParsedWord {
    pub len: uint16,
    pub nvariant: uint16,
    pub pos: ParsedWord__bindgen_ty_1,
    pub flags: uint16,
    pub word: *mut ::std::os::raw::c_char,
    pub alen: uint32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ParsedWord__bindgen_ty_1 {
    pub pos: uint16,
    pub apos: *mut uint16,
}
impl Default for ParsedWord__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ParsedWord {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParsedText {
    pub words: *mut ParsedWord,
    pub lenwords: int32,
    pub curwords: int32,
    pub pos: int32,
}
impl Default for ParsedText {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn parsetext(
    arg_cfgId: Oid,
    arg_prs: *mut ParsedText,
    arg_buf: *mut ::std::os::raw::c_char,
    arg_buflen: int32,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn parsetext(
                arg_cfgId: Oid,
                arg_prs: *mut ParsedText,
                arg_buf: *mut ::std::os::raw::c_char,
                arg_buflen: int32,
            );
        }
        parsetext(arg_cfgId, arg_prs, arg_buf, arg_buflen)
    })
}
pub unsafe fn hlparsetext(
    arg_cfgId: Oid,
    arg_prs: *mut HeadlineParsedText,
    arg_query: TSQuery,
    arg_buf: *mut ::std::os::raw::c_char,
    arg_buflen: int32,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hlparsetext(
                arg_cfgId: Oid,
                arg_prs: *mut HeadlineParsedText,
                arg_query: TSQuery,
                arg_buf: *mut ::std::os::raw::c_char,
                arg_buflen: int32,
            );
        }
        hlparsetext(arg_cfgId, arg_prs, arg_query, arg_buf, arg_buflen)
    })
}
pub unsafe fn generateHeadline(arg_prs: *mut HeadlineParsedText) -> *mut text {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn generateHeadline(arg_prs: *mut HeadlineParsedText) -> *mut text;
        }
        generateHeadline(arg_prs)
    })
}
pub const TSTernaryValue_TS_NO: TSTernaryValue = 0;
pub const TSTernaryValue_TS_YES: TSTernaryValue = 1;
pub const TSTernaryValue_TS_MAYBE: TSTernaryValue = 2;
pub type TSTernaryValue = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExecPhraseData {
    pub npos: ::std::os::raw::c_int,
    pub allocated: bool,
    pub negate: bool,
    pub pos: *mut WordEntryPos,
    pub width: ::std::os::raw::c_int,
}
impl Default for ExecPhraseData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TSExecuteCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::std::os::raw::c_void,
        val: *mut QueryOperand,
        data: *mut ExecPhraseData,
    ) -> TSTernaryValue,
>;
pub unsafe fn TS_execute(
    arg_curitem: *mut QueryItem,
    arg_arg: *mut ::std::os::raw::c_void,
    arg_flags: uint32,
    arg_chkcond: TSExecuteCallback,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TS_execute(
                arg_curitem: *mut QueryItem,
                arg_arg: *mut ::std::os::raw::c_void,
                arg_flags: uint32,
                arg_chkcond: TSExecuteCallback,
            ) -> bool;
        }
        TS_execute(arg_curitem, arg_arg, arg_flags, arg_chkcond)
    })
}
pub unsafe fn TS_execute_ternary(
    arg_curitem: *mut QueryItem,
    arg_arg: *mut ::std::os::raw::c_void,
    arg_flags: uint32,
    arg_chkcond: TSExecuteCallback,
) -> TSTernaryValue {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn TS_execute_ternary(
                arg_curitem: *mut QueryItem,
                arg_arg: *mut ::std::os::raw::c_void,
                arg_flags: uint32,
                arg_chkcond: TSExecuteCallback,
            ) -> TSTernaryValue;
        }
        TS_execute_ternary(arg_curitem, arg_arg, arg_flags, arg_chkcond)
    })
}
pub unsafe fn tsquery_requires_match(arg_curitem: *mut QueryItem) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsquery_requires_match(arg_curitem: *mut QueryItem) -> bool;
        }
        tsquery_requires_match(arg_curitem)
    })
}
pub unsafe fn make_tsvector(arg_prs: *mut ParsedText) -> TSVector {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_tsvector(arg_prs: *mut ParsedText) -> TSVector;
        }
        make_tsvector(arg_prs)
    })
}
pub unsafe fn tsCompareString(
    arg_a: *mut ::std::os::raw::c_char,
    arg_lena: ::std::os::raw::c_int,
    arg_b: *mut ::std::os::raw::c_char,
    arg_lenb: ::std::os::raw::c_int,
    arg_prefix: bool,
) -> int32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsCompareString(
                arg_a: *mut ::std::os::raw::c_char,
                arg_lena: ::std::os::raw::c_int,
                arg_b: *mut ::std::os::raw::c_char,
                arg_lenb: ::std::os::raw::c_int,
                arg_prefix: bool,
            ) -> int32;
        }
        tsCompareString(arg_a, arg_lena, arg_b, arg_lenb, arg_prefix)
    })
}
pub unsafe fn clean_NOT(arg_ptr: *mut QueryItem, arg_len: *mut int32) -> *mut QueryItem {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn clean_NOT(arg_ptr: *mut QueryItem, arg_len: *mut int32) -> *mut QueryItem;
        }
        clean_NOT(arg_ptr, arg_len)
    })
}
pub unsafe fn cleanup_tsquery_stopwords(arg_in_: TSQuery) -> TSQuery {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cleanup_tsquery_stopwords(arg_in_: TSQuery) -> TSQuery;
        }
        cleanup_tsquery_stopwords(arg_in_)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QTNode {
    pub valnode: *mut QueryItem,
    pub flags: uint32,
    pub nchild: int32,
    pub word: *mut ::std::os::raw::c_char,
    pub sign: uint32,
    pub child: *mut *mut QTNode,
}
impl Default for QTNode {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TSQuerySign = uint64;
pub unsafe fn QT2QTN(
    arg_in_: *mut QueryItem,
    arg_operand: *mut ::std::os::raw::c_char,
) -> *mut QTNode {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn QT2QTN(
                arg_in_: *mut QueryItem,
                arg_operand: *mut ::std::os::raw::c_char,
            ) -> *mut QTNode;
        }
        QT2QTN(arg_in_, arg_operand)
    })
}
pub unsafe fn QTN2QT(arg_in_: *mut QTNode) -> TSQuery {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn QTN2QT(arg_in_: *mut QTNode) -> TSQuery;
        }
        QTN2QT(arg_in_)
    })
}
pub unsafe fn QTNFree(arg_in_: *mut QTNode) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn QTNFree(arg_in_: *mut QTNode);
        }
        QTNFree(arg_in_)
    })
}
pub unsafe fn QTNSort(arg_in_: *mut QTNode) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn QTNSort(arg_in_: *mut QTNode);
        }
        QTNSort(arg_in_)
    })
}
pub unsafe fn QTNTernary(arg_in_: *mut QTNode) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn QTNTernary(arg_in_: *mut QTNode);
        }
        QTNTernary(arg_in_)
    })
}
pub unsafe fn QTNBinary(arg_in_: *mut QTNode) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn QTNBinary(arg_in_: *mut QTNode);
        }
        QTNBinary(arg_in_)
    })
}
pub unsafe fn QTNodeCompare(arg_an: *mut QTNode, arg_bn: *mut QTNode) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn QTNodeCompare(arg_an: *mut QTNode, arg_bn: *mut QTNode) -> ::std::os::raw::c_int;
        }
        QTNodeCompare(arg_an, arg_bn)
    })
}
pub unsafe fn QTNCopy(arg_in_: *mut QTNode) -> *mut QTNode {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn QTNCopy(arg_in_: *mut QTNode) -> *mut QTNode;
        }
        QTNCopy(arg_in_)
    })
}
pub unsafe fn QTNClearFlags(arg_in_: *mut QTNode, arg_flags: uint32) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn QTNClearFlags(arg_in_: *mut QTNode, arg_flags: uint32);
        }
        QTNClearFlags(arg_in_, arg_flags)
    })
}
pub unsafe fn QTNEq(arg_a: *mut QTNode, arg_b: *mut QTNode) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn QTNEq(arg_a: *mut QTNode, arg_b: *mut QTNode) -> bool;
        }
        QTNEq(arg_a, arg_b)
    })
}
pub unsafe fn makeTSQuerySign(arg_a: TSQuery) -> TSQuerySign {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeTSQuerySign(arg_a: TSQuery) -> TSQuerySign;
        }
        makeTSQuerySign(arg_a)
    })
}
pub unsafe fn findsubquery(
    arg_root: *mut QTNode,
    arg_ex: *mut QTNode,
    arg_subs: *mut QTNode,
    arg_isfind: *mut bool,
) -> *mut QTNode {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn findsubquery(
                arg_root: *mut QTNode,
                arg_ex: *mut QTNode,
                arg_subs: *mut QTNode,
                arg_isfind: *mut bool,
            ) -> *mut QTNode;
        }
        findsubquery(arg_root, arg_ex, arg_subs, arg_isfind)
    })
}
pub unsafe fn heap_tableam_handler(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn heap_tableam_handler(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        heap_tableam_handler(arg_fcinfo)
    })
}
pub unsafe fn byteaout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn byteaout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        byteaout(arg_fcinfo)
    })
}
pub unsafe fn charout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn charout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        charout(arg_fcinfo)
    })
}
pub unsafe fn namein(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn namein(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        namein(arg_fcinfo)
    })
}
pub unsafe fn nameout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn nameout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        nameout(arg_fcinfo)
    })
}
pub unsafe fn int2in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2in(arg_fcinfo)
    })
}
pub unsafe fn int2out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2out(arg_fcinfo)
    })
}
pub unsafe fn int2vectorin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2vectorin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2vectorin(arg_fcinfo)
    })
}
pub unsafe fn int2vectorout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2vectorout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2vectorout(arg_fcinfo)
    })
}
pub unsafe fn int4in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4in(arg_fcinfo)
    })
}
pub unsafe fn int4out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4out(arg_fcinfo)
    })
}
pub unsafe fn regprocin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regprocin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regprocin(arg_fcinfo)
    })
}
pub unsafe fn regprocout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regprocout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regprocout(arg_fcinfo)
    })
}
pub unsafe fn textin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn textin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        textin(arg_fcinfo)
    })
}
pub unsafe fn textout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn textout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        textout(arg_fcinfo)
    })
}
pub unsafe fn tidin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tidin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tidin(arg_fcinfo)
    })
}
pub unsafe fn tidout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tidout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tidout(arg_fcinfo)
    })
}
pub unsafe fn xidin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xidin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        xidin(arg_fcinfo)
    })
}
pub unsafe fn xidout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xidout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        xidout(arg_fcinfo)
    })
}
pub unsafe fn cidin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cidin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cidin(arg_fcinfo)
    })
}
pub unsafe fn cidout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cidout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cidout(arg_fcinfo)
    })
}
pub unsafe fn oidvectorin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn oidvectorin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        oidvectorin(arg_fcinfo)
    })
}
pub unsafe fn oidvectorout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn oidvectorout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        oidvectorout(arg_fcinfo)
    })
}
pub unsafe fn boollt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn boollt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        boollt(arg_fcinfo)
    })
}
pub unsafe fn boolgt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn boolgt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        boolgt(arg_fcinfo)
    })
}
pub unsafe fn booleq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn booleq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        booleq(arg_fcinfo)
    })
}
pub unsafe fn chareq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn chareq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        chareq(arg_fcinfo)
    })
}
pub unsafe fn nameeq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn nameeq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        nameeq(arg_fcinfo)
    })
}
pub unsafe fn int2eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2eq(arg_fcinfo)
    })
}
pub unsafe fn int2lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2lt(arg_fcinfo)
    })
}
pub unsafe fn int4eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4eq(arg_fcinfo)
    })
}
pub unsafe fn int4lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4lt(arg_fcinfo)
    })
}
pub unsafe fn texteq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn texteq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        texteq(arg_fcinfo)
    })
}
pub unsafe fn xideq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xideq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        xideq(arg_fcinfo)
    })
}
pub unsafe fn cideq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cideq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cideq(arg_fcinfo)
    })
}
pub unsafe fn charne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn charne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        charne(arg_fcinfo)
    })
}
pub unsafe fn charle(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn charle(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        charle(arg_fcinfo)
    })
}
pub unsafe fn chargt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn chargt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        chargt(arg_fcinfo)
    })
}
pub unsafe fn charge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn charge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        charge(arg_fcinfo)
    })
}
pub unsafe fn chartoi4(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn chartoi4(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        chartoi4(arg_fcinfo)
    })
}
pub unsafe fn i4tochar(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn i4tochar(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        i4tochar(arg_fcinfo)
    })
}
pub unsafe fn nameregexeq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn nameregexeq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        nameregexeq(arg_fcinfo)
    })
}
pub unsafe fn boolne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn boolne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        boolne(arg_fcinfo)
    })
}
pub unsafe fn pg_ddl_command_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_ddl_command_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_ddl_command_in(arg_fcinfo)
    })
}
pub unsafe fn pg_ddl_command_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_ddl_command_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_ddl_command_out(arg_fcinfo)
    })
}
pub unsafe fn pg_ddl_command_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_ddl_command_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_ddl_command_recv(arg_fcinfo)
    })
}
pub unsafe fn pgsql_version(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pgsql_version(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pgsql_version(arg_fcinfo)
    })
}
pub unsafe fn pg_ddl_command_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_ddl_command_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_ddl_command_send(arg_fcinfo)
    })
}
pub unsafe fn eqsel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn eqsel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        eqsel(arg_fcinfo)
    })
}
pub unsafe fn neqsel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn neqsel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        neqsel(arg_fcinfo)
    })
}
pub unsafe fn scalarltsel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn scalarltsel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        scalarltsel(arg_fcinfo)
    })
}
pub unsafe fn scalargtsel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn scalargtsel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        scalargtsel(arg_fcinfo)
    })
}
pub unsafe fn eqjoinsel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn eqjoinsel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        eqjoinsel(arg_fcinfo)
    })
}
pub unsafe fn neqjoinsel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn neqjoinsel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        neqjoinsel(arg_fcinfo)
    })
}
pub unsafe fn scalarltjoinsel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn scalarltjoinsel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        scalarltjoinsel(arg_fcinfo)
    })
}
pub unsafe fn scalargtjoinsel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn scalargtjoinsel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        scalargtjoinsel(arg_fcinfo)
    })
}
pub unsafe fn unknownin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn unknownin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        unknownin(arg_fcinfo)
    })
}
pub unsafe fn unknownout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn unknownout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        unknownout(arg_fcinfo)
    })
}
pub unsafe fn numeric_fac(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_fac(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_fac(arg_fcinfo)
    })
}
pub unsafe fn box_above_eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_above_eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_above_eq(arg_fcinfo)
    })
}
pub unsafe fn box_below_eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_below_eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_below_eq(arg_fcinfo)
    })
}
pub unsafe fn point_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn point_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        point_in(arg_fcinfo)
    })
}
pub unsafe fn point_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn point_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        point_out(arg_fcinfo)
    })
}
pub unsafe fn lseg_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lseg_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        lseg_in(arg_fcinfo)
    })
}
pub unsafe fn lseg_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lseg_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        lseg_out(arg_fcinfo)
    })
}
pub unsafe fn path_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn path_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        path_in(arg_fcinfo)
    })
}
pub unsafe fn path_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn path_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        path_out(arg_fcinfo)
    })
}
pub unsafe fn box_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_in(arg_fcinfo)
    })
}
pub unsafe fn box_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_out(arg_fcinfo)
    })
}
pub unsafe fn box_overlap(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_overlap(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_overlap(arg_fcinfo)
    })
}
pub unsafe fn box_ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_ge(arg_fcinfo)
    })
}
pub unsafe fn box_gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_gt(arg_fcinfo)
    })
}
pub unsafe fn box_eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_eq(arg_fcinfo)
    })
}
pub unsafe fn box_lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_lt(arg_fcinfo)
    })
}
pub unsafe fn box_le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_le(arg_fcinfo)
    })
}
pub unsafe fn point_above(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn point_above(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        point_above(arg_fcinfo)
    })
}
pub unsafe fn point_left(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn point_left(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        point_left(arg_fcinfo)
    })
}
pub unsafe fn point_right(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn point_right(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        point_right(arg_fcinfo)
    })
}
pub unsafe fn point_below(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn point_below(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        point_below(arg_fcinfo)
    })
}
pub unsafe fn point_eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn point_eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        point_eq(arg_fcinfo)
    })
}
pub unsafe fn on_pb(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn on_pb(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        on_pb(arg_fcinfo)
    })
}
pub unsafe fn on_ppath(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn on_ppath(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        on_ppath(arg_fcinfo)
    })
}
pub unsafe fn box_center(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_center(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_center(arg_fcinfo)
    })
}
pub unsafe fn areasel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn areasel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        areasel(arg_fcinfo)
    })
}
pub unsafe fn areajoinsel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn areajoinsel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        areajoinsel(arg_fcinfo)
    })
}
pub unsafe fn int4mul(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4mul(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4mul(arg_fcinfo)
    })
}
pub unsafe fn int4ne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4ne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4ne(arg_fcinfo)
    })
}
pub unsafe fn int2ne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2ne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2ne(arg_fcinfo)
    })
}
pub unsafe fn int2gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2gt(arg_fcinfo)
    })
}
pub unsafe fn int4gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4gt(arg_fcinfo)
    })
}
pub unsafe fn int2le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2le(arg_fcinfo)
    })
}
pub unsafe fn int4le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4le(arg_fcinfo)
    })
}
pub unsafe fn int4ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4ge(arg_fcinfo)
    })
}
pub unsafe fn int2ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2ge(arg_fcinfo)
    })
}
pub unsafe fn int2mul(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2mul(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2mul(arg_fcinfo)
    })
}
pub unsafe fn int2div(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2div(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2div(arg_fcinfo)
    })
}
pub unsafe fn int4div(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4div(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4div(arg_fcinfo)
    })
}
pub unsafe fn int2mod(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2mod(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2mod(arg_fcinfo)
    })
}
pub unsafe fn int4mod(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4mod(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4mod(arg_fcinfo)
    })
}
pub unsafe fn textne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn textne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        textne(arg_fcinfo)
    })
}
pub unsafe fn int24eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int24eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int24eq(arg_fcinfo)
    })
}
pub unsafe fn int42eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int42eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int42eq(arg_fcinfo)
    })
}
pub unsafe fn int24lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int24lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int24lt(arg_fcinfo)
    })
}
pub unsafe fn int42lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int42lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int42lt(arg_fcinfo)
    })
}
pub unsafe fn int24gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int24gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int24gt(arg_fcinfo)
    })
}
pub unsafe fn int42gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int42gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int42gt(arg_fcinfo)
    })
}
pub unsafe fn int24ne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int24ne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int24ne(arg_fcinfo)
    })
}
pub unsafe fn int42ne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int42ne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int42ne(arg_fcinfo)
    })
}
pub unsafe fn int24le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int24le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int24le(arg_fcinfo)
    })
}
pub unsafe fn int42le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int42le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int42le(arg_fcinfo)
    })
}
pub unsafe fn int24ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int24ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int24ge(arg_fcinfo)
    })
}
pub unsafe fn int42ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int42ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int42ge(arg_fcinfo)
    })
}
pub unsafe fn int24mul(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int24mul(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int24mul(arg_fcinfo)
    })
}
pub unsafe fn int42mul(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int42mul(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int42mul(arg_fcinfo)
    })
}
pub unsafe fn int24div(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int24div(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int24div(arg_fcinfo)
    })
}
pub unsafe fn int42div(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int42div(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int42div(arg_fcinfo)
    })
}
pub unsafe fn int2pl(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2pl(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2pl(arg_fcinfo)
    })
}
pub unsafe fn int4pl(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4pl(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4pl(arg_fcinfo)
    })
}
pub unsafe fn int24pl(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int24pl(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int24pl(arg_fcinfo)
    })
}
pub unsafe fn int42pl(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int42pl(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int42pl(arg_fcinfo)
    })
}
pub unsafe fn int2mi(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2mi(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2mi(arg_fcinfo)
    })
}
pub unsafe fn int4mi(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4mi(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4mi(arg_fcinfo)
    })
}
pub unsafe fn int24mi(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int24mi(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int24mi(arg_fcinfo)
    })
}
pub unsafe fn int42mi(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int42mi(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int42mi(arg_fcinfo)
    })
}
pub unsafe fn oideq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn oideq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        oideq(arg_fcinfo)
    })
}
pub unsafe fn oidne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn oidne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        oidne(arg_fcinfo)
    })
}
pub unsafe fn box_same(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_same(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_same(arg_fcinfo)
    })
}
pub unsafe fn box_contain(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_contain(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_contain(arg_fcinfo)
    })
}
pub unsafe fn box_left(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_left(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_left(arg_fcinfo)
    })
}
pub unsafe fn box_overleft(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_overleft(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_overleft(arg_fcinfo)
    })
}
pub unsafe fn box_overright(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_overright(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_overright(arg_fcinfo)
    })
}
pub unsafe fn box_right(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_right(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_right(arg_fcinfo)
    })
}
pub unsafe fn box_contained(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_contained(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_contained(arg_fcinfo)
    })
}
pub unsafe fn box_contain_pt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_contain_pt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_contain_pt(arg_fcinfo)
    })
}
pub unsafe fn pg_node_tree_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_node_tree_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_node_tree_in(arg_fcinfo)
    })
}
pub unsafe fn pg_node_tree_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_node_tree_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_node_tree_out(arg_fcinfo)
    })
}
pub unsafe fn pg_node_tree_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_node_tree_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_node_tree_recv(arg_fcinfo)
    })
}
pub unsafe fn pg_node_tree_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_node_tree_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_node_tree_send(arg_fcinfo)
    })
}
pub unsafe fn int4um(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4um(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4um(arg_fcinfo)
    })
}
pub unsafe fn int2um(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2um(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2um(arg_fcinfo)
    })
}
pub unsafe fn lseg_center(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lseg_center(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        lseg_center(arg_fcinfo)
    })
}
pub unsafe fn path_center(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn path_center(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        path_center(arg_fcinfo)
    })
}
pub unsafe fn poly_center(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn poly_center(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        poly_center(arg_fcinfo)
    })
}
pub unsafe fn dround(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dround(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dround(arg_fcinfo)
    })
}
pub unsafe fn dtrunc(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dtrunc(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dtrunc(arg_fcinfo)
    })
}
pub unsafe fn dsqrt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsqrt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dsqrt(arg_fcinfo)
    })
}
pub unsafe fn dcbrt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dcbrt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dcbrt(arg_fcinfo)
    })
}
pub unsafe fn dpow(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dpow(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dpow(arg_fcinfo)
    })
}
pub unsafe fn dexp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dexp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dexp(arg_fcinfo)
    })
}
pub unsafe fn dlog1(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dlog1(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dlog1(arg_fcinfo)
    })
}
pub unsafe fn i2tod(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn i2tod(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        i2tod(arg_fcinfo)
    })
}
pub unsafe fn i2tof(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn i2tof(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        i2tof(arg_fcinfo)
    })
}
pub unsafe fn dtoi2(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dtoi2(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dtoi2(arg_fcinfo)
    })
}
pub unsafe fn ftoi2(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ftoi2(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ftoi2(arg_fcinfo)
    })
}
pub unsafe fn line_distance(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn line_distance(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        line_distance(arg_fcinfo)
    })
}
pub unsafe fn nameeqtext(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn nameeqtext(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        nameeqtext(arg_fcinfo)
    })
}
pub unsafe fn namelttext(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn namelttext(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        namelttext(arg_fcinfo)
    })
}
pub unsafe fn nameletext(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn nameletext(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        nameletext(arg_fcinfo)
    })
}
pub unsafe fn namegetext(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn namegetext(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        namegetext(arg_fcinfo)
    })
}
pub unsafe fn namegttext(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn namegttext(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        namegttext(arg_fcinfo)
    })
}
pub unsafe fn namenetext(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn namenetext(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        namenetext(arg_fcinfo)
    })
}
pub unsafe fn btnametextcmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btnametextcmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btnametextcmp(arg_fcinfo)
    })
}
pub unsafe fn texteqname(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn texteqname(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        texteqname(arg_fcinfo)
    })
}
pub unsafe fn textltname(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn textltname(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        textltname(arg_fcinfo)
    })
}
pub unsafe fn textlename(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn textlename(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        textlename(arg_fcinfo)
    })
}
pub unsafe fn textgename(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn textgename(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        textgename(arg_fcinfo)
    })
}
pub unsafe fn textgtname(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn textgtname(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        textgtname(arg_fcinfo)
    })
}
pub unsafe fn textnename(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn textnename(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        textnename(arg_fcinfo)
    })
}
pub unsafe fn bttextnamecmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bttextnamecmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bttextnamecmp(arg_fcinfo)
    })
}
pub unsafe fn nameconcatoid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn nameconcatoid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        nameconcatoid(arg_fcinfo)
    })
}
pub unsafe fn table_am_handler_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn table_am_handler_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        table_am_handler_in(arg_fcinfo)
    })
}
pub unsafe fn table_am_handler_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn table_am_handler_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        table_am_handler_out(arg_fcinfo)
    })
}
pub unsafe fn timeofday(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timeofday(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timeofday(arg_fcinfo)
    })
}
pub unsafe fn pg_nextoid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_nextoid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_nextoid(arg_fcinfo)
    })
}
pub unsafe fn inter_sl(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inter_sl(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        inter_sl(arg_fcinfo)
    })
}
pub unsafe fn inter_lb(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inter_lb(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        inter_lb(arg_fcinfo)
    })
}
pub unsafe fn ftod(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ftod(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ftod(arg_fcinfo)
    })
}
pub unsafe fn dtof(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dtof(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dtof(arg_fcinfo)
    })
}
pub unsafe fn i2toi4(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn i2toi4(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        i2toi4(arg_fcinfo)
    })
}
pub unsafe fn i4toi2(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn i4toi2(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        i4toi2(arg_fcinfo)
    })
}
pub unsafe fn pg_jit_available(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_jit_available(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_jit_available(arg_fcinfo)
    })
}
pub unsafe fn i4tod(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn i4tod(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        i4tod(arg_fcinfo)
    })
}
pub unsafe fn dtoi4(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dtoi4(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dtoi4(arg_fcinfo)
    })
}
pub unsafe fn i4tof(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn i4tof(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        i4tof(arg_fcinfo)
    })
}
pub unsafe fn ftoi4(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ftoi4(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ftoi4(arg_fcinfo)
    })
}
pub unsafe fn width_bucket_float8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn width_bucket_float8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        width_bucket_float8(arg_fcinfo)
    })
}
pub unsafe fn json_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_in(arg_fcinfo)
    })
}
pub unsafe fn json_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_out(arg_fcinfo)
    })
}
pub unsafe fn json_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_recv(arg_fcinfo)
    })
}
pub unsafe fn json_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_send(arg_fcinfo)
    })
}
pub unsafe fn index_am_handler_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_am_handler_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        index_am_handler_in(arg_fcinfo)
    })
}
pub unsafe fn index_am_handler_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_am_handler_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        index_am_handler_out(arg_fcinfo)
    })
}
pub unsafe fn hashmacaddr8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashmacaddr8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashmacaddr8(arg_fcinfo)
    })
}
pub unsafe fn hash_aclitem(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hash_aclitem(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hash_aclitem(arg_fcinfo)
    })
}
pub unsafe fn bthandler(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bthandler(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bthandler(arg_fcinfo)
    })
}
pub unsafe fn hashhandler(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashhandler(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashhandler(arg_fcinfo)
    })
}
pub unsafe fn gisthandler(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gisthandler(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gisthandler(arg_fcinfo)
    })
}
pub unsafe fn ginhandler(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ginhandler(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ginhandler(arg_fcinfo)
    })
}
pub unsafe fn spghandler(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn spghandler(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        spghandler(arg_fcinfo)
    })
}
pub unsafe fn brinhandler(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn brinhandler(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        brinhandler(arg_fcinfo)
    })
}
pub unsafe fn scalarlesel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn scalarlesel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        scalarlesel(arg_fcinfo)
    })
}
pub unsafe fn scalargesel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn scalargesel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        scalargesel(arg_fcinfo)
    })
}
pub unsafe fn amvalidate(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn amvalidate(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        amvalidate(arg_fcinfo)
    })
}
pub unsafe fn poly_same(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn poly_same(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        poly_same(arg_fcinfo)
    })
}
pub unsafe fn poly_contain(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn poly_contain(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        poly_contain(arg_fcinfo)
    })
}
pub unsafe fn poly_left(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn poly_left(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        poly_left(arg_fcinfo)
    })
}
pub unsafe fn poly_overleft(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn poly_overleft(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        poly_overleft(arg_fcinfo)
    })
}
pub unsafe fn poly_overright(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn poly_overright(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        poly_overright(arg_fcinfo)
    })
}
pub unsafe fn poly_right(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn poly_right(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        poly_right(arg_fcinfo)
    })
}
pub unsafe fn poly_contained(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn poly_contained(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        poly_contained(arg_fcinfo)
    })
}
pub unsafe fn poly_overlap(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn poly_overlap(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        poly_overlap(arg_fcinfo)
    })
}
pub unsafe fn poly_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn poly_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        poly_in(arg_fcinfo)
    })
}
pub unsafe fn poly_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn poly_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        poly_out(arg_fcinfo)
    })
}
pub unsafe fn btint2cmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btint2cmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btint2cmp(arg_fcinfo)
    })
}
pub unsafe fn btint4cmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btint4cmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btint4cmp(arg_fcinfo)
    })
}
pub unsafe fn btfloat4cmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btfloat4cmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btfloat4cmp(arg_fcinfo)
    })
}
pub unsafe fn btfloat8cmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btfloat8cmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btfloat8cmp(arg_fcinfo)
    })
}
pub unsafe fn btoidcmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btoidcmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btoidcmp(arg_fcinfo)
    })
}
pub unsafe fn dist_bp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dist_bp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dist_bp(arg_fcinfo)
    })
}
pub unsafe fn btcharcmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btcharcmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btcharcmp(arg_fcinfo)
    })
}
pub unsafe fn btnamecmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btnamecmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btnamecmp(arg_fcinfo)
    })
}
pub unsafe fn bttextcmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bttextcmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bttextcmp(arg_fcinfo)
    })
}
pub unsafe fn lseg_distance(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lseg_distance(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        lseg_distance(arg_fcinfo)
    })
}
pub unsafe fn lseg_interpt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lseg_interpt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        lseg_interpt(arg_fcinfo)
    })
}
pub unsafe fn dist_ps(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dist_ps(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dist_ps(arg_fcinfo)
    })
}
pub unsafe fn dist_pb(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dist_pb(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dist_pb(arg_fcinfo)
    })
}
pub unsafe fn dist_sb(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dist_sb(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dist_sb(arg_fcinfo)
    })
}
pub unsafe fn close_ps(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn close_ps(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        close_ps(arg_fcinfo)
    })
}
pub unsafe fn close_pb(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn close_pb(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        close_pb(arg_fcinfo)
    })
}
pub unsafe fn close_sb(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn close_sb(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        close_sb(arg_fcinfo)
    })
}
pub unsafe fn on_ps(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn on_ps(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        on_ps(arg_fcinfo)
    })
}
pub unsafe fn path_distance(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn path_distance(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        path_distance(arg_fcinfo)
    })
}
pub unsafe fn dist_ppath(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dist_ppath(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dist_ppath(arg_fcinfo)
    })
}
pub unsafe fn on_sb(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn on_sb(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        on_sb(arg_fcinfo)
    })
}
pub unsafe fn inter_sb(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inter_sb(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        inter_sb(arg_fcinfo)
    })
}
pub unsafe fn text_to_array_null(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn text_to_array_null(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        text_to_array_null(arg_fcinfo)
    })
}
pub unsafe fn cash_cmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cash_cmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cash_cmp(arg_fcinfo)
    })
}
pub unsafe fn array_append(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_append(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_append(arg_fcinfo)
    })
}
pub unsafe fn array_prepend(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_prepend(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_prepend(arg_fcinfo)
    })
}
pub unsafe fn dist_sp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dist_sp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dist_sp(arg_fcinfo)
    })
}
pub unsafe fn dist_bs(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dist_bs(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dist_bs(arg_fcinfo)
    })
}
pub unsafe fn btarraycmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btarraycmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btarraycmp(arg_fcinfo)
    })
}
pub unsafe fn array_cat(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_cat(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_cat(arg_fcinfo)
    })
}
pub unsafe fn array_to_text_null(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_to_text_null(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_to_text_null(arg_fcinfo)
    })
}
pub unsafe fn scalarlejoinsel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn scalarlejoinsel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        scalarlejoinsel(arg_fcinfo)
    })
}
pub unsafe fn array_ne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_ne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_ne(arg_fcinfo)
    })
}
pub unsafe fn array_lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_lt(arg_fcinfo)
    })
}
pub unsafe fn array_gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_gt(arg_fcinfo)
    })
}
pub unsafe fn array_le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_le(arg_fcinfo)
    })
}
pub unsafe fn text_to_array(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn text_to_array(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        text_to_array(arg_fcinfo)
    })
}
pub unsafe fn array_to_text(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_to_text(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_to_text(arg_fcinfo)
    })
}
pub unsafe fn array_ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_ge(arg_fcinfo)
    })
}
pub unsafe fn scalargejoinsel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn scalargejoinsel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        scalargejoinsel(arg_fcinfo)
    })
}
pub unsafe fn hashmacaddr(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashmacaddr(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashmacaddr(arg_fcinfo)
    })
}
pub unsafe fn hashtext(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashtext(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashtext(arg_fcinfo)
    })
}
pub unsafe fn rtrim1(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn rtrim1(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        rtrim1(arg_fcinfo)
    })
}
pub unsafe fn btoidvectorcmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btoidvectorcmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btoidvectorcmp(arg_fcinfo)
    })
}
pub unsafe fn name_text(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn name_text(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        name_text(arg_fcinfo)
    })
}
pub unsafe fn text_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn text_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        text_name(arg_fcinfo)
    })
}
pub unsafe fn name_bpchar(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn name_bpchar(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        name_bpchar(arg_fcinfo)
    })
}
pub unsafe fn bpchar_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bpchar_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bpchar_name(arg_fcinfo)
    })
}
pub unsafe fn dist_pathp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dist_pathp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dist_pathp(arg_fcinfo)
    })
}
pub unsafe fn hashinet(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashinet(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashinet(arg_fcinfo)
    })
}
pub unsafe fn hashint4extended(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashint4extended(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashint4extended(arg_fcinfo)
    })
}
pub unsafe fn hash_numeric(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hash_numeric(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hash_numeric(arg_fcinfo)
    })
}
pub unsafe fn macaddr_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn macaddr_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        macaddr_in(arg_fcinfo)
    })
}
pub unsafe fn macaddr_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn macaddr_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        macaddr_out(arg_fcinfo)
    })
}
pub unsafe fn pg_num_nulls(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_num_nulls(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_num_nulls(arg_fcinfo)
    })
}
pub unsafe fn pg_num_nonnulls(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_num_nonnulls(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_num_nonnulls(arg_fcinfo)
    })
}
pub unsafe fn hashint2extended(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashint2extended(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashint2extended(arg_fcinfo)
    })
}
pub unsafe fn hashint8extended(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashint8extended(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashint8extended(arg_fcinfo)
    })
}
pub unsafe fn hashfloat4extended(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashfloat4extended(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashfloat4extended(arg_fcinfo)
    })
}
pub unsafe fn hashfloat8extended(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashfloat8extended(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashfloat8extended(arg_fcinfo)
    })
}
pub unsafe fn hashoidextended(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashoidextended(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashoidextended(arg_fcinfo)
    })
}
pub unsafe fn hashcharextended(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashcharextended(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashcharextended(arg_fcinfo)
    })
}
pub unsafe fn hashnameextended(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashnameextended(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashnameextended(arg_fcinfo)
    })
}
pub unsafe fn hashtextextended(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashtextextended(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashtextextended(arg_fcinfo)
    })
}
pub unsafe fn hashint2(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashint2(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashint2(arg_fcinfo)
    })
}
pub unsafe fn hashint4(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashint4(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashint4(arg_fcinfo)
    })
}
pub unsafe fn hashfloat4(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashfloat4(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashfloat4(arg_fcinfo)
    })
}
pub unsafe fn hashfloat8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashfloat8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashfloat8(arg_fcinfo)
    })
}
pub unsafe fn hashoid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashoid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashoid(arg_fcinfo)
    })
}
pub unsafe fn hashchar(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashchar(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashchar(arg_fcinfo)
    })
}
pub unsafe fn hashname(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashname(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashname(arg_fcinfo)
    })
}
pub unsafe fn hashvarlena(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashvarlena(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashvarlena(arg_fcinfo)
    })
}
pub unsafe fn hashoidvector(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashoidvector(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashoidvector(arg_fcinfo)
    })
}
pub unsafe fn text_larger(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn text_larger(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        text_larger(arg_fcinfo)
    })
}
pub unsafe fn text_smaller(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn text_smaller(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        text_smaller(arg_fcinfo)
    })
}
pub unsafe fn int8in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8in(arg_fcinfo)
    })
}
pub unsafe fn int8out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8out(arg_fcinfo)
    })
}
pub unsafe fn int8um(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8um(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8um(arg_fcinfo)
    })
}
pub unsafe fn int8pl(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8pl(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8pl(arg_fcinfo)
    })
}
pub unsafe fn int8mi(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8mi(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8mi(arg_fcinfo)
    })
}
pub unsafe fn int8mul(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8mul(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8mul(arg_fcinfo)
    })
}
pub unsafe fn int8div(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8div(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8div(arg_fcinfo)
    })
}
pub unsafe fn int8eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8eq(arg_fcinfo)
    })
}
pub unsafe fn int8ne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8ne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8ne(arg_fcinfo)
    })
}
pub unsafe fn int8lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8lt(arg_fcinfo)
    })
}
pub unsafe fn int8gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8gt(arg_fcinfo)
    })
}
pub unsafe fn int8le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8le(arg_fcinfo)
    })
}
pub unsafe fn int8ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8ge(arg_fcinfo)
    })
}
pub unsafe fn int84eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int84eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int84eq(arg_fcinfo)
    })
}
pub unsafe fn int84ne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int84ne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int84ne(arg_fcinfo)
    })
}
pub unsafe fn int84lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int84lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int84lt(arg_fcinfo)
    })
}
pub unsafe fn int84gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int84gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int84gt(arg_fcinfo)
    })
}
pub unsafe fn int84le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int84le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int84le(arg_fcinfo)
    })
}
pub unsafe fn int84ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int84ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int84ge(arg_fcinfo)
    })
}
pub unsafe fn int84(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int84(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int84(arg_fcinfo)
    })
}
pub unsafe fn int48(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int48(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int48(arg_fcinfo)
    })
}
pub unsafe fn i8tod(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn i8tod(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        i8tod(arg_fcinfo)
    })
}
pub unsafe fn dtoi8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dtoi8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dtoi8(arg_fcinfo)
    })
}
pub unsafe fn array_larger(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_larger(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_larger(arg_fcinfo)
    })
}
pub unsafe fn array_smaller(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_smaller(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_smaller(arg_fcinfo)
    })
}
pub unsafe fn inet_abbrev(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet_abbrev(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        inet_abbrev(arg_fcinfo)
    })
}
pub unsafe fn cidr_abbrev(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cidr_abbrev(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cidr_abbrev(arg_fcinfo)
    })
}
pub unsafe fn inet_set_masklen(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet_set_masklen(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        inet_set_masklen(arg_fcinfo)
    })
}
pub unsafe fn oidvectorne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn oidvectorne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        oidvectorne(arg_fcinfo)
    })
}
pub unsafe fn hash_array(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hash_array(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hash_array(arg_fcinfo)
    })
}
pub unsafe fn cidr_set_masklen(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cidr_set_masklen(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cidr_set_masklen(arg_fcinfo)
    })
}
pub unsafe fn pg_indexam_has_property(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_indexam_has_property(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_indexam_has_property(arg_fcinfo)
    })
}
pub unsafe fn pg_index_has_property(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_index_has_property(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_index_has_property(arg_fcinfo)
    })
}
pub unsafe fn pg_index_column_has_property(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_index_column_has_property(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_index_column_has_property(arg_fcinfo)
    })
}
pub unsafe fn i8tof(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn i8tof(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        i8tof(arg_fcinfo)
    })
}
pub unsafe fn ftoi8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ftoi8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ftoi8(arg_fcinfo)
    })
}
pub unsafe fn namelt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn namelt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        namelt(arg_fcinfo)
    })
}
pub unsafe fn namele(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn namele(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        namele(arg_fcinfo)
    })
}
pub unsafe fn namegt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn namegt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        namegt(arg_fcinfo)
    })
}
pub unsafe fn namege(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn namege(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        namege(arg_fcinfo)
    })
}
pub unsafe fn namene(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn namene(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        namene(arg_fcinfo)
    })
}
pub unsafe fn bpchar(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bpchar(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bpchar(arg_fcinfo)
    })
}
pub unsafe fn varchar(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn varchar(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        varchar(arg_fcinfo)
    })
}
pub unsafe fn pg_indexam_progress_phasename(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_indexam_progress_phasename(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_indexam_progress_phasename(arg_fcinfo)
    })
}
pub unsafe fn oidvectorlt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn oidvectorlt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        oidvectorlt(arg_fcinfo)
    })
}
pub unsafe fn oidvectorle(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn oidvectorle(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        oidvectorle(arg_fcinfo)
    })
}
pub unsafe fn oidvectoreq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn oidvectoreq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        oidvectoreq(arg_fcinfo)
    })
}
pub unsafe fn oidvectorge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn oidvectorge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        oidvectorge(arg_fcinfo)
    })
}
pub unsafe fn oidvectorgt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn oidvectorgt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        oidvectorgt(arg_fcinfo)
    })
}
pub unsafe fn network_network(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn network_network(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        network_network(arg_fcinfo)
    })
}
pub unsafe fn network_netmask(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn network_netmask(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        network_netmask(arg_fcinfo)
    })
}
pub unsafe fn network_masklen(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn network_masklen(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        network_masklen(arg_fcinfo)
    })
}
pub unsafe fn network_broadcast(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn network_broadcast(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        network_broadcast(arg_fcinfo)
    })
}
pub unsafe fn network_host(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn network_host(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        network_host(arg_fcinfo)
    })
}
pub unsafe fn dist_lp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dist_lp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dist_lp(arg_fcinfo)
    })
}
pub unsafe fn dist_bl(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dist_bl(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dist_bl(arg_fcinfo)
    })
}
pub unsafe fn dist_ls(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dist_ls(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dist_ls(arg_fcinfo)
    })
}
pub unsafe fn current_user(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn current_user(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        current_user(arg_fcinfo)
    })
}
pub unsafe fn network_family(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn network_family(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        network_family(arg_fcinfo)
    })
}
pub unsafe fn int82(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int82(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int82(arg_fcinfo)
    })
}
pub unsafe fn be_lo_create(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn be_lo_create(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        be_lo_create(arg_fcinfo)
    })
}
pub unsafe fn oidlt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn oidlt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        oidlt(arg_fcinfo)
    })
}
pub unsafe fn oidle(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn oidle(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        oidle(arg_fcinfo)
    })
}
pub unsafe fn byteaoctetlen(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn byteaoctetlen(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        byteaoctetlen(arg_fcinfo)
    })
}
pub unsafe fn byteaGetByte(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn byteaGetByte(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        byteaGetByte(arg_fcinfo)
    })
}
pub unsafe fn byteaSetByte(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn byteaSetByte(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        byteaSetByte(arg_fcinfo)
    })
}
pub unsafe fn byteaGetBit(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn byteaGetBit(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        byteaGetBit(arg_fcinfo)
    })
}
pub unsafe fn byteaSetBit(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn byteaSetBit(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        byteaSetBit(arg_fcinfo)
    })
}
pub unsafe fn dist_pl(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dist_pl(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dist_pl(arg_fcinfo)
    })
}
pub unsafe fn dist_lb(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dist_lb(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dist_lb(arg_fcinfo)
    })
}
pub unsafe fn dist_sl(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dist_sl(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dist_sl(arg_fcinfo)
    })
}
pub unsafe fn dist_cpoly(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dist_cpoly(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dist_cpoly(arg_fcinfo)
    })
}
pub unsafe fn poly_distance(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn poly_distance(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        poly_distance(arg_fcinfo)
    })
}
pub unsafe fn network_show(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn network_show(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        network_show(arg_fcinfo)
    })
}
pub unsafe fn text_lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn text_lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        text_lt(arg_fcinfo)
    })
}
pub unsafe fn text_le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn text_le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        text_le(arg_fcinfo)
    })
}
pub unsafe fn text_gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn text_gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        text_gt(arg_fcinfo)
    })
}
pub unsafe fn text_ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn text_ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        text_ge(arg_fcinfo)
    })
}
pub unsafe fn array_eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_eq(arg_fcinfo)
    })
}
pub unsafe fn session_user(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn session_user(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        session_user(arg_fcinfo)
    })
}
pub unsafe fn array_dims(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_dims(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_dims(arg_fcinfo)
    })
}
pub unsafe fn array_ndims(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_ndims(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_ndims(arg_fcinfo)
    })
}
pub unsafe fn byteaoverlay(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn byteaoverlay(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        byteaoverlay(arg_fcinfo)
    })
}
pub unsafe fn array_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_in(arg_fcinfo)
    })
}
pub unsafe fn array_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_out(arg_fcinfo)
    })
}
pub unsafe fn byteaoverlay_no_len(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn byteaoverlay_no_len(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        byteaoverlay_no_len(arg_fcinfo)
    })
}
pub unsafe fn macaddr_trunc(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn macaddr_trunc(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        macaddr_trunc(arg_fcinfo)
    })
}
pub unsafe fn int28(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int28(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int28(arg_fcinfo)
    })
}
pub unsafe fn be_lo_import(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn be_lo_import(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        be_lo_import(arg_fcinfo)
    })
}
pub unsafe fn be_lo_export(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn be_lo_export(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        be_lo_export(arg_fcinfo)
    })
}
pub unsafe fn int4inc(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4inc(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4inc(arg_fcinfo)
    })
}
pub unsafe fn be_lo_import_with_oid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn be_lo_import_with_oid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        be_lo_import_with_oid(arg_fcinfo)
    })
}
pub unsafe fn int4larger(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4larger(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4larger(arg_fcinfo)
    })
}
pub unsafe fn int4smaller(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4smaller(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4smaller(arg_fcinfo)
    })
}
pub unsafe fn int2larger(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2larger(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2larger(arg_fcinfo)
    })
}
pub unsafe fn int2smaller(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2smaller(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2smaller(arg_fcinfo)
    })
}
pub unsafe fn hashvarlenaextended(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashvarlenaextended(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashvarlenaextended(arg_fcinfo)
    })
}
pub unsafe fn hashoidvectorextended(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashoidvectorextended(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashoidvectorextended(arg_fcinfo)
    })
}
pub unsafe fn hash_aclitem_extended(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hash_aclitem_extended(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hash_aclitem_extended(arg_fcinfo)
    })
}
pub unsafe fn hashmacaddrextended(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashmacaddrextended(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashmacaddrextended(arg_fcinfo)
    })
}
pub unsafe fn hashinetextended(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashinetextended(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashinetextended(arg_fcinfo)
    })
}
pub unsafe fn hash_numeric_extended(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hash_numeric_extended(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hash_numeric_extended(arg_fcinfo)
    })
}
pub unsafe fn hashmacaddr8extended(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashmacaddr8extended(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashmacaddr8extended(arg_fcinfo)
    })
}
pub unsafe fn hash_array_extended(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hash_array_extended(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hash_array_extended(arg_fcinfo)
    })
}
pub unsafe fn dist_polyc(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dist_polyc(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dist_polyc(arg_fcinfo)
    })
}
pub unsafe fn pg_client_encoding(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_client_encoding(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_client_encoding(arg_fcinfo)
    })
}
pub unsafe fn current_query(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn current_query(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        current_query(arg_fcinfo)
    })
}
pub unsafe fn macaddr_eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn macaddr_eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        macaddr_eq(arg_fcinfo)
    })
}
pub unsafe fn macaddr_lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn macaddr_lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        macaddr_lt(arg_fcinfo)
    })
}
pub unsafe fn macaddr_le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn macaddr_le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        macaddr_le(arg_fcinfo)
    })
}
pub unsafe fn macaddr_gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn macaddr_gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        macaddr_gt(arg_fcinfo)
    })
}
pub unsafe fn macaddr_ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn macaddr_ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        macaddr_ge(arg_fcinfo)
    })
}
pub unsafe fn macaddr_ne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn macaddr_ne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        macaddr_ne(arg_fcinfo)
    })
}
pub unsafe fn macaddr_cmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn macaddr_cmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        macaddr_cmp(arg_fcinfo)
    })
}
pub unsafe fn int82pl(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int82pl(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int82pl(arg_fcinfo)
    })
}
pub unsafe fn int82mi(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int82mi(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int82mi(arg_fcinfo)
    })
}
pub unsafe fn int82mul(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int82mul(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int82mul(arg_fcinfo)
    })
}
pub unsafe fn int82div(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int82div(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int82div(arg_fcinfo)
    })
}
pub unsafe fn int28pl(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int28pl(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int28pl(arg_fcinfo)
    })
}
pub unsafe fn btint8cmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btint8cmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btint8cmp(arg_fcinfo)
    })
}
pub unsafe fn cash_mul_flt4(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cash_mul_flt4(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cash_mul_flt4(arg_fcinfo)
    })
}
pub unsafe fn cash_div_flt4(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cash_div_flt4(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cash_div_flt4(arg_fcinfo)
    })
}
pub unsafe fn flt4_mul_cash(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn flt4_mul_cash(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        flt4_mul_cash(arg_fcinfo)
    })
}
pub unsafe fn textpos(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn textpos(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        textpos(arg_fcinfo)
    })
}
pub unsafe fn textlike(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn textlike(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        textlike(arg_fcinfo)
    })
}
pub unsafe fn textnlike(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn textnlike(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        textnlike(arg_fcinfo)
    })
}
pub unsafe fn int48eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int48eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int48eq(arg_fcinfo)
    })
}
pub unsafe fn int48ne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int48ne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int48ne(arg_fcinfo)
    })
}
pub unsafe fn int48lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int48lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int48lt(arg_fcinfo)
    })
}
pub unsafe fn int48gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int48gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int48gt(arg_fcinfo)
    })
}
pub unsafe fn int48le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int48le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int48le(arg_fcinfo)
    })
}
pub unsafe fn int48ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int48ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int48ge(arg_fcinfo)
    })
}
pub unsafe fn namelike(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn namelike(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        namelike(arg_fcinfo)
    })
}
pub unsafe fn namenlike(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn namenlike(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        namenlike(arg_fcinfo)
    })
}
pub unsafe fn char_bpchar(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn char_bpchar(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        char_bpchar(arg_fcinfo)
    })
}
pub unsafe fn current_database(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn current_database(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        current_database(arg_fcinfo)
    })
}
pub unsafe fn int4_mul_cash(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4_mul_cash(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4_mul_cash(arg_fcinfo)
    })
}
pub unsafe fn int2_mul_cash(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2_mul_cash(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2_mul_cash(arg_fcinfo)
    })
}
pub unsafe fn cash_mul_int4(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cash_mul_int4(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cash_mul_int4(arg_fcinfo)
    })
}
pub unsafe fn cash_div_int4(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cash_div_int4(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cash_div_int4(arg_fcinfo)
    })
}
pub unsafe fn cash_mul_int2(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cash_mul_int2(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cash_mul_int2(arg_fcinfo)
    })
}
pub unsafe fn cash_div_int2(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cash_div_int2(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cash_div_int2(arg_fcinfo)
    })
}
pub unsafe fn lower(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lower(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        lower(arg_fcinfo)
    })
}
pub unsafe fn upper(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn upper(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        upper(arg_fcinfo)
    })
}
pub unsafe fn initcap(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn initcap(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        initcap(arg_fcinfo)
    })
}
pub unsafe fn lpad(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lpad(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        lpad(arg_fcinfo)
    })
}
pub unsafe fn rpad(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn rpad(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        rpad(arg_fcinfo)
    })
}
pub unsafe fn ltrim(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ltrim(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ltrim(arg_fcinfo)
    })
}
pub unsafe fn rtrim(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn rtrim(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        rtrim(arg_fcinfo)
    })
}
pub unsafe fn text_substr(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn text_substr(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        text_substr(arg_fcinfo)
    })
}
pub unsafe fn translate(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn translate(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        translate(arg_fcinfo)
    })
}
pub unsafe fn ltrim1(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ltrim1(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ltrim1(arg_fcinfo)
    })
}
pub unsafe fn text_substr_no_len(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn text_substr_no_len(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        text_substr_no_len(arg_fcinfo)
    })
}
pub unsafe fn btrim(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btrim(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btrim(arg_fcinfo)
    })
}
pub unsafe fn btrim1(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btrim1(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btrim1(arg_fcinfo)
    })
}
pub unsafe fn cash_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cash_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cash_in(arg_fcinfo)
    })
}
pub unsafe fn cash_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cash_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cash_out(arg_fcinfo)
    })
}
pub unsafe fn cash_eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cash_eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cash_eq(arg_fcinfo)
    })
}
pub unsafe fn cash_ne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cash_ne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cash_ne(arg_fcinfo)
    })
}
pub unsafe fn cash_lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cash_lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cash_lt(arg_fcinfo)
    })
}
pub unsafe fn cash_le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cash_le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cash_le(arg_fcinfo)
    })
}
pub unsafe fn cash_gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cash_gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cash_gt(arg_fcinfo)
    })
}
pub unsafe fn cash_ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cash_ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cash_ge(arg_fcinfo)
    })
}
pub unsafe fn cash_pl(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cash_pl(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cash_pl(arg_fcinfo)
    })
}
pub unsafe fn cash_mi(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cash_mi(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cash_mi(arg_fcinfo)
    })
}
pub unsafe fn cash_mul_flt8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cash_mul_flt8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cash_mul_flt8(arg_fcinfo)
    })
}
pub unsafe fn cash_div_flt8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cash_div_flt8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cash_div_flt8(arg_fcinfo)
    })
}
pub unsafe fn cashlarger(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cashlarger(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cashlarger(arg_fcinfo)
    })
}
pub unsafe fn cashsmaller(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cashsmaller(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cashsmaller(arg_fcinfo)
    })
}
pub unsafe fn inet_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        inet_in(arg_fcinfo)
    })
}
pub unsafe fn inet_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        inet_out(arg_fcinfo)
    })
}
pub unsafe fn flt8_mul_cash(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn flt8_mul_cash(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        flt8_mul_cash(arg_fcinfo)
    })
}
pub unsafe fn network_eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn network_eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        network_eq(arg_fcinfo)
    })
}
pub unsafe fn network_lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn network_lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        network_lt(arg_fcinfo)
    })
}
pub unsafe fn network_le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn network_le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        network_le(arg_fcinfo)
    })
}
pub unsafe fn network_gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn network_gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        network_gt(arg_fcinfo)
    })
}
pub unsafe fn network_ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn network_ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        network_ge(arg_fcinfo)
    })
}
pub unsafe fn network_ne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn network_ne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        network_ne(arg_fcinfo)
    })
}
pub unsafe fn network_cmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn network_cmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        network_cmp(arg_fcinfo)
    })
}
pub unsafe fn network_sub(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn network_sub(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        network_sub(arg_fcinfo)
    })
}
pub unsafe fn network_subeq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn network_subeq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        network_subeq(arg_fcinfo)
    })
}
pub unsafe fn network_sup(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn network_sup(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        network_sup(arg_fcinfo)
    })
}
pub unsafe fn network_supeq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn network_supeq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        network_supeq(arg_fcinfo)
    })
}
pub unsafe fn cash_words(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cash_words(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cash_words(arg_fcinfo)
    })
}
pub unsafe fn generate_series_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn generate_series_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        generate_series_timestamp(arg_fcinfo)
    })
}
pub unsafe fn generate_series_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn generate_series_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        generate_series_timestamptz(arg_fcinfo)
    })
}
pub unsafe fn int28mi(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int28mi(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int28mi(arg_fcinfo)
    })
}
pub unsafe fn int28mul(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int28mul(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int28mul(arg_fcinfo)
    })
}
pub unsafe fn text_char(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn text_char(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        text_char(arg_fcinfo)
    })
}
pub unsafe fn int8mod(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8mod(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8mod(arg_fcinfo)
    })
}
pub unsafe fn char_text(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn char_text(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        char_text(arg_fcinfo)
    })
}
pub unsafe fn int28div(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int28div(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int28div(arg_fcinfo)
    })
}
pub unsafe fn hashint8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashint8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashint8(arg_fcinfo)
    })
}
pub unsafe fn be_lo_open(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn be_lo_open(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        be_lo_open(arg_fcinfo)
    })
}
pub unsafe fn be_lo_close(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn be_lo_close(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        be_lo_close(arg_fcinfo)
    })
}
pub unsafe fn be_loread(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn be_loread(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        be_loread(arg_fcinfo)
    })
}
pub unsafe fn be_lowrite(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn be_lowrite(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        be_lowrite(arg_fcinfo)
    })
}
pub unsafe fn be_lo_lseek(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn be_lo_lseek(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        be_lo_lseek(arg_fcinfo)
    })
}
pub unsafe fn be_lo_creat(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn be_lo_creat(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        be_lo_creat(arg_fcinfo)
    })
}
pub unsafe fn be_lo_tell(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn be_lo_tell(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        be_lo_tell(arg_fcinfo)
    })
}
pub unsafe fn on_pl(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn on_pl(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        on_pl(arg_fcinfo)
    })
}
pub unsafe fn on_sl(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn on_sl(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        on_sl(arg_fcinfo)
    })
}
pub unsafe fn close_pl(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn close_pl(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        close_pl(arg_fcinfo)
    })
}
pub unsafe fn close_sl(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn close_sl(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        close_sl(arg_fcinfo)
    })
}
pub unsafe fn close_lb(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn close_lb(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        close_lb(arg_fcinfo)
    })
}
pub unsafe fn be_lo_unlink(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn be_lo_unlink(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        be_lo_unlink(arg_fcinfo)
    })
}
pub unsafe fn hashbpcharextended(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashbpcharextended(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashbpcharextended(arg_fcinfo)
    })
}
pub unsafe fn path_inter(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn path_inter(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        path_inter(arg_fcinfo)
    })
}
pub unsafe fn box_area(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_area(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_area(arg_fcinfo)
    })
}
pub unsafe fn box_width(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_width(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_width(arg_fcinfo)
    })
}
pub unsafe fn box_height(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_height(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_height(arg_fcinfo)
    })
}
pub unsafe fn box_distance(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_distance(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_distance(arg_fcinfo)
    })
}
pub unsafe fn path_area(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn path_area(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        path_area(arg_fcinfo)
    })
}
pub unsafe fn box_intersect(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_intersect(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_intersect(arg_fcinfo)
    })
}
pub unsafe fn box_diagonal(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_diagonal(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_diagonal(arg_fcinfo)
    })
}
pub unsafe fn path_n_lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn path_n_lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        path_n_lt(arg_fcinfo)
    })
}
pub unsafe fn path_n_gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn path_n_gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        path_n_gt(arg_fcinfo)
    })
}
pub unsafe fn path_n_eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn path_n_eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        path_n_eq(arg_fcinfo)
    })
}
pub unsafe fn path_n_le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn path_n_le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        path_n_le(arg_fcinfo)
    })
}
pub unsafe fn path_n_ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn path_n_ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        path_n_ge(arg_fcinfo)
    })
}
pub unsafe fn path_length(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn path_length(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        path_length(arg_fcinfo)
    })
}
pub unsafe fn point_ne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn point_ne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        point_ne(arg_fcinfo)
    })
}
pub unsafe fn point_vert(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn point_vert(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        point_vert(arg_fcinfo)
    })
}
pub unsafe fn point_horiz(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn point_horiz(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        point_horiz(arg_fcinfo)
    })
}
pub unsafe fn point_distance(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn point_distance(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        point_distance(arg_fcinfo)
    })
}
pub unsafe fn point_slope(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn point_slope(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        point_slope(arg_fcinfo)
    })
}
pub unsafe fn lseg_construct(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lseg_construct(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        lseg_construct(arg_fcinfo)
    })
}
pub unsafe fn lseg_intersect(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lseg_intersect(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        lseg_intersect(arg_fcinfo)
    })
}
pub unsafe fn lseg_parallel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lseg_parallel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        lseg_parallel(arg_fcinfo)
    })
}
pub unsafe fn lseg_perp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lseg_perp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        lseg_perp(arg_fcinfo)
    })
}
pub unsafe fn lseg_vertical(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lseg_vertical(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        lseg_vertical(arg_fcinfo)
    })
}
pub unsafe fn lseg_horizontal(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lseg_horizontal(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        lseg_horizontal(arg_fcinfo)
    })
}
pub unsafe fn lseg_eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lseg_eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        lseg_eq(arg_fcinfo)
    })
}
pub unsafe fn be_lo_truncate(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn be_lo_truncate(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        be_lo_truncate(arg_fcinfo)
    })
}
pub unsafe fn textlike_support(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn textlike_support(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        textlike_support(arg_fcinfo)
    })
}
pub unsafe fn texticregexeq_support(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn texticregexeq_support(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        texticregexeq_support(arg_fcinfo)
    })
}
pub unsafe fn texticlike_support(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn texticlike_support(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        texticlike_support(arg_fcinfo)
    })
}
pub unsafe fn timestamptz_izone(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptz_izone(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptz_izone(arg_fcinfo)
    })
}
pub unsafe fn gist_point_compress(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gist_point_compress(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gist_point_compress(arg_fcinfo)
    })
}
pub unsafe fn aclitemin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn aclitemin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        aclitemin(arg_fcinfo)
    })
}
pub unsafe fn aclitemout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn aclitemout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        aclitemout(arg_fcinfo)
    })
}
pub unsafe fn aclinsert(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn aclinsert(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        aclinsert(arg_fcinfo)
    })
}
pub unsafe fn aclremove(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn aclremove(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        aclremove(arg_fcinfo)
    })
}
pub unsafe fn aclcontains(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn aclcontains(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        aclcontains(arg_fcinfo)
    })
}
pub unsafe fn getdatabaseencoding(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getdatabaseencoding(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        getdatabaseencoding(arg_fcinfo)
    })
}
pub unsafe fn bpcharin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bpcharin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bpcharin(arg_fcinfo)
    })
}
pub unsafe fn bpcharout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bpcharout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bpcharout(arg_fcinfo)
    })
}
pub unsafe fn varcharin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn varcharin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        varcharin(arg_fcinfo)
    })
}
pub unsafe fn varcharout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn varcharout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        varcharout(arg_fcinfo)
    })
}
pub unsafe fn bpchareq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bpchareq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bpchareq(arg_fcinfo)
    })
}
pub unsafe fn bpcharlt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bpcharlt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bpcharlt(arg_fcinfo)
    })
}
pub unsafe fn bpcharle(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bpcharle(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bpcharle(arg_fcinfo)
    })
}
pub unsafe fn bpchargt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bpchargt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bpchargt(arg_fcinfo)
    })
}
pub unsafe fn bpcharge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bpcharge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bpcharge(arg_fcinfo)
    })
}
pub unsafe fn bpcharne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bpcharne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bpcharne(arg_fcinfo)
    })
}
pub unsafe fn aclitem_eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn aclitem_eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        aclitem_eq(arg_fcinfo)
    })
}
pub unsafe fn bpchar_larger(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bpchar_larger(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bpchar_larger(arg_fcinfo)
    })
}
pub unsafe fn bpchar_smaller(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bpchar_smaller(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bpchar_smaller(arg_fcinfo)
    })
}
pub unsafe fn pg_prepared_xact(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_prepared_xact(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_prepared_xact(arg_fcinfo)
    })
}
pub unsafe fn generate_series_step_int4(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn generate_series_step_int4(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        generate_series_step_int4(arg_fcinfo)
    })
}
pub unsafe fn generate_series_int4(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn generate_series_int4(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        generate_series_int4(arg_fcinfo)
    })
}
pub unsafe fn generate_series_step_int8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn generate_series_step_int8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        generate_series_step_int8(arg_fcinfo)
    })
}
pub unsafe fn generate_series_int8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn generate_series_int8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        generate_series_int8(arg_fcinfo)
    })
}
pub unsafe fn bpcharcmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bpcharcmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bpcharcmp(arg_fcinfo)
    })
}
pub unsafe fn text_regclass(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn text_regclass(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        text_regclass(arg_fcinfo)
    })
}
pub unsafe fn hashbpchar(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashbpchar(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashbpchar(arg_fcinfo)
    })
}
pub unsafe fn format_type(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn format_type(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        format_type(arg_fcinfo)
    })
}
pub unsafe fn date_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_in(arg_fcinfo)
    })
}
pub unsafe fn date_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_out(arg_fcinfo)
    })
}
pub unsafe fn date_eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_eq(arg_fcinfo)
    })
}
pub unsafe fn date_lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_lt(arg_fcinfo)
    })
}
pub unsafe fn date_le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_le(arg_fcinfo)
    })
}
pub unsafe fn date_gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_gt(arg_fcinfo)
    })
}
pub unsafe fn date_ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_ge(arg_fcinfo)
    })
}
pub unsafe fn date_ne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_ne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_ne(arg_fcinfo)
    })
}
pub unsafe fn date_cmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_cmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_cmp(arg_fcinfo)
    })
}
pub unsafe fn time_lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn time_lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        time_lt(arg_fcinfo)
    })
}
pub unsafe fn time_le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn time_le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        time_le(arg_fcinfo)
    })
}
pub unsafe fn time_gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn time_gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        time_gt(arg_fcinfo)
    })
}
pub unsafe fn time_ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn time_ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        time_ge(arg_fcinfo)
    })
}
pub unsafe fn time_ne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn time_ne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        time_ne(arg_fcinfo)
    })
}
pub unsafe fn time_cmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn time_cmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        time_cmp(arg_fcinfo)
    })
}
pub unsafe fn date_larger(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_larger(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_larger(arg_fcinfo)
    })
}
pub unsafe fn date_smaller(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_smaller(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_smaller(arg_fcinfo)
    })
}
pub unsafe fn date_mi(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_mi(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_mi(arg_fcinfo)
    })
}
pub unsafe fn date_pli(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_pli(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_pli(arg_fcinfo)
    })
}
pub unsafe fn date_mii(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_mii(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_mii(arg_fcinfo)
    })
}
pub unsafe fn time_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn time_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        time_in(arg_fcinfo)
    })
}
pub unsafe fn time_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn time_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        time_out(arg_fcinfo)
    })
}
pub unsafe fn time_eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn time_eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        time_eq(arg_fcinfo)
    })
}
pub unsafe fn circle_add_pt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn circle_add_pt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        circle_add_pt(arg_fcinfo)
    })
}
pub unsafe fn circle_sub_pt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn circle_sub_pt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        circle_sub_pt(arg_fcinfo)
    })
}
pub unsafe fn circle_mul_pt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn circle_mul_pt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        circle_mul_pt(arg_fcinfo)
    })
}
pub unsafe fn circle_div_pt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn circle_div_pt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        circle_div_pt(arg_fcinfo)
    })
}
pub unsafe fn timestamptz_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptz_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptz_in(arg_fcinfo)
    })
}
pub unsafe fn timestamptz_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptz_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptz_out(arg_fcinfo)
    })
}
pub unsafe fn timestamp_eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_eq(arg_fcinfo)
    })
}
pub unsafe fn timestamp_ne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_ne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_ne(arg_fcinfo)
    })
}
pub unsafe fn timestamp_lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_lt(arg_fcinfo)
    })
}
pub unsafe fn timestamp_le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_le(arg_fcinfo)
    })
}
pub unsafe fn timestamp_ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_ge(arg_fcinfo)
    })
}
pub unsafe fn timestamp_gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_gt(arg_fcinfo)
    })
}
pub unsafe fn timestamptz_zone(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptz_zone(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptz_zone(arg_fcinfo)
    })
}
pub unsafe fn interval_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        interval_in(arg_fcinfo)
    })
}
pub unsafe fn interval_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        interval_out(arg_fcinfo)
    })
}
pub unsafe fn interval_eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval_eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        interval_eq(arg_fcinfo)
    })
}
pub unsafe fn interval_ne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval_ne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        interval_ne(arg_fcinfo)
    })
}
pub unsafe fn interval_lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval_lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        interval_lt(arg_fcinfo)
    })
}
pub unsafe fn interval_le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval_le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        interval_le(arg_fcinfo)
    })
}
pub unsafe fn interval_ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval_ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        interval_ge(arg_fcinfo)
    })
}
pub unsafe fn interval_gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval_gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        interval_gt(arg_fcinfo)
    })
}
pub unsafe fn interval_um(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval_um(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        interval_um(arg_fcinfo)
    })
}
pub unsafe fn interval_pl(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval_pl(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        interval_pl(arg_fcinfo)
    })
}
pub unsafe fn interval_mi(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval_mi(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        interval_mi(arg_fcinfo)
    })
}
pub unsafe fn timestamptz_part(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptz_part(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptz_part(arg_fcinfo)
    })
}
pub unsafe fn interval_part(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval_part(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        interval_part(arg_fcinfo)
    })
}
pub unsafe fn network_subset_support(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn network_subset_support(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        network_subset_support(arg_fcinfo)
    })
}
pub unsafe fn date_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_timestamptz(arg_fcinfo)
    })
}
pub unsafe fn interval_justify_hours(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval_justify_hours(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        interval_justify_hours(arg_fcinfo)
    })
}
pub unsafe fn jsonb_path_exists_tz(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_path_exists_tz(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_path_exists_tz(arg_fcinfo)
    })
}
pub unsafe fn timestamptz_date(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptz_date(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptz_date(arg_fcinfo)
    })
}
pub unsafe fn jsonb_path_query_tz(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_path_query_tz(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_path_query_tz(arg_fcinfo)
    })
}
pub unsafe fn jsonb_path_query_array_tz(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_path_query_array_tz(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_path_query_array_tz(arg_fcinfo)
    })
}
pub unsafe fn xid_age(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xid_age(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        xid_age(arg_fcinfo)
    })
}
pub unsafe fn timestamp_mi(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_mi(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_mi(arg_fcinfo)
    })
}
pub unsafe fn timestamptz_pl_interval(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptz_pl_interval(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptz_pl_interval(arg_fcinfo)
    })
}
pub unsafe fn timestamptz_mi_interval(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptz_mi_interval(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptz_mi_interval(arg_fcinfo)
    })
}
pub unsafe fn generate_subscripts(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn generate_subscripts(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        generate_subscripts(arg_fcinfo)
    })
}
pub unsafe fn generate_subscripts_nodir(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn generate_subscripts_nodir(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        generate_subscripts_nodir(arg_fcinfo)
    })
}
pub unsafe fn array_fill(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_fill(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_fill(arg_fcinfo)
    })
}
pub unsafe fn dlog10(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dlog10(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dlog10(arg_fcinfo)
    })
}
pub unsafe fn timestamp_smaller(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_smaller(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_smaller(arg_fcinfo)
    })
}
pub unsafe fn timestamp_larger(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_larger(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_larger(arg_fcinfo)
    })
}
pub unsafe fn interval_smaller(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval_smaller(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        interval_smaller(arg_fcinfo)
    })
}
pub unsafe fn interval_larger(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval_larger(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        interval_larger(arg_fcinfo)
    })
}
pub unsafe fn timestamptz_age(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptz_age(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptz_age(arg_fcinfo)
    })
}
pub unsafe fn interval_scale(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval_scale(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        interval_scale(arg_fcinfo)
    })
}
pub unsafe fn timestamptz_trunc(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptz_trunc(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptz_trunc(arg_fcinfo)
    })
}
pub unsafe fn interval_trunc(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval_trunc(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        interval_trunc(arg_fcinfo)
    })
}
pub unsafe fn int8inc(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8inc(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8inc(arg_fcinfo)
    })
}
pub unsafe fn int8abs(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8abs(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8abs(arg_fcinfo)
    })
}
pub unsafe fn int8larger(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8larger(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8larger(arg_fcinfo)
    })
}
pub unsafe fn int8smaller(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8smaller(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8smaller(arg_fcinfo)
    })
}
pub unsafe fn texticregexeq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn texticregexeq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        texticregexeq(arg_fcinfo)
    })
}
pub unsafe fn texticregexne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn texticregexne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        texticregexne(arg_fcinfo)
    })
}
pub unsafe fn nameicregexeq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn nameicregexeq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        nameicregexeq(arg_fcinfo)
    })
}
pub unsafe fn nameicregexne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn nameicregexne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        nameicregexne(arg_fcinfo)
    })
}
pub unsafe fn boolin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn boolin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        boolin(arg_fcinfo)
    })
}
pub unsafe fn boolout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn boolout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        boolout(arg_fcinfo)
    })
}
pub unsafe fn byteain(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn byteain(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        byteain(arg_fcinfo)
    })
}
pub unsafe fn charin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn charin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        charin(arg_fcinfo)
    })
}
pub unsafe fn charlt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn charlt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        charlt(arg_fcinfo)
    })
}
pub unsafe fn unique_key_recheck(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn unique_key_recheck(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        unique_key_recheck(arg_fcinfo)
    })
}
pub unsafe fn int4abs(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4abs(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4abs(arg_fcinfo)
    })
}
pub unsafe fn nameregexne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn nameregexne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        nameregexne(arg_fcinfo)
    })
}
pub unsafe fn int2abs(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2abs(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2abs(arg_fcinfo)
    })
}
pub unsafe fn textregexeq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn textregexeq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        textregexeq(arg_fcinfo)
    })
}
pub unsafe fn textregexne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn textregexne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        textregexne(arg_fcinfo)
    })
}
pub unsafe fn textlen(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn textlen(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        textlen(arg_fcinfo)
    })
}
pub unsafe fn textcat(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn textcat(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        textcat(arg_fcinfo)
    })
}
pub unsafe fn PG_char_to_encoding(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PG_char_to_encoding(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        PG_char_to_encoding(arg_fcinfo)
    })
}
pub unsafe fn tidne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tidne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tidne(arg_fcinfo)
    })
}
pub unsafe fn cidr_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cidr_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cidr_in(arg_fcinfo)
    })
}
pub unsafe fn parse_ident(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn parse_ident(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        parse_ident(arg_fcinfo)
    })
}
pub unsafe fn pg_column_size(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_column_size(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_column_size(arg_fcinfo)
    })
}
pub unsafe fn overlaps_timetz(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn overlaps_timetz(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        overlaps_timetz(arg_fcinfo)
    })
}
pub unsafe fn datetime_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn datetime_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        datetime_timestamp(arg_fcinfo)
    })
}
pub unsafe fn timetz_part(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timetz_part(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timetz_part(arg_fcinfo)
    })
}
pub unsafe fn int84pl(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int84pl(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int84pl(arg_fcinfo)
    })
}
pub unsafe fn int84mi(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int84mi(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int84mi(arg_fcinfo)
    })
}
pub unsafe fn int84mul(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int84mul(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int84mul(arg_fcinfo)
    })
}
pub unsafe fn int84div(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int84div(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int84div(arg_fcinfo)
    })
}
pub unsafe fn int48pl(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int48pl(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int48pl(arg_fcinfo)
    })
}
pub unsafe fn int48mi(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int48mi(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int48mi(arg_fcinfo)
    })
}
pub unsafe fn int48mul(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int48mul(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int48mul(arg_fcinfo)
    })
}
pub unsafe fn int48div(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int48div(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int48div(arg_fcinfo)
    })
}
pub unsafe fn quote_ident(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn quote_ident(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        quote_ident(arg_fcinfo)
    })
}
pub unsafe fn quote_literal(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn quote_literal(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        quote_literal(arg_fcinfo)
    })
}
pub unsafe fn timestamptz_trunc_zone(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptz_trunc_zone(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptz_trunc_zone(arg_fcinfo)
    })
}
pub unsafe fn array_fill_with_lower_bounds(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_fill_with_lower_bounds(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_fill_with_lower_bounds(arg_fcinfo)
    })
}
pub unsafe fn i8tooid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn i8tooid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        i8tooid(arg_fcinfo)
    })
}
pub unsafe fn oidtoi8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn oidtoi8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        oidtoi8(arg_fcinfo)
    })
}
pub unsafe fn quote_nullable(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn quote_nullable(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        quote_nullable(arg_fcinfo)
    })
}
pub unsafe fn suppress_redundant_updates_trigger(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn suppress_redundant_updates_trigger(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        suppress_redundant_updates_trigger(arg_fcinfo)
    })
}
pub unsafe fn tideq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tideq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tideq(arg_fcinfo)
    })
}
pub unsafe fn currtid_byreloid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn currtid_byreloid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        currtid_byreloid(arg_fcinfo)
    })
}
pub unsafe fn currtid_byrelname(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn currtid_byrelname(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        currtid_byrelname(arg_fcinfo)
    })
}
pub unsafe fn interval_justify_days(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval_justify_days(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        interval_justify_days(arg_fcinfo)
    })
}
pub unsafe fn datetimetz_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn datetimetz_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        datetimetz_timestamptz(arg_fcinfo)
    })
}
pub unsafe fn now(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn now(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        now(arg_fcinfo)
    })
}
pub unsafe fn positionsel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn positionsel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        positionsel(arg_fcinfo)
    })
}
pub unsafe fn positionjoinsel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn positionjoinsel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        positionjoinsel(arg_fcinfo)
    })
}
pub unsafe fn contsel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn contsel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        contsel(arg_fcinfo)
    })
}
pub unsafe fn contjoinsel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn contjoinsel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        contjoinsel(arg_fcinfo)
    })
}
pub unsafe fn overlaps_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn overlaps_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        overlaps_timestamp(arg_fcinfo)
    })
}
pub unsafe fn overlaps_time(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn overlaps_time(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        overlaps_time(arg_fcinfo)
    })
}
pub unsafe fn timestamp_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_in(arg_fcinfo)
    })
}
pub unsafe fn timestamp_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_out(arg_fcinfo)
    })
}
pub unsafe fn timestamp_cmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_cmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_cmp(arg_fcinfo)
    })
}
pub unsafe fn interval_cmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval_cmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        interval_cmp(arg_fcinfo)
    })
}
pub unsafe fn timestamp_time(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_time(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_time(arg_fcinfo)
    })
}
pub unsafe fn bpcharlen(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bpcharlen(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bpcharlen(arg_fcinfo)
    })
}
pub unsafe fn interval_div(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval_div(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        interval_div(arg_fcinfo)
    })
}
pub unsafe fn oidvectortypes(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn oidvectortypes(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        oidvectortypes(arg_fcinfo)
    })
}
pub unsafe fn timetz_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timetz_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timetz_in(arg_fcinfo)
    })
}
pub unsafe fn timetz_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timetz_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timetz_out(arg_fcinfo)
    })
}
pub unsafe fn timetz_eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timetz_eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timetz_eq(arg_fcinfo)
    })
}
pub unsafe fn timetz_ne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timetz_ne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timetz_ne(arg_fcinfo)
    })
}
pub unsafe fn timetz_lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timetz_lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timetz_lt(arg_fcinfo)
    })
}
pub unsafe fn timetz_le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timetz_le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timetz_le(arg_fcinfo)
    })
}
pub unsafe fn timetz_ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timetz_ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timetz_ge(arg_fcinfo)
    })
}
pub unsafe fn timetz_gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timetz_gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timetz_gt(arg_fcinfo)
    })
}
pub unsafe fn timetz_cmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timetz_cmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timetz_cmp(arg_fcinfo)
    })
}
pub unsafe fn network_hostmask(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn network_hostmask(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        network_hostmask(arg_fcinfo)
    })
}
pub unsafe fn textregexeq_support(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn textregexeq_support(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        textregexeq_support(arg_fcinfo)
    })
}
pub unsafe fn makeaclitem(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn makeaclitem(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        makeaclitem(arg_fcinfo)
    })
}
pub unsafe fn time_interval(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn time_interval(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        time_interval(arg_fcinfo)
    })
}
pub unsafe fn pg_lock_status(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_lock_status(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_lock_status(arg_fcinfo)
    })
}
pub unsafe fn date_finite(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_finite(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_finite(arg_fcinfo)
    })
}
pub unsafe fn textoctetlen(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn textoctetlen(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        textoctetlen(arg_fcinfo)
    })
}
pub unsafe fn bpcharoctetlen(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bpcharoctetlen(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bpcharoctetlen(arg_fcinfo)
    })
}
pub unsafe fn time_larger(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn time_larger(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        time_larger(arg_fcinfo)
    })
}
pub unsafe fn time_smaller(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn time_smaller(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        time_smaller(arg_fcinfo)
    })
}
pub unsafe fn timetz_larger(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timetz_larger(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timetz_larger(arg_fcinfo)
    })
}
pub unsafe fn timetz_smaller(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timetz_smaller(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timetz_smaller(arg_fcinfo)
    })
}
pub unsafe fn time_part(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn time_part(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        time_part(arg_fcinfo)
    })
}
pub unsafe fn pg_get_constraintdef(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_constraintdef(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_get_constraintdef(arg_fcinfo)
    })
}
pub unsafe fn timestamptz_timetz(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptz_timetz(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptz_timetz(arg_fcinfo)
    })
}
pub unsafe fn timestamp_finite(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_finite(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_finite(arg_fcinfo)
    })
}
pub unsafe fn interval_finite(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval_finite(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        interval_finite(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_backend_start(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_backend_start(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_backend_start(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_backend_client_addr(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_backend_client_addr(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_backend_client_addr(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_backend_client_port(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_backend_client_port(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_backend_client_port(arg_fcinfo)
    })
}
pub unsafe fn current_schema(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn current_schema(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        current_schema(arg_fcinfo)
    })
}
pub unsafe fn current_schemas(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn current_schemas(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        current_schemas(arg_fcinfo)
    })
}
pub unsafe fn textoverlay(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn textoverlay(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        textoverlay(arg_fcinfo)
    })
}
pub unsafe fn textoverlay_no_len(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn textoverlay_no_len(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        textoverlay_no_len(arg_fcinfo)
    })
}
pub unsafe fn line_parallel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn line_parallel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        line_parallel(arg_fcinfo)
    })
}
pub unsafe fn line_perp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn line_perp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        line_perp(arg_fcinfo)
    })
}
pub unsafe fn line_vertical(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn line_vertical(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        line_vertical(arg_fcinfo)
    })
}
pub unsafe fn line_horizontal(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn line_horizontal(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        line_horizontal(arg_fcinfo)
    })
}
pub unsafe fn circle_center(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn circle_center(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        circle_center(arg_fcinfo)
    })
}
pub unsafe fn interval_time(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval_time(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        interval_time(arg_fcinfo)
    })
}
pub unsafe fn points_box(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn points_box(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        points_box(arg_fcinfo)
    })
}
pub unsafe fn box_add(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_add(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_add(arg_fcinfo)
    })
}
pub unsafe fn box_sub(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_sub(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_sub(arg_fcinfo)
    })
}
pub unsafe fn box_mul(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_mul(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_mul(arg_fcinfo)
    })
}
pub unsafe fn box_div(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_div(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_div(arg_fcinfo)
    })
}
pub unsafe fn cidr_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cidr_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cidr_out(arg_fcinfo)
    })
}
pub unsafe fn poly_contain_pt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn poly_contain_pt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        poly_contain_pt(arg_fcinfo)
    })
}
pub unsafe fn pt_contained_poly(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pt_contained_poly(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pt_contained_poly(arg_fcinfo)
    })
}
pub unsafe fn path_isclosed(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn path_isclosed(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        path_isclosed(arg_fcinfo)
    })
}
pub unsafe fn path_isopen(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn path_isopen(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        path_isopen(arg_fcinfo)
    })
}
pub unsafe fn path_npoints(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn path_npoints(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        path_npoints(arg_fcinfo)
    })
}
pub unsafe fn path_close(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn path_close(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        path_close(arg_fcinfo)
    })
}
pub unsafe fn path_open(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn path_open(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        path_open(arg_fcinfo)
    })
}
pub unsafe fn path_add(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn path_add(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        path_add(arg_fcinfo)
    })
}
pub unsafe fn path_add_pt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn path_add_pt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        path_add_pt(arg_fcinfo)
    })
}
pub unsafe fn path_sub_pt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn path_sub_pt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        path_sub_pt(arg_fcinfo)
    })
}
pub unsafe fn path_mul_pt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn path_mul_pt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        path_mul_pt(arg_fcinfo)
    })
}
pub unsafe fn path_div_pt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn path_div_pt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        path_div_pt(arg_fcinfo)
    })
}
pub unsafe fn construct_point(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn construct_point(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        construct_point(arg_fcinfo)
    })
}
pub unsafe fn point_add(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn point_add(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        point_add(arg_fcinfo)
    })
}
pub unsafe fn point_sub(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn point_sub(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        point_sub(arg_fcinfo)
    })
}
pub unsafe fn point_mul(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn point_mul(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        point_mul(arg_fcinfo)
    })
}
pub unsafe fn point_div(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn point_div(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        point_div(arg_fcinfo)
    })
}
pub unsafe fn poly_npoints(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn poly_npoints(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        poly_npoints(arg_fcinfo)
    })
}
pub unsafe fn poly_box(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn poly_box(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        poly_box(arg_fcinfo)
    })
}
pub unsafe fn poly_path(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn poly_path(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        poly_path(arg_fcinfo)
    })
}
pub unsafe fn box_poly(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_poly(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_poly(arg_fcinfo)
    })
}
pub unsafe fn path_poly(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn path_poly(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        path_poly(arg_fcinfo)
    })
}
pub unsafe fn circle_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn circle_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        circle_in(arg_fcinfo)
    })
}
pub unsafe fn circle_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn circle_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        circle_out(arg_fcinfo)
    })
}
pub unsafe fn circle_same(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn circle_same(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        circle_same(arg_fcinfo)
    })
}
pub unsafe fn circle_contain(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn circle_contain(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        circle_contain(arg_fcinfo)
    })
}
pub unsafe fn circle_left(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn circle_left(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        circle_left(arg_fcinfo)
    })
}
pub unsafe fn circle_overleft(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn circle_overleft(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        circle_overleft(arg_fcinfo)
    })
}
pub unsafe fn circle_overright(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn circle_overright(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        circle_overright(arg_fcinfo)
    })
}
pub unsafe fn circle_right(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn circle_right(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        circle_right(arg_fcinfo)
    })
}
pub unsafe fn circle_contained(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn circle_contained(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        circle_contained(arg_fcinfo)
    })
}
pub unsafe fn circle_overlap(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn circle_overlap(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        circle_overlap(arg_fcinfo)
    })
}
pub unsafe fn circle_below(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn circle_below(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        circle_below(arg_fcinfo)
    })
}
pub unsafe fn circle_above(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn circle_above(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        circle_above(arg_fcinfo)
    })
}
pub unsafe fn circle_eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn circle_eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        circle_eq(arg_fcinfo)
    })
}
pub unsafe fn circle_ne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn circle_ne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        circle_ne(arg_fcinfo)
    })
}
pub unsafe fn circle_lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn circle_lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        circle_lt(arg_fcinfo)
    })
}
pub unsafe fn circle_gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn circle_gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        circle_gt(arg_fcinfo)
    })
}
pub unsafe fn circle_le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn circle_le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        circle_le(arg_fcinfo)
    })
}
pub unsafe fn circle_ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn circle_ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        circle_ge(arg_fcinfo)
    })
}
pub unsafe fn circle_area(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn circle_area(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        circle_area(arg_fcinfo)
    })
}
pub unsafe fn circle_diameter(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn circle_diameter(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        circle_diameter(arg_fcinfo)
    })
}
pub unsafe fn circle_radius(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn circle_radius(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        circle_radius(arg_fcinfo)
    })
}
pub unsafe fn circle_distance(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn circle_distance(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        circle_distance(arg_fcinfo)
    })
}
pub unsafe fn cr_circle(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cr_circle(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cr_circle(arg_fcinfo)
    })
}
pub unsafe fn poly_circle(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn poly_circle(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        poly_circle(arg_fcinfo)
    })
}
pub unsafe fn circle_poly(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn circle_poly(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        circle_poly(arg_fcinfo)
    })
}
pub unsafe fn dist_pc(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dist_pc(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dist_pc(arg_fcinfo)
    })
}
pub unsafe fn circle_contain_pt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn circle_contain_pt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        circle_contain_pt(arg_fcinfo)
    })
}
pub unsafe fn pt_contained_circle(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pt_contained_circle(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pt_contained_circle(arg_fcinfo)
    })
}
pub unsafe fn box_circle(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_circle(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_circle(arg_fcinfo)
    })
}
pub unsafe fn circle_box(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn circle_box(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        circle_box(arg_fcinfo)
    })
}
pub unsafe fn lseg_ne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lseg_ne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        lseg_ne(arg_fcinfo)
    })
}
pub unsafe fn lseg_lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lseg_lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        lseg_lt(arg_fcinfo)
    })
}
pub unsafe fn lseg_le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lseg_le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        lseg_le(arg_fcinfo)
    })
}
pub unsafe fn lseg_gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lseg_gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        lseg_gt(arg_fcinfo)
    })
}
pub unsafe fn lseg_ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lseg_ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        lseg_ge(arg_fcinfo)
    })
}
pub unsafe fn lseg_length(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lseg_length(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        lseg_length(arg_fcinfo)
    })
}
pub unsafe fn close_ls(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn close_ls(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        close_ls(arg_fcinfo)
    })
}
pub unsafe fn close_lseg(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn close_lseg(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        close_lseg(arg_fcinfo)
    })
}
pub unsafe fn line_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn line_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        line_in(arg_fcinfo)
    })
}
pub unsafe fn line_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn line_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        line_out(arg_fcinfo)
    })
}
pub unsafe fn line_eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn line_eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        line_eq(arg_fcinfo)
    })
}
pub unsafe fn line_construct_pp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn line_construct_pp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        line_construct_pp(arg_fcinfo)
    })
}
pub unsafe fn line_interpt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn line_interpt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        line_interpt(arg_fcinfo)
    })
}
pub unsafe fn line_intersect(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn line_intersect(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        line_intersect(arg_fcinfo)
    })
}
pub unsafe fn bit_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bit_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bit_in(arg_fcinfo)
    })
}
pub unsafe fn bit_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bit_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bit_out(arg_fcinfo)
    })
}
pub unsafe fn pg_get_ruledef(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_ruledef(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_get_ruledef(arg_fcinfo)
    })
}
pub unsafe fn nextval_oid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn nextval_oid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        nextval_oid(arg_fcinfo)
    })
}
pub unsafe fn currval_oid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn currval_oid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        currval_oid(arg_fcinfo)
    })
}
pub unsafe fn setval_oid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn setval_oid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        setval_oid(arg_fcinfo)
    })
}
pub unsafe fn varbit_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn varbit_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        varbit_in(arg_fcinfo)
    })
}
pub unsafe fn varbit_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn varbit_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        varbit_out(arg_fcinfo)
    })
}
pub unsafe fn biteq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn biteq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        biteq(arg_fcinfo)
    })
}
pub unsafe fn bitne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bitne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bitne(arg_fcinfo)
    })
}
pub unsafe fn bitge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bitge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bitge(arg_fcinfo)
    })
}
pub unsafe fn bitgt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bitgt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bitgt(arg_fcinfo)
    })
}
pub unsafe fn bitle(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bitle(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bitle(arg_fcinfo)
    })
}
pub unsafe fn bitlt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bitlt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bitlt(arg_fcinfo)
    })
}
pub unsafe fn bitcmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bitcmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bitcmp(arg_fcinfo)
    })
}
pub unsafe fn PG_encoding_to_char(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn PG_encoding_to_char(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        PG_encoding_to_char(arg_fcinfo)
    })
}
pub unsafe fn drandom(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn drandom(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        drandom(arg_fcinfo)
    })
}
pub unsafe fn setseed(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn setseed(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        setseed(arg_fcinfo)
    })
}
pub unsafe fn dasin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dasin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dasin(arg_fcinfo)
    })
}
pub unsafe fn dacos(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dacos(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dacos(arg_fcinfo)
    })
}
pub unsafe fn datan(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn datan(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        datan(arg_fcinfo)
    })
}
pub unsafe fn datan2(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn datan2(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        datan2(arg_fcinfo)
    })
}
pub unsafe fn dsin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dsin(arg_fcinfo)
    })
}
pub unsafe fn dcos(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dcos(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dcos(arg_fcinfo)
    })
}
pub unsafe fn dtan(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dtan(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dtan(arg_fcinfo)
    })
}
pub unsafe fn dcot(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dcot(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dcot(arg_fcinfo)
    })
}
pub unsafe fn degrees(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn degrees(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        degrees(arg_fcinfo)
    })
}
pub unsafe fn radians(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn radians(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        radians(arg_fcinfo)
    })
}
pub unsafe fn dpi(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dpi(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dpi(arg_fcinfo)
    })
}
pub unsafe fn interval_mul(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval_mul(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        interval_mul(arg_fcinfo)
    })
}
pub unsafe fn pg_typeof(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_typeof(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_typeof(arg_fcinfo)
    })
}
pub unsafe fn ascii(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ascii(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ascii(arg_fcinfo)
    })
}
pub unsafe fn chr(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn chr(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        chr(arg_fcinfo)
    })
}
pub unsafe fn repeat(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn repeat(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        repeat(arg_fcinfo)
    })
}
pub unsafe fn similar_escape(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn similar_escape(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        similar_escape(arg_fcinfo)
    })
}
pub unsafe fn mul_d_interval(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn mul_d_interval(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        mul_d_interval(arg_fcinfo)
    })
}
pub unsafe fn texticlike(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn texticlike(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        texticlike(arg_fcinfo)
    })
}
pub unsafe fn texticnlike(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn texticnlike(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        texticnlike(arg_fcinfo)
    })
}
pub unsafe fn nameiclike(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn nameiclike(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        nameiclike(arg_fcinfo)
    })
}
pub unsafe fn nameicnlike(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn nameicnlike(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        nameicnlike(arg_fcinfo)
    })
}
pub unsafe fn like_escape(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn like_escape(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        like_escape(arg_fcinfo)
    })
}
pub unsafe fn oidgt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn oidgt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        oidgt(arg_fcinfo)
    })
}
pub unsafe fn oidge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn oidge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        oidge(arg_fcinfo)
    })
}
pub unsafe fn pg_get_viewdef_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_viewdef_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_get_viewdef_name(arg_fcinfo)
    })
}
pub unsafe fn pg_get_viewdef(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_viewdef(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_get_viewdef(arg_fcinfo)
    })
}
pub unsafe fn pg_get_userbyid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_userbyid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_get_userbyid(arg_fcinfo)
    })
}
pub unsafe fn pg_get_indexdef(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_indexdef(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_get_indexdef(arg_fcinfo)
    })
}
pub unsafe fn RI_FKey_check_ins(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RI_FKey_check_ins(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        RI_FKey_check_ins(arg_fcinfo)
    })
}
pub unsafe fn RI_FKey_check_upd(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RI_FKey_check_upd(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        RI_FKey_check_upd(arg_fcinfo)
    })
}
pub unsafe fn RI_FKey_cascade_del(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RI_FKey_cascade_del(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        RI_FKey_cascade_del(arg_fcinfo)
    })
}
pub unsafe fn RI_FKey_cascade_upd(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RI_FKey_cascade_upd(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        RI_FKey_cascade_upd(arg_fcinfo)
    })
}
pub unsafe fn RI_FKey_restrict_del(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RI_FKey_restrict_del(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        RI_FKey_restrict_del(arg_fcinfo)
    })
}
pub unsafe fn RI_FKey_restrict_upd(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RI_FKey_restrict_upd(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        RI_FKey_restrict_upd(arg_fcinfo)
    })
}
pub unsafe fn RI_FKey_setnull_del(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RI_FKey_setnull_del(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        RI_FKey_setnull_del(arg_fcinfo)
    })
}
pub unsafe fn RI_FKey_setnull_upd(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RI_FKey_setnull_upd(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        RI_FKey_setnull_upd(arg_fcinfo)
    })
}
pub unsafe fn RI_FKey_setdefault_del(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RI_FKey_setdefault_del(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        RI_FKey_setdefault_del(arg_fcinfo)
    })
}
pub unsafe fn RI_FKey_setdefault_upd(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RI_FKey_setdefault_upd(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        RI_FKey_setdefault_upd(arg_fcinfo)
    })
}
pub unsafe fn RI_FKey_noaction_del(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RI_FKey_noaction_del(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        RI_FKey_noaction_del(arg_fcinfo)
    })
}
pub unsafe fn RI_FKey_noaction_upd(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RI_FKey_noaction_upd(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        RI_FKey_noaction_upd(arg_fcinfo)
    })
}
pub unsafe fn pg_get_triggerdef(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_triggerdef(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_get_triggerdef(arg_fcinfo)
    })
}
pub unsafe fn pg_get_serial_sequence(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_serial_sequence(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_get_serial_sequence(arg_fcinfo)
    })
}
pub unsafe fn bit_and(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bit_and(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bit_and(arg_fcinfo)
    })
}
pub unsafe fn bit_or(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bit_or(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bit_or(arg_fcinfo)
    })
}
pub unsafe fn bitxor(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bitxor(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bitxor(arg_fcinfo)
    })
}
pub unsafe fn bitnot(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bitnot(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bitnot(arg_fcinfo)
    })
}
pub unsafe fn bitshiftleft(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bitshiftleft(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bitshiftleft(arg_fcinfo)
    })
}
pub unsafe fn bitshiftright(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bitshiftright(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bitshiftright(arg_fcinfo)
    })
}
pub unsafe fn bitcat(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bitcat(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bitcat(arg_fcinfo)
    })
}
pub unsafe fn bitsubstr(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bitsubstr(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bitsubstr(arg_fcinfo)
    })
}
pub unsafe fn bitlength(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bitlength(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bitlength(arg_fcinfo)
    })
}
pub unsafe fn bitoctetlength(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bitoctetlength(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bitoctetlength(arg_fcinfo)
    })
}
pub unsafe fn bitfromint4(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bitfromint4(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bitfromint4(arg_fcinfo)
    })
}
pub unsafe fn bittoint4(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bittoint4(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bittoint4(arg_fcinfo)
    })
}
pub unsafe fn bit(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bit(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bit(arg_fcinfo)
    })
}
pub unsafe fn pg_get_keywords(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_keywords(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_get_keywords(arg_fcinfo)
    })
}
pub unsafe fn varbit(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn varbit(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        varbit(arg_fcinfo)
    })
}
pub unsafe fn time_hash(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn time_hash(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        time_hash(arg_fcinfo)
    })
}
pub unsafe fn aclexplode(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn aclexplode(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        aclexplode(arg_fcinfo)
    })
}
pub unsafe fn time_mi_time(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn time_mi_time(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        time_mi_time(arg_fcinfo)
    })
}
pub unsafe fn boolle(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn boolle(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        boolle(arg_fcinfo)
    })
}
pub unsafe fn boolge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn boolge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        boolge(arg_fcinfo)
    })
}
pub unsafe fn btboolcmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btboolcmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btboolcmp(arg_fcinfo)
    })
}
pub unsafe fn timetz_hash(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timetz_hash(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timetz_hash(arg_fcinfo)
    })
}
pub unsafe fn interval_hash(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval_hash(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        interval_hash(arg_fcinfo)
    })
}
pub unsafe fn bitposition(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bitposition(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bitposition(arg_fcinfo)
    })
}
pub unsafe fn bitsubstr_no_len(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bitsubstr_no_len(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bitsubstr_no_len(arg_fcinfo)
    })
}
pub unsafe fn numeric_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_in(arg_fcinfo)
    })
}
pub unsafe fn numeric_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_out(arg_fcinfo)
    })
}
pub unsafe fn numeric(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric(arg_fcinfo)
    })
}
pub unsafe fn numeric_abs(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_abs(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_abs(arg_fcinfo)
    })
}
pub unsafe fn numeric_sign(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_sign(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_sign(arg_fcinfo)
    })
}
pub unsafe fn numeric_round(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_round(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_round(arg_fcinfo)
    })
}
pub unsafe fn numeric_trunc(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_trunc(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_trunc(arg_fcinfo)
    })
}
pub unsafe fn numeric_ceil(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_ceil(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_ceil(arg_fcinfo)
    })
}
pub unsafe fn numeric_floor(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_floor(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_floor(arg_fcinfo)
    })
}
pub unsafe fn length_in_encoding(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn length_in_encoding(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        length_in_encoding(arg_fcinfo)
    })
}
pub unsafe fn pg_convert_from(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_convert_from(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_convert_from(arg_fcinfo)
    })
}
pub unsafe fn inet_to_cidr(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet_to_cidr(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        inet_to_cidr(arg_fcinfo)
    })
}
pub unsafe fn pg_get_expr(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_expr(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_get_expr(arg_fcinfo)
    })
}
pub unsafe fn pg_convert_to(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_convert_to(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_convert_to(arg_fcinfo)
    })
}
pub unsafe fn numeric_eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_eq(arg_fcinfo)
    })
}
pub unsafe fn numeric_ne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_ne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_ne(arg_fcinfo)
    })
}
pub unsafe fn numeric_gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_gt(arg_fcinfo)
    })
}
pub unsafe fn numeric_ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_ge(arg_fcinfo)
    })
}
pub unsafe fn numeric_lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_lt(arg_fcinfo)
    })
}
pub unsafe fn numeric_le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_le(arg_fcinfo)
    })
}
pub unsafe fn numeric_add(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_add(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_add(arg_fcinfo)
    })
}
pub unsafe fn numeric_sub(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_sub(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_sub(arg_fcinfo)
    })
}
pub unsafe fn numeric_mul(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_mul(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_mul(arg_fcinfo)
    })
}
pub unsafe fn numeric_div(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_div(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_div(arg_fcinfo)
    })
}
pub unsafe fn numeric_mod(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_mod(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_mod(arg_fcinfo)
    })
}
pub unsafe fn numeric_sqrt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_sqrt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_sqrt(arg_fcinfo)
    })
}
pub unsafe fn numeric_exp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_exp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_exp(arg_fcinfo)
    })
}
pub unsafe fn numeric_ln(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_ln(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_ln(arg_fcinfo)
    })
}
pub unsafe fn numeric_log(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_log(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_log(arg_fcinfo)
    })
}
pub unsafe fn numeric_power(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_power(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_power(arg_fcinfo)
    })
}
pub unsafe fn int4_numeric(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4_numeric(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4_numeric(arg_fcinfo)
    })
}
pub unsafe fn numeric_int4(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_int4(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_int4(arg_fcinfo)
    })
}
pub unsafe fn numeric_float4(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_float4(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_float4(arg_fcinfo)
    })
}
pub unsafe fn numeric_float8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_float8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_float8(arg_fcinfo)
    })
}
pub unsafe fn time_pl_interval(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn time_pl_interval(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        time_pl_interval(arg_fcinfo)
    })
}
pub unsafe fn time_mi_interval(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn time_mi_interval(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        time_mi_interval(arg_fcinfo)
    })
}
pub unsafe fn timetz_pl_interval(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timetz_pl_interval(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timetz_pl_interval(arg_fcinfo)
    })
}
pub unsafe fn timetz_mi_interval(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timetz_mi_interval(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timetz_mi_interval(arg_fcinfo)
    })
}
pub unsafe fn numeric_inc(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_inc(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_inc(arg_fcinfo)
    })
}
pub unsafe fn setval3_oid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn setval3_oid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        setval3_oid(arg_fcinfo)
    })
}
pub unsafe fn numeric_smaller(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_smaller(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_smaller(arg_fcinfo)
    })
}
pub unsafe fn numeric_larger(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_larger(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_larger(arg_fcinfo)
    })
}
pub unsafe fn interval_to_char(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval_to_char(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        interval_to_char(arg_fcinfo)
    })
}
pub unsafe fn numeric_cmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_cmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_cmp(arg_fcinfo)
    })
}
pub unsafe fn timestamptz_to_char(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptz_to_char(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptz_to_char(arg_fcinfo)
    })
}
pub unsafe fn numeric_uminus(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_uminus(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_uminus(arg_fcinfo)
    })
}
pub unsafe fn numeric_to_char(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_to_char(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_to_char(arg_fcinfo)
    })
}
pub unsafe fn int4_to_char(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4_to_char(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4_to_char(arg_fcinfo)
    })
}
pub unsafe fn int8_to_char(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8_to_char(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8_to_char(arg_fcinfo)
    })
}
pub unsafe fn numeric_to_number(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_to_number(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_to_number(arg_fcinfo)
    })
}
pub unsafe fn to_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn to_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        to_timestamp(arg_fcinfo)
    })
}
pub unsafe fn numeric_int8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_int8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_int8(arg_fcinfo)
    })
}
pub unsafe fn to_date(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn to_date(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        to_date(arg_fcinfo)
    })
}
pub unsafe fn int8_numeric(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8_numeric(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8_numeric(arg_fcinfo)
    })
}
pub unsafe fn int2_numeric(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2_numeric(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2_numeric(arg_fcinfo)
    })
}
pub unsafe fn numeric_int2(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_int2(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_int2(arg_fcinfo)
    })
}
pub unsafe fn oidin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn oidin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        oidin(arg_fcinfo)
    })
}
pub unsafe fn oidout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn oidout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        oidout(arg_fcinfo)
    })
}
pub unsafe fn pg_convert(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_convert(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_convert(arg_fcinfo)
    })
}
pub unsafe fn iclikesel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn iclikesel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        iclikesel(arg_fcinfo)
    })
}
pub unsafe fn icnlikesel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn icnlikesel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        icnlikesel(arg_fcinfo)
    })
}
pub unsafe fn iclikejoinsel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn iclikejoinsel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        iclikejoinsel(arg_fcinfo)
    })
}
pub unsafe fn icnlikejoinsel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn icnlikejoinsel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        icnlikejoinsel(arg_fcinfo)
    })
}
pub unsafe fn regexeqsel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regexeqsel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regexeqsel(arg_fcinfo)
    })
}
pub unsafe fn likesel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn likesel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        likesel(arg_fcinfo)
    })
}
pub unsafe fn icregexeqsel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn icregexeqsel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        icregexeqsel(arg_fcinfo)
    })
}
pub unsafe fn regexnesel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regexnesel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regexnesel(arg_fcinfo)
    })
}
pub unsafe fn nlikesel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn nlikesel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        nlikesel(arg_fcinfo)
    })
}
pub unsafe fn icregexnesel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn icregexnesel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        icregexnesel(arg_fcinfo)
    })
}
pub unsafe fn regexeqjoinsel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regexeqjoinsel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regexeqjoinsel(arg_fcinfo)
    })
}
pub unsafe fn likejoinsel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn likejoinsel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        likejoinsel(arg_fcinfo)
    })
}
pub unsafe fn icregexeqjoinsel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn icregexeqjoinsel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        icregexeqjoinsel(arg_fcinfo)
    })
}
pub unsafe fn regexnejoinsel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regexnejoinsel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regexnejoinsel(arg_fcinfo)
    })
}
pub unsafe fn nlikejoinsel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn nlikejoinsel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        nlikejoinsel(arg_fcinfo)
    })
}
pub unsafe fn icregexnejoinsel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn icregexnejoinsel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        icregexnejoinsel(arg_fcinfo)
    })
}
pub unsafe fn numeric_accum(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_accum(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_accum(arg_fcinfo)
    })
}
pub unsafe fn int2_accum(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2_accum(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2_accum(arg_fcinfo)
    })
}
pub unsafe fn int4_accum(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4_accum(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4_accum(arg_fcinfo)
    })
}
pub unsafe fn int8_accum(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8_accum(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8_accum(arg_fcinfo)
    })
}
pub unsafe fn numeric_avg(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_avg(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_avg(arg_fcinfo)
    })
}
pub unsafe fn numeric_var_samp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_var_samp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_var_samp(arg_fcinfo)
    })
}
pub unsafe fn numeric_stddev_samp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_stddev_samp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_stddev_samp(arg_fcinfo)
    })
}
pub unsafe fn int2_sum(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2_sum(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2_sum(arg_fcinfo)
    })
}
pub unsafe fn int4_sum(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4_sum(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4_sum(arg_fcinfo)
    })
}
pub unsafe fn int8_sum(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8_sum(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8_sum(arg_fcinfo)
    })
}
pub unsafe fn interval_accum(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval_accum(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        interval_accum(arg_fcinfo)
    })
}
pub unsafe fn interval_avg(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval_avg(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        interval_avg(arg_fcinfo)
    })
}
pub unsafe fn to_ascii_default(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn to_ascii_default(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        to_ascii_default(arg_fcinfo)
    })
}
pub unsafe fn to_ascii_enc(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn to_ascii_enc(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        to_ascii_enc(arg_fcinfo)
    })
}
pub unsafe fn to_ascii_encname(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn to_ascii_encname(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        to_ascii_encname(arg_fcinfo)
    })
}
pub unsafe fn int28eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int28eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int28eq(arg_fcinfo)
    })
}
pub unsafe fn int28ne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int28ne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int28ne(arg_fcinfo)
    })
}
pub unsafe fn int28lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int28lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int28lt(arg_fcinfo)
    })
}
pub unsafe fn int28gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int28gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int28gt(arg_fcinfo)
    })
}
pub unsafe fn int28le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int28le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int28le(arg_fcinfo)
    })
}
pub unsafe fn int28ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int28ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int28ge(arg_fcinfo)
    })
}
pub unsafe fn int82eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int82eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int82eq(arg_fcinfo)
    })
}
pub unsafe fn int82ne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int82ne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int82ne(arg_fcinfo)
    })
}
pub unsafe fn int82lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int82lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int82lt(arg_fcinfo)
    })
}
pub unsafe fn int82gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int82gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int82gt(arg_fcinfo)
    })
}
pub unsafe fn int82le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int82le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int82le(arg_fcinfo)
    })
}
pub unsafe fn int82ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int82ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int82ge(arg_fcinfo)
    })
}
pub unsafe fn int2and(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2and(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2and(arg_fcinfo)
    })
}
pub unsafe fn int2or(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2or(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2or(arg_fcinfo)
    })
}
pub unsafe fn int2xor(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2xor(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2xor(arg_fcinfo)
    })
}
pub unsafe fn int2not(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2not(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2not(arg_fcinfo)
    })
}
pub unsafe fn int2shl(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2shl(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2shl(arg_fcinfo)
    })
}
pub unsafe fn int2shr(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2shr(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2shr(arg_fcinfo)
    })
}
pub unsafe fn int4and(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4and(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4and(arg_fcinfo)
    })
}
pub unsafe fn int4or(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4or(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4or(arg_fcinfo)
    })
}
pub unsafe fn int4xor(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4xor(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4xor(arg_fcinfo)
    })
}
pub unsafe fn int4not(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4not(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4not(arg_fcinfo)
    })
}
pub unsafe fn int4shl(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4shl(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4shl(arg_fcinfo)
    })
}
pub unsafe fn int4shr(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4shr(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4shr(arg_fcinfo)
    })
}
pub unsafe fn int8and(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8and(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8and(arg_fcinfo)
    })
}
pub unsafe fn int8or(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8or(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8or(arg_fcinfo)
    })
}
pub unsafe fn int8xor(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8xor(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8xor(arg_fcinfo)
    })
}
pub unsafe fn int8not(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8not(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8not(arg_fcinfo)
    })
}
pub unsafe fn int8shl(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8shl(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8shl(arg_fcinfo)
    })
}
pub unsafe fn int8shr(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8shr(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8shr(arg_fcinfo)
    })
}
pub unsafe fn int8up(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8up(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8up(arg_fcinfo)
    })
}
pub unsafe fn int2up(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2up(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2up(arg_fcinfo)
    })
}
pub unsafe fn int4up(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4up(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4up(arg_fcinfo)
    })
}
pub unsafe fn numeric_uplus(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_uplus(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_uplus(arg_fcinfo)
    })
}
pub unsafe fn has_table_privilege_name_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_table_privilege_name_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_table_privilege_name_name(arg_fcinfo)
    })
}
pub unsafe fn has_table_privilege_name_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_table_privilege_name_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_table_privilege_name_id(arg_fcinfo)
    })
}
pub unsafe fn has_table_privilege_id_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_table_privilege_id_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_table_privilege_id_name(arg_fcinfo)
    })
}
pub unsafe fn has_table_privilege_id_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_table_privilege_id_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_table_privilege_id_id(arg_fcinfo)
    })
}
pub unsafe fn has_table_privilege_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_table_privilege_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_table_privilege_name(arg_fcinfo)
    })
}
pub unsafe fn has_table_privilege_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_table_privilege_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_table_privilege_id(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_numscans(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_numscans(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_numscans(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_tuples_returned(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_tuples_returned(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_tuples_returned(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_tuples_fetched(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_tuples_fetched(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_tuples_fetched(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_tuples_inserted(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_tuples_inserted(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_tuples_inserted(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_tuples_updated(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_tuples_updated(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_tuples_updated(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_tuples_deleted(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_tuples_deleted(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_tuples_deleted(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_blocks_fetched(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_blocks_fetched(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_blocks_fetched(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_blocks_hit(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_blocks_hit(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_blocks_hit(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_backend_idset(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_backend_idset(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_backend_idset(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_backend_pid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_backend_pid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_backend_pid(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_backend_dbid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_backend_dbid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_backend_dbid(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_backend_userid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_backend_userid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_backend_userid(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_backend_activity(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_backend_activity(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_backend_activity(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_db_numbackends(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_db_numbackends(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_db_numbackends(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_db_xact_commit(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_db_xact_commit(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_db_xact_commit(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_db_xact_rollback(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_db_xact_rollback(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_db_xact_rollback(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_db_blocks_fetched(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_db_blocks_fetched(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_db_blocks_fetched(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_db_blocks_hit(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_db_blocks_hit(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_db_blocks_hit(arg_fcinfo)
    })
}
pub unsafe fn binary_encode(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn binary_encode(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        binary_encode(arg_fcinfo)
    })
}
pub unsafe fn binary_decode(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn binary_decode(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        binary_decode(arg_fcinfo)
    })
}
pub unsafe fn byteaeq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn byteaeq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        byteaeq(arg_fcinfo)
    })
}
pub unsafe fn bytealt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bytealt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bytealt(arg_fcinfo)
    })
}
pub unsafe fn byteale(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn byteale(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        byteale(arg_fcinfo)
    })
}
pub unsafe fn byteagt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn byteagt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        byteagt(arg_fcinfo)
    })
}
pub unsafe fn byteage(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn byteage(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        byteage(arg_fcinfo)
    })
}
pub unsafe fn byteane(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn byteane(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        byteane(arg_fcinfo)
    })
}
pub unsafe fn byteacmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn byteacmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        byteacmp(arg_fcinfo)
    })
}
pub unsafe fn timestamp_scale(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_scale(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_scale(arg_fcinfo)
    })
}
pub unsafe fn int2_avg_accum(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2_avg_accum(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2_avg_accum(arg_fcinfo)
    })
}
pub unsafe fn int4_avg_accum(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4_avg_accum(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4_avg_accum(arg_fcinfo)
    })
}
pub unsafe fn int8_avg(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8_avg(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8_avg(arg_fcinfo)
    })
}
pub unsafe fn oidlarger(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn oidlarger(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        oidlarger(arg_fcinfo)
    })
}
pub unsafe fn oidsmaller(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn oidsmaller(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        oidsmaller(arg_fcinfo)
    })
}
pub unsafe fn timestamptz_scale(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptz_scale(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptz_scale(arg_fcinfo)
    })
}
pub unsafe fn time_scale(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn time_scale(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        time_scale(arg_fcinfo)
    })
}
pub unsafe fn timetz_scale(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timetz_scale(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timetz_scale(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_tuples_hot_updated(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_tuples_hot_updated(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_tuples_hot_updated(arg_fcinfo)
    })
}
pub unsafe fn numeric_div_trunc(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_div_trunc(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_div_trunc(arg_fcinfo)
    })
}
pub unsafe fn similar_to_escape_2(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn similar_to_escape_2(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        similar_to_escape_2(arg_fcinfo)
    })
}
pub unsafe fn similar_to_escape_1(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn similar_to_escape_1(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        similar_to_escape_1(arg_fcinfo)
    })
}
pub unsafe fn bytealike(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bytealike(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bytealike(arg_fcinfo)
    })
}
pub unsafe fn byteanlike(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn byteanlike(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        byteanlike(arg_fcinfo)
    })
}
pub unsafe fn like_escape_bytea(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn like_escape_bytea(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        like_escape_bytea(arg_fcinfo)
    })
}
pub unsafe fn byteacat(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn byteacat(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        byteacat(arg_fcinfo)
    })
}
pub unsafe fn bytea_substr(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bytea_substr(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bytea_substr(arg_fcinfo)
    })
}
pub unsafe fn bytea_substr_no_len(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bytea_substr_no_len(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bytea_substr_no_len(arg_fcinfo)
    })
}
pub unsafe fn byteapos(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn byteapos(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        byteapos(arg_fcinfo)
    })
}
pub unsafe fn byteatrim(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn byteatrim(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        byteatrim(arg_fcinfo)
    })
}
pub unsafe fn timestamptz_time(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptz_time(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptz_time(arg_fcinfo)
    })
}
pub unsafe fn timestamp_trunc(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_trunc(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_trunc(arg_fcinfo)
    })
}
pub unsafe fn timestamp_part(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_part(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_part(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_activity(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_activity(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_activity(arg_fcinfo)
    })
}
pub unsafe fn jsonb_path_query_first_tz(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_path_query_first_tz(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_path_query_first_tz(arg_fcinfo)
    })
}
pub unsafe fn date_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_timestamp(arg_fcinfo)
    })
}
pub unsafe fn pg_backend_pid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_backend_pid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_backend_pid(arg_fcinfo)
    })
}
pub unsafe fn timestamptz_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptz_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptz_timestamp(arg_fcinfo)
    })
}
pub unsafe fn timestamp_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_timestamptz(arg_fcinfo)
    })
}
pub unsafe fn timestamp_date(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_date(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_date(arg_fcinfo)
    })
}
pub unsafe fn jsonb_path_match_tz(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_path_match_tz(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_path_match_tz(arg_fcinfo)
    })
}
pub unsafe fn timestamp_pl_interval(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_pl_interval(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_pl_interval(arg_fcinfo)
    })
}
pub unsafe fn timestamp_mi_interval(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_mi_interval(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_mi_interval(arg_fcinfo)
    })
}
pub unsafe fn pg_conf_load_time(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_conf_load_time(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_conf_load_time(arg_fcinfo)
    })
}
pub unsafe fn timetz_zone(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timetz_zone(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timetz_zone(arg_fcinfo)
    })
}
pub unsafe fn timetz_izone(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timetz_izone(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timetz_izone(arg_fcinfo)
    })
}
pub unsafe fn timestamp_hash(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_hash(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_hash(arg_fcinfo)
    })
}
pub unsafe fn timetz_time(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timetz_time(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timetz_time(arg_fcinfo)
    })
}
pub unsafe fn time_timetz(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn time_timetz(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        time_timetz(arg_fcinfo)
    })
}
pub unsafe fn timestamp_to_char(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_to_char(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_to_char(arg_fcinfo)
    })
}
pub unsafe fn aggregate_dummy(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn aggregate_dummy(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        aggregate_dummy(arg_fcinfo)
    })
}
pub unsafe fn timestamp_age(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_age(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_age(arg_fcinfo)
    })
}
pub unsafe fn timestamp_zone(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_zone(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_zone(arg_fcinfo)
    })
}
pub unsafe fn timestamp_izone(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_izone(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_izone(arg_fcinfo)
    })
}
pub unsafe fn date_pl_interval(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_pl_interval(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_pl_interval(arg_fcinfo)
    })
}
pub unsafe fn date_mi_interval(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_mi_interval(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_mi_interval(arg_fcinfo)
    })
}
pub unsafe fn textregexsubstr(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn textregexsubstr(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        textregexsubstr(arg_fcinfo)
    })
}
pub unsafe fn bitfromint8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bitfromint8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bitfromint8(arg_fcinfo)
    })
}
pub unsafe fn bittoint8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bittoint8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bittoint8(arg_fcinfo)
    })
}
pub unsafe fn show_config_by_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn show_config_by_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        show_config_by_name(arg_fcinfo)
    })
}
pub unsafe fn set_config_by_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn set_config_by_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        set_config_by_name(arg_fcinfo)
    })
}
pub unsafe fn pg_table_is_visible(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_table_is_visible(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_table_is_visible(arg_fcinfo)
    })
}
pub unsafe fn pg_type_is_visible(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_type_is_visible(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_type_is_visible(arg_fcinfo)
    })
}
pub unsafe fn pg_function_is_visible(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_function_is_visible(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_function_is_visible(arg_fcinfo)
    })
}
pub unsafe fn pg_operator_is_visible(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_operator_is_visible(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_operator_is_visible(arg_fcinfo)
    })
}
pub unsafe fn pg_opclass_is_visible(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_opclass_is_visible(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_opclass_is_visible(arg_fcinfo)
    })
}
pub unsafe fn show_all_settings(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn show_all_settings(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        show_all_settings(arg_fcinfo)
    })
}
pub unsafe fn replace_text(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn replace_text(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        replace_text(arg_fcinfo)
    })
}
pub unsafe fn split_text(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn split_text(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        split_text(arg_fcinfo)
    })
}
pub unsafe fn to_hex32(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn to_hex32(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        to_hex32(arg_fcinfo)
    })
}
pub unsafe fn to_hex64(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn to_hex64(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        to_hex64(arg_fcinfo)
    })
}
pub unsafe fn array_lower(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_lower(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_lower(arg_fcinfo)
    })
}
pub unsafe fn array_upper(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_upper(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_upper(arg_fcinfo)
    })
}
pub unsafe fn pg_conversion_is_visible(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_conversion_is_visible(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_conversion_is_visible(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_backend_activity_start(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_backend_activity_start(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_backend_activity_start(arg_fcinfo)
    })
}
pub unsafe fn pg_terminate_backend(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_terminate_backend(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_terminate_backend(arg_fcinfo)
    })
}
pub unsafe fn pg_get_functiondef(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_functiondef(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_get_functiondef(arg_fcinfo)
    })
}
pub unsafe fn text_pattern_lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn text_pattern_lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        text_pattern_lt(arg_fcinfo)
    })
}
pub unsafe fn text_pattern_le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn text_pattern_le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        text_pattern_le(arg_fcinfo)
    })
}
pub unsafe fn pg_get_function_arguments(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_function_arguments(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_get_function_arguments(arg_fcinfo)
    })
}
pub unsafe fn text_pattern_ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn text_pattern_ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        text_pattern_ge(arg_fcinfo)
    })
}
pub unsafe fn text_pattern_gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn text_pattern_gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        text_pattern_gt(arg_fcinfo)
    })
}
pub unsafe fn pg_get_function_result(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_function_result(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_get_function_result(arg_fcinfo)
    })
}
pub unsafe fn bttext_pattern_cmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bttext_pattern_cmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bttext_pattern_cmp(arg_fcinfo)
    })
}
pub unsafe fn pg_database_size_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_database_size_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_database_size_name(arg_fcinfo)
    })
}
pub unsafe fn width_bucket_numeric(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn width_bucket_numeric(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        width_bucket_numeric(arg_fcinfo)
    })
}
pub unsafe fn pg_cancel_backend(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_cancel_backend(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_cancel_backend(arg_fcinfo)
    })
}
pub unsafe fn pg_start_backup(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_start_backup(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_start_backup(arg_fcinfo)
    })
}
pub unsafe fn pg_stop_backup(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stop_backup(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stop_backup(arg_fcinfo)
    })
}
pub unsafe fn bpchar_pattern_lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bpchar_pattern_lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bpchar_pattern_lt(arg_fcinfo)
    })
}
pub unsafe fn bpchar_pattern_le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bpchar_pattern_le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bpchar_pattern_le(arg_fcinfo)
    })
}
pub unsafe fn array_length(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_length(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_length(arg_fcinfo)
    })
}
pub unsafe fn bpchar_pattern_ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bpchar_pattern_ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bpchar_pattern_ge(arg_fcinfo)
    })
}
pub unsafe fn bpchar_pattern_gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bpchar_pattern_gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bpchar_pattern_gt(arg_fcinfo)
    })
}
pub unsafe fn gist_point_consistent(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gist_point_consistent(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gist_point_consistent(arg_fcinfo)
    })
}
pub unsafe fn btbpchar_pattern_cmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btbpchar_pattern_cmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btbpchar_pattern_cmp(arg_fcinfo)
    })
}
pub unsafe fn has_sequence_privilege_name_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_sequence_privilege_name_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_sequence_privilege_name_name(arg_fcinfo)
    })
}
pub unsafe fn has_sequence_privilege_name_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_sequence_privilege_name_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_sequence_privilege_name_id(arg_fcinfo)
    })
}
pub unsafe fn has_sequence_privilege_id_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_sequence_privilege_id_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_sequence_privilege_id_name(arg_fcinfo)
    })
}
pub unsafe fn has_sequence_privilege_id_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_sequence_privilege_id_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_sequence_privilege_id_id(arg_fcinfo)
    })
}
pub unsafe fn has_sequence_privilege_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_sequence_privilege_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_sequence_privilege_name(arg_fcinfo)
    })
}
pub unsafe fn has_sequence_privilege_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_sequence_privilege_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_sequence_privilege_id(arg_fcinfo)
    })
}
pub unsafe fn btint48cmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btint48cmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btint48cmp(arg_fcinfo)
    })
}
pub unsafe fn btint84cmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btint84cmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btint84cmp(arg_fcinfo)
    })
}
pub unsafe fn btint24cmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btint24cmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btint24cmp(arg_fcinfo)
    })
}
pub unsafe fn btint42cmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btint42cmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btint42cmp(arg_fcinfo)
    })
}
pub unsafe fn btint28cmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btint28cmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btint28cmp(arg_fcinfo)
    })
}
pub unsafe fn btint82cmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btint82cmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btint82cmp(arg_fcinfo)
    })
}
pub unsafe fn btfloat48cmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btfloat48cmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btfloat48cmp(arg_fcinfo)
    })
}
pub unsafe fn btfloat84cmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btfloat84cmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btfloat84cmp(arg_fcinfo)
    })
}
pub unsafe fn inet_client_addr(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet_client_addr(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        inet_client_addr(arg_fcinfo)
    })
}
pub unsafe fn inet_client_port(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet_client_port(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        inet_client_port(arg_fcinfo)
    })
}
pub unsafe fn inet_server_addr(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet_server_addr(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        inet_server_addr(arg_fcinfo)
    })
}
pub unsafe fn inet_server_port(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet_server_port(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        inet_server_port(arg_fcinfo)
    })
}
pub unsafe fn regprocedurein(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regprocedurein(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regprocedurein(arg_fcinfo)
    })
}
pub unsafe fn regprocedureout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regprocedureout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regprocedureout(arg_fcinfo)
    })
}
pub unsafe fn regoperin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regoperin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regoperin(arg_fcinfo)
    })
}
pub unsafe fn regoperout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regoperout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regoperout(arg_fcinfo)
    })
}
pub unsafe fn regoperatorin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regoperatorin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regoperatorin(arg_fcinfo)
    })
}
pub unsafe fn regoperatorout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regoperatorout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regoperatorout(arg_fcinfo)
    })
}
pub unsafe fn regclassin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regclassin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regclassin(arg_fcinfo)
    })
}
pub unsafe fn regclassout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regclassout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regclassout(arg_fcinfo)
    })
}
pub unsafe fn regtypein(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regtypein(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regtypein(arg_fcinfo)
    })
}
pub unsafe fn regtypeout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regtypeout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regtypeout(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_clear_snapshot(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_clear_snapshot(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_clear_snapshot(arg_fcinfo)
    })
}
pub unsafe fn pg_get_function_identity_arguments(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_function_identity_arguments(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_get_function_identity_arguments(arg_fcinfo)
    })
}
pub unsafe fn hashtid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashtid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashtid(arg_fcinfo)
    })
}
pub unsafe fn hashtidextended(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashtidextended(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashtidextended(arg_fcinfo)
    })
}
pub unsafe fn fmgr_internal_validator(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fmgr_internal_validator(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        fmgr_internal_validator(arg_fcinfo)
    })
}
pub unsafe fn fmgr_c_validator(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fmgr_c_validator(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        fmgr_c_validator(arg_fcinfo)
    })
}
pub unsafe fn fmgr_sql_validator(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fmgr_sql_validator(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        fmgr_sql_validator(arg_fcinfo)
    })
}
pub unsafe fn has_database_privilege_name_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_database_privilege_name_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_database_privilege_name_name(arg_fcinfo)
    })
}
pub unsafe fn has_database_privilege_name_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_database_privilege_name_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_database_privilege_name_id(arg_fcinfo)
    })
}
pub unsafe fn has_database_privilege_id_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_database_privilege_id_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_database_privilege_id_name(arg_fcinfo)
    })
}
pub unsafe fn has_database_privilege_id_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_database_privilege_id_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_database_privilege_id_id(arg_fcinfo)
    })
}
pub unsafe fn has_database_privilege_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_database_privilege_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_database_privilege_name(arg_fcinfo)
    })
}
pub unsafe fn has_database_privilege_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_database_privilege_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_database_privilege_id(arg_fcinfo)
    })
}
pub unsafe fn has_function_privilege_name_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_function_privilege_name_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_function_privilege_name_name(arg_fcinfo)
    })
}
pub unsafe fn has_function_privilege_name_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_function_privilege_name_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_function_privilege_name_id(arg_fcinfo)
    })
}
pub unsafe fn has_function_privilege_id_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_function_privilege_id_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_function_privilege_id_name(arg_fcinfo)
    })
}
pub unsafe fn has_function_privilege_id_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_function_privilege_id_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_function_privilege_id_id(arg_fcinfo)
    })
}
pub unsafe fn has_function_privilege_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_function_privilege_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_function_privilege_name(arg_fcinfo)
    })
}
pub unsafe fn has_function_privilege_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_function_privilege_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_function_privilege_id(arg_fcinfo)
    })
}
pub unsafe fn has_language_privilege_name_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_language_privilege_name_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_language_privilege_name_name(arg_fcinfo)
    })
}
pub unsafe fn has_language_privilege_name_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_language_privilege_name_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_language_privilege_name_id(arg_fcinfo)
    })
}
pub unsafe fn has_language_privilege_id_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_language_privilege_id_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_language_privilege_id_name(arg_fcinfo)
    })
}
pub unsafe fn has_language_privilege_id_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_language_privilege_id_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_language_privilege_id_id(arg_fcinfo)
    })
}
pub unsafe fn has_language_privilege_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_language_privilege_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_language_privilege_name(arg_fcinfo)
    })
}
pub unsafe fn has_language_privilege_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_language_privilege_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_language_privilege_id(arg_fcinfo)
    })
}
pub unsafe fn has_schema_privilege_name_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_schema_privilege_name_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_schema_privilege_name_name(arg_fcinfo)
    })
}
pub unsafe fn has_schema_privilege_name_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_schema_privilege_name_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_schema_privilege_name_id(arg_fcinfo)
    })
}
pub unsafe fn has_schema_privilege_id_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_schema_privilege_id_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_schema_privilege_id_name(arg_fcinfo)
    })
}
pub unsafe fn has_schema_privilege_id_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_schema_privilege_id_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_schema_privilege_id_id(arg_fcinfo)
    })
}
pub unsafe fn has_schema_privilege_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_schema_privilege_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_schema_privilege_name(arg_fcinfo)
    })
}
pub unsafe fn has_schema_privilege_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_schema_privilege_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_schema_privilege_id(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_reset(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_reset(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_reset(arg_fcinfo)
    })
}
pub unsafe fn textregexreplace_noopt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn textregexreplace_noopt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        textregexreplace_noopt(arg_fcinfo)
    })
}
pub unsafe fn textregexreplace(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn textregexreplace(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        textregexreplace(arg_fcinfo)
    })
}
pub unsafe fn pg_total_relation_size(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_total_relation_size(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_total_relation_size(arg_fcinfo)
    })
}
pub unsafe fn pg_size_pretty(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_size_pretty(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_size_pretty(arg_fcinfo)
    })
}
pub unsafe fn pg_options_to_table(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_options_to_table(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_options_to_table(arg_fcinfo)
    })
}
pub unsafe fn record_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn record_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        record_in(arg_fcinfo)
    })
}
pub unsafe fn record_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn record_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        record_out(arg_fcinfo)
    })
}
pub unsafe fn cstring_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cstring_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cstring_in(arg_fcinfo)
    })
}
pub unsafe fn cstring_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cstring_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cstring_out(arg_fcinfo)
    })
}
pub unsafe fn any_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn any_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        any_in(arg_fcinfo)
    })
}
pub unsafe fn any_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn any_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        any_out(arg_fcinfo)
    })
}
pub unsafe fn anyarray_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn anyarray_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        anyarray_in(arg_fcinfo)
    })
}
pub unsafe fn anyarray_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn anyarray_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        anyarray_out(arg_fcinfo)
    })
}
pub unsafe fn void_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn void_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        void_in(arg_fcinfo)
    })
}
pub unsafe fn void_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn void_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        void_out(arg_fcinfo)
    })
}
pub unsafe fn trigger_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn trigger_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        trigger_in(arg_fcinfo)
    })
}
pub unsafe fn trigger_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn trigger_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        trigger_out(arg_fcinfo)
    })
}
pub unsafe fn language_handler_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn language_handler_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        language_handler_in(arg_fcinfo)
    })
}
pub unsafe fn language_handler_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn language_handler_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        language_handler_out(arg_fcinfo)
    })
}
pub unsafe fn internal_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn internal_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        internal_in(arg_fcinfo)
    })
}
pub unsafe fn internal_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn internal_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        internal_out(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_slru(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_slru(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_slru(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_reset_slru(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_reset_slru(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_reset_slru(arg_fcinfo)
    })
}
pub unsafe fn dceil(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dceil(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dceil(arg_fcinfo)
    })
}
pub unsafe fn dfloor(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dfloor(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dfloor(arg_fcinfo)
    })
}
pub unsafe fn dsign(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsign(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dsign(arg_fcinfo)
    })
}
pub unsafe fn md5_text(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn md5_text(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        md5_text(arg_fcinfo)
    })
}
pub unsafe fn anyelement_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn anyelement_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        anyelement_in(arg_fcinfo)
    })
}
pub unsafe fn anyelement_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn anyelement_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        anyelement_out(arg_fcinfo)
    })
}
pub unsafe fn postgresql_fdw_validator(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn postgresql_fdw_validator(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        postgresql_fdw_validator(arg_fcinfo)
    })
}
pub unsafe fn pg_encoding_max_length_sql(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_encoding_max_length_sql(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_encoding_max_length_sql(arg_fcinfo)
    })
}
pub unsafe fn md5_bytea(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn md5_bytea(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        md5_bytea(arg_fcinfo)
    })
}
pub unsafe fn pg_tablespace_size_oid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_tablespace_size_oid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_tablespace_size_oid(arg_fcinfo)
    })
}
pub unsafe fn pg_tablespace_size_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_tablespace_size_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_tablespace_size_name(arg_fcinfo)
    })
}
pub unsafe fn pg_database_size_oid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_database_size_oid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_database_size_oid(arg_fcinfo)
    })
}
pub unsafe fn array_unnest(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_unnest(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_unnest(arg_fcinfo)
    })
}
pub unsafe fn pg_relation_size(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_relation_size(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_relation_size(arg_fcinfo)
    })
}
pub unsafe fn array_agg_transfn(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_agg_transfn(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_agg_transfn(arg_fcinfo)
    })
}
pub unsafe fn array_agg_finalfn(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_agg_finalfn(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_agg_finalfn(arg_fcinfo)
    })
}
pub unsafe fn date_lt_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_lt_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_lt_timestamp(arg_fcinfo)
    })
}
pub unsafe fn date_le_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_le_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_le_timestamp(arg_fcinfo)
    })
}
pub unsafe fn date_eq_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_eq_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_eq_timestamp(arg_fcinfo)
    })
}
pub unsafe fn date_gt_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_gt_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_gt_timestamp(arg_fcinfo)
    })
}
pub unsafe fn date_ge_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_ge_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_ge_timestamp(arg_fcinfo)
    })
}
pub unsafe fn date_ne_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_ne_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_ne_timestamp(arg_fcinfo)
    })
}
pub unsafe fn date_cmp_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_cmp_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_cmp_timestamp(arg_fcinfo)
    })
}
pub unsafe fn date_lt_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_lt_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_lt_timestamptz(arg_fcinfo)
    })
}
pub unsafe fn date_le_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_le_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_le_timestamptz(arg_fcinfo)
    })
}
pub unsafe fn date_eq_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_eq_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_eq_timestamptz(arg_fcinfo)
    })
}
pub unsafe fn date_gt_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_gt_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_gt_timestamptz(arg_fcinfo)
    })
}
pub unsafe fn date_ge_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_ge_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_ge_timestamptz(arg_fcinfo)
    })
}
pub unsafe fn date_ne_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_ne_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_ne_timestamptz(arg_fcinfo)
    })
}
pub unsafe fn date_cmp_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_cmp_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_cmp_timestamptz(arg_fcinfo)
    })
}
pub unsafe fn timestamp_lt_date(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_lt_date(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_lt_date(arg_fcinfo)
    })
}
pub unsafe fn timestamp_le_date(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_le_date(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_le_date(arg_fcinfo)
    })
}
pub unsafe fn timestamp_eq_date(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_eq_date(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_eq_date(arg_fcinfo)
    })
}
pub unsafe fn timestamp_gt_date(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_gt_date(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_gt_date(arg_fcinfo)
    })
}
pub unsafe fn timestamp_ge_date(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_ge_date(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_ge_date(arg_fcinfo)
    })
}
pub unsafe fn timestamp_ne_date(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_ne_date(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_ne_date(arg_fcinfo)
    })
}
pub unsafe fn timestamp_cmp_date(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_cmp_date(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_cmp_date(arg_fcinfo)
    })
}
pub unsafe fn timestamptz_lt_date(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptz_lt_date(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptz_lt_date(arg_fcinfo)
    })
}
pub unsafe fn timestamptz_le_date(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptz_le_date(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptz_le_date(arg_fcinfo)
    })
}
pub unsafe fn timestamptz_eq_date(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptz_eq_date(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptz_eq_date(arg_fcinfo)
    })
}
pub unsafe fn timestamptz_gt_date(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptz_gt_date(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptz_gt_date(arg_fcinfo)
    })
}
pub unsafe fn timestamptz_ge_date(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptz_ge_date(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptz_ge_date(arg_fcinfo)
    })
}
pub unsafe fn timestamptz_ne_date(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptz_ne_date(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptz_ne_date(arg_fcinfo)
    })
}
pub unsafe fn timestamptz_cmp_date(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptz_cmp_date(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptz_cmp_date(arg_fcinfo)
    })
}
pub unsafe fn has_tablespace_privilege_name_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_tablespace_privilege_name_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_tablespace_privilege_name_name(arg_fcinfo)
    })
}
pub unsafe fn has_tablespace_privilege_name_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_tablespace_privilege_name_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_tablespace_privilege_name_id(arg_fcinfo)
    })
}
pub unsafe fn has_tablespace_privilege_id_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_tablespace_privilege_id_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_tablespace_privilege_id_name(arg_fcinfo)
    })
}
pub unsafe fn has_tablespace_privilege_id_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_tablespace_privilege_id_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_tablespace_privilege_id_id(arg_fcinfo)
    })
}
pub unsafe fn has_tablespace_privilege_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_tablespace_privilege_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_tablespace_privilege_name(arg_fcinfo)
    })
}
pub unsafe fn has_tablespace_privilege_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_tablespace_privilege_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_tablespace_privilege_id(arg_fcinfo)
    })
}
pub unsafe fn shell_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn shell_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        shell_in(arg_fcinfo)
    })
}
pub unsafe fn shell_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn shell_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        shell_out(arg_fcinfo)
    })
}
pub unsafe fn array_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_recv(arg_fcinfo)
    })
}
pub unsafe fn array_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_send(arg_fcinfo)
    })
}
pub unsafe fn record_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn record_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        record_recv(arg_fcinfo)
    })
}
pub unsafe fn record_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn record_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        record_send(arg_fcinfo)
    })
}
pub unsafe fn int2recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2recv(arg_fcinfo)
    })
}
pub unsafe fn int2send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2send(arg_fcinfo)
    })
}
pub unsafe fn int4recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4recv(arg_fcinfo)
    })
}
pub unsafe fn int4send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4send(arg_fcinfo)
    })
}
pub unsafe fn int8recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8recv(arg_fcinfo)
    })
}
pub unsafe fn int8send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8send(arg_fcinfo)
    })
}
pub unsafe fn int2vectorrecv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2vectorrecv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2vectorrecv(arg_fcinfo)
    })
}
pub unsafe fn int2vectorsend(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2vectorsend(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2vectorsend(arg_fcinfo)
    })
}
pub unsafe fn bytearecv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bytearecv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bytearecv(arg_fcinfo)
    })
}
pub unsafe fn byteasend(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn byteasend(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        byteasend(arg_fcinfo)
    })
}
pub unsafe fn textrecv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn textrecv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        textrecv(arg_fcinfo)
    })
}
pub unsafe fn textsend(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn textsend(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        textsend(arg_fcinfo)
    })
}
pub unsafe fn unknownrecv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn unknownrecv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        unknownrecv(arg_fcinfo)
    })
}
pub unsafe fn unknownsend(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn unknownsend(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        unknownsend(arg_fcinfo)
    })
}
pub unsafe fn oidrecv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn oidrecv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        oidrecv(arg_fcinfo)
    })
}
pub unsafe fn oidsend(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn oidsend(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        oidsend(arg_fcinfo)
    })
}
pub unsafe fn oidvectorrecv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn oidvectorrecv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        oidvectorrecv(arg_fcinfo)
    })
}
pub unsafe fn oidvectorsend(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn oidvectorsend(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        oidvectorsend(arg_fcinfo)
    })
}
pub unsafe fn namerecv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn namerecv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        namerecv(arg_fcinfo)
    })
}
pub unsafe fn namesend(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn namesend(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        namesend(arg_fcinfo)
    })
}
pub unsafe fn point_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn point_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        point_recv(arg_fcinfo)
    })
}
pub unsafe fn point_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn point_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        point_send(arg_fcinfo)
    })
}
pub unsafe fn bpcharrecv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bpcharrecv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bpcharrecv(arg_fcinfo)
    })
}
pub unsafe fn bpcharsend(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bpcharsend(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bpcharsend(arg_fcinfo)
    })
}
pub unsafe fn varcharrecv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn varcharrecv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        varcharrecv(arg_fcinfo)
    })
}
pub unsafe fn varcharsend(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn varcharsend(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        varcharsend(arg_fcinfo)
    })
}
pub unsafe fn charrecv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn charrecv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        charrecv(arg_fcinfo)
    })
}
pub unsafe fn charsend(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn charsend(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        charsend(arg_fcinfo)
    })
}
pub unsafe fn boolrecv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn boolrecv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        boolrecv(arg_fcinfo)
    })
}
pub unsafe fn boolsend(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn boolsend(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        boolsend(arg_fcinfo)
    })
}
pub unsafe fn tidrecv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tidrecv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tidrecv(arg_fcinfo)
    })
}
pub unsafe fn tidsend(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tidsend(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tidsend(arg_fcinfo)
    })
}
pub unsafe fn xidrecv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xidrecv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        xidrecv(arg_fcinfo)
    })
}
pub unsafe fn xidsend(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xidsend(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        xidsend(arg_fcinfo)
    })
}
pub unsafe fn cidrecv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cidrecv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cidrecv(arg_fcinfo)
    })
}
pub unsafe fn cidsend(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cidsend(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cidsend(arg_fcinfo)
    })
}
pub unsafe fn regprocrecv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regprocrecv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regprocrecv(arg_fcinfo)
    })
}
pub unsafe fn regprocsend(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regprocsend(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regprocsend(arg_fcinfo)
    })
}
pub unsafe fn regprocedurerecv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regprocedurerecv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regprocedurerecv(arg_fcinfo)
    })
}
pub unsafe fn regproceduresend(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regproceduresend(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regproceduresend(arg_fcinfo)
    })
}
pub unsafe fn regoperrecv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regoperrecv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regoperrecv(arg_fcinfo)
    })
}
pub unsafe fn regopersend(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regopersend(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regopersend(arg_fcinfo)
    })
}
pub unsafe fn regoperatorrecv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regoperatorrecv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regoperatorrecv(arg_fcinfo)
    })
}
pub unsafe fn regoperatorsend(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regoperatorsend(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regoperatorsend(arg_fcinfo)
    })
}
pub unsafe fn regclassrecv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regclassrecv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regclassrecv(arg_fcinfo)
    })
}
pub unsafe fn regclasssend(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regclasssend(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regclasssend(arg_fcinfo)
    })
}
pub unsafe fn regtyperecv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regtyperecv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regtyperecv(arg_fcinfo)
    })
}
pub unsafe fn regtypesend(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regtypesend(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regtypesend(arg_fcinfo)
    })
}
pub unsafe fn bit_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bit_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bit_recv(arg_fcinfo)
    })
}
pub unsafe fn bit_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bit_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bit_send(arg_fcinfo)
    })
}
pub unsafe fn varbit_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn varbit_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        varbit_recv(arg_fcinfo)
    })
}
pub unsafe fn varbit_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn varbit_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        varbit_send(arg_fcinfo)
    })
}
pub unsafe fn numeric_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_recv(arg_fcinfo)
    })
}
pub unsafe fn numeric_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_send(arg_fcinfo)
    })
}
pub unsafe fn dsinh(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsinh(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dsinh(arg_fcinfo)
    })
}
pub unsafe fn dcosh(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dcosh(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dcosh(arg_fcinfo)
    })
}
pub unsafe fn dtanh(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dtanh(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dtanh(arg_fcinfo)
    })
}
pub unsafe fn dasinh(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dasinh(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dasinh(arg_fcinfo)
    })
}
pub unsafe fn dacosh(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dacosh(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dacosh(arg_fcinfo)
    })
}
pub unsafe fn datanh(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn datanh(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        datanh(arg_fcinfo)
    })
}
pub unsafe fn date_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_recv(arg_fcinfo)
    })
}
pub unsafe fn date_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_send(arg_fcinfo)
    })
}
pub unsafe fn time_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn time_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        time_recv(arg_fcinfo)
    })
}
pub unsafe fn time_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn time_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        time_send(arg_fcinfo)
    })
}
pub unsafe fn timetz_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timetz_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timetz_recv(arg_fcinfo)
    })
}
pub unsafe fn timetz_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timetz_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timetz_send(arg_fcinfo)
    })
}
pub unsafe fn timestamp_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_recv(arg_fcinfo)
    })
}
pub unsafe fn timestamp_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_send(arg_fcinfo)
    })
}
pub unsafe fn timestamptz_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptz_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptz_recv(arg_fcinfo)
    })
}
pub unsafe fn timestamptz_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptz_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptz_send(arg_fcinfo)
    })
}
pub unsafe fn interval_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        interval_recv(arg_fcinfo)
    })
}
pub unsafe fn interval_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        interval_send(arg_fcinfo)
    })
}
pub unsafe fn lseg_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lseg_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        lseg_recv(arg_fcinfo)
    })
}
pub unsafe fn lseg_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lseg_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        lseg_send(arg_fcinfo)
    })
}
pub unsafe fn path_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn path_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        path_recv(arg_fcinfo)
    })
}
pub unsafe fn path_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn path_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        path_send(arg_fcinfo)
    })
}
pub unsafe fn box_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_recv(arg_fcinfo)
    })
}
pub unsafe fn box_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_send(arg_fcinfo)
    })
}
pub unsafe fn poly_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn poly_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        poly_recv(arg_fcinfo)
    })
}
pub unsafe fn poly_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn poly_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        poly_send(arg_fcinfo)
    })
}
pub unsafe fn line_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn line_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        line_recv(arg_fcinfo)
    })
}
pub unsafe fn line_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn line_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        line_send(arg_fcinfo)
    })
}
pub unsafe fn circle_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn circle_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        circle_recv(arg_fcinfo)
    })
}
pub unsafe fn circle_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn circle_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        circle_send(arg_fcinfo)
    })
}
pub unsafe fn cash_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cash_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cash_recv(arg_fcinfo)
    })
}
pub unsafe fn cash_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cash_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cash_send(arg_fcinfo)
    })
}
pub unsafe fn macaddr_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn macaddr_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        macaddr_recv(arg_fcinfo)
    })
}
pub unsafe fn macaddr_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn macaddr_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        macaddr_send(arg_fcinfo)
    })
}
pub unsafe fn inet_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        inet_recv(arg_fcinfo)
    })
}
pub unsafe fn inet_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        inet_send(arg_fcinfo)
    })
}
pub unsafe fn cidr_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cidr_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cidr_recv(arg_fcinfo)
    })
}
pub unsafe fn cidr_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cidr_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cidr_send(arg_fcinfo)
    })
}
pub unsafe fn cstring_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cstring_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cstring_recv(arg_fcinfo)
    })
}
pub unsafe fn cstring_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cstring_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cstring_send(arg_fcinfo)
    })
}
pub unsafe fn anyarray_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn anyarray_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        anyarray_recv(arg_fcinfo)
    })
}
pub unsafe fn anyarray_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn anyarray_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        anyarray_send(arg_fcinfo)
    })
}
pub unsafe fn pg_get_ruledef_ext(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_ruledef_ext(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_get_ruledef_ext(arg_fcinfo)
    })
}
pub unsafe fn pg_get_viewdef_name_ext(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_viewdef_name_ext(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_get_viewdef_name_ext(arg_fcinfo)
    })
}
pub unsafe fn pg_get_viewdef_ext(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_viewdef_ext(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_get_viewdef_ext(arg_fcinfo)
    })
}
pub unsafe fn pg_get_indexdef_ext(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_indexdef_ext(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_get_indexdef_ext(arg_fcinfo)
    })
}
pub unsafe fn pg_get_constraintdef_ext(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_constraintdef_ext(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_get_constraintdef_ext(arg_fcinfo)
    })
}
pub unsafe fn pg_get_expr_ext(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_expr_ext(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_get_expr_ext(arg_fcinfo)
    })
}
pub unsafe fn pg_prepared_statement(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_prepared_statement(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_prepared_statement(arg_fcinfo)
    })
}
pub unsafe fn pg_cursor(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_cursor(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_cursor(arg_fcinfo)
    })
}
pub unsafe fn numeric_var_pop(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_var_pop(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_var_pop(arg_fcinfo)
    })
}
pub unsafe fn booland_statefunc(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn booland_statefunc(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        booland_statefunc(arg_fcinfo)
    })
}
pub unsafe fn boolor_statefunc(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn boolor_statefunc(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        boolor_statefunc(arg_fcinfo)
    })
}
pub unsafe fn timestamp_lt_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_lt_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_lt_timestamptz(arg_fcinfo)
    })
}
pub unsafe fn timestamp_le_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_le_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_le_timestamptz(arg_fcinfo)
    })
}
pub unsafe fn timestamp_eq_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_eq_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_eq_timestamptz(arg_fcinfo)
    })
}
pub unsafe fn timestamp_gt_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_gt_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_gt_timestamptz(arg_fcinfo)
    })
}
pub unsafe fn timestamp_ge_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_ge_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_ge_timestamptz(arg_fcinfo)
    })
}
pub unsafe fn timestamp_ne_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_ne_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_ne_timestamptz(arg_fcinfo)
    })
}
pub unsafe fn timestamp_cmp_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_cmp_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_cmp_timestamptz(arg_fcinfo)
    })
}
pub unsafe fn timestamptz_lt_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptz_lt_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptz_lt_timestamp(arg_fcinfo)
    })
}
pub unsafe fn timestamptz_le_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptz_le_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptz_le_timestamp(arg_fcinfo)
    })
}
pub unsafe fn timestamptz_eq_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptz_eq_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptz_eq_timestamp(arg_fcinfo)
    })
}
pub unsafe fn timestamptz_gt_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptz_gt_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptz_gt_timestamp(arg_fcinfo)
    })
}
pub unsafe fn timestamptz_ge_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptz_ge_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptz_ge_timestamp(arg_fcinfo)
    })
}
pub unsafe fn timestamptz_ne_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptz_ne_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptz_ne_timestamp(arg_fcinfo)
    })
}
pub unsafe fn timestamptz_cmp_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptz_cmp_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptz_cmp_timestamp(arg_fcinfo)
    })
}
pub unsafe fn pg_tablespace_databases(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_tablespace_databases(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_tablespace_databases(arg_fcinfo)
    })
}
pub unsafe fn int4_bool(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4_bool(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4_bool(arg_fcinfo)
    })
}
pub unsafe fn bool_int4(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bool_int4(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bool_int4(arg_fcinfo)
    })
}
pub unsafe fn lastval(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lastval(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        lastval(arg_fcinfo)
    })
}
pub unsafe fn pg_postmaster_start_time(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_postmaster_start_time(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_postmaster_start_time(arg_fcinfo)
    })
}
pub unsafe fn pg_blocking_pids(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_blocking_pids(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_blocking_pids(arg_fcinfo)
    })
}
pub unsafe fn box_below(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_below(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_below(arg_fcinfo)
    })
}
pub unsafe fn box_overbelow(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_overbelow(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_overbelow(arg_fcinfo)
    })
}
pub unsafe fn box_overabove(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_overabove(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_overabove(arg_fcinfo)
    })
}
pub unsafe fn box_above(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn box_above(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        box_above(arg_fcinfo)
    })
}
pub unsafe fn poly_below(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn poly_below(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        poly_below(arg_fcinfo)
    })
}
pub unsafe fn poly_overbelow(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn poly_overbelow(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        poly_overbelow(arg_fcinfo)
    })
}
pub unsafe fn poly_overabove(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn poly_overabove(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        poly_overabove(arg_fcinfo)
    })
}
pub unsafe fn poly_above(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn poly_above(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        poly_above(arg_fcinfo)
    })
}
pub unsafe fn gist_box_consistent(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gist_box_consistent(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gist_box_consistent(arg_fcinfo)
    })
}
pub unsafe fn jsonb_float8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_float8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_float8(arg_fcinfo)
    })
}
pub unsafe fn gist_box_penalty(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gist_box_penalty(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gist_box_penalty(arg_fcinfo)
    })
}
pub unsafe fn gist_box_picksplit(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gist_box_picksplit(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gist_box_picksplit(arg_fcinfo)
    })
}
pub unsafe fn gist_box_union(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gist_box_union(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gist_box_union(arg_fcinfo)
    })
}
pub unsafe fn gist_box_same(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gist_box_same(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gist_box_same(arg_fcinfo)
    })
}
pub unsafe fn gist_poly_consistent(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gist_poly_consistent(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gist_poly_consistent(arg_fcinfo)
    })
}
pub unsafe fn gist_poly_compress(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gist_poly_compress(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gist_poly_compress(arg_fcinfo)
    })
}
pub unsafe fn circle_overbelow(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn circle_overbelow(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        circle_overbelow(arg_fcinfo)
    })
}
pub unsafe fn circle_overabove(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn circle_overabove(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        circle_overabove(arg_fcinfo)
    })
}
pub unsafe fn gist_circle_consistent(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gist_circle_consistent(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gist_circle_consistent(arg_fcinfo)
    })
}
pub unsafe fn gist_circle_compress(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gist_circle_compress(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gist_circle_compress(arg_fcinfo)
    })
}
pub unsafe fn numeric_stddev_pop(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_stddev_pop(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_stddev_pop(arg_fcinfo)
    })
}
pub unsafe fn domain_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn domain_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        domain_in(arg_fcinfo)
    })
}
pub unsafe fn domain_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn domain_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        domain_recv(arg_fcinfo)
    })
}
pub unsafe fn pg_timezone_abbrevs(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_timezone_abbrevs(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_timezone_abbrevs(arg_fcinfo)
    })
}
pub unsafe fn xmlexists(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xmlexists(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        xmlexists(arg_fcinfo)
    })
}
pub unsafe fn pg_reload_conf(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_reload_conf(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_reload_conf(arg_fcinfo)
    })
}
pub unsafe fn pg_rotate_logfile_v2(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_rotate_logfile_v2(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_rotate_logfile_v2(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_file_1arg(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_file_1arg(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_file_1arg(arg_fcinfo)
    })
}
pub unsafe fn pg_read_file_off_len(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_read_file_off_len(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_read_file_off_len(arg_fcinfo)
    })
}
pub unsafe fn pg_ls_dir_1arg(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_ls_dir_1arg(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_ls_dir_1arg(arg_fcinfo)
    })
}
pub unsafe fn pg_sleep(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_sleep(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_sleep(arg_fcinfo)
    })
}
pub unsafe fn inetnot(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inetnot(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        inetnot(arg_fcinfo)
    })
}
pub unsafe fn inetand(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inetand(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        inetand(arg_fcinfo)
    })
}
pub unsafe fn inetor(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inetor(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        inetor(arg_fcinfo)
    })
}
pub unsafe fn inetpl(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inetpl(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        inetpl(arg_fcinfo)
    })
}
pub unsafe fn inetmi_int8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inetmi_int8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        inetmi_int8(arg_fcinfo)
    })
}
pub unsafe fn inetmi(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inetmi(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        inetmi(arg_fcinfo)
    })
}
pub unsafe fn statement_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn statement_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        statement_timestamp(arg_fcinfo)
    })
}
pub unsafe fn clock_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn clock_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        clock_timestamp(arg_fcinfo)
    })
}
pub unsafe fn gin_cmp_prefix(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gin_cmp_prefix(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gin_cmp_prefix(arg_fcinfo)
    })
}
pub unsafe fn pg_has_role_name_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_has_role_name_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_has_role_name_name(arg_fcinfo)
    })
}
pub unsafe fn pg_has_role_name_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_has_role_name_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_has_role_name_id(arg_fcinfo)
    })
}
pub unsafe fn pg_has_role_id_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_has_role_id_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_has_role_id_name(arg_fcinfo)
    })
}
pub unsafe fn pg_has_role_id_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_has_role_id_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_has_role_id_id(arg_fcinfo)
    })
}
pub unsafe fn pg_has_role_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_has_role_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_has_role_name(arg_fcinfo)
    })
}
pub unsafe fn pg_has_role_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_has_role_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_has_role_id(arg_fcinfo)
    })
}
pub unsafe fn interval_justify_interval(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval_justify_interval(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        interval_justify_interval(arg_fcinfo)
    })
}
pub unsafe fn pg_get_triggerdef_ext(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_triggerdef_ext(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_get_triggerdef_ext(arg_fcinfo)
    })
}
pub unsafe fn dasind(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dasind(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dasind(arg_fcinfo)
    })
}
pub unsafe fn dacosd(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dacosd(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dacosd(arg_fcinfo)
    })
}
pub unsafe fn datand(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn datand(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        datand(arg_fcinfo)
    })
}
pub unsafe fn datan2d(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn datan2d(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        datan2d(arg_fcinfo)
    })
}
pub unsafe fn dsind(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsind(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dsind(arg_fcinfo)
    })
}
pub unsafe fn dcosd(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dcosd(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dcosd(arg_fcinfo)
    })
}
pub unsafe fn dtand(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dtand(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dtand(arg_fcinfo)
    })
}
pub unsafe fn dcotd(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dcotd(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dcotd(arg_fcinfo)
    })
}
pub unsafe fn pg_stop_backup_v2(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stop_backup_v2(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stop_backup_v2(arg_fcinfo)
    })
}
pub unsafe fn numeric_avg_serialize(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_avg_serialize(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_avg_serialize(arg_fcinfo)
    })
}
pub unsafe fn numeric_avg_deserialize(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_avg_deserialize(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_avg_deserialize(arg_fcinfo)
    })
}
pub unsafe fn ginarrayextract(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ginarrayextract(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ginarrayextract(arg_fcinfo)
    })
}
pub unsafe fn ginarrayconsistent(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ginarrayconsistent(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ginarrayconsistent(arg_fcinfo)
    })
}
pub unsafe fn int8_avg_accum(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8_avg_accum(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8_avg_accum(arg_fcinfo)
    })
}
pub unsafe fn arrayoverlap(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn arrayoverlap(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        arrayoverlap(arg_fcinfo)
    })
}
pub unsafe fn arraycontains(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn arraycontains(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        arraycontains(arg_fcinfo)
    })
}
pub unsafe fn arraycontained(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn arraycontained(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        arraycontained(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_db_tuples_returned(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_db_tuples_returned(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_db_tuples_returned(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_db_tuples_fetched(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_db_tuples_fetched(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_db_tuples_fetched(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_db_tuples_inserted(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_db_tuples_inserted(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_db_tuples_inserted(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_db_tuples_updated(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_db_tuples_updated(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_db_tuples_updated(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_db_tuples_deleted(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_db_tuples_deleted(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_db_tuples_deleted(arg_fcinfo)
    })
}
pub unsafe fn regexp_matches_no_flags(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regexp_matches_no_flags(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regexp_matches_no_flags(arg_fcinfo)
    })
}
pub unsafe fn regexp_matches(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regexp_matches(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regexp_matches(arg_fcinfo)
    })
}
pub unsafe fn regexp_split_to_table_no_flags(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regexp_split_to_table_no_flags(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regexp_split_to_table_no_flags(arg_fcinfo)
    })
}
pub unsafe fn regexp_split_to_table(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regexp_split_to_table(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regexp_split_to_table(arg_fcinfo)
    })
}
pub unsafe fn regexp_split_to_array_no_flags(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regexp_split_to_array_no_flags(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regexp_split_to_array_no_flags(arg_fcinfo)
    })
}
pub unsafe fn regexp_split_to_array(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regexp_split_to_array(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regexp_split_to_array(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_bgwriter_timed_checkpoints(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_bgwriter_timed_checkpoints(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_bgwriter_timed_checkpoints(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_bgwriter_requested_checkpoints(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_bgwriter_requested_checkpoints(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_bgwriter_requested_checkpoints(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_bgwriter_buf_written_checkpoints(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_bgwriter_buf_written_checkpoints(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_bgwriter_buf_written_checkpoints(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_bgwriter_buf_written_clean(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_bgwriter_buf_written_clean(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_bgwriter_buf_written_clean(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_bgwriter_maxwritten_clean(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_bgwriter_maxwritten_clean(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_bgwriter_maxwritten_clean(arg_fcinfo)
    })
}
pub unsafe fn ginqueryarrayextract(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ginqueryarrayextract(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ginqueryarrayextract(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_buf_written_backend(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_buf_written_backend(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_buf_written_backend(arg_fcinfo)
    })
}
pub unsafe fn anynonarray_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn anynonarray_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        anynonarray_in(arg_fcinfo)
    })
}
pub unsafe fn anynonarray_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn anynonarray_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        anynonarray_out(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_last_vacuum_time(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_last_vacuum_time(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_last_vacuum_time(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_last_autovacuum_time(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_last_autovacuum_time(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_last_autovacuum_time(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_last_analyze_time(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_last_analyze_time(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_last_analyze_time(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_last_autoanalyze_time(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_last_autoanalyze_time(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_last_autoanalyze_time(arg_fcinfo)
    })
}
pub unsafe fn int8_avg_combine(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8_avg_combine(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8_avg_combine(arg_fcinfo)
    })
}
pub unsafe fn int8_avg_serialize(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8_avg_serialize(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8_avg_serialize(arg_fcinfo)
    })
}
pub unsafe fn int8_avg_deserialize(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8_avg_deserialize(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8_avg_deserialize(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_backend_wait_event_type(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_backend_wait_event_type(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_backend_wait_event_type(arg_fcinfo)
    })
}
pub unsafe fn tidgt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tidgt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tidgt(arg_fcinfo)
    })
}
pub unsafe fn tidlt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tidlt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tidlt(arg_fcinfo)
    })
}
pub unsafe fn tidge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tidge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tidge(arg_fcinfo)
    })
}
pub unsafe fn tidle(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tidle(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tidle(arg_fcinfo)
    })
}
pub unsafe fn bttidcmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bttidcmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bttidcmp(arg_fcinfo)
    })
}
pub unsafe fn tidlarger(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tidlarger(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tidlarger(arg_fcinfo)
    })
}
pub unsafe fn tidsmaller(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tidsmaller(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tidsmaller(arg_fcinfo)
    })
}
pub unsafe fn int8inc_any(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8inc_any(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8inc_any(arg_fcinfo)
    })
}
pub unsafe fn int8inc_float8_float8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8inc_float8_float8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8inc_float8_float8(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_db_blk_read_time(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_db_blk_read_time(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_db_blk_read_time(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_db_blk_write_time(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_db_blk_write_time(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_db_blk_write_time(arg_fcinfo)
    })
}
pub unsafe fn pg_switch_wal(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_switch_wal(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_switch_wal(arg_fcinfo)
    })
}
pub unsafe fn pg_current_wal_lsn(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_current_wal_lsn(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_current_wal_lsn(arg_fcinfo)
    })
}
pub unsafe fn pg_walfile_name_offset(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_walfile_name_offset(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_walfile_name_offset(arg_fcinfo)
    })
}
pub unsafe fn pg_walfile_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_walfile_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_walfile_name(arg_fcinfo)
    })
}
pub unsafe fn pg_current_wal_insert_lsn(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_current_wal_insert_lsn(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_current_wal_insert_lsn(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_backend_wait_event(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_backend_wait_event(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_backend_wait_event(arg_fcinfo)
    })
}
pub unsafe fn pg_my_temp_schema(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_my_temp_schema(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_my_temp_schema(arg_fcinfo)
    })
}
pub unsafe fn pg_is_other_temp_schema(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_is_other_temp_schema(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_is_other_temp_schema(arg_fcinfo)
    })
}
pub unsafe fn pg_timezone_names(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_timezone_names(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_timezone_names(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_backend_xact_start(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_backend_xact_start(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_backend_xact_start(arg_fcinfo)
    })
}
pub unsafe fn numeric_avg_accum(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_avg_accum(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_avg_accum(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_buf_alloc(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_buf_alloc(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_buf_alloc(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_live_tuples(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_live_tuples(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_live_tuples(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_dead_tuples(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_dead_tuples(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_dead_tuples(arg_fcinfo)
    })
}
pub unsafe fn pg_advisory_lock_int8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_advisory_lock_int8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_advisory_lock_int8(arg_fcinfo)
    })
}
pub unsafe fn pg_advisory_lock_shared_int8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_advisory_lock_shared_int8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_advisory_lock_shared_int8(arg_fcinfo)
    })
}
pub unsafe fn pg_try_advisory_lock_int8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_try_advisory_lock_int8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_try_advisory_lock_int8(arg_fcinfo)
    })
}
pub unsafe fn pg_try_advisory_lock_shared_int8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_try_advisory_lock_shared_int8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_try_advisory_lock_shared_int8(arg_fcinfo)
    })
}
pub unsafe fn pg_advisory_unlock_int8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_advisory_unlock_int8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_advisory_unlock_int8(arg_fcinfo)
    })
}
pub unsafe fn pg_advisory_unlock_shared_int8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_advisory_unlock_shared_int8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_advisory_unlock_shared_int8(arg_fcinfo)
    })
}
pub unsafe fn pg_advisory_lock_int4(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_advisory_lock_int4(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_advisory_lock_int4(arg_fcinfo)
    })
}
pub unsafe fn pg_advisory_lock_shared_int4(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_advisory_lock_shared_int4(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_advisory_lock_shared_int4(arg_fcinfo)
    })
}
pub unsafe fn pg_try_advisory_lock_int4(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_try_advisory_lock_int4(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_try_advisory_lock_int4(arg_fcinfo)
    })
}
pub unsafe fn pg_try_advisory_lock_shared_int4(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_try_advisory_lock_shared_int4(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_try_advisory_lock_shared_int4(arg_fcinfo)
    })
}
pub unsafe fn pg_advisory_unlock_int4(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_advisory_unlock_int4(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_advisory_unlock_int4(arg_fcinfo)
    })
}
pub unsafe fn pg_advisory_unlock_shared_int4(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_advisory_unlock_shared_int4(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_advisory_unlock_shared_int4(arg_fcinfo)
    })
}
pub unsafe fn pg_advisory_unlock_all(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_advisory_unlock_all(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_advisory_unlock_all(arg_fcinfo)
    })
}
pub unsafe fn xml_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xml_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        xml_in(arg_fcinfo)
    })
}
pub unsafe fn xml_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xml_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        xml_out(arg_fcinfo)
    })
}
pub unsafe fn xmlcomment(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xmlcomment(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        xmlcomment(arg_fcinfo)
    })
}
pub unsafe fn texttoxml(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn texttoxml(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        texttoxml(arg_fcinfo)
    })
}
pub unsafe fn xmlvalidate(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xmlvalidate(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        xmlvalidate(arg_fcinfo)
    })
}
pub unsafe fn xml_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xml_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        xml_recv(arg_fcinfo)
    })
}
pub unsafe fn xml_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xml_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        xml_send(arg_fcinfo)
    })
}
pub unsafe fn xmlconcat2(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xmlconcat2(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        xmlconcat2(arg_fcinfo)
    })
}
pub unsafe fn varbittypmodin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn varbittypmodin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        varbittypmodin(arg_fcinfo)
    })
}
pub unsafe fn intervaltypmodin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn intervaltypmodin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        intervaltypmodin(arg_fcinfo)
    })
}
pub unsafe fn intervaltypmodout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn intervaltypmodout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        intervaltypmodout(arg_fcinfo)
    })
}
pub unsafe fn timestamptypmodin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptypmodin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptypmodin(arg_fcinfo)
    })
}
pub unsafe fn timestamptypmodout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptypmodout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptypmodout(arg_fcinfo)
    })
}
pub unsafe fn timestamptztypmodin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptztypmodin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptztypmodin(arg_fcinfo)
    })
}
pub unsafe fn timestamptztypmodout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamptztypmodout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamptztypmodout(arg_fcinfo)
    })
}
pub unsafe fn timetypmodin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timetypmodin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timetypmodin(arg_fcinfo)
    })
}
pub unsafe fn timetypmodout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timetypmodout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timetypmodout(arg_fcinfo)
    })
}
pub unsafe fn timetztypmodin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timetztypmodin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timetztypmodin(arg_fcinfo)
    })
}
pub unsafe fn timetztypmodout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timetztypmodout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timetztypmodout(arg_fcinfo)
    })
}
pub unsafe fn bpchartypmodin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bpchartypmodin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bpchartypmodin(arg_fcinfo)
    })
}
pub unsafe fn bpchartypmodout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bpchartypmodout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bpchartypmodout(arg_fcinfo)
    })
}
pub unsafe fn varchartypmodin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn varchartypmodin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        varchartypmodin(arg_fcinfo)
    })
}
pub unsafe fn varchartypmodout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn varchartypmodout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        varchartypmodout(arg_fcinfo)
    })
}
pub unsafe fn numerictypmodin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numerictypmodin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numerictypmodin(arg_fcinfo)
    })
}
pub unsafe fn numerictypmodout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numerictypmodout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numerictypmodout(arg_fcinfo)
    })
}
pub unsafe fn bittypmodin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bittypmodin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bittypmodin(arg_fcinfo)
    })
}
pub unsafe fn bittypmodout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bittypmodout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bittypmodout(arg_fcinfo)
    })
}
pub unsafe fn varbittypmodout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn varbittypmodout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        varbittypmodout(arg_fcinfo)
    })
}
pub unsafe fn xmltotext(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xmltotext(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        xmltotext(arg_fcinfo)
    })
}
pub unsafe fn table_to_xml(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn table_to_xml(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        table_to_xml(arg_fcinfo)
    })
}
pub unsafe fn query_to_xml(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn query_to_xml(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        query_to_xml(arg_fcinfo)
    })
}
pub unsafe fn cursor_to_xml(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cursor_to_xml(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cursor_to_xml(arg_fcinfo)
    })
}
pub unsafe fn table_to_xmlschema(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn table_to_xmlschema(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        table_to_xmlschema(arg_fcinfo)
    })
}
pub unsafe fn query_to_xmlschema(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn query_to_xmlschema(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        query_to_xmlschema(arg_fcinfo)
    })
}
pub unsafe fn cursor_to_xmlschema(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cursor_to_xmlschema(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cursor_to_xmlschema(arg_fcinfo)
    })
}
pub unsafe fn table_to_xml_and_xmlschema(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn table_to_xml_and_xmlschema(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        table_to_xml_and_xmlschema(arg_fcinfo)
    })
}
pub unsafe fn query_to_xml_and_xmlschema(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn query_to_xml_and_xmlschema(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        query_to_xml_and_xmlschema(arg_fcinfo)
    })
}
pub unsafe fn xpath(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xpath(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        xpath(arg_fcinfo)
    })
}
pub unsafe fn schema_to_xml(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn schema_to_xml(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        schema_to_xml(arg_fcinfo)
    })
}
pub unsafe fn schema_to_xmlschema(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn schema_to_xmlschema(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        schema_to_xmlschema(arg_fcinfo)
    })
}
pub unsafe fn schema_to_xml_and_xmlschema(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn schema_to_xml_and_xmlschema(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        schema_to_xml_and_xmlschema(arg_fcinfo)
    })
}
pub unsafe fn database_to_xml(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn database_to_xml(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        database_to_xml(arg_fcinfo)
    })
}
pub unsafe fn database_to_xmlschema(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn database_to_xmlschema(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        database_to_xmlschema(arg_fcinfo)
    })
}
pub unsafe fn database_to_xml_and_xmlschema(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn database_to_xml_and_xmlschema(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        database_to_xml_and_xmlschema(arg_fcinfo)
    })
}
pub unsafe fn pg_snapshot_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_snapshot_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_snapshot_in(arg_fcinfo)
    })
}
pub unsafe fn pg_snapshot_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_snapshot_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_snapshot_out(arg_fcinfo)
    })
}
pub unsafe fn pg_snapshot_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_snapshot_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_snapshot_recv(arg_fcinfo)
    })
}
pub unsafe fn pg_snapshot_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_snapshot_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_snapshot_send(arg_fcinfo)
    })
}
pub unsafe fn pg_current_xact_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_current_xact_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_current_xact_id(arg_fcinfo)
    })
}
pub unsafe fn pg_current_snapshot(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_current_snapshot(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_current_snapshot(arg_fcinfo)
    })
}
pub unsafe fn pg_snapshot_xmin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_snapshot_xmin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_snapshot_xmin(arg_fcinfo)
    })
}
pub unsafe fn pg_snapshot_xmax(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_snapshot_xmax(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_snapshot_xmax(arg_fcinfo)
    })
}
pub unsafe fn pg_snapshot_xip(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_snapshot_xip(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_snapshot_xip(arg_fcinfo)
    })
}
pub unsafe fn pg_visible_in_snapshot(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_visible_in_snapshot(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_visible_in_snapshot(arg_fcinfo)
    })
}
pub unsafe fn uuid_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn uuid_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        uuid_in(arg_fcinfo)
    })
}
pub unsafe fn uuid_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn uuid_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        uuid_out(arg_fcinfo)
    })
}
pub unsafe fn uuid_lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn uuid_lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        uuid_lt(arg_fcinfo)
    })
}
pub unsafe fn uuid_le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn uuid_le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        uuid_le(arg_fcinfo)
    })
}
pub unsafe fn uuid_eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn uuid_eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        uuid_eq(arg_fcinfo)
    })
}
pub unsafe fn uuid_ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn uuid_ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        uuid_ge(arg_fcinfo)
    })
}
pub unsafe fn uuid_gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn uuid_gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        uuid_gt(arg_fcinfo)
    })
}
pub unsafe fn uuid_ne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn uuid_ne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        uuid_ne(arg_fcinfo)
    })
}
pub unsafe fn uuid_cmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn uuid_cmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        uuid_cmp(arg_fcinfo)
    })
}
pub unsafe fn uuid_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn uuid_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        uuid_recv(arg_fcinfo)
    })
}
pub unsafe fn uuid_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn uuid_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        uuid_send(arg_fcinfo)
    })
}
pub unsafe fn uuid_hash(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn uuid_hash(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        uuid_hash(arg_fcinfo)
    })
}
pub unsafe fn booltext(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn booltext(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        booltext(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_function_calls(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_function_calls(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_function_calls(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_function_total_time(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_function_total_time(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_function_total_time(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_function_self_time(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_function_self_time(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_function_self_time(arg_fcinfo)
    })
}
pub unsafe fn record_eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn record_eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        record_eq(arg_fcinfo)
    })
}
pub unsafe fn record_ne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn record_ne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        record_ne(arg_fcinfo)
    })
}
pub unsafe fn record_lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn record_lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        record_lt(arg_fcinfo)
    })
}
pub unsafe fn record_gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn record_gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        record_gt(arg_fcinfo)
    })
}
pub unsafe fn record_le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn record_le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        record_le(arg_fcinfo)
    })
}
pub unsafe fn record_ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn record_ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        record_ge(arg_fcinfo)
    })
}
pub unsafe fn btrecordcmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btrecordcmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btrecordcmp(arg_fcinfo)
    })
}
pub unsafe fn pg_table_size(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_table_size(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_table_size(arg_fcinfo)
    })
}
pub unsafe fn pg_indexes_size(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_indexes_size(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_indexes_size(arg_fcinfo)
    })
}
pub unsafe fn pg_relation_filenode(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_relation_filenode(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_relation_filenode(arg_fcinfo)
    })
}
pub unsafe fn has_foreign_data_wrapper_privilege_name_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_foreign_data_wrapper_privilege_name_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_foreign_data_wrapper_privilege_name_name(arg_fcinfo)
    })
}
pub unsafe fn has_foreign_data_wrapper_privilege_name_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_foreign_data_wrapper_privilege_name_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_foreign_data_wrapper_privilege_name_id(arg_fcinfo)
    })
}
pub unsafe fn has_foreign_data_wrapper_privilege_id_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_foreign_data_wrapper_privilege_id_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_foreign_data_wrapper_privilege_id_name(arg_fcinfo)
    })
}
pub unsafe fn has_foreign_data_wrapper_privilege_id_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_foreign_data_wrapper_privilege_id_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_foreign_data_wrapper_privilege_id_id(arg_fcinfo)
    })
}
pub unsafe fn has_foreign_data_wrapper_privilege_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_foreign_data_wrapper_privilege_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_foreign_data_wrapper_privilege_name(arg_fcinfo)
    })
}
pub unsafe fn has_foreign_data_wrapper_privilege_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_foreign_data_wrapper_privilege_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_foreign_data_wrapper_privilege_id(arg_fcinfo)
    })
}
pub unsafe fn has_server_privilege_name_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_server_privilege_name_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_server_privilege_name_name(arg_fcinfo)
    })
}
pub unsafe fn has_server_privilege_name_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_server_privilege_name_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_server_privilege_name_id(arg_fcinfo)
    })
}
pub unsafe fn has_server_privilege_id_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_server_privilege_id_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_server_privilege_id_name(arg_fcinfo)
    })
}
pub unsafe fn has_server_privilege_id_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_server_privilege_id_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_server_privilege_id_id(arg_fcinfo)
    })
}
pub unsafe fn has_server_privilege_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_server_privilege_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_server_privilege_name(arg_fcinfo)
    })
}
pub unsafe fn has_server_privilege_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_server_privilege_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_server_privilege_id(arg_fcinfo)
    })
}
pub unsafe fn has_column_privilege_name_name_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_column_privilege_name_name_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_column_privilege_name_name_name(arg_fcinfo)
    })
}
pub unsafe fn has_column_privilege_name_name_attnum(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_column_privilege_name_name_attnum(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_column_privilege_name_name_attnum(arg_fcinfo)
    })
}
pub unsafe fn has_column_privilege_name_id_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_column_privilege_name_id_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_column_privilege_name_id_name(arg_fcinfo)
    })
}
pub unsafe fn has_column_privilege_name_id_attnum(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_column_privilege_name_id_attnum(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_column_privilege_name_id_attnum(arg_fcinfo)
    })
}
pub unsafe fn has_column_privilege_id_name_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_column_privilege_id_name_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_column_privilege_id_name_name(arg_fcinfo)
    })
}
pub unsafe fn has_column_privilege_id_name_attnum(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_column_privilege_id_name_attnum(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_column_privilege_id_name_attnum(arg_fcinfo)
    })
}
pub unsafe fn has_column_privilege_id_id_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_column_privilege_id_id_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_column_privilege_id_id_name(arg_fcinfo)
    })
}
pub unsafe fn has_column_privilege_id_id_attnum(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_column_privilege_id_id_attnum(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_column_privilege_id_id_attnum(arg_fcinfo)
    })
}
pub unsafe fn has_column_privilege_name_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_column_privilege_name_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_column_privilege_name_name(arg_fcinfo)
    })
}
pub unsafe fn has_column_privilege_name_attnum(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_column_privilege_name_attnum(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_column_privilege_name_attnum(arg_fcinfo)
    })
}
pub unsafe fn has_column_privilege_id_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_column_privilege_id_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_column_privilege_id_name(arg_fcinfo)
    })
}
pub unsafe fn has_column_privilege_id_attnum(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_column_privilege_id_attnum(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_column_privilege_id_attnum(arg_fcinfo)
    })
}
pub unsafe fn has_any_column_privilege_name_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_any_column_privilege_name_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_any_column_privilege_name_name(arg_fcinfo)
    })
}
pub unsafe fn has_any_column_privilege_name_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_any_column_privilege_name_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_any_column_privilege_name_id(arg_fcinfo)
    })
}
pub unsafe fn has_any_column_privilege_id_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_any_column_privilege_id_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_any_column_privilege_id_name(arg_fcinfo)
    })
}
pub unsafe fn has_any_column_privilege_id_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_any_column_privilege_id_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_any_column_privilege_id_id(arg_fcinfo)
    })
}
pub unsafe fn has_any_column_privilege_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_any_column_privilege_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_any_column_privilege_name(arg_fcinfo)
    })
}
pub unsafe fn has_any_column_privilege_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_any_column_privilege_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_any_column_privilege_id(arg_fcinfo)
    })
}
pub unsafe fn bitoverlay(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bitoverlay(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bitoverlay(arg_fcinfo)
    })
}
pub unsafe fn bitoverlay_no_len(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bitoverlay_no_len(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bitoverlay_no_len(arg_fcinfo)
    })
}
pub unsafe fn bitgetbit(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bitgetbit(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bitgetbit(arg_fcinfo)
    })
}
pub unsafe fn bitsetbit(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bitsetbit(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bitsetbit(arg_fcinfo)
    })
}
pub unsafe fn pg_relation_filepath(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_relation_filepath(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_relation_filepath(arg_fcinfo)
    })
}
pub unsafe fn pg_listening_channels(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_listening_channels(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_listening_channels(arg_fcinfo)
    })
}
pub unsafe fn pg_notify(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_notify(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_notify(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_xact_numscans(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_xact_numscans(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_xact_numscans(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_xact_tuples_returned(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_xact_tuples_returned(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_xact_tuples_returned(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_xact_tuples_fetched(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_xact_tuples_fetched(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_xact_tuples_fetched(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_xact_tuples_inserted(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_xact_tuples_inserted(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_xact_tuples_inserted(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_xact_tuples_updated(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_xact_tuples_updated(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_xact_tuples_updated(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_xact_tuples_deleted(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_xact_tuples_deleted(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_xact_tuples_deleted(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_xact_tuples_hot_updated(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_xact_tuples_hot_updated(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_xact_tuples_hot_updated(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_xact_blocks_fetched(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_xact_blocks_fetched(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_xact_blocks_fetched(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_xact_blocks_hit(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_xact_blocks_hit(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_xact_blocks_hit(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_xact_function_calls(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_xact_function_calls(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_xact_function_calls(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_xact_function_total_time(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_xact_function_total_time(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_xact_function_total_time(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_xact_function_self_time(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_xact_function_self_time(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_xact_function_self_time(arg_fcinfo)
    })
}
pub unsafe fn xpath_exists(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xpath_exists(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        xpath_exists(arg_fcinfo)
    })
}
pub unsafe fn xml_is_well_formed(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xml_is_well_formed(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        xml_is_well_formed(arg_fcinfo)
    })
}
pub unsafe fn xml_is_well_formed_document(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xml_is_well_formed_document(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        xml_is_well_formed_document(arg_fcinfo)
    })
}
pub unsafe fn xml_is_well_formed_content(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xml_is_well_formed_content(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        xml_is_well_formed_content(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_vacuum_count(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_vacuum_count(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_vacuum_count(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_autovacuum_count(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_autovacuum_count(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_autovacuum_count(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_analyze_count(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_analyze_count(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_analyze_count(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_autoanalyze_count(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_autoanalyze_count(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_autoanalyze_count(arg_fcinfo)
    })
}
pub unsafe fn text_concat(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn text_concat(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        text_concat(arg_fcinfo)
    })
}
pub unsafe fn text_concat_ws(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn text_concat_ws(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        text_concat_ws(arg_fcinfo)
    })
}
pub unsafe fn text_left(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn text_left(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        text_left(arg_fcinfo)
    })
}
pub unsafe fn text_right(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn text_right(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        text_right(arg_fcinfo)
    })
}
pub unsafe fn text_reverse(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn text_reverse(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        text_reverse(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_buf_fsync_backend(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_buf_fsync_backend(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_buf_fsync_backend(arg_fcinfo)
    })
}
pub unsafe fn gist_point_distance(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gist_point_distance(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gist_point_distance(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_db_conflict_tablespace(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_db_conflict_tablespace(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_db_conflict_tablespace(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_db_conflict_lock(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_db_conflict_lock(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_db_conflict_lock(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_db_conflict_snapshot(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_db_conflict_snapshot(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_db_conflict_snapshot(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_db_conflict_bufferpin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_db_conflict_bufferpin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_db_conflict_bufferpin(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_db_conflict_startup_deadlock(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_db_conflict_startup_deadlock(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_db_conflict_startup_deadlock(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_db_conflict_all(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_db_conflict_all(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_db_conflict_all(arg_fcinfo)
    })
}
pub unsafe fn pg_wal_replay_pause(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_wal_replay_pause(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_wal_replay_pause(arg_fcinfo)
    })
}
pub unsafe fn pg_wal_replay_resume(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_wal_replay_resume(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_wal_replay_resume(arg_fcinfo)
    })
}
pub unsafe fn pg_is_wal_replay_paused(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_is_wal_replay_paused(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_is_wal_replay_paused(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_db_stat_reset_time(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_db_stat_reset_time(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_db_stat_reset_time(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_bgwriter_stat_reset_time(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_bgwriter_stat_reset_time(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_bgwriter_stat_reset_time(arg_fcinfo)
    })
}
pub unsafe fn ginarrayextract_2args(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ginarrayextract_2args(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ginarrayextract_2args(arg_fcinfo)
    })
}
pub unsafe fn gin_extract_tsvector_2args(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gin_extract_tsvector_2args(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gin_extract_tsvector_2args(arg_fcinfo)
    })
}
pub unsafe fn pg_sequence_parameters(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_sequence_parameters(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_sequence_parameters(arg_fcinfo)
    })
}
pub unsafe fn pg_available_extensions(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_available_extensions(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_available_extensions(arg_fcinfo)
    })
}
pub unsafe fn pg_available_extension_versions(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_available_extension_versions(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_available_extension_versions(arg_fcinfo)
    })
}
pub unsafe fn pg_extension_update_paths(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_extension_update_paths(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_extension_update_paths(arg_fcinfo)
    })
}
pub unsafe fn pg_extension_config_dump(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_extension_config_dump(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_extension_config_dump(arg_fcinfo)
    })
}
pub unsafe fn gin_extract_tsquery_5args(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gin_extract_tsquery_5args(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gin_extract_tsquery_5args(arg_fcinfo)
    })
}
pub unsafe fn gin_tsquery_consistent_6args(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gin_tsquery_consistent_6args(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gin_tsquery_consistent_6args(arg_fcinfo)
    })
}
pub unsafe fn pg_advisory_xact_lock_int8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_advisory_xact_lock_int8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_advisory_xact_lock_int8(arg_fcinfo)
    })
}
pub unsafe fn pg_advisory_xact_lock_shared_int8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_advisory_xact_lock_shared_int8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_advisory_xact_lock_shared_int8(arg_fcinfo)
    })
}
pub unsafe fn pg_try_advisory_xact_lock_int8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_try_advisory_xact_lock_int8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_try_advisory_xact_lock_int8(arg_fcinfo)
    })
}
pub unsafe fn pg_try_advisory_xact_lock_shared_int8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_try_advisory_xact_lock_shared_int8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_try_advisory_xact_lock_shared_int8(arg_fcinfo)
    })
}
pub unsafe fn pg_advisory_xact_lock_int4(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_advisory_xact_lock_int4(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_advisory_xact_lock_int4(arg_fcinfo)
    })
}
pub unsafe fn pg_advisory_xact_lock_shared_int4(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_advisory_xact_lock_shared_int4(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_advisory_xact_lock_shared_int4(arg_fcinfo)
    })
}
pub unsafe fn pg_try_advisory_xact_lock_int4(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_try_advisory_xact_lock_int4(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_try_advisory_xact_lock_int4(arg_fcinfo)
    })
}
pub unsafe fn pg_try_advisory_xact_lock_shared_int4(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_try_advisory_xact_lock_shared_int4(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_try_advisory_xact_lock_shared_int4(arg_fcinfo)
    })
}
pub unsafe fn varchar_support(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn varchar_support(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        varchar_support(arg_fcinfo)
    })
}
pub unsafe fn pg_create_restore_point(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_create_restore_point(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_create_restore_point(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_wal_senders(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_wal_senders(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_wal_senders(arg_fcinfo)
    })
}
pub unsafe fn window_row_number(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn window_row_number(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        window_row_number(arg_fcinfo)
    })
}
pub unsafe fn window_rank(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn window_rank(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        window_rank(arg_fcinfo)
    })
}
pub unsafe fn window_dense_rank(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn window_dense_rank(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        window_dense_rank(arg_fcinfo)
    })
}
pub unsafe fn window_percent_rank(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn window_percent_rank(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        window_percent_rank(arg_fcinfo)
    })
}
pub unsafe fn window_cume_dist(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn window_cume_dist(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        window_cume_dist(arg_fcinfo)
    })
}
pub unsafe fn window_ntile(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn window_ntile(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        window_ntile(arg_fcinfo)
    })
}
pub unsafe fn window_lag(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn window_lag(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        window_lag(arg_fcinfo)
    })
}
pub unsafe fn window_lag_with_offset(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn window_lag_with_offset(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        window_lag_with_offset(arg_fcinfo)
    })
}
pub unsafe fn window_lag_with_offset_and_default(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn window_lag_with_offset_and_default(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        window_lag_with_offset_and_default(arg_fcinfo)
    })
}
pub unsafe fn window_lead(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn window_lead(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        window_lead(arg_fcinfo)
    })
}
pub unsafe fn window_lead_with_offset(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn window_lead_with_offset(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        window_lead_with_offset(arg_fcinfo)
    })
}
pub unsafe fn window_lead_with_offset_and_default(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn window_lead_with_offset_and_default(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        window_lead_with_offset_and_default(arg_fcinfo)
    })
}
pub unsafe fn window_first_value(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn window_first_value(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        window_first_value(arg_fcinfo)
    })
}
pub unsafe fn window_last_value(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn window_last_value(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        window_last_value(arg_fcinfo)
    })
}
pub unsafe fn window_nth_value(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn window_nth_value(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        window_nth_value(arg_fcinfo)
    })
}
pub unsafe fn fdw_handler_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fdw_handler_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        fdw_handler_in(arg_fcinfo)
    })
}
pub unsafe fn fdw_handler_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn fdw_handler_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        fdw_handler_out(arg_fcinfo)
    })
}
pub unsafe fn void_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn void_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        void_recv(arg_fcinfo)
    })
}
pub unsafe fn void_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn void_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        void_send(arg_fcinfo)
    })
}
pub unsafe fn btint2sortsupport(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btint2sortsupport(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btint2sortsupport(arg_fcinfo)
    })
}
pub unsafe fn btint4sortsupport(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btint4sortsupport(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btint4sortsupport(arg_fcinfo)
    })
}
pub unsafe fn btint8sortsupport(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btint8sortsupport(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btint8sortsupport(arg_fcinfo)
    })
}
pub unsafe fn btfloat4sortsupport(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btfloat4sortsupport(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btfloat4sortsupport(arg_fcinfo)
    })
}
pub unsafe fn btfloat8sortsupport(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btfloat8sortsupport(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btfloat8sortsupport(arg_fcinfo)
    })
}
pub unsafe fn btoidsortsupport(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btoidsortsupport(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btoidsortsupport(arg_fcinfo)
    })
}
pub unsafe fn btnamesortsupport(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btnamesortsupport(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btnamesortsupport(arg_fcinfo)
    })
}
pub unsafe fn date_sortsupport(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_sortsupport(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        date_sortsupport(arg_fcinfo)
    })
}
pub unsafe fn timestamp_sortsupport(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_sortsupport(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_sortsupport(arg_fcinfo)
    })
}
pub unsafe fn has_type_privilege_name_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_type_privilege_name_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_type_privilege_name_name(arg_fcinfo)
    })
}
pub unsafe fn has_type_privilege_name_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_type_privilege_name_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_type_privilege_name_id(arg_fcinfo)
    })
}
pub unsafe fn has_type_privilege_id_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_type_privilege_id_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_type_privilege_id_name(arg_fcinfo)
    })
}
pub unsafe fn has_type_privilege_id_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_type_privilege_id_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_type_privilege_id_id(arg_fcinfo)
    })
}
pub unsafe fn has_type_privilege_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_type_privilege_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_type_privilege_name(arg_fcinfo)
    })
}
pub unsafe fn has_type_privilege_id(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn has_type_privilege_id(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        has_type_privilege_id(arg_fcinfo)
    })
}
pub unsafe fn macaddr_not(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn macaddr_not(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        macaddr_not(arg_fcinfo)
    })
}
pub unsafe fn macaddr_and(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn macaddr_and(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        macaddr_and(arg_fcinfo)
    })
}
pub unsafe fn macaddr_or(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn macaddr_or(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        macaddr_or(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_db_temp_files(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_db_temp_files(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_db_temp_files(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_db_temp_bytes(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_db_temp_bytes(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_db_temp_bytes(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_db_deadlocks(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_db_deadlocks(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_db_deadlocks(arg_fcinfo)
    })
}
pub unsafe fn array_to_json(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_to_json(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_to_json(arg_fcinfo)
    })
}
pub unsafe fn array_to_json_pretty(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_to_json_pretty(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_to_json_pretty(arg_fcinfo)
    })
}
pub unsafe fn row_to_json(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn row_to_json(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        row_to_json(arg_fcinfo)
    })
}
pub unsafe fn row_to_json_pretty(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn row_to_json_pretty(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        row_to_json_pretty(arg_fcinfo)
    })
}
pub unsafe fn numeric_support(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_support(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_support(arg_fcinfo)
    })
}
pub unsafe fn varbit_support(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn varbit_support(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        varbit_support(arg_fcinfo)
    })
}
pub unsafe fn pg_get_viewdef_wrap(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_viewdef_wrap(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_get_viewdef_wrap(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_checkpoint_write_time(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_checkpoint_write_time(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_checkpoint_write_time(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_checkpoint_sync_time(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_checkpoint_sync_time(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_checkpoint_sync_time(arg_fcinfo)
    })
}
pub unsafe fn pg_collation_for(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_collation_for(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_collation_for(arg_fcinfo)
    })
}
pub unsafe fn pg_trigger_depth(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_trigger_depth(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_trigger_depth(arg_fcinfo)
    })
}
pub unsafe fn pg_wal_lsn_diff(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_wal_lsn_diff(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_wal_lsn_diff(arg_fcinfo)
    })
}
pub unsafe fn pg_size_pretty_numeric(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_size_pretty_numeric(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_size_pretty_numeric(arg_fcinfo)
    })
}
pub unsafe fn array_remove(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_remove(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_remove(arg_fcinfo)
    })
}
pub unsafe fn array_replace(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_replace(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_replace(arg_fcinfo)
    })
}
pub unsafe fn rangesel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn rangesel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        rangesel(arg_fcinfo)
    })
}
pub unsafe fn be_lo_lseek64(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn be_lo_lseek64(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        be_lo_lseek64(arg_fcinfo)
    })
}
pub unsafe fn be_lo_tell64(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn be_lo_tell64(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        be_lo_tell64(arg_fcinfo)
    })
}
pub unsafe fn be_lo_truncate64(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn be_lo_truncate64(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        be_lo_truncate64(arg_fcinfo)
    })
}
pub unsafe fn json_agg_transfn(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_agg_transfn(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_agg_transfn(arg_fcinfo)
    })
}
pub unsafe fn json_agg_finalfn(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_agg_finalfn(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_agg_finalfn(arg_fcinfo)
    })
}
pub unsafe fn to_json(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn to_json(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        to_json(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_mod_since_analyze(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_mod_since_analyze(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_mod_since_analyze(arg_fcinfo)
    })
}
pub unsafe fn numeric_sum(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_sum(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_sum(arg_fcinfo)
    })
}
pub unsafe fn array_cardinality(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_cardinality(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_cardinality(arg_fcinfo)
    })
}
pub unsafe fn json_object_agg_transfn(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_object_agg_transfn(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_object_agg_transfn(arg_fcinfo)
    })
}
pub unsafe fn record_image_eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn record_image_eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        record_image_eq(arg_fcinfo)
    })
}
pub unsafe fn record_image_ne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn record_image_ne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        record_image_ne(arg_fcinfo)
    })
}
pub unsafe fn record_image_lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn record_image_lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        record_image_lt(arg_fcinfo)
    })
}
pub unsafe fn record_image_gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn record_image_gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        record_image_gt(arg_fcinfo)
    })
}
pub unsafe fn record_image_le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn record_image_le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        record_image_le(arg_fcinfo)
    })
}
pub unsafe fn record_image_ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn record_image_ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        record_image_ge(arg_fcinfo)
    })
}
pub unsafe fn btrecordimagecmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btrecordimagecmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btrecordimagecmp(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_archiver(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_archiver(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_archiver(arg_fcinfo)
    })
}
pub unsafe fn json_object_agg_finalfn(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_object_agg_finalfn(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_object_agg_finalfn(arg_fcinfo)
    })
}
pub unsafe fn json_build_array(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_build_array(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_build_array(arg_fcinfo)
    })
}
pub unsafe fn json_build_array_noargs(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_build_array_noargs(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_build_array_noargs(arg_fcinfo)
    })
}
pub unsafe fn json_build_object(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_build_object(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_build_object(arg_fcinfo)
    })
}
pub unsafe fn json_build_object_noargs(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_build_object_noargs(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_build_object_noargs(arg_fcinfo)
    })
}
pub unsafe fn json_object(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_object(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_object(arg_fcinfo)
    })
}
pub unsafe fn json_object_two_arg(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_object_two_arg(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_object_two_arg(arg_fcinfo)
    })
}
pub unsafe fn json_to_record(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_to_record(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_to_record(arg_fcinfo)
    })
}
pub unsafe fn json_to_recordset(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_to_recordset(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_to_recordset(arg_fcinfo)
    })
}
pub unsafe fn jsonb_array_length(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_array_length(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_array_length(arg_fcinfo)
    })
}
pub unsafe fn jsonb_each(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_each(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_each(arg_fcinfo)
    })
}
pub unsafe fn jsonb_populate_record(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_populate_record(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_populate_record(arg_fcinfo)
    })
}
pub unsafe fn jsonb_typeof(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_typeof(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_typeof(arg_fcinfo)
    })
}
pub unsafe fn jsonb_object_field_text(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_object_field_text(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_object_field_text(arg_fcinfo)
    })
}
pub unsafe fn jsonb_array_element(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_array_element(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_array_element(arg_fcinfo)
    })
}
pub unsafe fn jsonb_array_element_text(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_array_element_text(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_array_element_text(arg_fcinfo)
    })
}
pub unsafe fn jsonb_extract_path(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_extract_path(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_extract_path(arg_fcinfo)
    })
}
pub unsafe fn width_bucket_array(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn width_bucket_array(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        width_bucket_array(arg_fcinfo)
    })
}
pub unsafe fn jsonb_array_elements(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_array_elements(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_array_elements(arg_fcinfo)
    })
}
pub unsafe fn pg_lsn_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_lsn_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_lsn_in(arg_fcinfo)
    })
}
pub unsafe fn pg_lsn_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_lsn_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_lsn_out(arg_fcinfo)
    })
}
pub unsafe fn pg_lsn_lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_lsn_lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_lsn_lt(arg_fcinfo)
    })
}
pub unsafe fn pg_lsn_le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_lsn_le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_lsn_le(arg_fcinfo)
    })
}
pub unsafe fn pg_lsn_eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_lsn_eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_lsn_eq(arg_fcinfo)
    })
}
pub unsafe fn pg_lsn_ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_lsn_ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_lsn_ge(arg_fcinfo)
    })
}
pub unsafe fn pg_lsn_gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_lsn_gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_lsn_gt(arg_fcinfo)
    })
}
pub unsafe fn pg_lsn_ne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_lsn_ne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_lsn_ne(arg_fcinfo)
    })
}
pub unsafe fn pg_lsn_mi(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_lsn_mi(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_lsn_mi(arg_fcinfo)
    })
}
pub unsafe fn pg_lsn_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_lsn_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_lsn_recv(arg_fcinfo)
    })
}
pub unsafe fn pg_lsn_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_lsn_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_lsn_send(arg_fcinfo)
    })
}
pub unsafe fn pg_lsn_cmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_lsn_cmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_lsn_cmp(arg_fcinfo)
    })
}
pub unsafe fn pg_lsn_hash(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_lsn_hash(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_lsn_hash(arg_fcinfo)
    })
}
pub unsafe fn bttextsortsupport(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bttextsortsupport(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bttextsortsupport(arg_fcinfo)
    })
}
pub unsafe fn generate_series_step_numeric(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn generate_series_step_numeric(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        generate_series_step_numeric(arg_fcinfo)
    })
}
pub unsafe fn generate_series_numeric(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn generate_series_numeric(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        generate_series_numeric(arg_fcinfo)
    })
}
pub unsafe fn json_strip_nulls(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_strip_nulls(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_strip_nulls(arg_fcinfo)
    })
}
pub unsafe fn jsonb_strip_nulls(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_strip_nulls(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_strip_nulls(arg_fcinfo)
    })
}
pub unsafe fn jsonb_object(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_object(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_object(arg_fcinfo)
    })
}
pub unsafe fn jsonb_object_two_arg(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_object_two_arg(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_object_two_arg(arg_fcinfo)
    })
}
pub unsafe fn jsonb_agg_transfn(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_agg_transfn(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_agg_transfn(arg_fcinfo)
    })
}
pub unsafe fn jsonb_agg_finalfn(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_agg_finalfn(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_agg_finalfn(arg_fcinfo)
    })
}
pub unsafe fn jsonb_object_agg_transfn(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_object_agg_transfn(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_object_agg_transfn(arg_fcinfo)
    })
}
pub unsafe fn jsonb_object_agg_finalfn(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_object_agg_finalfn(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_object_agg_finalfn(arg_fcinfo)
    })
}
pub unsafe fn jsonb_build_array(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_build_array(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_build_array(arg_fcinfo)
    })
}
pub unsafe fn jsonb_build_array_noargs(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_build_array_noargs(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_build_array_noargs(arg_fcinfo)
    })
}
pub unsafe fn jsonb_build_object(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_build_object(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_build_object(arg_fcinfo)
    })
}
pub unsafe fn jsonb_build_object_noargs(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_build_object_noargs(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_build_object_noargs(arg_fcinfo)
    })
}
pub unsafe fn dist_ppoly(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dist_ppoly(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dist_ppoly(arg_fcinfo)
    })
}
pub unsafe fn array_position(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_position(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_position(arg_fcinfo)
    })
}
pub unsafe fn array_position_start(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_position_start(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_position_start(arg_fcinfo)
    })
}
pub unsafe fn array_positions(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_positions(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_positions(arg_fcinfo)
    })
}
pub unsafe fn gist_circle_distance(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gist_circle_distance(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gist_circle_distance(arg_fcinfo)
    })
}
pub unsafe fn numeric_scale(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_scale(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_scale(arg_fcinfo)
    })
}
pub unsafe fn gist_point_fetch(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gist_point_fetch(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gist_point_fetch(arg_fcinfo)
    })
}
pub unsafe fn numeric_sortsupport(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_sortsupport(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_sortsupport(arg_fcinfo)
    })
}
pub unsafe fn gist_poly_distance(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gist_poly_distance(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gist_poly_distance(arg_fcinfo)
    })
}
pub unsafe fn dist_cpoint(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dist_cpoint(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dist_cpoint(arg_fcinfo)
    })
}
pub unsafe fn dist_polyp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dist_polyp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dist_polyp(arg_fcinfo)
    })
}
pub unsafe fn pg_read_file_v2(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_read_file_v2(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_read_file_v2(arg_fcinfo)
    })
}
pub unsafe fn show_config_by_name_missing_ok(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn show_config_by_name_missing_ok(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        show_config_by_name_missing_ok(arg_fcinfo)
    })
}
pub unsafe fn pg_read_binary_file(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_read_binary_file(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_read_binary_file(arg_fcinfo)
    })
}
pub unsafe fn pg_notification_queue_usage(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_notification_queue_usage(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_notification_queue_usage(arg_fcinfo)
    })
}
pub unsafe fn pg_ls_dir(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_ls_dir(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_ls_dir(arg_fcinfo)
    })
}
pub unsafe fn row_security_active(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn row_security_active(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        row_security_active(arg_fcinfo)
    })
}
pub unsafe fn row_security_active_name(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn row_security_active_name(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        row_security_active_name(arg_fcinfo)
    })
}
pub unsafe fn uuid_sortsupport(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn uuid_sortsupport(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        uuid_sortsupport(arg_fcinfo)
    })
}
pub unsafe fn jsonb_concat(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_concat(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_concat(arg_fcinfo)
    })
}
pub unsafe fn jsonb_delete(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_delete(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_delete(arg_fcinfo)
    })
}
pub unsafe fn jsonb_delete_idx(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_delete_idx(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_delete_idx(arg_fcinfo)
    })
}
pub unsafe fn jsonb_delete_path(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_delete_path(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_delete_path(arg_fcinfo)
    })
}
pub unsafe fn jsonb_set(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_set(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_set(arg_fcinfo)
    })
}
pub unsafe fn jsonb_pretty(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_pretty(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_pretty(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_file(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_file(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_file(arg_fcinfo)
    })
}
pub unsafe fn xidneq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xidneq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        xidneq(arg_fcinfo)
    })
}
pub unsafe fn tsm_handler_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsm_handler_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsm_handler_in(arg_fcinfo)
    })
}
pub unsafe fn tsm_handler_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsm_handler_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsm_handler_out(arg_fcinfo)
    })
}
pub unsafe fn tsm_bernoulli_handler(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsm_bernoulli_handler(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsm_bernoulli_handler(arg_fcinfo)
    })
}
pub unsafe fn tsm_system_handler(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsm_system_handler(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsm_system_handler(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_wal_receiver(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_wal_receiver(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_wal_receiver(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_progress_info(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_progress_info(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_progress_info(arg_fcinfo)
    })
}
pub unsafe fn tsvector_filter(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsvector_filter(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsvector_filter(arg_fcinfo)
    })
}
pub unsafe fn tsvector_setweight_by_filter(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsvector_setweight_by_filter(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsvector_setweight_by_filter(arg_fcinfo)
    })
}
pub unsafe fn tsvector_delete_str(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsvector_delete_str(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsvector_delete_str(arg_fcinfo)
    })
}
pub unsafe fn tsvector_unnest(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsvector_unnest(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsvector_unnest(arg_fcinfo)
    })
}
pub unsafe fn tsvector_delete_arr(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsvector_delete_arr(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsvector_delete_arr(arg_fcinfo)
    })
}
pub unsafe fn int4_avg_combine(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4_avg_combine(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4_avg_combine(arg_fcinfo)
    })
}
pub unsafe fn interval_combine(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval_combine(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        interval_combine(arg_fcinfo)
    })
}
pub unsafe fn tsvector_to_array(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsvector_to_array(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsvector_to_array(arg_fcinfo)
    })
}
pub unsafe fn array_to_tsvector(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_to_tsvector(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_to_tsvector(arg_fcinfo)
    })
}
pub unsafe fn bpchar_sortsupport(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bpchar_sortsupport(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bpchar_sortsupport(arg_fcinfo)
    })
}
pub unsafe fn show_all_file_settings(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn show_all_file_settings(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        show_all_file_settings(arg_fcinfo)
    })
}
pub unsafe fn pg_current_wal_flush_lsn(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_current_wal_flush_lsn(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_current_wal_flush_lsn(arg_fcinfo)
    })
}
pub unsafe fn bytea_sortsupport(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bytea_sortsupport(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bytea_sortsupport(arg_fcinfo)
    })
}
pub unsafe fn bttext_pattern_sortsupport(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bttext_pattern_sortsupport(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bttext_pattern_sortsupport(arg_fcinfo)
    })
}
pub unsafe fn btbpchar_pattern_sortsupport(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btbpchar_pattern_sortsupport(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btbpchar_pattern_sortsupport(arg_fcinfo)
    })
}
pub unsafe fn pg_size_bytes(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_size_bytes(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_size_bytes(arg_fcinfo)
    })
}
pub unsafe fn numeric_serialize(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_serialize(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_serialize(arg_fcinfo)
    })
}
pub unsafe fn numeric_deserialize(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_deserialize(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_deserialize(arg_fcinfo)
    })
}
pub unsafe fn numeric_avg_combine(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_avg_combine(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_avg_combine(arg_fcinfo)
    })
}
pub unsafe fn numeric_poly_combine(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_poly_combine(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_poly_combine(arg_fcinfo)
    })
}
pub unsafe fn numeric_poly_serialize(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_poly_serialize(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_poly_serialize(arg_fcinfo)
    })
}
pub unsafe fn numeric_poly_deserialize(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_poly_deserialize(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_poly_deserialize(arg_fcinfo)
    })
}
pub unsafe fn numeric_combine(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_combine(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_combine(arg_fcinfo)
    })
}
pub unsafe fn jsonb_delete_array(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_delete_array(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_delete_array(arg_fcinfo)
    })
}
pub unsafe fn cash_mul_int8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cash_mul_int8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cash_mul_int8(arg_fcinfo)
    })
}
pub unsafe fn cash_div_int8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cash_div_int8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cash_div_int8(arg_fcinfo)
    })
}
pub unsafe fn pg_current_xact_id_if_assigned(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_current_xact_id_if_assigned(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_current_xact_id_if_assigned(arg_fcinfo)
    })
}
pub unsafe fn pg_get_partkeydef(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_partkeydef(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_get_partkeydef(arg_fcinfo)
    })
}
pub unsafe fn pg_ls_logdir(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_ls_logdir(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_ls_logdir(arg_fcinfo)
    })
}
pub unsafe fn pg_ls_waldir(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_ls_waldir(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_ls_waldir(arg_fcinfo)
    })
}
pub unsafe fn pg_ndistinct_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_ndistinct_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_ndistinct_in(arg_fcinfo)
    })
}
pub unsafe fn pg_ndistinct_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_ndistinct_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_ndistinct_out(arg_fcinfo)
    })
}
pub unsafe fn pg_ndistinct_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_ndistinct_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_ndistinct_recv(arg_fcinfo)
    })
}
pub unsafe fn pg_ndistinct_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_ndistinct_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_ndistinct_send(arg_fcinfo)
    })
}
pub unsafe fn macaddr_sortsupport(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn macaddr_sortsupport(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        macaddr_sortsupport(arg_fcinfo)
    })
}
pub unsafe fn pg_xact_status(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_xact_status(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_xact_status(arg_fcinfo)
    })
}
pub unsafe fn pg_safe_snapshot_blocking_pids(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_safe_snapshot_blocking_pids(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_safe_snapshot_blocking_pids(arg_fcinfo)
    })
}
pub unsafe fn pg_isolation_test_session_is_blocked(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_isolation_test_session_is_blocked(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_isolation_test_session_is_blocked(arg_fcinfo)
    })
}
pub unsafe fn pg_identify_object_as_address(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_identify_object_as_address(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_identify_object_as_address(arg_fcinfo)
    })
}
pub unsafe fn brin_minmax_opcinfo(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn brin_minmax_opcinfo(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        brin_minmax_opcinfo(arg_fcinfo)
    })
}
pub unsafe fn brin_minmax_add_value(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn brin_minmax_add_value(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        brin_minmax_add_value(arg_fcinfo)
    })
}
pub unsafe fn brin_minmax_consistent(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn brin_minmax_consistent(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        brin_minmax_consistent(arg_fcinfo)
    })
}
pub unsafe fn brin_minmax_union(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn brin_minmax_union(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        brin_minmax_union(arg_fcinfo)
    })
}
pub unsafe fn int8_avg_accum_inv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8_avg_accum_inv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8_avg_accum_inv(arg_fcinfo)
    })
}
pub unsafe fn numeric_poly_sum(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_poly_sum(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_poly_sum(arg_fcinfo)
    })
}
pub unsafe fn numeric_poly_avg(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_poly_avg(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_poly_avg(arg_fcinfo)
    })
}
pub unsafe fn numeric_poly_var_pop(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_poly_var_pop(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_poly_var_pop(arg_fcinfo)
    })
}
pub unsafe fn numeric_poly_var_samp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_poly_var_samp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_poly_var_samp(arg_fcinfo)
    })
}
pub unsafe fn numeric_poly_stddev_pop(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_poly_stddev_pop(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_poly_stddev_pop(arg_fcinfo)
    })
}
pub unsafe fn numeric_poly_stddev_samp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_poly_stddev_samp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_poly_stddev_samp(arg_fcinfo)
    })
}
pub unsafe fn regexp_match_no_flags(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regexp_match_no_flags(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regexp_match_no_flags(arg_fcinfo)
    })
}
pub unsafe fn regexp_match(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regexp_match(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regexp_match(arg_fcinfo)
    })
}
pub unsafe fn int8_mul_cash(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8_mul_cash(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8_mul_cash(arg_fcinfo)
    })
}
pub unsafe fn pg_config(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_config(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_config(arg_fcinfo)
    })
}
pub unsafe fn pg_hba_file_rules(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_hba_file_rules(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_hba_file_rules(arg_fcinfo)
    })
}
pub unsafe fn pg_statistics_obj_is_visible(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_statistics_obj_is_visible(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_statistics_obj_is_visible(arg_fcinfo)
    })
}
pub unsafe fn pg_dependencies_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_dependencies_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_dependencies_in(arg_fcinfo)
    })
}
pub unsafe fn pg_dependencies_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_dependencies_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_dependencies_out(arg_fcinfo)
    })
}
pub unsafe fn pg_dependencies_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_dependencies_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_dependencies_recv(arg_fcinfo)
    })
}
pub unsafe fn pg_dependencies_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_dependencies_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_dependencies_send(arg_fcinfo)
    })
}
pub unsafe fn pg_get_partition_constraintdef(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_partition_constraintdef(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_get_partition_constraintdef(arg_fcinfo)
    })
}
pub unsafe fn time_hash_extended(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn time_hash_extended(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        time_hash_extended(arg_fcinfo)
    })
}
pub unsafe fn timetz_hash_extended(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timetz_hash_extended(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timetz_hash_extended(arg_fcinfo)
    })
}
pub unsafe fn timestamp_hash_extended(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_hash_extended(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_hash_extended(arg_fcinfo)
    })
}
pub unsafe fn uuid_hash_extended(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn uuid_hash_extended(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        uuid_hash_extended(arg_fcinfo)
    })
}
pub unsafe fn pg_lsn_hash_extended(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_lsn_hash_extended(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_lsn_hash_extended(arg_fcinfo)
    })
}
pub unsafe fn hashenumextended(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashenumextended(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashenumextended(arg_fcinfo)
    })
}
pub unsafe fn pg_get_statisticsobjdef(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_statisticsobjdef(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_get_statisticsobjdef(arg_fcinfo)
    })
}
pub unsafe fn jsonb_hash_extended(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_hash_extended(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_hash_extended(arg_fcinfo)
    })
}
pub unsafe fn hash_range_extended(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hash_range_extended(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hash_range_extended(arg_fcinfo)
    })
}
pub unsafe fn interval_hash_extended(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval_hash_extended(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        interval_hash_extended(arg_fcinfo)
    })
}
pub unsafe fn sha224_bytea(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sha224_bytea(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        sha224_bytea(arg_fcinfo)
    })
}
pub unsafe fn sha256_bytea(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sha256_bytea(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        sha256_bytea(arg_fcinfo)
    })
}
pub unsafe fn sha384_bytea(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sha384_bytea(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        sha384_bytea(arg_fcinfo)
    })
}
pub unsafe fn sha512_bytea(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sha512_bytea(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        sha512_bytea(arg_fcinfo)
    })
}
pub unsafe fn pg_partition_tree(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_partition_tree(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_partition_tree(arg_fcinfo)
    })
}
pub unsafe fn pg_partition_root(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_partition_root(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_partition_root(arg_fcinfo)
    })
}
pub unsafe fn pg_partition_ancestors(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_partition_ancestors(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_partition_ancestors(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_db_checksum_failures(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_db_checksum_failures(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_db_checksum_failures(arg_fcinfo)
    })
}
pub unsafe fn pg_stats_ext_mcvlist_items(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stats_ext_mcvlist_items(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stats_ext_mcvlist_items(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_db_checksum_last_failure(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_db_checksum_last_failure(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_db_checksum_last_failure(arg_fcinfo)
    })
}
pub unsafe fn gen_random_uuid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gen_random_uuid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gen_random_uuid(arg_fcinfo)
    })
}
pub unsafe fn gtsvector_options(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gtsvector_options(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gtsvector_options(arg_fcinfo)
    })
}
pub unsafe fn pg_promote(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_promote(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_promote(arg_fcinfo)
    })
}
pub unsafe fn prefixsel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn prefixsel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        prefixsel(arg_fcinfo)
    })
}
pub unsafe fn prefixjoinsel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn prefixjoinsel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        prefixjoinsel(arg_fcinfo)
    })
}
pub unsafe fn pg_control_system(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_control_system(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_control_system(arg_fcinfo)
    })
}
pub unsafe fn pg_control_checkpoint(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_control_checkpoint(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_control_checkpoint(arg_fcinfo)
    })
}
pub unsafe fn pg_control_recovery(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_control_recovery(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_control_recovery(arg_fcinfo)
    })
}
pub unsafe fn pg_control_init(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_control_init(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_control_init(arg_fcinfo)
    })
}
pub unsafe fn pg_import_system_collations(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_import_system_collations(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_import_system_collations(arg_fcinfo)
    })
}
pub unsafe fn macaddr8_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn macaddr8_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        macaddr8_recv(arg_fcinfo)
    })
}
pub unsafe fn macaddr8_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn macaddr8_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        macaddr8_send(arg_fcinfo)
    })
}
pub unsafe fn pg_collation_actual_version(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_collation_actual_version(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_collation_actual_version(arg_fcinfo)
    })
}
pub unsafe fn jsonb_numeric(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_numeric(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_numeric(arg_fcinfo)
    })
}
pub unsafe fn jsonb_int2(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_int2(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_int2(arg_fcinfo)
    })
}
pub unsafe fn jsonb_int4(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_int4(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_int4(arg_fcinfo)
    })
}
pub unsafe fn jsonb_int8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_int8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_int8(arg_fcinfo)
    })
}
pub unsafe fn jsonb_float4(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_float4(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_float4(arg_fcinfo)
    })
}
pub unsafe fn pg_filenode_relation(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_filenode_relation(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_filenode_relation(arg_fcinfo)
    })
}
pub unsafe fn be_lo_from_bytea(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn be_lo_from_bytea(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        be_lo_from_bytea(arg_fcinfo)
    })
}
pub unsafe fn be_lo_get(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn be_lo_get(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        be_lo_get(arg_fcinfo)
    })
}
pub unsafe fn be_lo_get_fragment(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn be_lo_get_fragment(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        be_lo_get_fragment(arg_fcinfo)
    })
}
pub unsafe fn be_lo_put(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn be_lo_put(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        be_lo_put(arg_fcinfo)
    })
}
pub unsafe fn make_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        make_timestamp(arg_fcinfo)
    })
}
pub unsafe fn make_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_timestamptz(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        make_timestamptz(arg_fcinfo)
    })
}
pub unsafe fn make_timestamptz_at_timezone(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_timestamptz_at_timezone(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        make_timestamptz_at_timezone(arg_fcinfo)
    })
}
pub unsafe fn make_interval(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_interval(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        make_interval(arg_fcinfo)
    })
}
pub unsafe fn jsonb_array_elements_text(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_array_elements_text(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_array_elements_text(arg_fcinfo)
    })
}
pub unsafe fn spg_range_quad_config(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn spg_range_quad_config(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        spg_range_quad_config(arg_fcinfo)
    })
}
pub unsafe fn spg_range_quad_choose(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn spg_range_quad_choose(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        spg_range_quad_choose(arg_fcinfo)
    })
}
pub unsafe fn spg_range_quad_picksplit(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn spg_range_quad_picksplit(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        spg_range_quad_picksplit(arg_fcinfo)
    })
}
pub unsafe fn spg_range_quad_inner_consistent(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn spg_range_quad_inner_consistent(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        spg_range_quad_inner_consistent(arg_fcinfo)
    })
}
pub unsafe fn spg_range_quad_leaf_consistent(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn spg_range_quad_leaf_consistent(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        spg_range_quad_leaf_consistent(arg_fcinfo)
    })
}
pub unsafe fn jsonb_populate_recordset(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_populate_recordset(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_populate_recordset(arg_fcinfo)
    })
}
pub unsafe fn to_regoperator(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn to_regoperator(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        to_regoperator(arg_fcinfo)
    })
}
pub unsafe fn jsonb_object_field(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_object_field(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_object_field(arg_fcinfo)
    })
}
pub unsafe fn to_regprocedure(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn to_regprocedure(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        to_regprocedure(arg_fcinfo)
    })
}
pub unsafe fn gin_compare_jsonb(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gin_compare_jsonb(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gin_compare_jsonb(arg_fcinfo)
    })
}
pub unsafe fn gin_extract_jsonb(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gin_extract_jsonb(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gin_extract_jsonb(arg_fcinfo)
    })
}
pub unsafe fn gin_extract_jsonb_query(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gin_extract_jsonb_query(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gin_extract_jsonb_query(arg_fcinfo)
    })
}
pub unsafe fn gin_consistent_jsonb(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gin_consistent_jsonb(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gin_consistent_jsonb(arg_fcinfo)
    })
}
pub unsafe fn gin_extract_jsonb_path(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gin_extract_jsonb_path(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gin_extract_jsonb_path(arg_fcinfo)
    })
}
pub unsafe fn gin_extract_jsonb_query_path(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gin_extract_jsonb_query_path(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gin_extract_jsonb_query_path(arg_fcinfo)
    })
}
pub unsafe fn gin_consistent_jsonb_path(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gin_consistent_jsonb_path(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gin_consistent_jsonb_path(arg_fcinfo)
    })
}
pub unsafe fn gin_triconsistent_jsonb(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gin_triconsistent_jsonb(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gin_triconsistent_jsonb(arg_fcinfo)
    })
}
pub unsafe fn gin_triconsistent_jsonb_path(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gin_triconsistent_jsonb_path(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gin_triconsistent_jsonb_path(arg_fcinfo)
    })
}
pub unsafe fn jsonb_to_record(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_to_record(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_to_record(arg_fcinfo)
    })
}
pub unsafe fn jsonb_to_recordset(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_to_recordset(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_to_recordset(arg_fcinfo)
    })
}
pub unsafe fn to_regoper(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn to_regoper(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        to_regoper(arg_fcinfo)
    })
}
pub unsafe fn to_regtype(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn to_regtype(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        to_regtype(arg_fcinfo)
    })
}
pub unsafe fn to_regproc(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn to_regproc(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        to_regproc(arg_fcinfo)
    })
}
pub unsafe fn to_regclass(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn to_regclass(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        to_regclass(arg_fcinfo)
    })
}
pub unsafe fn bool_accum(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bool_accum(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bool_accum(arg_fcinfo)
    })
}
pub unsafe fn bool_accum_inv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bool_accum_inv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bool_accum_inv(arg_fcinfo)
    })
}
pub unsafe fn bool_alltrue(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bool_alltrue(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bool_alltrue(arg_fcinfo)
    })
}
pub unsafe fn bool_anytrue(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bool_anytrue(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bool_anytrue(arg_fcinfo)
    })
}
pub unsafe fn anyenum_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn anyenum_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        anyenum_in(arg_fcinfo)
    })
}
pub unsafe fn anyenum_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn anyenum_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        anyenum_out(arg_fcinfo)
    })
}
pub unsafe fn enum_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn enum_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        enum_in(arg_fcinfo)
    })
}
pub unsafe fn enum_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn enum_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        enum_out(arg_fcinfo)
    })
}
pub unsafe fn enum_eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn enum_eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        enum_eq(arg_fcinfo)
    })
}
pub unsafe fn enum_ne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn enum_ne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        enum_ne(arg_fcinfo)
    })
}
pub unsafe fn enum_lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn enum_lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        enum_lt(arg_fcinfo)
    })
}
pub unsafe fn enum_gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn enum_gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        enum_gt(arg_fcinfo)
    })
}
pub unsafe fn enum_le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn enum_le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        enum_le(arg_fcinfo)
    })
}
pub unsafe fn enum_ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn enum_ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        enum_ge(arg_fcinfo)
    })
}
pub unsafe fn enum_cmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn enum_cmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        enum_cmp(arg_fcinfo)
    })
}
pub unsafe fn hashenum(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hashenum(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hashenum(arg_fcinfo)
    })
}
pub unsafe fn enum_smaller(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn enum_smaller(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        enum_smaller(arg_fcinfo)
    })
}
pub unsafe fn enum_larger(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn enum_larger(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        enum_larger(arg_fcinfo)
    })
}
pub unsafe fn enum_first(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn enum_first(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        enum_first(arg_fcinfo)
    })
}
pub unsafe fn enum_last(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn enum_last(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        enum_last(arg_fcinfo)
    })
}
pub unsafe fn enum_range_bounds(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn enum_range_bounds(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        enum_range_bounds(arg_fcinfo)
    })
}
pub unsafe fn enum_range_all(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn enum_range_all(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        enum_range_all(arg_fcinfo)
    })
}
pub unsafe fn enum_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn enum_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        enum_recv(arg_fcinfo)
    })
}
pub unsafe fn enum_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn enum_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        enum_send(arg_fcinfo)
    })
}
pub unsafe fn string_agg_transfn(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn string_agg_transfn(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        string_agg_transfn(arg_fcinfo)
    })
}
pub unsafe fn string_agg_finalfn(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn string_agg_finalfn(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        string_agg_finalfn(arg_fcinfo)
    })
}
pub unsafe fn pg_describe_object(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_describe_object(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_describe_object(arg_fcinfo)
    })
}
pub unsafe fn text_format(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn text_format(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        text_format(arg_fcinfo)
    })
}
pub unsafe fn text_format_nv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn text_format_nv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        text_format_nv(arg_fcinfo)
    })
}
pub unsafe fn bytea_string_agg_transfn(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bytea_string_agg_transfn(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bytea_string_agg_transfn(arg_fcinfo)
    })
}
pub unsafe fn bytea_string_agg_finalfn(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bytea_string_agg_finalfn(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        bytea_string_agg_finalfn(arg_fcinfo)
    })
}
pub unsafe fn int8dec(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8dec(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8dec(arg_fcinfo)
    })
}
pub unsafe fn int8dec_any(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8dec_any(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8dec_any(arg_fcinfo)
    })
}
pub unsafe fn numeric_accum_inv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_accum_inv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_accum_inv(arg_fcinfo)
    })
}
pub unsafe fn interval_accum_inv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval_accum_inv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        interval_accum_inv(arg_fcinfo)
    })
}
pub unsafe fn network_overlap(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn network_overlap(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        network_overlap(arg_fcinfo)
    })
}
pub unsafe fn inet_gist_consistent(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet_gist_consistent(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        inet_gist_consistent(arg_fcinfo)
    })
}
pub unsafe fn inet_gist_union(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet_gist_union(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        inet_gist_union(arg_fcinfo)
    })
}
pub unsafe fn inet_gist_compress(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet_gist_compress(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        inet_gist_compress(arg_fcinfo)
    })
}
pub unsafe fn jsonb_bool(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_bool(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_bool(arg_fcinfo)
    })
}
pub unsafe fn inet_gist_penalty(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet_gist_penalty(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        inet_gist_penalty(arg_fcinfo)
    })
}
pub unsafe fn inet_gist_picksplit(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet_gist_picksplit(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        inet_gist_picksplit(arg_fcinfo)
    })
}
pub unsafe fn inet_gist_same(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet_gist_same(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        inet_gist_same(arg_fcinfo)
    })
}
pub unsafe fn networksel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn networksel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        networksel(arg_fcinfo)
    })
}
pub unsafe fn networkjoinsel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn networkjoinsel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        networkjoinsel(arg_fcinfo)
    })
}
pub unsafe fn network_larger(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn network_larger(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        network_larger(arg_fcinfo)
    })
}
pub unsafe fn network_smaller(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn network_smaller(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        network_smaller(arg_fcinfo)
    })
}
pub unsafe fn pg_event_trigger_dropped_objects(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_event_trigger_dropped_objects(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_event_trigger_dropped_objects(arg_fcinfo)
    })
}
pub unsafe fn int2_accum_inv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2_accum_inv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2_accum_inv(arg_fcinfo)
    })
}
pub unsafe fn int4_accum_inv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4_accum_inv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4_accum_inv(arg_fcinfo)
    })
}
pub unsafe fn int8_accum_inv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8_accum_inv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8_accum_inv(arg_fcinfo)
    })
}
pub unsafe fn int2_avg_accum_inv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2_avg_accum_inv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2_avg_accum_inv(arg_fcinfo)
    })
}
pub unsafe fn int4_avg_accum_inv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4_avg_accum_inv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4_avg_accum_inv(arg_fcinfo)
    })
}
pub unsafe fn int2int4_sum(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int2int4_sum(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int2int4_sum(arg_fcinfo)
    })
}
pub unsafe fn inet_gist_fetch(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet_gist_fetch(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        inet_gist_fetch(arg_fcinfo)
    })
}
pub unsafe fn pg_logical_emit_message_text(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_logical_emit_message_text(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_logical_emit_message_text(arg_fcinfo)
    })
}
pub unsafe fn pg_logical_emit_message_bytea(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_logical_emit_message_bytea(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_logical_emit_message_bytea(arg_fcinfo)
    })
}
pub unsafe fn jsonb_insert(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_insert(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_insert(arg_fcinfo)
    })
}
pub unsafe fn pg_xact_commit_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_xact_commit_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_xact_commit_timestamp(arg_fcinfo)
    })
}
pub unsafe fn binary_upgrade_set_next_pg_type_oid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn binary_upgrade_set_next_pg_type_oid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        binary_upgrade_set_next_pg_type_oid(arg_fcinfo)
    })
}
pub unsafe fn pg_last_committed_xact(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_last_committed_xact(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_last_committed_xact(arg_fcinfo)
    })
}
pub unsafe fn binary_upgrade_set_next_array_pg_type_oid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn binary_upgrade_set_next_array_pg_type_oid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        binary_upgrade_set_next_array_pg_type_oid(arg_fcinfo)
    })
}
pub unsafe fn binary_upgrade_set_next_toast_pg_type_oid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn binary_upgrade_set_next_toast_pg_type_oid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        binary_upgrade_set_next_toast_pg_type_oid(arg_fcinfo)
    })
}
pub unsafe fn binary_upgrade_set_next_heap_pg_class_oid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn binary_upgrade_set_next_heap_pg_class_oid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        binary_upgrade_set_next_heap_pg_class_oid(arg_fcinfo)
    })
}
pub unsafe fn binary_upgrade_set_next_index_pg_class_oid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn binary_upgrade_set_next_index_pg_class_oid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        binary_upgrade_set_next_index_pg_class_oid(arg_fcinfo)
    })
}
pub unsafe fn binary_upgrade_set_next_toast_pg_class_oid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn binary_upgrade_set_next_toast_pg_class_oid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        binary_upgrade_set_next_toast_pg_class_oid(arg_fcinfo)
    })
}
pub unsafe fn binary_upgrade_set_next_pg_enum_oid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn binary_upgrade_set_next_pg_enum_oid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        binary_upgrade_set_next_pg_enum_oid(arg_fcinfo)
    })
}
pub unsafe fn binary_upgrade_set_next_pg_authid_oid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn binary_upgrade_set_next_pg_authid_oid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        binary_upgrade_set_next_pg_authid_oid(arg_fcinfo)
    })
}
pub unsafe fn binary_upgrade_create_empty_extension(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn binary_upgrade_create_empty_extension(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        binary_upgrade_create_empty_extension(arg_fcinfo)
    })
}
pub unsafe fn event_trigger_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn event_trigger_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        event_trigger_in(arg_fcinfo)
    })
}
pub unsafe fn event_trigger_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn event_trigger_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        event_trigger_out(arg_fcinfo)
    })
}
pub unsafe fn tsvectorin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsvectorin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsvectorin(arg_fcinfo)
    })
}
pub unsafe fn tsvectorout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsvectorout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsvectorout(arg_fcinfo)
    })
}
pub unsafe fn tsqueryin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsqueryin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsqueryin(arg_fcinfo)
    })
}
pub unsafe fn tsqueryout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsqueryout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsqueryout(arg_fcinfo)
    })
}
pub unsafe fn tsvector_lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsvector_lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsvector_lt(arg_fcinfo)
    })
}
pub unsafe fn tsvector_le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsvector_le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsvector_le(arg_fcinfo)
    })
}
pub unsafe fn tsvector_eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsvector_eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsvector_eq(arg_fcinfo)
    })
}
pub unsafe fn tsvector_ne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsvector_ne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsvector_ne(arg_fcinfo)
    })
}
pub unsafe fn tsvector_ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsvector_ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsvector_ge(arg_fcinfo)
    })
}
pub unsafe fn tsvector_gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsvector_gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsvector_gt(arg_fcinfo)
    })
}
pub unsafe fn tsvector_cmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsvector_cmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsvector_cmp(arg_fcinfo)
    })
}
pub unsafe fn tsvector_strip(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsvector_strip(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsvector_strip(arg_fcinfo)
    })
}
pub unsafe fn tsvector_setweight(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsvector_setweight(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsvector_setweight(arg_fcinfo)
    })
}
pub unsafe fn tsvector_concat(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsvector_concat(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsvector_concat(arg_fcinfo)
    })
}
pub unsafe fn ts_match_vq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ts_match_vq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ts_match_vq(arg_fcinfo)
    })
}
pub unsafe fn ts_match_qv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ts_match_qv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ts_match_qv(arg_fcinfo)
    })
}
pub unsafe fn tsvectorsend(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsvectorsend(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsvectorsend(arg_fcinfo)
    })
}
pub unsafe fn tsvectorrecv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsvectorrecv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsvectorrecv(arg_fcinfo)
    })
}
pub unsafe fn tsquerysend(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsquerysend(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsquerysend(arg_fcinfo)
    })
}
pub unsafe fn tsqueryrecv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsqueryrecv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsqueryrecv(arg_fcinfo)
    })
}
pub unsafe fn gtsvectorin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gtsvectorin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gtsvectorin(arg_fcinfo)
    })
}
pub unsafe fn gtsvectorout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gtsvectorout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gtsvectorout(arg_fcinfo)
    })
}
pub unsafe fn gtsvector_compress(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gtsvector_compress(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gtsvector_compress(arg_fcinfo)
    })
}
pub unsafe fn gtsvector_decompress(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gtsvector_decompress(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gtsvector_decompress(arg_fcinfo)
    })
}
pub unsafe fn gtsvector_picksplit(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gtsvector_picksplit(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gtsvector_picksplit(arg_fcinfo)
    })
}
pub unsafe fn gtsvector_union(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gtsvector_union(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gtsvector_union(arg_fcinfo)
    })
}
pub unsafe fn gtsvector_same(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gtsvector_same(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gtsvector_same(arg_fcinfo)
    })
}
pub unsafe fn gtsvector_penalty(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gtsvector_penalty(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gtsvector_penalty(arg_fcinfo)
    })
}
pub unsafe fn gtsvector_consistent(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gtsvector_consistent(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gtsvector_consistent(arg_fcinfo)
    })
}
pub unsafe fn gin_extract_tsvector(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gin_extract_tsvector(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gin_extract_tsvector(arg_fcinfo)
    })
}
pub unsafe fn gin_extract_tsquery(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gin_extract_tsquery(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gin_extract_tsquery(arg_fcinfo)
    })
}
pub unsafe fn gin_tsquery_consistent(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gin_tsquery_consistent(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gin_tsquery_consistent(arg_fcinfo)
    })
}
pub unsafe fn tsquery_lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsquery_lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsquery_lt(arg_fcinfo)
    })
}
pub unsafe fn tsquery_le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsquery_le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsquery_le(arg_fcinfo)
    })
}
pub unsafe fn tsquery_eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsquery_eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsquery_eq(arg_fcinfo)
    })
}
pub unsafe fn tsquery_ne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsquery_ne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsquery_ne(arg_fcinfo)
    })
}
pub unsafe fn tsquery_ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsquery_ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsquery_ge(arg_fcinfo)
    })
}
pub unsafe fn tsquery_gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsquery_gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsquery_gt(arg_fcinfo)
    })
}
pub unsafe fn tsquery_cmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsquery_cmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsquery_cmp(arg_fcinfo)
    })
}
pub unsafe fn tsquery_and(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsquery_and(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsquery_and(arg_fcinfo)
    })
}
pub unsafe fn tsquery_or(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsquery_or(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsquery_or(arg_fcinfo)
    })
}
pub unsafe fn tsquery_not(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsquery_not(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsquery_not(arg_fcinfo)
    })
}
pub unsafe fn tsquery_numnode(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsquery_numnode(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsquery_numnode(arg_fcinfo)
    })
}
pub unsafe fn tsquerytree(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsquerytree(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsquerytree(arg_fcinfo)
    })
}
pub unsafe fn tsquery_rewrite(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsquery_rewrite(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsquery_rewrite(arg_fcinfo)
    })
}
pub unsafe fn tsquery_rewrite_query(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsquery_rewrite_query(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsquery_rewrite_query(arg_fcinfo)
    })
}
pub unsafe fn tsmatchsel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsmatchsel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsmatchsel(arg_fcinfo)
    })
}
pub unsafe fn tsmatchjoinsel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsmatchjoinsel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsmatchjoinsel(arg_fcinfo)
    })
}
pub unsafe fn ts_typanalyze(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ts_typanalyze(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ts_typanalyze(arg_fcinfo)
    })
}
pub unsafe fn ts_stat1(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ts_stat1(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ts_stat1(arg_fcinfo)
    })
}
pub unsafe fn ts_stat2(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ts_stat2(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ts_stat2(arg_fcinfo)
    })
}
pub unsafe fn tsq_mcontains(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsq_mcontains(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsq_mcontains(arg_fcinfo)
    })
}
pub unsafe fn tsq_mcontained(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsq_mcontained(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsq_mcontained(arg_fcinfo)
    })
}
pub unsafe fn gtsquery_compress(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gtsquery_compress(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gtsquery_compress(arg_fcinfo)
    })
}
pub unsafe fn text_starts_with(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn text_starts_with(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        text_starts_with(arg_fcinfo)
    })
}
pub unsafe fn gtsquery_picksplit(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gtsquery_picksplit(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gtsquery_picksplit(arg_fcinfo)
    })
}
pub unsafe fn gtsquery_union(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gtsquery_union(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gtsquery_union(arg_fcinfo)
    })
}
pub unsafe fn gtsquery_same(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gtsquery_same(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gtsquery_same(arg_fcinfo)
    })
}
pub unsafe fn gtsquery_penalty(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gtsquery_penalty(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gtsquery_penalty(arg_fcinfo)
    })
}
pub unsafe fn gtsquery_consistent(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gtsquery_consistent(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gtsquery_consistent(arg_fcinfo)
    })
}
pub unsafe fn ts_rank_wttf(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ts_rank_wttf(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ts_rank_wttf(arg_fcinfo)
    })
}
pub unsafe fn ts_rank_wtt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ts_rank_wtt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ts_rank_wtt(arg_fcinfo)
    })
}
pub unsafe fn ts_rank_ttf(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ts_rank_ttf(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ts_rank_ttf(arg_fcinfo)
    })
}
pub unsafe fn ts_rank_tt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ts_rank_tt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ts_rank_tt(arg_fcinfo)
    })
}
pub unsafe fn ts_rankcd_wttf(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ts_rankcd_wttf(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ts_rankcd_wttf(arg_fcinfo)
    })
}
pub unsafe fn ts_rankcd_wtt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ts_rankcd_wtt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ts_rankcd_wtt(arg_fcinfo)
    })
}
pub unsafe fn ts_rankcd_ttf(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ts_rankcd_ttf(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ts_rankcd_ttf(arg_fcinfo)
    })
}
pub unsafe fn ts_rankcd_tt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ts_rankcd_tt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ts_rankcd_tt(arg_fcinfo)
    })
}
pub unsafe fn tsvector_length(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsvector_length(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsvector_length(arg_fcinfo)
    })
}
pub unsafe fn ts_token_type_byid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ts_token_type_byid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ts_token_type_byid(arg_fcinfo)
    })
}
pub unsafe fn ts_token_type_byname(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ts_token_type_byname(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ts_token_type_byname(arg_fcinfo)
    })
}
pub unsafe fn ts_parse_byid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ts_parse_byid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ts_parse_byid(arg_fcinfo)
    })
}
pub unsafe fn ts_parse_byname(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ts_parse_byname(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ts_parse_byname(arg_fcinfo)
    })
}
pub unsafe fn prsd_start(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn prsd_start(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        prsd_start(arg_fcinfo)
    })
}
pub unsafe fn prsd_nexttoken(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn prsd_nexttoken(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        prsd_nexttoken(arg_fcinfo)
    })
}
pub unsafe fn prsd_end(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn prsd_end(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        prsd_end(arg_fcinfo)
    })
}
pub unsafe fn prsd_headline(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn prsd_headline(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        prsd_headline(arg_fcinfo)
    })
}
pub unsafe fn prsd_lextype(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn prsd_lextype(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        prsd_lextype(arg_fcinfo)
    })
}
pub unsafe fn ts_lexize(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ts_lexize(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ts_lexize(arg_fcinfo)
    })
}
pub unsafe fn gin_cmp_tslexeme(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gin_cmp_tslexeme(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gin_cmp_tslexeme(arg_fcinfo)
    })
}
pub unsafe fn dsimple_init(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsimple_init(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dsimple_init(arg_fcinfo)
    })
}
pub unsafe fn dsimple_lexize(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsimple_lexize(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dsimple_lexize(arg_fcinfo)
    })
}
pub unsafe fn dsynonym_init(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsynonym_init(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dsynonym_init(arg_fcinfo)
    })
}
pub unsafe fn dsynonym_lexize(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dsynonym_lexize(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dsynonym_lexize(arg_fcinfo)
    })
}
pub unsafe fn dispell_init(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dispell_init(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dispell_init(arg_fcinfo)
    })
}
pub unsafe fn dispell_lexize(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn dispell_lexize(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        dispell_lexize(arg_fcinfo)
    })
}
pub unsafe fn regconfigin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regconfigin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regconfigin(arg_fcinfo)
    })
}
pub unsafe fn regconfigout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regconfigout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regconfigout(arg_fcinfo)
    })
}
pub unsafe fn regconfigrecv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regconfigrecv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regconfigrecv(arg_fcinfo)
    })
}
pub unsafe fn regconfigsend(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regconfigsend(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regconfigsend(arg_fcinfo)
    })
}
pub unsafe fn thesaurus_init(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn thesaurus_init(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        thesaurus_init(arg_fcinfo)
    })
}
pub unsafe fn thesaurus_lexize(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn thesaurus_lexize(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        thesaurus_lexize(arg_fcinfo)
    })
}
pub unsafe fn ts_headline_byid_opt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ts_headline_byid_opt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ts_headline_byid_opt(arg_fcinfo)
    })
}
pub unsafe fn ts_headline_byid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ts_headline_byid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ts_headline_byid(arg_fcinfo)
    })
}
pub unsafe fn to_tsvector_byid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn to_tsvector_byid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        to_tsvector_byid(arg_fcinfo)
    })
}
pub unsafe fn to_tsquery_byid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn to_tsquery_byid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        to_tsquery_byid(arg_fcinfo)
    })
}
pub unsafe fn plainto_tsquery_byid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn plainto_tsquery_byid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        plainto_tsquery_byid(arg_fcinfo)
    })
}
pub unsafe fn to_tsvector(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn to_tsvector(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        to_tsvector(arg_fcinfo)
    })
}
pub unsafe fn to_tsquery(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn to_tsquery(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        to_tsquery(arg_fcinfo)
    })
}
pub unsafe fn plainto_tsquery(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn plainto_tsquery(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        plainto_tsquery(arg_fcinfo)
    })
}
pub unsafe fn tsvector_update_trigger_byid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsvector_update_trigger_byid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsvector_update_trigger_byid(arg_fcinfo)
    })
}
pub unsafe fn tsvector_update_trigger_bycolumn(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsvector_update_trigger_bycolumn(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsvector_update_trigger_bycolumn(arg_fcinfo)
    })
}
pub unsafe fn ts_headline_opt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ts_headline_opt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ts_headline_opt(arg_fcinfo)
    })
}
pub unsafe fn ts_headline(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ts_headline(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ts_headline(arg_fcinfo)
    })
}
pub unsafe fn pg_ts_parser_is_visible(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_ts_parser_is_visible(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_ts_parser_is_visible(arg_fcinfo)
    })
}
pub unsafe fn pg_ts_dict_is_visible(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_ts_dict_is_visible(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_ts_dict_is_visible(arg_fcinfo)
    })
}
pub unsafe fn pg_ts_config_is_visible(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_ts_config_is_visible(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_ts_config_is_visible(arg_fcinfo)
    })
}
pub unsafe fn get_current_ts_config(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_current_ts_config(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        get_current_ts_config(arg_fcinfo)
    })
}
pub unsafe fn ts_match_tt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ts_match_tt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ts_match_tt(arg_fcinfo)
    })
}
pub unsafe fn ts_match_tq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ts_match_tq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ts_match_tq(arg_fcinfo)
    })
}
pub unsafe fn pg_ts_template_is_visible(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_ts_template_is_visible(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_ts_template_is_visible(arg_fcinfo)
    })
}
pub unsafe fn regdictionaryin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regdictionaryin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regdictionaryin(arg_fcinfo)
    })
}
pub unsafe fn regdictionaryout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regdictionaryout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regdictionaryout(arg_fcinfo)
    })
}
pub unsafe fn regdictionaryrecv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regdictionaryrecv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regdictionaryrecv(arg_fcinfo)
    })
}
pub unsafe fn regdictionarysend(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regdictionarysend(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regdictionarysend(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_reset_shared(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_reset_shared(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_reset_shared(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_reset_single_table_counters(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_reset_single_table_counters(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_reset_single_table_counters(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_reset_single_function_counters(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_reset_single_function_counters(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_reset_single_function_counters(arg_fcinfo)
    })
}
pub unsafe fn pg_tablespace_location(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_tablespace_location(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_tablespace_location(arg_fcinfo)
    })
}
pub unsafe fn pg_create_physical_replication_slot(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_create_physical_replication_slot(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_create_physical_replication_slot(arg_fcinfo)
    })
}
pub unsafe fn pg_drop_replication_slot(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_drop_replication_slot(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_drop_replication_slot(arg_fcinfo)
    })
}
pub unsafe fn pg_get_replication_slots(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_replication_slots(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_get_replication_slots(arg_fcinfo)
    })
}
pub unsafe fn pg_logical_slot_get_changes(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_logical_slot_get_changes(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_logical_slot_get_changes(arg_fcinfo)
    })
}
pub unsafe fn pg_logical_slot_get_binary_changes(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_logical_slot_get_binary_changes(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_logical_slot_get_binary_changes(arg_fcinfo)
    })
}
pub unsafe fn pg_logical_slot_peek_changes(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_logical_slot_peek_changes(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_logical_slot_peek_changes(arg_fcinfo)
    })
}
pub unsafe fn pg_logical_slot_peek_binary_changes(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_logical_slot_peek_binary_changes(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_logical_slot_peek_binary_changes(arg_fcinfo)
    })
}
pub unsafe fn pg_create_logical_replication_slot(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_create_logical_replication_slot(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_create_logical_replication_slot(arg_fcinfo)
    })
}
pub unsafe fn to_jsonb(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn to_jsonb(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        to_jsonb(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_snapshot_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_snapshot_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_snapshot_timestamp(arg_fcinfo)
    })
}
pub unsafe fn gin_clean_pending_list(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gin_clean_pending_list(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gin_clean_pending_list(arg_fcinfo)
    })
}
pub unsafe fn gtsvector_consistent_oldsig(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gtsvector_consistent_oldsig(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gtsvector_consistent_oldsig(arg_fcinfo)
    })
}
pub unsafe fn gin_extract_tsquery_oldsig(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gin_extract_tsquery_oldsig(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gin_extract_tsquery_oldsig(arg_fcinfo)
    })
}
pub unsafe fn gin_tsquery_consistent_oldsig(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gin_tsquery_consistent_oldsig(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gin_tsquery_consistent_oldsig(arg_fcinfo)
    })
}
pub unsafe fn gtsquery_consistent_oldsig(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gtsquery_consistent_oldsig(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gtsquery_consistent_oldsig(arg_fcinfo)
    })
}
pub unsafe fn inet_spg_config(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet_spg_config(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        inet_spg_config(arg_fcinfo)
    })
}
pub unsafe fn inet_spg_choose(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet_spg_choose(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        inet_spg_choose(arg_fcinfo)
    })
}
pub unsafe fn inet_spg_picksplit(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet_spg_picksplit(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        inet_spg_picksplit(arg_fcinfo)
    })
}
pub unsafe fn inet_spg_inner_consistent(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet_spg_inner_consistent(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        inet_spg_inner_consistent(arg_fcinfo)
    })
}
pub unsafe fn inet_spg_leaf_consistent(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet_spg_leaf_consistent(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        inet_spg_leaf_consistent(arg_fcinfo)
    })
}
pub unsafe fn pg_current_logfile(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_current_logfile(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_current_logfile(arg_fcinfo)
    })
}
pub unsafe fn pg_current_logfile_1arg(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_current_logfile_1arg(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_current_logfile_1arg(arg_fcinfo)
    })
}
pub unsafe fn jsonb_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_send(arg_fcinfo)
    })
}
pub unsafe fn jsonb_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_out(arg_fcinfo)
    })
}
pub unsafe fn jsonb_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_recv(arg_fcinfo)
    })
}
pub unsafe fn jsonb_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_in(arg_fcinfo)
    })
}
pub unsafe fn pg_get_function_arg_default(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_function_arg_default(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_get_function_arg_default(arg_fcinfo)
    })
}
pub unsafe fn pg_export_snapshot(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_export_snapshot(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_export_snapshot(arg_fcinfo)
    })
}
pub unsafe fn pg_is_in_recovery(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_is_in_recovery(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_is_in_recovery(arg_fcinfo)
    })
}
pub unsafe fn int4_cash(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4_cash(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4_cash(arg_fcinfo)
    })
}
pub unsafe fn int8_cash(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8_cash(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8_cash(arg_fcinfo)
    })
}
pub unsafe fn pg_is_in_backup(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_is_in_backup(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_is_in_backup(arg_fcinfo)
    })
}
pub unsafe fn pg_backup_start_time(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_backup_start_time(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_backup_start_time(arg_fcinfo)
    })
}
pub unsafe fn pg_collation_is_visible(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_collation_is_visible(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_collation_is_visible(arg_fcinfo)
    })
}
pub unsafe fn array_typanalyze(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_typanalyze(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_typanalyze(arg_fcinfo)
    })
}
pub unsafe fn arraycontsel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn arraycontsel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        arraycontsel(arg_fcinfo)
    })
}
pub unsafe fn arraycontjoinsel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn arraycontjoinsel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        arraycontjoinsel(arg_fcinfo)
    })
}
pub unsafe fn pg_get_multixact_members(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_multixact_members(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_get_multixact_members(arg_fcinfo)
    })
}
pub unsafe fn pg_last_wal_receive_lsn(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_last_wal_receive_lsn(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_last_wal_receive_lsn(arg_fcinfo)
    })
}
pub unsafe fn pg_last_wal_replay_lsn(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_last_wal_replay_lsn(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_last_wal_replay_lsn(arg_fcinfo)
    })
}
pub unsafe fn cash_div_cash(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cash_div_cash(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cash_div_cash(arg_fcinfo)
    })
}
pub unsafe fn cash_numeric(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cash_numeric(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        cash_numeric(arg_fcinfo)
    })
}
pub unsafe fn numeric_cash(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_cash(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_cash(arg_fcinfo)
    })
}
pub unsafe fn pg_read_file_all(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_read_file_all(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_read_file_all(arg_fcinfo)
    })
}
pub unsafe fn pg_read_binary_file_off_len(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_read_binary_file_off_len(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_read_binary_file_off_len(arg_fcinfo)
    })
}
pub unsafe fn pg_read_binary_file_all(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_read_binary_file_all(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_read_binary_file_all(arg_fcinfo)
    })
}
pub unsafe fn pg_opfamily_is_visible(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_opfamily_is_visible(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_opfamily_is_visible(arg_fcinfo)
    })
}
pub unsafe fn pg_last_xact_replay_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_last_xact_replay_timestamp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_last_xact_replay_timestamp(arg_fcinfo)
    })
}
pub unsafe fn anyrange_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn anyrange_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        anyrange_in(arg_fcinfo)
    })
}
pub unsafe fn anyrange_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn anyrange_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        anyrange_out(arg_fcinfo)
    })
}
pub unsafe fn range_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_in(arg_fcinfo)
    })
}
pub unsafe fn range_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_out(arg_fcinfo)
    })
}
pub unsafe fn range_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_recv(arg_fcinfo)
    })
}
pub unsafe fn range_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_send(arg_fcinfo)
    })
}
pub unsafe fn pg_identify_object(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_identify_object(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_identify_object(arg_fcinfo)
    })
}
pub unsafe fn range_constructor2(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_constructor2(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_constructor2(arg_fcinfo)
    })
}
pub unsafe fn range_constructor3(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_constructor3(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_constructor3(arg_fcinfo)
    })
}
pub unsafe fn pg_relation_is_updatable(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_relation_is_updatable(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_relation_is_updatable(arg_fcinfo)
    })
}
pub unsafe fn pg_column_is_updatable(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_column_is_updatable(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_column_is_updatable(arg_fcinfo)
    })
}
pub unsafe fn make_date(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_date(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        make_date(arg_fcinfo)
    })
}
pub unsafe fn make_time(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_time(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        make_time(arg_fcinfo)
    })
}
pub unsafe fn range_lower(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_lower(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_lower(arg_fcinfo)
    })
}
pub unsafe fn range_upper(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_upper(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_upper(arg_fcinfo)
    })
}
pub unsafe fn range_empty(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_empty(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_empty(arg_fcinfo)
    })
}
pub unsafe fn range_lower_inc(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_lower_inc(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_lower_inc(arg_fcinfo)
    })
}
pub unsafe fn range_upper_inc(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_upper_inc(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_upper_inc(arg_fcinfo)
    })
}
pub unsafe fn range_lower_inf(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_lower_inf(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_lower_inf(arg_fcinfo)
    })
}
pub unsafe fn range_upper_inf(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_upper_inf(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_upper_inf(arg_fcinfo)
    })
}
pub unsafe fn range_eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_eq(arg_fcinfo)
    })
}
pub unsafe fn range_ne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_ne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_ne(arg_fcinfo)
    })
}
pub unsafe fn range_overlaps(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_overlaps(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_overlaps(arg_fcinfo)
    })
}
pub unsafe fn range_contains_elem(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_contains_elem(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_contains_elem(arg_fcinfo)
    })
}
pub unsafe fn range_contains(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_contains(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_contains(arg_fcinfo)
    })
}
pub unsafe fn elem_contained_by_range(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn elem_contained_by_range(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        elem_contained_by_range(arg_fcinfo)
    })
}
pub unsafe fn range_contained_by(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_contained_by(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_contained_by(arg_fcinfo)
    })
}
pub unsafe fn range_adjacent(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_adjacent(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_adjacent(arg_fcinfo)
    })
}
pub unsafe fn range_before(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_before(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_before(arg_fcinfo)
    })
}
pub unsafe fn range_after(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_after(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_after(arg_fcinfo)
    })
}
pub unsafe fn range_overleft(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_overleft(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_overleft(arg_fcinfo)
    })
}
pub unsafe fn range_overright(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_overright(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_overright(arg_fcinfo)
    })
}
pub unsafe fn range_union(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_union(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_union(arg_fcinfo)
    })
}
pub unsafe fn range_intersect(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_intersect(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_intersect(arg_fcinfo)
    })
}
pub unsafe fn range_minus(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_minus(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_minus(arg_fcinfo)
    })
}
pub unsafe fn range_cmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_cmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_cmp(arg_fcinfo)
    })
}
pub unsafe fn range_lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_lt(arg_fcinfo)
    })
}
pub unsafe fn range_le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_le(arg_fcinfo)
    })
}
pub unsafe fn range_ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_ge(arg_fcinfo)
    })
}
pub unsafe fn range_gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_gt(arg_fcinfo)
    })
}
pub unsafe fn range_gist_consistent(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_gist_consistent(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_gist_consistent(arg_fcinfo)
    })
}
pub unsafe fn range_gist_union(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_gist_union(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_gist_union(arg_fcinfo)
    })
}
pub unsafe fn pg_replication_slot_advance(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_replication_slot_advance(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_replication_slot_advance(arg_fcinfo)
    })
}
pub unsafe fn range_gist_penalty(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_gist_penalty(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_gist_penalty(arg_fcinfo)
    })
}
pub unsafe fn range_gist_picksplit(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_gist_picksplit(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_gist_picksplit(arg_fcinfo)
    })
}
pub unsafe fn range_gist_same(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_gist_same(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_gist_same(arg_fcinfo)
    })
}
pub unsafe fn hash_range(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hash_range(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hash_range(arg_fcinfo)
    })
}
pub unsafe fn int4range_canonical(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4range_canonical(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4range_canonical(arg_fcinfo)
    })
}
pub unsafe fn daterange_canonical(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn daterange_canonical(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        daterange_canonical(arg_fcinfo)
    })
}
pub unsafe fn range_typanalyze(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_typanalyze(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_typanalyze(arg_fcinfo)
    })
}
pub unsafe fn timestamp_support(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timestamp_support(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        timestamp_support(arg_fcinfo)
    })
}
pub unsafe fn interval_support(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn interval_support(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        interval_support(arg_fcinfo)
    })
}
pub unsafe fn ginarraytriconsistent(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ginarraytriconsistent(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ginarraytriconsistent(arg_fcinfo)
    })
}
pub unsafe fn gin_tsquery_triconsistent(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gin_tsquery_triconsistent(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gin_tsquery_triconsistent(arg_fcinfo)
    })
}
pub unsafe fn int4range_subdiff(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4range_subdiff(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4range_subdiff(arg_fcinfo)
    })
}
pub unsafe fn int8range_subdiff(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8range_subdiff(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8range_subdiff(arg_fcinfo)
    })
}
pub unsafe fn numrange_subdiff(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numrange_subdiff(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numrange_subdiff(arg_fcinfo)
    })
}
pub unsafe fn daterange_subdiff(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn daterange_subdiff(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        daterange_subdiff(arg_fcinfo)
    })
}
pub unsafe fn int8range_canonical(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8range_canonical(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8range_canonical(arg_fcinfo)
    })
}
pub unsafe fn tsrange_subdiff(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsrange_subdiff(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsrange_subdiff(arg_fcinfo)
    })
}
pub unsafe fn tstzrange_subdiff(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tstzrange_subdiff(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tstzrange_subdiff(arg_fcinfo)
    })
}
pub unsafe fn jsonb_object_keys(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_object_keys(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_object_keys(arg_fcinfo)
    })
}
pub unsafe fn jsonb_each_text(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_each_text(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_each_text(arg_fcinfo)
    })
}
pub unsafe fn mxid_age(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn mxid_age(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        mxid_age(arg_fcinfo)
    })
}
pub unsafe fn jsonb_extract_path_text(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_extract_path_text(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_extract_path_text(arg_fcinfo)
    })
}
pub unsafe fn acldefault_sql(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn acldefault_sql(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        acldefault_sql(arg_fcinfo)
    })
}
pub unsafe fn time_support(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn time_support(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        time_support(arg_fcinfo)
    })
}
pub unsafe fn json_object_field(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_object_field(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_object_field(arg_fcinfo)
    })
}
pub unsafe fn json_object_field_text(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_object_field_text(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_object_field_text(arg_fcinfo)
    })
}
pub unsafe fn json_array_element(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_array_element(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_array_element(arg_fcinfo)
    })
}
pub unsafe fn json_array_element_text(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_array_element_text(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_array_element_text(arg_fcinfo)
    })
}
pub unsafe fn json_extract_path(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_extract_path(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_extract_path(arg_fcinfo)
    })
}
pub unsafe fn brin_summarize_new_values(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn brin_summarize_new_values(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        brin_summarize_new_values(arg_fcinfo)
    })
}
pub unsafe fn json_extract_path_text(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_extract_path_text(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_extract_path_text(arg_fcinfo)
    })
}
pub unsafe fn pg_get_object_address(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_object_address(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_get_object_address(arg_fcinfo)
    })
}
pub unsafe fn json_array_elements(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_array_elements(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_array_elements(arg_fcinfo)
    })
}
pub unsafe fn json_array_length(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_array_length(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_array_length(arg_fcinfo)
    })
}
pub unsafe fn json_object_keys(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_object_keys(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_object_keys(arg_fcinfo)
    })
}
pub unsafe fn json_each(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_each(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_each(arg_fcinfo)
    })
}
pub unsafe fn json_each_text(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_each_text(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_each_text(arg_fcinfo)
    })
}
pub unsafe fn json_populate_record(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_populate_record(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_populate_record(arg_fcinfo)
    })
}
pub unsafe fn json_populate_recordset(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_populate_recordset(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_populate_recordset(arg_fcinfo)
    })
}
pub unsafe fn json_typeof(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_typeof(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_typeof(arg_fcinfo)
    })
}
pub unsafe fn json_array_elements_text(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_array_elements_text(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_array_elements_text(arg_fcinfo)
    })
}
pub unsafe fn ordered_set_transition(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ordered_set_transition(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ordered_set_transition(arg_fcinfo)
    })
}
pub unsafe fn ordered_set_transition_multi(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ordered_set_transition_multi(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ordered_set_transition_multi(arg_fcinfo)
    })
}
pub unsafe fn percentile_disc_final(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn percentile_disc_final(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        percentile_disc_final(arg_fcinfo)
    })
}
pub unsafe fn percentile_cont_float8_final(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn percentile_cont_float8_final(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        percentile_cont_float8_final(arg_fcinfo)
    })
}
pub unsafe fn percentile_cont_interval_final(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn percentile_cont_interval_final(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        percentile_cont_interval_final(arg_fcinfo)
    })
}
pub unsafe fn percentile_disc_multi_final(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn percentile_disc_multi_final(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        percentile_disc_multi_final(arg_fcinfo)
    })
}
pub unsafe fn percentile_cont_float8_multi_final(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn percentile_cont_float8_multi_final(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        percentile_cont_float8_multi_final(arg_fcinfo)
    })
}
pub unsafe fn percentile_cont_interval_multi_final(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn percentile_cont_interval_multi_final(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        percentile_cont_interval_multi_final(arg_fcinfo)
    })
}
pub unsafe fn mode_final(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn mode_final(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        mode_final(arg_fcinfo)
    })
}
pub unsafe fn hypothetical_rank_final(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hypothetical_rank_final(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hypothetical_rank_final(arg_fcinfo)
    })
}
pub unsafe fn hypothetical_percent_rank_final(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hypothetical_percent_rank_final(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hypothetical_percent_rank_final(arg_fcinfo)
    })
}
pub unsafe fn hypothetical_cume_dist_final(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hypothetical_cume_dist_final(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hypothetical_cume_dist_final(arg_fcinfo)
    })
}
pub unsafe fn hypothetical_dense_rank_final(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hypothetical_dense_rank_final(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        hypothetical_dense_rank_final(arg_fcinfo)
    })
}
pub unsafe fn generate_series_int4_support(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn generate_series_int4_support(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        generate_series_int4_support(arg_fcinfo)
    })
}
pub unsafe fn generate_series_int8_support(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn generate_series_int8_support(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        generate_series_int8_support(arg_fcinfo)
    })
}
pub unsafe fn array_unnest_support(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_unnest_support(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_unnest_support(arg_fcinfo)
    })
}
pub unsafe fn gist_box_distance(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn gist_box_distance(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        gist_box_distance(arg_fcinfo)
    })
}
pub unsafe fn brin_summarize_range(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn brin_summarize_range(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        brin_summarize_range(arg_fcinfo)
    })
}
pub unsafe fn jsonpath_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonpath_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonpath_in(arg_fcinfo)
    })
}
pub unsafe fn jsonpath_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonpath_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonpath_recv(arg_fcinfo)
    })
}
pub unsafe fn jsonpath_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonpath_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonpath_out(arg_fcinfo)
    })
}
pub unsafe fn jsonpath_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonpath_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonpath_send(arg_fcinfo)
    })
}
pub unsafe fn jsonb_path_exists(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_path_exists(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_path_exists(arg_fcinfo)
    })
}
pub unsafe fn jsonb_path_query(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_path_query(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_path_query(arg_fcinfo)
    })
}
pub unsafe fn jsonb_path_query_array(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_path_query_array(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_path_query_array(arg_fcinfo)
    })
}
pub unsafe fn jsonb_path_query_first(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_path_query_first(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_path_query_first(arg_fcinfo)
    })
}
pub unsafe fn jsonb_path_match(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_path_match(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_path_match(arg_fcinfo)
    })
}
pub unsafe fn jsonb_path_exists_opr(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_path_exists_opr(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_path_exists_opr(arg_fcinfo)
    })
}
pub unsafe fn jsonb_path_match_opr(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_path_match_opr(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_path_match_opr(arg_fcinfo)
    })
}
pub unsafe fn brin_desummarize_range(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn brin_desummarize_range(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        brin_desummarize_range(arg_fcinfo)
    })
}
pub unsafe fn spg_quad_config(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn spg_quad_config(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        spg_quad_config(arg_fcinfo)
    })
}
pub unsafe fn spg_quad_choose(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn spg_quad_choose(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        spg_quad_choose(arg_fcinfo)
    })
}
pub unsafe fn spg_quad_picksplit(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn spg_quad_picksplit(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        spg_quad_picksplit(arg_fcinfo)
    })
}
pub unsafe fn spg_quad_inner_consistent(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn spg_quad_inner_consistent(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        spg_quad_inner_consistent(arg_fcinfo)
    })
}
pub unsafe fn spg_quad_leaf_consistent(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn spg_quad_leaf_consistent(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        spg_quad_leaf_consistent(arg_fcinfo)
    })
}
pub unsafe fn spg_kd_config(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn spg_kd_config(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        spg_kd_config(arg_fcinfo)
    })
}
pub unsafe fn spg_kd_choose(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn spg_kd_choose(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        spg_kd_choose(arg_fcinfo)
    })
}
pub unsafe fn spg_kd_picksplit(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn spg_kd_picksplit(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        spg_kd_picksplit(arg_fcinfo)
    })
}
pub unsafe fn spg_kd_inner_consistent(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn spg_kd_inner_consistent(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        spg_kd_inner_consistent(arg_fcinfo)
    })
}
pub unsafe fn spg_text_config(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn spg_text_config(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        spg_text_config(arg_fcinfo)
    })
}
pub unsafe fn spg_text_choose(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn spg_text_choose(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        spg_text_choose(arg_fcinfo)
    })
}
pub unsafe fn spg_text_picksplit(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn spg_text_picksplit(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        spg_text_picksplit(arg_fcinfo)
    })
}
pub unsafe fn spg_text_inner_consistent(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn spg_text_inner_consistent(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        spg_text_inner_consistent(arg_fcinfo)
    })
}
pub unsafe fn spg_text_leaf_consistent(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn spg_text_leaf_consistent(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        spg_text_leaf_consistent(arg_fcinfo)
    })
}
pub unsafe fn pg_sequence_last_value(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_sequence_last_value(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_sequence_last_value(arg_fcinfo)
    })
}
pub unsafe fn jsonb_ne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_ne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_ne(arg_fcinfo)
    })
}
pub unsafe fn jsonb_lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_lt(arg_fcinfo)
    })
}
pub unsafe fn jsonb_gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_gt(arg_fcinfo)
    })
}
pub unsafe fn jsonb_le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_le(arg_fcinfo)
    })
}
pub unsafe fn jsonb_ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_ge(arg_fcinfo)
    })
}
pub unsafe fn jsonb_eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_eq(arg_fcinfo)
    })
}
pub unsafe fn jsonb_cmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_cmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_cmp(arg_fcinfo)
    })
}
pub unsafe fn jsonb_hash(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_hash(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_hash(arg_fcinfo)
    })
}
pub unsafe fn jsonb_contains(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_contains(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_contains(arg_fcinfo)
    })
}
pub unsafe fn jsonb_exists(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_exists(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_exists(arg_fcinfo)
    })
}
pub unsafe fn jsonb_exists_any(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_exists_any(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_exists_any(arg_fcinfo)
    })
}
pub unsafe fn jsonb_exists_all(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_exists_all(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_exists_all(arg_fcinfo)
    })
}
pub unsafe fn jsonb_contained(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_contained(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_contained(arg_fcinfo)
    })
}
pub unsafe fn array_agg_array_transfn(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_agg_array_transfn(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_agg_array_transfn(arg_fcinfo)
    })
}
pub unsafe fn array_agg_array_finalfn(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn array_agg_array_finalfn(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        array_agg_array_finalfn(arg_fcinfo)
    })
}
pub unsafe fn range_merge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_merge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        range_merge(arg_fcinfo)
    })
}
pub unsafe fn inet_merge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet_merge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        inet_merge(arg_fcinfo)
    })
}
pub unsafe fn boxes_bound_box(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn boxes_bound_box(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        boxes_bound_box(arg_fcinfo)
    })
}
pub unsafe fn inet_same_family(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn inet_same_family(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        inet_same_family(arg_fcinfo)
    })
}
pub unsafe fn binary_upgrade_set_record_init_privs(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn binary_upgrade_set_record_init_privs(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        binary_upgrade_set_record_init_privs(arg_fcinfo)
    })
}
pub unsafe fn regnamespacein(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regnamespacein(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regnamespacein(arg_fcinfo)
    })
}
pub unsafe fn regnamespaceout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regnamespaceout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regnamespaceout(arg_fcinfo)
    })
}
pub unsafe fn to_regnamespace(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn to_regnamespace(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        to_regnamespace(arg_fcinfo)
    })
}
pub unsafe fn regnamespacerecv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regnamespacerecv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regnamespacerecv(arg_fcinfo)
    })
}
pub unsafe fn regnamespacesend(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regnamespacesend(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regnamespacesend(arg_fcinfo)
    })
}
pub unsafe fn point_box(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn point_box(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        point_box(arg_fcinfo)
    })
}
pub unsafe fn regroleout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regroleout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regroleout(arg_fcinfo)
    })
}
pub unsafe fn to_regrole(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn to_regrole(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        to_regrole(arg_fcinfo)
    })
}
pub unsafe fn regrolerecv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regrolerecv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regrolerecv(arg_fcinfo)
    })
}
pub unsafe fn regrolesend(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regrolesend(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regrolesend(arg_fcinfo)
    })
}
pub unsafe fn regrolein(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regrolein(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regrolein(arg_fcinfo)
    })
}
pub unsafe fn pg_rotate_logfile(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_rotate_logfile(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_rotate_logfile(arg_fcinfo)
    })
}
pub unsafe fn pg_read_file(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_read_file(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_read_file(arg_fcinfo)
    })
}
pub unsafe fn binary_upgrade_set_missing_value(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn binary_upgrade_set_missing_value(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        binary_upgrade_set_missing_value(arg_fcinfo)
    })
}
pub unsafe fn brin_inclusion_opcinfo(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn brin_inclusion_opcinfo(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        brin_inclusion_opcinfo(arg_fcinfo)
    })
}
pub unsafe fn brin_inclusion_add_value(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn brin_inclusion_add_value(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        brin_inclusion_add_value(arg_fcinfo)
    })
}
pub unsafe fn brin_inclusion_consistent(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn brin_inclusion_consistent(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        brin_inclusion_consistent(arg_fcinfo)
    })
}
pub unsafe fn brin_inclusion_union(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn brin_inclusion_union(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        brin_inclusion_union(arg_fcinfo)
    })
}
pub unsafe fn macaddr8_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn macaddr8_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        macaddr8_in(arg_fcinfo)
    })
}
pub unsafe fn macaddr8_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn macaddr8_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        macaddr8_out(arg_fcinfo)
    })
}
pub unsafe fn macaddr8_trunc(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn macaddr8_trunc(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        macaddr8_trunc(arg_fcinfo)
    })
}
pub unsafe fn macaddr8_eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn macaddr8_eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        macaddr8_eq(arg_fcinfo)
    })
}
pub unsafe fn macaddr8_lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn macaddr8_lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        macaddr8_lt(arg_fcinfo)
    })
}
pub unsafe fn macaddr8_le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn macaddr8_le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        macaddr8_le(arg_fcinfo)
    })
}
pub unsafe fn macaddr8_gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn macaddr8_gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        macaddr8_gt(arg_fcinfo)
    })
}
pub unsafe fn macaddr8_ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn macaddr8_ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        macaddr8_ge(arg_fcinfo)
    })
}
pub unsafe fn macaddr8_ne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn macaddr8_ne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        macaddr8_ne(arg_fcinfo)
    })
}
pub unsafe fn macaddr8_cmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn macaddr8_cmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        macaddr8_cmp(arg_fcinfo)
    })
}
pub unsafe fn macaddr8_not(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn macaddr8_not(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        macaddr8_not(arg_fcinfo)
    })
}
pub unsafe fn macaddr8_and(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn macaddr8_and(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        macaddr8_and(arg_fcinfo)
    })
}
pub unsafe fn macaddr8_or(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn macaddr8_or(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        macaddr8_or(arg_fcinfo)
    })
}
pub unsafe fn macaddrtomacaddr8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn macaddrtomacaddr8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        macaddrtomacaddr8(arg_fcinfo)
    })
}
pub unsafe fn macaddr8tomacaddr(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn macaddr8tomacaddr(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        macaddr8tomacaddr(arg_fcinfo)
    })
}
pub unsafe fn macaddr8_set7bit(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn macaddr8_set7bit(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        macaddr8_set7bit(arg_fcinfo)
    })
}
pub unsafe fn in_range_int8_int8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn in_range_int8_int8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        in_range_int8_int8(arg_fcinfo)
    })
}
pub unsafe fn in_range_int4_int8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn in_range_int4_int8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        in_range_int4_int8(arg_fcinfo)
    })
}
pub unsafe fn in_range_int4_int4(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn in_range_int4_int4(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        in_range_int4_int4(arg_fcinfo)
    })
}
pub unsafe fn in_range_int4_int2(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn in_range_int4_int2(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        in_range_int4_int2(arg_fcinfo)
    })
}
pub unsafe fn in_range_int2_int8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn in_range_int2_int8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        in_range_int2_int8(arg_fcinfo)
    })
}
pub unsafe fn in_range_int2_int4(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn in_range_int2_int4(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        in_range_int2_int4(arg_fcinfo)
    })
}
pub unsafe fn in_range_int2_int2(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn in_range_int2_int2(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        in_range_int2_int2(arg_fcinfo)
    })
}
pub unsafe fn in_range_date_interval(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn in_range_date_interval(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        in_range_date_interval(arg_fcinfo)
    })
}
pub unsafe fn in_range_timestamp_interval(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn in_range_timestamp_interval(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        in_range_timestamp_interval(arg_fcinfo)
    })
}
pub unsafe fn in_range_timestamptz_interval(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn in_range_timestamptz_interval(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        in_range_timestamptz_interval(arg_fcinfo)
    })
}
pub unsafe fn in_range_interval_interval(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn in_range_interval_interval(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        in_range_interval_interval(arg_fcinfo)
    })
}
pub unsafe fn in_range_time_interval(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn in_range_time_interval(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        in_range_time_interval(arg_fcinfo)
    })
}
pub unsafe fn in_range_timetz_interval(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn in_range_timetz_interval(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        in_range_timetz_interval(arg_fcinfo)
    })
}
pub unsafe fn in_range_float8_float8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn in_range_float8_float8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        in_range_float8_float8(arg_fcinfo)
    })
}
pub unsafe fn in_range_float4_float8(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn in_range_float4_float8(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        in_range_float4_float8(arg_fcinfo)
    })
}
pub unsafe fn in_range_numeric_numeric(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn in_range_numeric_numeric(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        in_range_numeric_numeric(arg_fcinfo)
    })
}
pub unsafe fn pg_lsn_larger(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_lsn_larger(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_lsn_larger(arg_fcinfo)
    })
}
pub unsafe fn pg_lsn_smaller(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_lsn_smaller(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_lsn_smaller(arg_fcinfo)
    })
}
pub unsafe fn regcollationin(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regcollationin(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regcollationin(arg_fcinfo)
    })
}
pub unsafe fn regcollationout(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regcollationout(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regcollationout(arg_fcinfo)
    })
}
pub unsafe fn to_regcollation(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn to_regcollation(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        to_regcollation(arg_fcinfo)
    })
}
pub unsafe fn regcollationrecv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regcollationrecv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regcollationrecv(arg_fcinfo)
    })
}
pub unsafe fn regcollationsend(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regcollationsend(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        regcollationsend(arg_fcinfo)
    })
}
pub unsafe fn ts_headline_jsonb_byid_opt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ts_headline_jsonb_byid_opt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ts_headline_jsonb_byid_opt(arg_fcinfo)
    })
}
pub unsafe fn ts_headline_jsonb_byid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ts_headline_jsonb_byid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ts_headline_jsonb_byid(arg_fcinfo)
    })
}
pub unsafe fn ts_headline_jsonb_opt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ts_headline_jsonb_opt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ts_headline_jsonb_opt(arg_fcinfo)
    })
}
pub unsafe fn ts_headline_jsonb(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ts_headline_jsonb(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ts_headline_jsonb(arg_fcinfo)
    })
}
pub unsafe fn ts_headline_json_byid_opt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ts_headline_json_byid_opt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ts_headline_json_byid_opt(arg_fcinfo)
    })
}
pub unsafe fn ts_headline_json_byid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ts_headline_json_byid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ts_headline_json_byid(arg_fcinfo)
    })
}
pub unsafe fn ts_headline_json_opt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ts_headline_json_opt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ts_headline_json_opt(arg_fcinfo)
    })
}
pub unsafe fn ts_headline_json(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ts_headline_json(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        ts_headline_json(arg_fcinfo)
    })
}
pub unsafe fn jsonb_string_to_tsvector(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_string_to_tsvector(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_string_to_tsvector(arg_fcinfo)
    })
}
pub unsafe fn json_string_to_tsvector(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_string_to_tsvector(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_string_to_tsvector(arg_fcinfo)
    })
}
pub unsafe fn jsonb_string_to_tsvector_byid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_string_to_tsvector_byid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_string_to_tsvector_byid(arg_fcinfo)
    })
}
pub unsafe fn json_string_to_tsvector_byid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_string_to_tsvector_byid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_string_to_tsvector_byid(arg_fcinfo)
    })
}
pub unsafe fn jsonb_to_tsvector(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_to_tsvector(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_to_tsvector(arg_fcinfo)
    })
}
pub unsafe fn jsonb_to_tsvector_byid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_to_tsvector_byid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_to_tsvector_byid(arg_fcinfo)
    })
}
pub unsafe fn json_to_tsvector(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_to_tsvector(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_to_tsvector(arg_fcinfo)
    })
}
pub unsafe fn json_to_tsvector_byid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn json_to_tsvector_byid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        json_to_tsvector_byid(arg_fcinfo)
    })
}
pub unsafe fn pg_copy_physical_replication_slot_a(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_copy_physical_replication_slot_a(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_copy_physical_replication_slot_a(arg_fcinfo)
    })
}
pub unsafe fn pg_copy_physical_replication_slot_b(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_copy_physical_replication_slot_b(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_copy_physical_replication_slot_b(arg_fcinfo)
    })
}
pub unsafe fn pg_copy_logical_replication_slot_a(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_copy_logical_replication_slot_a(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_copy_logical_replication_slot_a(arg_fcinfo)
    })
}
pub unsafe fn pg_copy_logical_replication_slot_b(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_copy_logical_replication_slot_b(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_copy_logical_replication_slot_b(arg_fcinfo)
    })
}
pub unsafe fn pg_copy_logical_replication_slot_c(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_copy_logical_replication_slot_c(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_copy_logical_replication_slot_c(arg_fcinfo)
    })
}
pub unsafe fn unicode_normalize_func(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn unicode_normalize_func(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        unicode_normalize_func(arg_fcinfo)
    })
}
pub unsafe fn unicode_is_normalized(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn unicode_is_normalized(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        unicode_is_normalized(arg_fcinfo)
    })
}
pub unsafe fn pg_event_trigger_table_rewrite_oid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_event_trigger_table_rewrite_oid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_event_trigger_table_rewrite_oid(arg_fcinfo)
    })
}
pub unsafe fn pg_event_trigger_table_rewrite_reason(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_event_trigger_table_rewrite_reason(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_event_trigger_table_rewrite_reason(arg_fcinfo)
    })
}
pub unsafe fn pg_event_trigger_ddl_commands(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_event_trigger_ddl_commands(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_event_trigger_ddl_commands(arg_fcinfo)
    })
}
pub unsafe fn phraseto_tsquery(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn phraseto_tsquery(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        phraseto_tsquery(arg_fcinfo)
    })
}
pub unsafe fn tsquery_phrase(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsquery_phrase(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsquery_phrase(arg_fcinfo)
    })
}
pub unsafe fn tsquery_phrase_distance(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tsquery_phrase_distance(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        tsquery_phrase_distance(arg_fcinfo)
    })
}
pub unsafe fn phraseto_tsquery_byid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn phraseto_tsquery_byid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        phraseto_tsquery_byid(arg_fcinfo)
    })
}
pub unsafe fn websearch_to_tsquery_byid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn websearch_to_tsquery_byid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        websearch_to_tsquery_byid(arg_fcinfo)
    })
}
pub unsafe fn websearch_to_tsquery(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn websearch_to_tsquery(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        websearch_to_tsquery(arg_fcinfo)
    })
}
pub unsafe fn spg_bbox_quad_config(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn spg_bbox_quad_config(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        spg_bbox_quad_config(arg_fcinfo)
    })
}
pub unsafe fn spg_poly_quad_compress(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn spg_poly_quad_compress(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        spg_poly_quad_compress(arg_fcinfo)
    })
}
pub unsafe fn spg_box_quad_config(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn spg_box_quad_config(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        spg_box_quad_config(arg_fcinfo)
    })
}
pub unsafe fn spg_box_quad_choose(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn spg_box_quad_choose(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        spg_box_quad_choose(arg_fcinfo)
    })
}
pub unsafe fn spg_box_quad_picksplit(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn spg_box_quad_picksplit(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        spg_box_quad_picksplit(arg_fcinfo)
    })
}
pub unsafe fn spg_box_quad_inner_consistent(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn spg_box_quad_inner_consistent(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        spg_box_quad_inner_consistent(arg_fcinfo)
    })
}
pub unsafe fn spg_box_quad_leaf_consistent(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn spg_box_quad_leaf_consistent(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        spg_box_quad_leaf_consistent(arg_fcinfo)
    })
}
pub unsafe fn pg_mcv_list_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_mcv_list_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_mcv_list_in(arg_fcinfo)
    })
}
pub unsafe fn pg_mcv_list_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_mcv_list_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_mcv_list_out(arg_fcinfo)
    })
}
pub unsafe fn pg_mcv_list_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_mcv_list_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_mcv_list_recv(arg_fcinfo)
    })
}
pub unsafe fn pg_mcv_list_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_mcv_list_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_mcv_list_send(arg_fcinfo)
    })
}
pub unsafe fn satisfies_hash_partition(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn satisfies_hash_partition(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        satisfies_hash_partition(arg_fcinfo)
    })
}
pub unsafe fn pg_ls_tmpdir_noargs(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_ls_tmpdir_noargs(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_ls_tmpdir_noargs(arg_fcinfo)
    })
}
pub unsafe fn pg_ls_tmpdir_1arg(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_ls_tmpdir_1arg(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_ls_tmpdir_1arg(arg_fcinfo)
    })
}
pub unsafe fn pg_ls_archive_statusdir(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_ls_archive_statusdir(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_ls_archive_statusdir(arg_fcinfo)
    })
}
pub unsafe fn network_sortsupport(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn network_sortsupport(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        network_sortsupport(arg_fcinfo)
    })
}
pub unsafe fn xid8lt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xid8lt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        xid8lt(arg_fcinfo)
    })
}
pub unsafe fn xid8gt(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xid8gt(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        xid8gt(arg_fcinfo)
    })
}
pub unsafe fn xid8le(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xid8le(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        xid8le(arg_fcinfo)
    })
}
pub unsafe fn xid8ge(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xid8ge(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        xid8ge(arg_fcinfo)
    })
}
pub unsafe fn matchingsel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn matchingsel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        matchingsel(arg_fcinfo)
    })
}
pub unsafe fn matchingjoinsel(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn matchingjoinsel(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        matchingjoinsel(arg_fcinfo)
    })
}
pub unsafe fn numeric_min_scale(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_min_scale(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_min_scale(arg_fcinfo)
    })
}
pub unsafe fn numeric_trim_scale(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_trim_scale(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_trim_scale(arg_fcinfo)
    })
}
pub unsafe fn int4gcd(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4gcd(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4gcd(arg_fcinfo)
    })
}
pub unsafe fn int8gcd(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8gcd(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8gcd(arg_fcinfo)
    })
}
pub unsafe fn int4lcm(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int4lcm(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int4lcm(arg_fcinfo)
    })
}
pub unsafe fn int8lcm(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn int8lcm(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        int8lcm(arg_fcinfo)
    })
}
pub unsafe fn numeric_gcd(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_gcd(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_gcd(arg_fcinfo)
    })
}
pub unsafe fn numeric_lcm(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_lcm(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_lcm(arg_fcinfo)
    })
}
pub unsafe fn btvarstrequalimage(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btvarstrequalimage(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btvarstrequalimage(arg_fcinfo)
    })
}
pub unsafe fn btequalimage(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn btequalimage(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        btequalimage(arg_fcinfo)
    })
}
pub unsafe fn pg_get_shmem_allocations(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_shmem_allocations(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_get_shmem_allocations(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_ins_since_vacuum(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_ins_since_vacuum(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_ins_since_vacuum(arg_fcinfo)
    })
}
pub unsafe fn jsonb_set_lax(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn jsonb_set_lax(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        jsonb_set_lax(arg_fcinfo)
    })
}
pub unsafe fn xid8in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xid8in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        xid8in(arg_fcinfo)
    })
}
pub unsafe fn xid8toxid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xid8toxid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        xid8toxid(arg_fcinfo)
    })
}
pub unsafe fn xid8out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xid8out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        xid8out(arg_fcinfo)
    })
}
pub unsafe fn xid8recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xid8recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        xid8recv(arg_fcinfo)
    })
}
pub unsafe fn xid8send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xid8send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        xid8send(arg_fcinfo)
    })
}
pub unsafe fn xid8eq(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xid8eq(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        xid8eq(arg_fcinfo)
    })
}
pub unsafe fn xid8ne(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xid8ne(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        xid8ne(arg_fcinfo)
    })
}
pub unsafe fn anycompatible_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn anycompatible_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        anycompatible_in(arg_fcinfo)
    })
}
pub unsafe fn anycompatible_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn anycompatible_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        anycompatible_out(arg_fcinfo)
    })
}
pub unsafe fn anycompatiblearray_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn anycompatiblearray_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        anycompatiblearray_in(arg_fcinfo)
    })
}
pub unsafe fn anycompatiblearray_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn anycompatiblearray_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        anycompatiblearray_out(arg_fcinfo)
    })
}
pub unsafe fn anycompatiblearray_recv(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn anycompatiblearray_recv(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        anycompatiblearray_recv(arg_fcinfo)
    })
}
pub unsafe fn anycompatiblearray_send(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn anycompatiblearray_send(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        anycompatiblearray_send(arg_fcinfo)
    })
}
pub unsafe fn anycompatiblenonarray_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn anycompatiblenonarray_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        anycompatiblenonarray_in(arg_fcinfo)
    })
}
pub unsafe fn anycompatiblenonarray_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn anycompatiblenonarray_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        anycompatiblenonarray_out(arg_fcinfo)
    })
}
pub unsafe fn anycompatiblerange_in(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn anycompatiblerange_in(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        anycompatiblerange_in(arg_fcinfo)
    })
}
pub unsafe fn anycompatiblerange_out(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn anycompatiblerange_out(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        anycompatiblerange_out(arg_fcinfo)
    })
}
pub unsafe fn xid8cmp(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xid8cmp(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        xid8cmp(arg_fcinfo)
    })
}
pub unsafe fn pg_replication_origin_create(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_replication_origin_create(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_replication_origin_create(arg_fcinfo)
    })
}
pub unsafe fn pg_replication_origin_drop(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_replication_origin_drop(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_replication_origin_drop(arg_fcinfo)
    })
}
pub unsafe fn pg_replication_origin_oid(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_replication_origin_oid(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_replication_origin_oid(arg_fcinfo)
    })
}
pub unsafe fn pg_replication_origin_session_setup(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_replication_origin_session_setup(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_replication_origin_session_setup(arg_fcinfo)
    })
}
pub unsafe fn pg_replication_origin_session_reset(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_replication_origin_session_reset(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_replication_origin_session_reset(arg_fcinfo)
    })
}
pub unsafe fn pg_replication_origin_session_is_setup(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_replication_origin_session_is_setup(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_replication_origin_session_is_setup(arg_fcinfo)
    })
}
pub unsafe fn pg_replication_origin_session_progress(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_replication_origin_session_progress(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_replication_origin_session_progress(arg_fcinfo)
    })
}
pub unsafe fn pg_replication_origin_xact_setup(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_replication_origin_xact_setup(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_replication_origin_xact_setup(arg_fcinfo)
    })
}
pub unsafe fn pg_replication_origin_xact_reset(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_replication_origin_xact_reset(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_replication_origin_xact_reset(arg_fcinfo)
    })
}
pub unsafe fn pg_replication_origin_advance(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_replication_origin_advance(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_replication_origin_advance(arg_fcinfo)
    })
}
pub unsafe fn pg_replication_origin_progress(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_replication_origin_progress(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_replication_origin_progress(arg_fcinfo)
    })
}
pub unsafe fn pg_show_replication_origin_status(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_show_replication_origin_status(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_show_replication_origin_status(arg_fcinfo)
    })
}
pub unsafe fn pg_stat_get_subscription(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_stat_get_subscription(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_stat_get_subscription(arg_fcinfo)
    })
}
pub unsafe fn pg_get_publication_tables(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_publication_tables(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_get_publication_tables(arg_fcinfo)
    })
}
pub unsafe fn pg_get_replica_identity_index(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_get_replica_identity_index(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_get_replica_identity_index(arg_fcinfo)
    })
}
pub unsafe fn pg_relation_is_publishable(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_relation_is_publishable(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        pg_relation_is_publishable(arg_fcinfo)
    })
}
pub unsafe fn parse_bool(arg_value: *const ::std::os::raw::c_char, arg_result: *mut bool) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn parse_bool(arg_value: *const ::std::os::raw::c_char, arg_result: *mut bool) -> bool;
        }
        parse_bool(arg_value, arg_result)
    })
}
pub unsafe fn parse_bool_with_len(
    arg_value: *const ::std::os::raw::c_char,
    arg_len: usize,
    arg_result: *mut bool,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn parse_bool_with_len(
                arg_value: *const ::std::os::raw::c_char,
                arg_len: usize,
                arg_result: *mut bool,
            ) -> bool;
        }
        parse_bool_with_len(arg_value, arg_len, arg_result)
    })
}
pub unsafe fn domain_check(
    arg_value: Datum,
    arg_isnull: bool,
    arg_domainType: Oid,
    arg_extra: *mut *mut ::std::os::raw::c_void,
    arg_mcxt: MemoryContext,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn domain_check(
                arg_value: Datum,
                arg_isnull: bool,
                arg_domainType: Oid,
                arg_extra: *mut *mut ::std::os::raw::c_void,
                arg_mcxt: MemoryContext,
            );
        }
        domain_check(arg_value, arg_isnull, arg_domainType, arg_extra, arg_mcxt)
    })
}
pub unsafe fn errdatatype(arg_datatypeOid: Oid) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn errdatatype(arg_datatypeOid: Oid) -> ::std::os::raw::c_int;
        }
        errdatatype(arg_datatypeOid)
    })
}
pub unsafe fn errdomainconstraint(
    arg_datatypeOid: Oid,
    arg_conname: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn errdomainconstraint(
                arg_datatypeOid: Oid,
                arg_conname: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        errdomainconstraint(arg_datatypeOid, arg_conname)
    })
}
pub unsafe fn hex_encode(
    arg_src: *const ::std::os::raw::c_char,
    arg_len: usize,
    arg_dst: *mut ::std::os::raw::c_char,
) -> uint64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hex_encode(
                arg_src: *const ::std::os::raw::c_char,
                arg_len: usize,
                arg_dst: *mut ::std::os::raw::c_char,
            ) -> uint64;
        }
        hex_encode(arg_src, arg_len, arg_dst)
    })
}
pub unsafe fn hex_decode(
    arg_src: *const ::std::os::raw::c_char,
    arg_len: usize,
    arg_dst: *mut ::std::os::raw::c_char,
) -> uint64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn hex_decode(
                arg_src: *const ::std::os::raw::c_char,
                arg_len: usize,
                arg_dst: *mut ::std::os::raw::c_char,
            ) -> uint64;
        }
        hex_decode(arg_src, arg_len, arg_dst)
    })
}
pub unsafe fn buildint2vector(
    arg_int2s: *const int16,
    arg_n: ::std::os::raw::c_int,
) -> *mut int2vector {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn buildint2vector(
                arg_int2s: *const int16,
                arg_n: ::std::os::raw::c_int,
            ) -> *mut int2vector;
        }
        buildint2vector(arg_int2s, arg_n)
    })
}
pub unsafe fn namecpy(arg_n1: Name, arg_n2: *const NameData) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn namecpy(arg_n1: Name, arg_n2: *const NameData) -> ::std::os::raw::c_int;
        }
        namecpy(arg_n1, arg_n2)
    })
}
pub unsafe fn namestrcpy(
    arg_name: Name,
    arg_str_: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn namestrcpy(
                arg_name: Name,
                arg_str_: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        namestrcpy(arg_name, arg_str_)
    })
}
pub unsafe fn namestrcmp(
    arg_name: Name,
    arg_str_: *const ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn namestrcmp(
                arg_name: Name,
                arg_str_: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        namestrcmp(arg_name, arg_str_)
    })
}
pub unsafe fn pg_atoi(
    arg_s: *const ::std::os::raw::c_char,
    arg_size: ::std::os::raw::c_int,
    arg_c: ::std::os::raw::c_int,
) -> int32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_atoi(
                arg_s: *const ::std::os::raw::c_char,
                arg_size: ::std::os::raw::c_int,
                arg_c: ::std::os::raw::c_int,
            ) -> int32;
        }
        pg_atoi(arg_s, arg_size, arg_c)
    })
}
pub unsafe fn pg_strtoint16(arg_s: *const ::std::os::raw::c_char) -> int16 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_strtoint16(arg_s: *const ::std::os::raw::c_char) -> int16;
        }
        pg_strtoint16(arg_s)
    })
}
pub unsafe fn pg_strtoint32(arg_s: *const ::std::os::raw::c_char) -> int32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_strtoint32(arg_s: *const ::std::os::raw::c_char) -> int32;
        }
        pg_strtoint32(arg_s)
    })
}
pub unsafe fn pg_itoa(arg_i: int16, arg_a: *mut ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_itoa(arg_i: int16, arg_a: *mut ::std::os::raw::c_char);
        }
        pg_itoa(arg_i, arg_a)
    })
}
pub unsafe fn pg_ultoa_n(
    arg_l: uint32,
    arg_a: *mut ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_ultoa_n(
                arg_l: uint32,
                arg_a: *mut ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        pg_ultoa_n(arg_l, arg_a)
    })
}
pub unsafe fn pg_ulltoa_n(
    arg_l: uint64,
    arg_a: *mut ::std::os::raw::c_char,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_ulltoa_n(
                arg_l: uint64,
                arg_a: *mut ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int;
        }
        pg_ulltoa_n(arg_l, arg_a)
    })
}
pub unsafe fn pg_ltoa(arg_l: int32, arg_a: *mut ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_ltoa(arg_l: int32, arg_a: *mut ::std::os::raw::c_char);
        }
        pg_ltoa(arg_l, arg_a)
    })
}
pub unsafe fn pg_lltoa(arg_ll: int64, arg_a: *mut ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_lltoa(arg_ll: int64, arg_a: *mut ::std::os::raw::c_char);
        }
        pg_lltoa(arg_ll, arg_a)
    })
}
pub unsafe fn pg_ultostr_zeropad(
    arg_str_: *mut ::std::os::raw::c_char,
    arg_value: uint32,
    arg_minwidth: int32,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_ultostr_zeropad(
                arg_str_: *mut ::std::os::raw::c_char,
                arg_value: uint32,
                arg_minwidth: int32,
            ) -> *mut ::std::os::raw::c_char;
        }
        pg_ultostr_zeropad(arg_str_, arg_value, arg_minwidth)
    })
}
pub unsafe fn pg_ultostr(
    arg_str_: *mut ::std::os::raw::c_char,
    arg_value: uint32,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_ultostr(
                arg_str_: *mut ::std::os::raw::c_char,
                arg_value: uint32,
            ) -> *mut ::std::os::raw::c_char;
        }
        pg_ultostr(arg_str_, arg_value)
    })
}
pub unsafe fn pg_strtouint64(
    arg_str_: *const ::std::os::raw::c_char,
    arg_endptr: *mut *mut ::std::os::raw::c_char,
    arg_base: ::std::os::raw::c_int,
) -> uint64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_strtouint64(
                arg_str_: *const ::std::os::raw::c_char,
                arg_endptr: *mut *mut ::std::os::raw::c_char,
                arg_base: ::std::os::raw::c_int,
            ) -> uint64;
        }
        pg_strtouint64(arg_str_, arg_endptr, arg_base)
    })
}
pub unsafe fn buildoidvector(arg_oids: *const Oid, arg_n: ::std::os::raw::c_int) -> *mut oidvector {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn buildoidvector(arg_oids: *const Oid, arg_n: ::std::os::raw::c_int)
                -> *mut oidvector;
        }
        buildoidvector(arg_oids, arg_n)
    })
}
pub unsafe fn oidparse(arg_node: *mut Node) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn oidparse(arg_node: *mut Node) -> Oid;
        }
        oidparse(arg_node)
    })
}
pub unsafe fn oid_cmp(
    arg_p1: *const ::std::os::raw::c_void,
    arg_p2: *const ::std::os::raw::c_void,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn oid_cmp(
                arg_p1: *const ::std::os::raw::c_void,
                arg_p2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int;
        }
        oid_cmp(arg_p1, arg_p2)
    })
}
pub unsafe fn regexp_fixed_prefix(
    arg_text_re: *mut text,
    arg_case_insensitive: bool,
    arg_collation: Oid,
    arg_exact: *mut bool,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn regexp_fixed_prefix(
                arg_text_re: *mut text,
                arg_case_insensitive: bool,
                arg_collation: Oid,
                arg_exact: *mut bool,
            ) -> *mut ::std::os::raw::c_char;
        }
        regexp_fixed_prefix(arg_text_re, arg_case_insensitive, arg_collation, arg_exact)
    })
}
extern "C" {
    pub static mut quote_all_identifiers: bool;
}
pub unsafe fn quote_identifier(
    arg_ident: *const ::std::os::raw::c_char,
) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn quote_identifier(
                arg_ident: *const ::std::os::raw::c_char,
            ) -> *const ::std::os::raw::c_char;
        }
        quote_identifier(arg_ident)
    })
}
pub unsafe fn quote_qualified_identifier(
    arg_qualifier: *const ::std::os::raw::c_char,
    arg_ident: *const ::std::os::raw::c_char,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn quote_qualified_identifier(
                arg_qualifier: *const ::std::os::raw::c_char,
                arg_ident: *const ::std::os::raw::c_char,
            ) -> *mut ::std::os::raw::c_char;
        }
        quote_qualified_identifier(arg_qualifier, arg_ident)
    })
}
pub unsafe fn generate_operator_clause(
    arg_buf: fmStringInfo,
    arg_leftop: *const ::std::os::raw::c_char,
    arg_leftoptype: Oid,
    arg_opoid: Oid,
    arg_rightop: *const ::std::os::raw::c_char,
    arg_rightoptype: Oid,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn generate_operator_clause(
                arg_buf: fmStringInfo,
                arg_leftop: *const ::std::os::raw::c_char,
                arg_leftoptype: Oid,
                arg_opoid: Oid,
                arg_rightop: *const ::std::os::raw::c_char,
                arg_rightoptype: Oid,
            );
        }
        generate_operator_clause(
            arg_buf,
            arg_leftop,
            arg_leftoptype,
            arg_opoid,
            arg_rightop,
            arg_rightoptype,
        )
    })
}
pub unsafe fn bpchartruelen(
    arg_s: *mut ::std::os::raw::c_char,
    arg_len: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bpchartruelen(
                arg_s: *mut ::std::os::raw::c_char,
                arg_len: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        bpchartruelen(arg_s, arg_len)
    })
}
pub unsafe fn cstring_to_text(arg_s: *const ::std::os::raw::c_char) -> *mut text {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cstring_to_text(arg_s: *const ::std::os::raw::c_char) -> *mut text;
        }
        cstring_to_text(arg_s)
    })
}
pub unsafe fn cstring_to_text_with_len(
    arg_s: *const ::std::os::raw::c_char,
    arg_len: ::std::os::raw::c_int,
) -> *mut text {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn cstring_to_text_with_len(
                arg_s: *const ::std::os::raw::c_char,
                arg_len: ::std::os::raw::c_int,
            ) -> *mut text;
        }
        cstring_to_text_with_len(arg_s, arg_len)
    })
}
pub unsafe fn text_to_cstring(arg_t: *const text) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn text_to_cstring(arg_t: *const text) -> *mut ::std::os::raw::c_char;
        }
        text_to_cstring(arg_t)
    })
}
pub unsafe fn text_to_cstring_buffer(
    arg_src: *const text,
    arg_dst: *mut ::std::os::raw::c_char,
    arg_dst_len: usize,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn text_to_cstring_buffer(
                arg_src: *const text,
                arg_dst: *mut ::std::os::raw::c_char,
                arg_dst_len: usize,
            );
        }
        text_to_cstring_buffer(arg_src, arg_dst, arg_dst_len)
    })
}
pub unsafe fn xidComparator(
    arg_arg1: *const ::std::os::raw::c_void,
    arg_arg2: *const ::std::os::raw::c_void,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn xidComparator(
                arg_arg1: *const ::std::os::raw::c_void,
                arg_arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int;
        }
        xidComparator(arg_arg1, arg_arg2)
    })
}
pub unsafe fn pg_inet_cidr_ntop(
    arg_af: ::std::os::raw::c_int,
    arg_src: *const ::std::os::raw::c_void,
    arg_bits: ::std::os::raw::c_int,
    arg_dst: *mut ::std::os::raw::c_char,
    arg_size: usize,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_inet_cidr_ntop(
                arg_af: ::std::os::raw::c_int,
                arg_src: *const ::std::os::raw::c_void,
                arg_bits: ::std::os::raw::c_int,
                arg_dst: *mut ::std::os::raw::c_char,
                arg_size: usize,
            ) -> *mut ::std::os::raw::c_char;
        }
        pg_inet_cidr_ntop(arg_af, arg_src, arg_bits, arg_dst, arg_size)
    })
}
pub unsafe fn pg_inet_net_pton(
    arg_af: ::std::os::raw::c_int,
    arg_src: *const ::std::os::raw::c_char,
    arg_dst: *mut ::std::os::raw::c_void,
    arg_size: usize,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_inet_net_pton(
                arg_af: ::std::os::raw::c_int,
                arg_src: *const ::std::os::raw::c_char,
                arg_dst: *mut ::std::os::raw::c_void,
                arg_size: usize,
            ) -> ::std::os::raw::c_int;
        }
        pg_inet_net_pton(arg_af, arg_src, arg_dst, arg_size)
    })
}
pub unsafe fn convert_network_to_scalar(
    arg_value: Datum,
    arg_typid: Oid,
    arg_failure: *mut bool,
) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn convert_network_to_scalar(
                arg_value: Datum,
                arg_typid: Oid,
                arg_failure: *mut bool,
            ) -> f64;
        }
        convert_network_to_scalar(arg_value, arg_typid, arg_failure)
    })
}
pub unsafe fn network_scan_first(arg_in_: Datum) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn network_scan_first(arg_in_: Datum) -> Datum;
        }
        network_scan_first(arg_in_)
    })
}
pub unsafe fn network_scan_last(arg_in_: Datum) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn network_scan_last(arg_in_: Datum) -> Datum;
        }
        network_scan_last(arg_in_)
    })
}
pub unsafe fn clean_ipv6_addr(
    arg_addr_family: ::std::os::raw::c_int,
    arg_addr: *mut ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn clean_ipv6_addr(
                arg_addr_family: ::std::os::raw::c_int,
                arg_addr: *mut ::std::os::raw::c_char,
            );
        }
        clean_ipv6_addr(arg_addr_family, arg_addr)
    })
}
pub unsafe fn numeric_float8_no_overflow(arg_fcinfo: FunctionCallInfo) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_float8_no_overflow(arg_fcinfo: FunctionCallInfo) -> Datum;
        }
        numeric_float8_no_overflow(arg_fcinfo)
    })
}
pub unsafe fn format_type_extended(
    arg_type_oid: Oid,
    arg_typemod: int32,
    arg_flags: bits16,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn format_type_extended(
                arg_type_oid: Oid,
                arg_typemod: int32,
                arg_flags: bits16,
            ) -> *mut ::std::os::raw::c_char;
        }
        format_type_extended(arg_type_oid, arg_typemod, arg_flags)
    })
}
pub unsafe fn format_type_be(arg_type_oid: Oid) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn format_type_be(arg_type_oid: Oid) -> *mut ::std::os::raw::c_char;
        }
        format_type_be(arg_type_oid)
    })
}
pub unsafe fn format_type_be_qualified(arg_type_oid: Oid) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn format_type_be_qualified(arg_type_oid: Oid) -> *mut ::std::os::raw::c_char;
        }
        format_type_be_qualified(arg_type_oid)
    })
}
pub unsafe fn format_type_with_typemod(
    arg_type_oid: Oid,
    arg_typemod: int32,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn format_type_with_typemod(
                arg_type_oid: Oid,
                arg_typemod: int32,
            ) -> *mut ::std::os::raw::c_char;
        }
        format_type_with_typemod(arg_type_oid, arg_typemod)
    })
}
pub unsafe fn type_maximum_size(arg_type_oid: Oid, arg_typemod: int32) -> int32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn type_maximum_size(arg_type_oid: Oid, arg_typemod: int32) -> int32;
        }
        type_maximum_size(arg_type_oid, arg_typemod)
    })
}
pub unsafe fn quote_literal_cstr(
    arg_rawstr: *const ::std::os::raw::c_char,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn quote_literal_cstr(
                arg_rawstr: *const ::std::os::raw::c_char,
            ) -> *mut ::std::os::raw::c_char;
        }
        quote_literal_cstr(arg_rawstr)
    })
}
pub type DateADT = int32;
pub type TimeADT = int64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TimeTzADT {
    pub time: TimeADT,
    pub zone: int32,
}
pub unsafe fn anytime_typmod_check(arg_istz: bool, arg_typmod: int32) -> int32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn anytime_typmod_check(arg_istz: bool, arg_typmod: int32) -> int32;
        }
        anytime_typmod_check(arg_istz, arg_typmod)
    })
}
pub unsafe fn date2timestamp_no_overflow(arg_dateVal: DateADT) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date2timestamp_no_overflow(arg_dateVal: DateADT) -> f64;
        }
        date2timestamp_no_overflow(arg_dateVal)
    })
}
pub unsafe fn date2timestamp_opt_overflow(
    arg_dateVal: DateADT,
    arg_overflow: *mut ::std::os::raw::c_int,
) -> Timestamp {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date2timestamp_opt_overflow(
                arg_dateVal: DateADT,
                arg_overflow: *mut ::std::os::raw::c_int,
            ) -> Timestamp;
        }
        date2timestamp_opt_overflow(arg_dateVal, arg_overflow)
    })
}
pub unsafe fn date2timestamptz_opt_overflow(
    arg_dateVal: DateADT,
    arg_overflow: *mut ::std::os::raw::c_int,
) -> TimestampTz {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date2timestamptz_opt_overflow(
                arg_dateVal: DateADT,
                arg_overflow: *mut ::std::os::raw::c_int,
            ) -> TimestampTz;
        }
        date2timestamptz_opt_overflow(arg_dateVal, arg_overflow)
    })
}
pub unsafe fn date_cmp_timestamp_internal(arg_dateVal: DateADT, arg_dt2: Timestamp) -> int32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_cmp_timestamp_internal(arg_dateVal: DateADT, arg_dt2: Timestamp) -> int32;
        }
        date_cmp_timestamp_internal(arg_dateVal, arg_dt2)
    })
}
pub unsafe fn date_cmp_timestamptz_internal(arg_dateVal: DateADT, arg_dt2: TimestampTz) -> int32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn date_cmp_timestamptz_internal(arg_dateVal: DateADT, arg_dt2: TimestampTz) -> int32;
        }
        date_cmp_timestamptz_internal(arg_dateVal, arg_dt2)
    })
}
pub unsafe fn EncodeSpecialDate(arg_dt: DateADT, arg_str_: *mut ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn EncodeSpecialDate(arg_dt: DateADT, arg_str_: *mut ::std::os::raw::c_char);
        }
        EncodeSpecialDate(arg_dt, arg_str_)
    })
}
pub unsafe fn GetSQLCurrentDate() -> DateADT {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetSQLCurrentDate() -> DateADT;
        }
        GetSQLCurrentDate()
    })
}
pub unsafe fn GetSQLCurrentTime(arg_typmod: int32) -> *mut TimeTzADT {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetSQLCurrentTime(arg_typmod: int32) -> *mut TimeTzADT;
        }
        GetSQLCurrentTime(arg_typmod)
    })
}
pub unsafe fn GetSQLLocalTime(arg_typmod: int32) -> TimeADT {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetSQLLocalTime(arg_typmod: int32) -> TimeADT;
        }
        GetSQLLocalTime(arg_typmod)
    })
}
pub unsafe fn time2tm(
    arg_time: TimeADT,
    arg_tm: *mut pg_tm,
    arg_fsec: *mut fsec_t,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn time2tm(
                arg_time: TimeADT,
                arg_tm: *mut pg_tm,
                arg_fsec: *mut fsec_t,
            ) -> ::std::os::raw::c_int;
        }
        time2tm(arg_time, arg_tm, arg_fsec)
    })
}
pub unsafe fn timetz2tm(
    arg_time: *mut TimeTzADT,
    arg_tm: *mut pg_tm,
    arg_fsec: *mut fsec_t,
    arg_tzp: *mut ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn timetz2tm(
                arg_time: *mut TimeTzADT,
                arg_tm: *mut pg_tm,
                arg_fsec: *mut fsec_t,
                arg_tzp: *mut ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        timetz2tm(arg_time, arg_tm, arg_fsec, arg_tzp)
    })
}
pub unsafe fn tm2time(
    arg_tm: *mut pg_tm,
    arg_fsec: fsec_t,
    arg_result: *mut TimeADT,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tm2time(
                arg_tm: *mut pg_tm,
                arg_fsec: fsec_t,
                arg_result: *mut TimeADT,
            ) -> ::std::os::raw::c_int;
        }
        tm2time(arg_tm, arg_fsec, arg_result)
    })
}
pub unsafe fn tm2timetz(
    arg_tm: *mut pg_tm,
    arg_fsec: fsec_t,
    arg_tz: ::std::os::raw::c_int,
    arg_result: *mut TimeTzADT,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn tm2timetz(
                arg_tm: *mut pg_tm,
                arg_fsec: fsec_t,
                arg_tz: ::std::os::raw::c_int,
                arg_result: *mut TimeTzADT,
            ) -> ::std::os::raw::c_int;
        }
        tm2timetz(arg_tm, arg_fsec, arg_tz, arg_result)
    })
}
pub unsafe fn time_overflows(
    arg_hour: ::std::os::raw::c_int,
    arg_min: ::std::os::raw::c_int,
    arg_sec: ::std::os::raw::c_int,
    arg_fsec: fsec_t,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn time_overflows(
                arg_hour: ::std::os::raw::c_int,
                arg_min: ::std::os::raw::c_int,
                arg_sec: ::std::os::raw::c_int,
                arg_fsec: fsec_t,
            ) -> bool;
        }
        time_overflows(arg_hour, arg_min, arg_sec, arg_fsec)
    })
}
pub unsafe fn float_time_overflows(
    arg_hour: ::std::os::raw::c_int,
    arg_min: ::std::os::raw::c_int,
    arg_sec: f64,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn float_time_overflows(
                arg_hour: ::std::os::raw::c_int,
                arg_min: ::std::os::raw::c_int,
                arg_sec: f64,
            ) -> bool;
        }
        float_time_overflows(arg_hour, arg_min, arg_sec)
    })
}
pub unsafe fn AdjustTimeForTypmod(arg_time: *mut TimeADT, arg_typmod: int32) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn AdjustTimeForTypmod(arg_time: *mut TimeADT, arg_typmod: int32);
        }
        AdjustTimeForTypmod(arg_time, arg_typmod)
    })
}
extern "C" {
    pub static mut extra_float_digits: ::std::os::raw::c_int;
}
pub unsafe fn float_overflow_error() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn float_overflow_error();
        }
        float_overflow_error()
    })
}
pub unsafe fn float_underflow_error() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn float_underflow_error();
        }
        float_underflow_error()
    })
}
pub unsafe fn float_zero_divide_error() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn float_zero_divide_error();
        }
        float_zero_divide_error()
    })
}
pub unsafe fn is_infinite(arg_val: float8) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn is_infinite(arg_val: float8) -> ::std::os::raw::c_int;
        }
        is_infinite(arg_val)
    })
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Point {
    pub x: float8,
    pub y: float8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LSEG {
    pub p: [Point; 2usize],
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct PATH {
    pub vl_len_: int32,
    pub npts: int32,
    pub closed: int32,
    pub dummy: int32,
    pub p: __IncompleteArrayField<Point>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LINE {
    pub A: float8,
    pub B: float8,
    pub C: float8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct BOX {
    pub high: Point,
    pub low: Point,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct POLYGON {
    pub vl_len_: int32,
    pub npts: int32,
    pub boundbox: BOX,
    pub p: __IncompleteArrayField<Point>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CIRCLE {
    pub center: Point,
    pub radius: float8,
}
pub unsafe fn pg_hypot(arg_x: float8, arg_y: float8) -> float8 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pg_hypot(arg_x: float8, arg_y: float8) -> float8;
        }
        pg_hypot(arg_x, arg_y)
    })
}
pub unsafe fn escape_json(arg_buf: StringInfo, arg_str_: *const ::std::os::raw::c_char) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn escape_json(arg_buf: StringInfo, arg_str_: *const ::std::os::raw::c_char);
        }
        escape_json(arg_buf, arg_str_)
    })
}
pub unsafe fn JsonEncodeDateTime(
    arg_buf: *mut ::std::os::raw::c_char,
    arg_value: Datum,
    arg_typid: Oid,
    arg_tzp: *const ::std::os::raw::c_int,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn JsonEncodeDateTime(
                arg_buf: *mut ::std::os::raw::c_char,
                arg_value: Datum,
                arg_typid: Oid,
                arg_tzp: *const ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_char;
        }
        JsonEncodeDateTime(arg_buf, arg_value, arg_typid, arg_tzp)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NumericData {
    _unused: [u8; 0],
}
pub type Numeric = *mut NumericData;
pub unsafe fn numeric_is_nan(arg_num: Numeric) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_is_nan(arg_num: Numeric) -> bool;
        }
        numeric_is_nan(arg_num)
    })
}
pub unsafe fn numeric_maximum_size(arg_typmod: int32) -> int32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_maximum_size(arg_typmod: int32) -> int32;
        }
        numeric_maximum_size(arg_typmod)
    })
}
pub unsafe fn numeric_out_sci(
    arg_num: Numeric,
    arg_scale: ::std::os::raw::c_int,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_out_sci(
                arg_num: Numeric,
                arg_scale: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_char;
        }
        numeric_out_sci(arg_num, arg_scale)
    })
}
pub unsafe fn numeric_normalize(arg_num: Numeric) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_normalize(arg_num: Numeric) -> *mut ::std::os::raw::c_char;
        }
        numeric_normalize(arg_num)
    })
}
pub unsafe fn numeric_add_opt_error(
    arg_num1: Numeric,
    arg_num2: Numeric,
    arg_have_error: *mut bool,
) -> Numeric {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_add_opt_error(
                arg_num1: Numeric,
                arg_num2: Numeric,
                arg_have_error: *mut bool,
            ) -> Numeric;
        }
        numeric_add_opt_error(arg_num1, arg_num2, arg_have_error)
    })
}
pub unsafe fn numeric_sub_opt_error(
    arg_num1: Numeric,
    arg_num2: Numeric,
    arg_have_error: *mut bool,
) -> Numeric {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_sub_opt_error(
                arg_num1: Numeric,
                arg_num2: Numeric,
                arg_have_error: *mut bool,
            ) -> Numeric;
        }
        numeric_sub_opt_error(arg_num1, arg_num2, arg_have_error)
    })
}
pub unsafe fn numeric_mul_opt_error(
    arg_num1: Numeric,
    arg_num2: Numeric,
    arg_have_error: *mut bool,
) -> Numeric {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_mul_opt_error(
                arg_num1: Numeric,
                arg_num2: Numeric,
                arg_have_error: *mut bool,
            ) -> Numeric;
        }
        numeric_mul_opt_error(arg_num1, arg_num2, arg_have_error)
    })
}
pub unsafe fn numeric_div_opt_error(
    arg_num1: Numeric,
    arg_num2: Numeric,
    arg_have_error: *mut bool,
) -> Numeric {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_div_opt_error(
                arg_num1: Numeric,
                arg_num2: Numeric,
                arg_have_error: *mut bool,
            ) -> Numeric;
        }
        numeric_div_opt_error(arg_num1, arg_num2, arg_have_error)
    })
}
pub unsafe fn numeric_mod_opt_error(
    arg_num1: Numeric,
    arg_num2: Numeric,
    arg_have_error: *mut bool,
) -> Numeric {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_mod_opt_error(
                arg_num1: Numeric,
                arg_num2: Numeric,
                arg_have_error: *mut bool,
            ) -> Numeric;
        }
        numeric_mod_opt_error(arg_num1, arg_num2, arg_have_error)
    })
}
pub unsafe fn numeric_int4_opt_error(arg_num: Numeric, arg_error: *mut bool) -> int32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn numeric_int4_opt_error(arg_num: Numeric, arg_error: *mut bool) -> int32;
        }
        numeric_int4_opt_error(arg_num, arg_error)
    })
}
pub const JsonbIteratorToken_WJB_DONE: JsonbIteratorToken = 0;
pub const JsonbIteratorToken_WJB_KEY: JsonbIteratorToken = 1;
pub const JsonbIteratorToken_WJB_VALUE: JsonbIteratorToken = 2;
pub const JsonbIteratorToken_WJB_ELEM: JsonbIteratorToken = 3;
pub const JsonbIteratorToken_WJB_BEGIN_ARRAY: JsonbIteratorToken = 4;
pub const JsonbIteratorToken_WJB_END_ARRAY: JsonbIteratorToken = 5;
pub const JsonbIteratorToken_WJB_BEGIN_OBJECT: JsonbIteratorToken = 6;
pub const JsonbIteratorToken_WJB_END_OBJECT: JsonbIteratorToken = 7;
pub type JsonbIteratorToken = ::std::os::raw::c_uint;
pub type JEntry = uint32;
#[repr(C)]
#[derive(Debug, Default)]
pub struct JsonbContainer {
    pub header: uint32,
    pub children: __IncompleteArrayField<JEntry>,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct Jsonb {
    pub vl_len_: int32,
    pub root: JsonbContainer,
}
pub const jbvType_jbvNull: jbvType = 0;
pub const jbvType_jbvString: jbvType = 1;
pub const jbvType_jbvNumeric: jbvType = 2;
pub const jbvType_jbvBool: jbvType = 3;
pub const jbvType_jbvArray: jbvType = 16;
pub const jbvType_jbvObject: jbvType = 17;
pub const jbvType_jbvBinary: jbvType = 18;
pub const jbvType_jbvDatetime: jbvType = 32;
pub type jbvType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct JsonbValue {
    pub type_: jbvType,
    pub val: JsonbValue__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union JsonbValue__bindgen_ty_1 {
    pub numeric: Numeric,
    pub boolean: bool,
    pub string: JsonbValue__bindgen_ty_1__bindgen_ty_1,
    pub array: JsonbValue__bindgen_ty_1__bindgen_ty_2,
    pub object: JsonbValue__bindgen_ty_1__bindgen_ty_3,
    pub binary: JsonbValue__bindgen_ty_1__bindgen_ty_4,
    pub datetime: JsonbValue__bindgen_ty_1__bindgen_ty_5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonbValue__bindgen_ty_1__bindgen_ty_1 {
    pub len: ::std::os::raw::c_int,
    pub val: *mut ::std::os::raw::c_char,
}
impl Default for JsonbValue__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonbValue__bindgen_ty_1__bindgen_ty_2 {
    pub nElems: ::std::os::raw::c_int,
    pub elems: *mut JsonbValue,
    pub rawScalar: bool,
}
impl Default for JsonbValue__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonbValue__bindgen_ty_1__bindgen_ty_3 {
    pub nPairs: ::std::os::raw::c_int,
    pub pairs: *mut JsonbPair,
}
impl Default for JsonbValue__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonbValue__bindgen_ty_1__bindgen_ty_4 {
    pub len: ::std::os::raw::c_int,
    pub data: *mut JsonbContainer,
}
impl Default for JsonbValue__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonbValue__bindgen_ty_1__bindgen_ty_5 {
    pub value: Datum,
    pub typid: Oid,
    pub typmod: int32,
    pub tz: ::std::os::raw::c_int,
}
impl Default for JsonbValue__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for JsonbValue__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for JsonbValue {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct JsonbPair {
    pub key: JsonbValue,
    pub value: JsonbValue,
    pub order: uint32,
}
impl Default for JsonbPair {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct JsonbParseState {
    pub contVal: JsonbValue,
    pub size: Size,
    pub next: *mut JsonbParseState,
}
impl Default for JsonbParseState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const JsonbIterState_JBI_ARRAY_START: JsonbIterState = 0;
pub const JsonbIterState_JBI_ARRAY_ELEM: JsonbIterState = 1;
pub const JsonbIterState_JBI_OBJECT_START: JsonbIterState = 2;
pub const JsonbIterState_JBI_OBJECT_KEY: JsonbIterState = 3;
pub const JsonbIterState_JBI_OBJECT_VALUE: JsonbIterState = 4;
pub type JsonbIterState = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JsonbIterator {
    pub container: *mut JsonbContainer,
    pub nElems: uint32,
    pub isScalar: bool,
    pub children: *mut JEntry,
    pub dataProper: *mut ::std::os::raw::c_char,
    pub curIndex: ::std::os::raw::c_int,
    pub curDataOffset: uint32,
    pub curValueOffset: uint32,
    pub state: JsonbIterState,
    pub parent: *mut JsonbIterator,
}
impl Default for JsonbIterator {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn getJsonbOffset(
    arg_jc: *const JsonbContainer,
    arg_index: ::std::os::raw::c_int,
) -> uint32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getJsonbOffset(
                arg_jc: *const JsonbContainer,
                arg_index: ::std::os::raw::c_int,
            ) -> uint32;
        }
        getJsonbOffset(arg_jc, arg_index)
    })
}
pub unsafe fn getJsonbLength(
    arg_jc: *const JsonbContainer,
    arg_index: ::std::os::raw::c_int,
) -> uint32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getJsonbLength(
                arg_jc: *const JsonbContainer,
                arg_index: ::std::os::raw::c_int,
            ) -> uint32;
        }
        getJsonbLength(arg_jc, arg_index)
    })
}
pub unsafe fn compareJsonbContainers(
    arg_a: *mut JsonbContainer,
    arg_b: *mut JsonbContainer,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn compareJsonbContainers(
                arg_a: *mut JsonbContainer,
                arg_b: *mut JsonbContainer,
            ) -> ::std::os::raw::c_int;
        }
        compareJsonbContainers(arg_a, arg_b)
    })
}
pub unsafe fn findJsonbValueFromContainer(
    arg_sheader: *mut JsonbContainer,
    arg_flags: uint32,
    arg_key: *mut JsonbValue,
) -> *mut JsonbValue {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn findJsonbValueFromContainer(
                arg_sheader: *mut JsonbContainer,
                arg_flags: uint32,
                arg_key: *mut JsonbValue,
            ) -> *mut JsonbValue;
        }
        findJsonbValueFromContainer(arg_sheader, arg_flags, arg_key)
    })
}
pub unsafe fn getKeyJsonValueFromContainer(
    arg_container: *mut JsonbContainer,
    arg_keyVal: *const ::std::os::raw::c_char,
    arg_keyLen: ::std::os::raw::c_int,
    arg_res: *mut JsonbValue,
) -> *mut JsonbValue {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getKeyJsonValueFromContainer(
                arg_container: *mut JsonbContainer,
                arg_keyVal: *const ::std::os::raw::c_char,
                arg_keyLen: ::std::os::raw::c_int,
                arg_res: *mut JsonbValue,
            ) -> *mut JsonbValue;
        }
        getKeyJsonValueFromContainer(arg_container, arg_keyVal, arg_keyLen, arg_res)
    })
}
pub unsafe fn getIthJsonbValueFromContainer(
    arg_sheader: *mut JsonbContainer,
    arg_i: uint32,
) -> *mut JsonbValue {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getIthJsonbValueFromContainer(
                arg_sheader: *mut JsonbContainer,
                arg_i: uint32,
            ) -> *mut JsonbValue;
        }
        getIthJsonbValueFromContainer(arg_sheader, arg_i)
    })
}
pub unsafe fn pushJsonbValue(
    arg_pstate: *mut *mut JsonbParseState,
    arg_seq: JsonbIteratorToken,
    arg_jbval: *mut JsonbValue,
) -> *mut JsonbValue {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn pushJsonbValue(
                arg_pstate: *mut *mut JsonbParseState,
                arg_seq: JsonbIteratorToken,
                arg_jbval: *mut JsonbValue,
            ) -> *mut JsonbValue;
        }
        pushJsonbValue(arg_pstate, arg_seq, arg_jbval)
    })
}
pub unsafe fn JsonbIteratorInit(arg_container: *mut JsonbContainer) -> *mut JsonbIterator {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn JsonbIteratorInit(arg_container: *mut JsonbContainer) -> *mut JsonbIterator;
        }
        JsonbIteratorInit(arg_container)
    })
}
pub unsafe fn JsonbIteratorNext(
    arg_it: *mut *mut JsonbIterator,
    arg_val: *mut JsonbValue,
    arg_skipNested: bool,
) -> JsonbIteratorToken {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn JsonbIteratorNext(
                arg_it: *mut *mut JsonbIterator,
                arg_val: *mut JsonbValue,
                arg_skipNested: bool,
            ) -> JsonbIteratorToken;
        }
        JsonbIteratorNext(arg_it, arg_val, arg_skipNested)
    })
}
pub unsafe fn JsonbValueToJsonb(arg_val: *mut JsonbValue) -> *mut Jsonb {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn JsonbValueToJsonb(arg_val: *mut JsonbValue) -> *mut Jsonb;
        }
        JsonbValueToJsonb(arg_val)
    })
}
pub unsafe fn JsonbDeepContains(
    arg_val: *mut *mut JsonbIterator,
    arg_mContained: *mut *mut JsonbIterator,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn JsonbDeepContains(
                arg_val: *mut *mut JsonbIterator,
                arg_mContained: *mut *mut JsonbIterator,
            ) -> bool;
        }
        JsonbDeepContains(arg_val, arg_mContained)
    })
}
pub unsafe fn JsonbHashScalarValue(arg_scalarVal: *const JsonbValue, arg_hash: *mut uint32) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn JsonbHashScalarValue(arg_scalarVal: *const JsonbValue, arg_hash: *mut uint32);
        }
        JsonbHashScalarValue(arg_scalarVal, arg_hash)
    })
}
pub unsafe fn JsonbHashScalarValueExtended(
    arg_scalarVal: *const JsonbValue,
    arg_hash: *mut uint64,
    arg_seed: uint64,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn JsonbHashScalarValueExtended(
                arg_scalarVal: *const JsonbValue,
                arg_hash: *mut uint64,
                arg_seed: uint64,
            );
        }
        JsonbHashScalarValueExtended(arg_scalarVal, arg_hash, arg_seed)
    })
}
pub unsafe fn JsonbToCString(
    arg_out: StringInfo,
    arg_in_: *mut JsonbContainer,
    arg_estimated_len: ::std::os::raw::c_int,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn JsonbToCString(
                arg_out: StringInfo,
                arg_in_: *mut JsonbContainer,
                arg_estimated_len: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_char;
        }
        JsonbToCString(arg_out, arg_in_, arg_estimated_len)
    })
}
pub unsafe fn JsonbToCStringIndent(
    arg_out: StringInfo,
    arg_in_: *mut JsonbContainer,
    arg_estimated_len: ::std::os::raw::c_int,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn JsonbToCStringIndent(
                arg_out: StringInfo,
                arg_in_: *mut JsonbContainer,
                arg_estimated_len: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_char;
        }
        JsonbToCStringIndent(arg_out, arg_in_, arg_estimated_len)
    })
}
pub unsafe fn JsonbExtractScalar(arg_jbc: *mut JsonbContainer, arg_res: *mut JsonbValue) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn JsonbExtractScalar(arg_jbc: *mut JsonbContainer, arg_res: *mut JsonbValue) -> bool;
        }
        JsonbExtractScalar(arg_jbc, arg_res)
    })
}
pub unsafe fn JsonbTypeName(arg_jb: *mut JsonbValue) -> *const ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn JsonbTypeName(arg_jb: *mut JsonbValue) -> *const ::std::os::raw::c_char;
        }
        JsonbTypeName(arg_jb)
    })
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct OpBtreeInterpretation {
    pub opfamily_id: Oid,
    pub strategy: ::std::os::raw::c_int,
    pub oplefttype: Oid,
    pub oprighttype: Oid,
}
pub const IOFuncSelector_IOFunc_input: IOFuncSelector = 0;
pub const IOFuncSelector_IOFunc_output: IOFuncSelector = 1;
pub const IOFuncSelector_IOFunc_receive: IOFuncSelector = 2;
pub const IOFuncSelector_IOFunc_send: IOFuncSelector = 3;
pub type IOFuncSelector = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AttStatsSlot {
    pub staop: Oid,
    pub stacoll: Oid,
    pub valuetype: Oid,
    pub values: *mut Datum,
    pub nvalues: ::std::os::raw::c_int,
    pub numbers: *mut float4,
    pub nnumbers: ::std::os::raw::c_int,
    pub values_arr: *mut ::std::os::raw::c_void,
    pub numbers_arr: *mut ::std::os::raw::c_void,
}
impl Default for AttStatsSlot {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type get_attavgwidth_hook_type =
    ::std::option::Option<unsafe extern "C" fn(relid: Oid, attnum: AttrNumber) -> int32>;
extern "C" {
    pub static mut get_attavgwidth_hook: get_attavgwidth_hook_type;
}
pub unsafe fn op_in_opfamily(arg_opno: Oid, arg_opfamily: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn op_in_opfamily(arg_opno: Oid, arg_opfamily: Oid) -> bool;
        }
        op_in_opfamily(arg_opno, arg_opfamily)
    })
}
pub unsafe fn get_op_opfamily_strategy(arg_opno: Oid, arg_opfamily: Oid) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_op_opfamily_strategy(arg_opno: Oid, arg_opfamily: Oid) -> ::std::os::raw::c_int;
        }
        get_op_opfamily_strategy(arg_opno, arg_opfamily)
    })
}
pub unsafe fn get_op_opfamily_sortfamily(arg_opno: Oid, arg_opfamily: Oid) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_op_opfamily_sortfamily(arg_opno: Oid, arg_opfamily: Oid) -> Oid;
        }
        get_op_opfamily_sortfamily(arg_opno, arg_opfamily)
    })
}
pub unsafe fn get_op_opfamily_properties(
    arg_opno: Oid,
    arg_opfamily: Oid,
    arg_ordering_op: bool,
    arg_strategy: *mut ::std::os::raw::c_int,
    arg_lefttype: *mut Oid,
    arg_righttype: *mut Oid,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_op_opfamily_properties(
                arg_opno: Oid,
                arg_opfamily: Oid,
                arg_ordering_op: bool,
                arg_strategy: *mut ::std::os::raw::c_int,
                arg_lefttype: *mut Oid,
                arg_righttype: *mut Oid,
            );
        }
        get_op_opfamily_properties(
            arg_opno,
            arg_opfamily,
            arg_ordering_op,
            arg_strategy,
            arg_lefttype,
            arg_righttype,
        )
    })
}
pub unsafe fn get_opfamily_member(
    arg_opfamily: Oid,
    arg_lefttype: Oid,
    arg_righttype: Oid,
    arg_strategy: int16,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_opfamily_member(
                arg_opfamily: Oid,
                arg_lefttype: Oid,
                arg_righttype: Oid,
                arg_strategy: int16,
            ) -> Oid;
        }
        get_opfamily_member(arg_opfamily, arg_lefttype, arg_righttype, arg_strategy)
    })
}
pub unsafe fn get_ordering_op_properties(
    arg_opno: Oid,
    arg_opfamily: *mut Oid,
    arg_opcintype: *mut Oid,
    arg_strategy: *mut int16,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_ordering_op_properties(
                arg_opno: Oid,
                arg_opfamily: *mut Oid,
                arg_opcintype: *mut Oid,
                arg_strategy: *mut int16,
            ) -> bool;
        }
        get_ordering_op_properties(arg_opno, arg_opfamily, arg_opcintype, arg_strategy)
    })
}
pub unsafe fn get_equality_op_for_ordering_op(arg_opno: Oid, arg_reverse: *mut bool) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_equality_op_for_ordering_op(arg_opno: Oid, arg_reverse: *mut bool) -> Oid;
        }
        get_equality_op_for_ordering_op(arg_opno, arg_reverse)
    })
}
pub unsafe fn get_ordering_op_for_equality_op(arg_opno: Oid, arg_use_lhs_type: bool) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_ordering_op_for_equality_op(arg_opno: Oid, arg_use_lhs_type: bool) -> Oid;
        }
        get_ordering_op_for_equality_op(arg_opno, arg_use_lhs_type)
    })
}
pub unsafe fn get_mergejoin_opfamilies(arg_opno: Oid) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_mergejoin_opfamilies(arg_opno: Oid) -> *mut List;
        }
        get_mergejoin_opfamilies(arg_opno)
    })
}
pub unsafe fn get_compatible_hash_operators(
    arg_opno: Oid,
    arg_lhs_opno: *mut Oid,
    arg_rhs_opno: *mut Oid,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_compatible_hash_operators(
                arg_opno: Oid,
                arg_lhs_opno: *mut Oid,
                arg_rhs_opno: *mut Oid,
            ) -> bool;
        }
        get_compatible_hash_operators(arg_opno, arg_lhs_opno, arg_rhs_opno)
    })
}
pub unsafe fn get_op_hash_functions(
    arg_opno: Oid,
    arg_lhs_procno: *mut RegProcedure,
    arg_rhs_procno: *mut RegProcedure,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_op_hash_functions(
                arg_opno: Oid,
                arg_lhs_procno: *mut RegProcedure,
                arg_rhs_procno: *mut RegProcedure,
            ) -> bool;
        }
        get_op_hash_functions(arg_opno, arg_lhs_procno, arg_rhs_procno)
    })
}
pub unsafe fn get_op_btree_interpretation(arg_opno: Oid) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_op_btree_interpretation(arg_opno: Oid) -> *mut List;
        }
        get_op_btree_interpretation(arg_opno)
    })
}
pub unsafe fn equality_ops_are_compatible(arg_opno1: Oid, arg_opno2: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn equality_ops_are_compatible(arg_opno1: Oid, arg_opno2: Oid) -> bool;
        }
        equality_ops_are_compatible(arg_opno1, arg_opno2)
    })
}
pub unsafe fn comparison_ops_are_compatible(arg_opno1: Oid, arg_opno2: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn comparison_ops_are_compatible(arg_opno1: Oid, arg_opno2: Oid) -> bool;
        }
        comparison_ops_are_compatible(arg_opno1, arg_opno2)
    })
}
pub unsafe fn get_opfamily_proc(
    arg_opfamily: Oid,
    arg_lefttype: Oid,
    arg_righttype: Oid,
    arg_procnum: int16,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_opfamily_proc(
                arg_opfamily: Oid,
                arg_lefttype: Oid,
                arg_righttype: Oid,
                arg_procnum: int16,
            ) -> Oid;
        }
        get_opfamily_proc(arg_opfamily, arg_lefttype, arg_righttype, arg_procnum)
    })
}
pub unsafe fn get_attname(
    arg_relid: Oid,
    arg_attnum: AttrNumber,
    arg_missing_ok: bool,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_attname(
                arg_relid: Oid,
                arg_attnum: AttrNumber,
                arg_missing_ok: bool,
            ) -> *mut ::std::os::raw::c_char;
        }
        get_attname(arg_relid, arg_attnum, arg_missing_ok)
    })
}
pub unsafe fn get_attnum(arg_relid: Oid, arg_attname: *const ::std::os::raw::c_char) -> AttrNumber {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_attnum(arg_relid: Oid, arg_attname: *const ::std::os::raw::c_char)
                -> AttrNumber;
        }
        get_attnum(arg_relid, arg_attname)
    })
}
pub unsafe fn get_attstattarget(arg_relid: Oid, arg_attnum: AttrNumber) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_attstattarget(arg_relid: Oid, arg_attnum: AttrNumber) -> ::std::os::raw::c_int;
        }
        get_attstattarget(arg_relid, arg_attnum)
    })
}
pub unsafe fn get_attgenerated(arg_relid: Oid, arg_attnum: AttrNumber) -> ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_attgenerated(arg_relid: Oid, arg_attnum: AttrNumber) -> ::std::os::raw::c_char;
        }
        get_attgenerated(arg_relid, arg_attnum)
    })
}
pub unsafe fn get_atttype(arg_relid: Oid, arg_attnum: AttrNumber) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_atttype(arg_relid: Oid, arg_attnum: AttrNumber) -> Oid;
        }
        get_atttype(arg_relid, arg_attnum)
    })
}
pub unsafe fn get_atttypetypmodcoll(
    arg_relid: Oid,
    arg_attnum: AttrNumber,
    arg_typid: *mut Oid,
    arg_typmod: *mut int32,
    arg_collid: *mut Oid,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_atttypetypmodcoll(
                arg_relid: Oid,
                arg_attnum: AttrNumber,
                arg_typid: *mut Oid,
                arg_typmod: *mut int32,
                arg_collid: *mut Oid,
            );
        }
        get_atttypetypmodcoll(arg_relid, arg_attnum, arg_typid, arg_typmod, arg_collid)
    })
}
pub unsafe fn get_attoptions(arg_relid: Oid, arg_attnum: int16) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_attoptions(arg_relid: Oid, arg_attnum: int16) -> Datum;
        }
        get_attoptions(arg_relid, arg_attnum)
    })
}
pub unsafe fn get_cast_oid(
    arg_sourcetypeid: Oid,
    arg_targettypeid: Oid,
    arg_missing_ok: bool,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_cast_oid(
                arg_sourcetypeid: Oid,
                arg_targettypeid: Oid,
                arg_missing_ok: bool,
            ) -> Oid;
        }
        get_cast_oid(arg_sourcetypeid, arg_targettypeid, arg_missing_ok)
    })
}
pub unsafe fn get_collation_name(arg_colloid: Oid) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_collation_name(arg_colloid: Oid) -> *mut ::std::os::raw::c_char;
        }
        get_collation_name(arg_colloid)
    })
}
pub unsafe fn get_collation_isdeterministic(arg_colloid: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_collation_isdeterministic(arg_colloid: Oid) -> bool;
        }
        get_collation_isdeterministic(arg_colloid)
    })
}
pub unsafe fn get_constraint_name(arg_conoid: Oid) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_constraint_name(arg_conoid: Oid) -> *mut ::std::os::raw::c_char;
        }
        get_constraint_name(arg_conoid)
    })
}
pub unsafe fn get_language_name(
    arg_langoid: Oid,
    arg_missing_ok: bool,
) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_language_name(
                arg_langoid: Oid,
                arg_missing_ok: bool,
            ) -> *mut ::std::os::raw::c_char;
        }
        get_language_name(arg_langoid, arg_missing_ok)
    })
}
pub unsafe fn get_opclass_family(arg_opclass: Oid) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_opclass_family(arg_opclass: Oid) -> Oid;
        }
        get_opclass_family(arg_opclass)
    })
}
pub unsafe fn get_opclass_input_type(arg_opclass: Oid) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_opclass_input_type(arg_opclass: Oid) -> Oid;
        }
        get_opclass_input_type(arg_opclass)
    })
}
pub unsafe fn get_opclass_opfamily_and_input_type(
    arg_opclass: Oid,
    arg_opfamily: *mut Oid,
    arg_opcintype: *mut Oid,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_opclass_opfamily_and_input_type(
                arg_opclass: Oid,
                arg_opfamily: *mut Oid,
                arg_opcintype: *mut Oid,
            ) -> bool;
        }
        get_opclass_opfamily_and_input_type(arg_opclass, arg_opfamily, arg_opcintype)
    })
}
pub unsafe fn get_opcode(arg_opno: Oid) -> RegProcedure {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_opcode(arg_opno: Oid) -> RegProcedure;
        }
        get_opcode(arg_opno)
    })
}
pub unsafe fn get_opname(arg_opno: Oid) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_opname(arg_opno: Oid) -> *mut ::std::os::raw::c_char;
        }
        get_opname(arg_opno)
    })
}
pub unsafe fn get_op_rettype(arg_opno: Oid) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_op_rettype(arg_opno: Oid) -> Oid;
        }
        get_op_rettype(arg_opno)
    })
}
pub unsafe fn op_input_types(arg_opno: Oid, arg_lefttype: *mut Oid, arg_righttype: *mut Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn op_input_types(arg_opno: Oid, arg_lefttype: *mut Oid, arg_righttype: *mut Oid);
        }
        op_input_types(arg_opno, arg_lefttype, arg_righttype)
    })
}
pub unsafe fn op_mergejoinable(arg_opno: Oid, arg_inputtype: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn op_mergejoinable(arg_opno: Oid, arg_inputtype: Oid) -> bool;
        }
        op_mergejoinable(arg_opno, arg_inputtype)
    })
}
pub unsafe fn op_hashjoinable(arg_opno: Oid, arg_inputtype: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn op_hashjoinable(arg_opno: Oid, arg_inputtype: Oid) -> bool;
        }
        op_hashjoinable(arg_opno, arg_inputtype)
    })
}
pub unsafe fn op_strict(arg_opno: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn op_strict(arg_opno: Oid) -> bool;
        }
        op_strict(arg_opno)
    })
}
pub unsafe fn op_volatile(arg_opno: Oid) -> ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn op_volatile(arg_opno: Oid) -> ::std::os::raw::c_char;
        }
        op_volatile(arg_opno)
    })
}
pub unsafe fn get_commutator(arg_opno: Oid) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_commutator(arg_opno: Oid) -> Oid;
        }
        get_commutator(arg_opno)
    })
}
pub unsafe fn get_negator(arg_opno: Oid) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_negator(arg_opno: Oid) -> Oid;
        }
        get_negator(arg_opno)
    })
}
pub unsafe fn get_oprrest(arg_opno: Oid) -> RegProcedure {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_oprrest(arg_opno: Oid) -> RegProcedure;
        }
        get_oprrest(arg_opno)
    })
}
pub unsafe fn get_oprjoin(arg_opno: Oid) -> RegProcedure {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_oprjoin(arg_opno: Oid) -> RegProcedure;
        }
        get_oprjoin(arg_opno)
    })
}
pub unsafe fn get_func_name(arg_funcid: Oid) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_func_name(arg_funcid: Oid) -> *mut ::std::os::raw::c_char;
        }
        get_func_name(arg_funcid)
    })
}
pub unsafe fn get_func_namespace(arg_funcid: Oid) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_func_namespace(arg_funcid: Oid) -> Oid;
        }
        get_func_namespace(arg_funcid)
    })
}
pub unsafe fn get_func_rettype(arg_funcid: Oid) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_func_rettype(arg_funcid: Oid) -> Oid;
        }
        get_func_rettype(arg_funcid)
    })
}
pub unsafe fn get_func_nargs(arg_funcid: Oid) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_func_nargs(arg_funcid: Oid) -> ::std::os::raw::c_int;
        }
        get_func_nargs(arg_funcid)
    })
}
pub unsafe fn get_func_signature(
    arg_funcid: Oid,
    arg_argtypes: *mut *mut Oid,
    arg_nargs: *mut ::std::os::raw::c_int,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_func_signature(
                arg_funcid: Oid,
                arg_argtypes: *mut *mut Oid,
                arg_nargs: *mut ::std::os::raw::c_int,
            ) -> Oid;
        }
        get_func_signature(arg_funcid, arg_argtypes, arg_nargs)
    })
}
pub unsafe fn get_func_variadictype(arg_funcid: Oid) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_func_variadictype(arg_funcid: Oid) -> Oid;
        }
        get_func_variadictype(arg_funcid)
    })
}
pub unsafe fn get_func_retset(arg_funcid: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_func_retset(arg_funcid: Oid) -> bool;
        }
        get_func_retset(arg_funcid)
    })
}
pub unsafe fn func_strict(arg_funcid: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn func_strict(arg_funcid: Oid) -> bool;
        }
        func_strict(arg_funcid)
    })
}
pub unsafe fn func_volatile(arg_funcid: Oid) -> ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn func_volatile(arg_funcid: Oid) -> ::std::os::raw::c_char;
        }
        func_volatile(arg_funcid)
    })
}
pub unsafe fn func_parallel(arg_funcid: Oid) -> ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn func_parallel(arg_funcid: Oid) -> ::std::os::raw::c_char;
        }
        func_parallel(arg_funcid)
    })
}
pub unsafe fn get_func_prokind(arg_funcid: Oid) -> ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_func_prokind(arg_funcid: Oid) -> ::std::os::raw::c_char;
        }
        get_func_prokind(arg_funcid)
    })
}
pub unsafe fn get_func_leakproof(arg_funcid: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_func_leakproof(arg_funcid: Oid) -> bool;
        }
        get_func_leakproof(arg_funcid)
    })
}
pub unsafe fn get_func_support(arg_funcid: Oid) -> RegProcedure {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_func_support(arg_funcid: Oid) -> RegProcedure;
        }
        get_func_support(arg_funcid)
    })
}
pub unsafe fn get_relname_relid(
    arg_relname: *const ::std::os::raw::c_char,
    arg_relnamespace: Oid,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_relname_relid(
                arg_relname: *const ::std::os::raw::c_char,
                arg_relnamespace: Oid,
            ) -> Oid;
        }
        get_relname_relid(arg_relname, arg_relnamespace)
    })
}
pub unsafe fn get_rel_name(arg_relid: Oid) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_rel_name(arg_relid: Oid) -> *mut ::std::os::raw::c_char;
        }
        get_rel_name(arg_relid)
    })
}
pub unsafe fn get_rel_namespace(arg_relid: Oid) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_rel_namespace(arg_relid: Oid) -> Oid;
        }
        get_rel_namespace(arg_relid)
    })
}
pub unsafe fn get_rel_type_id(arg_relid: Oid) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_rel_type_id(arg_relid: Oid) -> Oid;
        }
        get_rel_type_id(arg_relid)
    })
}
pub unsafe fn get_rel_relkind(arg_relid: Oid) -> ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_rel_relkind(arg_relid: Oid) -> ::std::os::raw::c_char;
        }
        get_rel_relkind(arg_relid)
    })
}
pub unsafe fn get_rel_relispartition(arg_relid: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_rel_relispartition(arg_relid: Oid) -> bool;
        }
        get_rel_relispartition(arg_relid)
    })
}
pub unsafe fn get_rel_tablespace(arg_relid: Oid) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_rel_tablespace(arg_relid: Oid) -> Oid;
        }
        get_rel_tablespace(arg_relid)
    })
}
pub unsafe fn get_rel_persistence(arg_relid: Oid) -> ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_rel_persistence(arg_relid: Oid) -> ::std::os::raw::c_char;
        }
        get_rel_persistence(arg_relid)
    })
}
pub unsafe fn get_transform_fromsql(
    arg_typid: Oid,
    arg_langid: Oid,
    arg_trftypes: *mut List,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_transform_fromsql(
                arg_typid: Oid,
                arg_langid: Oid,
                arg_trftypes: *mut List,
            ) -> Oid;
        }
        get_transform_fromsql(arg_typid, arg_langid, arg_trftypes)
    })
}
pub unsafe fn get_transform_tosql(arg_typid: Oid, arg_langid: Oid, arg_trftypes: *mut List) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_transform_tosql(arg_typid: Oid, arg_langid: Oid, arg_trftypes: *mut List)
                -> Oid;
        }
        get_transform_tosql(arg_typid, arg_langid, arg_trftypes)
    })
}
pub unsafe fn get_typisdefined(arg_typid: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_typisdefined(arg_typid: Oid) -> bool;
        }
        get_typisdefined(arg_typid)
    })
}
pub unsafe fn get_typlen(arg_typid: Oid) -> int16 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_typlen(arg_typid: Oid) -> int16;
        }
        get_typlen(arg_typid)
    })
}
pub unsafe fn get_typbyval(arg_typid: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_typbyval(arg_typid: Oid) -> bool;
        }
        get_typbyval(arg_typid)
    })
}
pub unsafe fn get_typlenbyval(arg_typid: Oid, arg_typlen: *mut int16, arg_typbyval: *mut bool) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_typlenbyval(arg_typid: Oid, arg_typlen: *mut int16, arg_typbyval: *mut bool);
        }
        get_typlenbyval(arg_typid, arg_typlen, arg_typbyval)
    })
}
pub unsafe fn get_typlenbyvalalign(
    arg_typid: Oid,
    arg_typlen: *mut int16,
    arg_typbyval: *mut bool,
    arg_typalign: *mut ::std::os::raw::c_char,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_typlenbyvalalign(
                arg_typid: Oid,
                arg_typlen: *mut int16,
                arg_typbyval: *mut bool,
                arg_typalign: *mut ::std::os::raw::c_char,
            );
        }
        get_typlenbyvalalign(arg_typid, arg_typlen, arg_typbyval, arg_typalign)
    })
}
pub unsafe fn getTypeIOParam(arg_typeTuple: HeapTuple) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getTypeIOParam(arg_typeTuple: HeapTuple) -> Oid;
        }
        getTypeIOParam(arg_typeTuple)
    })
}
pub unsafe fn get_type_io_data(
    arg_typid: Oid,
    arg_which_func: IOFuncSelector,
    arg_typlen: *mut int16,
    arg_typbyval: *mut bool,
    arg_typalign: *mut ::std::os::raw::c_char,
    arg_typdelim: *mut ::std::os::raw::c_char,
    arg_typioparam: *mut Oid,
    arg_func: *mut Oid,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_type_io_data(
                arg_typid: Oid,
                arg_which_func: IOFuncSelector,
                arg_typlen: *mut int16,
                arg_typbyval: *mut bool,
                arg_typalign: *mut ::std::os::raw::c_char,
                arg_typdelim: *mut ::std::os::raw::c_char,
                arg_typioparam: *mut Oid,
                arg_func: *mut Oid,
            );
        }
        get_type_io_data(
            arg_typid,
            arg_which_func,
            arg_typlen,
            arg_typbyval,
            arg_typalign,
            arg_typdelim,
            arg_typioparam,
            arg_func,
        )
    })
}
pub unsafe fn get_typstorage(arg_typid: Oid) -> ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_typstorage(arg_typid: Oid) -> ::std::os::raw::c_char;
        }
        get_typstorage(arg_typid)
    })
}
pub unsafe fn get_typdefault(arg_typid: Oid) -> *mut Node {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_typdefault(arg_typid: Oid) -> *mut Node;
        }
        get_typdefault(arg_typid)
    })
}
pub unsafe fn get_typtype(arg_typid: Oid) -> ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_typtype(arg_typid: Oid) -> ::std::os::raw::c_char;
        }
        get_typtype(arg_typid)
    })
}
pub unsafe fn type_is_rowtype(arg_typid: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn type_is_rowtype(arg_typid: Oid) -> bool;
        }
        type_is_rowtype(arg_typid)
    })
}
pub unsafe fn type_is_enum(arg_typid: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn type_is_enum(arg_typid: Oid) -> bool;
        }
        type_is_enum(arg_typid)
    })
}
pub unsafe fn type_is_range(arg_typid: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn type_is_range(arg_typid: Oid) -> bool;
        }
        type_is_range(arg_typid)
    })
}
pub unsafe fn get_type_category_preferred(
    arg_typid: Oid,
    arg_typcategory: *mut ::std::os::raw::c_char,
    arg_typispreferred: *mut bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_type_category_preferred(
                arg_typid: Oid,
                arg_typcategory: *mut ::std::os::raw::c_char,
                arg_typispreferred: *mut bool,
            );
        }
        get_type_category_preferred(arg_typid, arg_typcategory, arg_typispreferred)
    })
}
pub unsafe fn get_typ_typrelid(arg_typid: Oid) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_typ_typrelid(arg_typid: Oid) -> Oid;
        }
        get_typ_typrelid(arg_typid)
    })
}
pub unsafe fn get_element_type(arg_typid: Oid) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_element_type(arg_typid: Oid) -> Oid;
        }
        get_element_type(arg_typid)
    })
}
pub unsafe fn get_array_type(arg_typid: Oid) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_array_type(arg_typid: Oid) -> Oid;
        }
        get_array_type(arg_typid)
    })
}
pub unsafe fn get_promoted_array_type(arg_typid: Oid) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_promoted_array_type(arg_typid: Oid) -> Oid;
        }
        get_promoted_array_type(arg_typid)
    })
}
pub unsafe fn get_base_element_type(arg_typid: Oid) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_base_element_type(arg_typid: Oid) -> Oid;
        }
        get_base_element_type(arg_typid)
    })
}
pub unsafe fn getTypeInputInfo(arg_type_: Oid, arg_typInput: *mut Oid, arg_typIOParam: *mut Oid) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getTypeInputInfo(arg_type_: Oid, arg_typInput: *mut Oid, arg_typIOParam: *mut Oid);
        }
        getTypeInputInfo(arg_type_, arg_typInput, arg_typIOParam)
    })
}
pub unsafe fn getTypeOutputInfo(
    arg_type_: Oid,
    arg_typOutput: *mut Oid,
    arg_typIsVarlena: *mut bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getTypeOutputInfo(
                arg_type_: Oid,
                arg_typOutput: *mut Oid,
                arg_typIsVarlena: *mut bool,
            );
        }
        getTypeOutputInfo(arg_type_, arg_typOutput, arg_typIsVarlena)
    })
}
pub unsafe fn getTypeBinaryInputInfo(
    arg_type_: Oid,
    arg_typReceive: *mut Oid,
    arg_typIOParam: *mut Oid,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getTypeBinaryInputInfo(
                arg_type_: Oid,
                arg_typReceive: *mut Oid,
                arg_typIOParam: *mut Oid,
            );
        }
        getTypeBinaryInputInfo(arg_type_, arg_typReceive, arg_typIOParam)
    })
}
pub unsafe fn getTypeBinaryOutputInfo(
    arg_type_: Oid,
    arg_typSend: *mut Oid,
    arg_typIsVarlena: *mut bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getTypeBinaryOutputInfo(
                arg_type_: Oid,
                arg_typSend: *mut Oid,
                arg_typIsVarlena: *mut bool,
            );
        }
        getTypeBinaryOutputInfo(arg_type_, arg_typSend, arg_typIsVarlena)
    })
}
pub unsafe fn get_typmodin(arg_typid: Oid) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_typmodin(arg_typid: Oid) -> Oid;
        }
        get_typmodin(arg_typid)
    })
}
pub unsafe fn get_typcollation(arg_typid: Oid) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_typcollation(arg_typid: Oid) -> Oid;
        }
        get_typcollation(arg_typid)
    })
}
pub unsafe fn type_is_collatable(arg_typid: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn type_is_collatable(arg_typid: Oid) -> bool;
        }
        type_is_collatable(arg_typid)
    })
}
pub unsafe fn getBaseType(arg_typid: Oid) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getBaseType(arg_typid: Oid) -> Oid;
        }
        getBaseType(arg_typid)
    })
}
pub unsafe fn getBaseTypeAndTypmod(arg_typid: Oid, arg_typmod: *mut int32) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn getBaseTypeAndTypmod(arg_typid: Oid, arg_typmod: *mut int32) -> Oid;
        }
        getBaseTypeAndTypmod(arg_typid, arg_typmod)
    })
}
pub unsafe fn get_typavgwidth(arg_typid: Oid, arg_typmod: int32) -> int32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_typavgwidth(arg_typid: Oid, arg_typmod: int32) -> int32;
        }
        get_typavgwidth(arg_typid, arg_typmod)
    })
}
pub unsafe fn get_attavgwidth(arg_relid: Oid, arg_attnum: AttrNumber) -> int32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_attavgwidth(arg_relid: Oid, arg_attnum: AttrNumber) -> int32;
        }
        get_attavgwidth(arg_relid, arg_attnum)
    })
}
pub unsafe fn get_attstatsslot(
    arg_sslot: *mut AttStatsSlot,
    arg_statstuple: HeapTuple,
    arg_reqkind: ::std::os::raw::c_int,
    arg_reqop: Oid,
    arg_flags: ::std::os::raw::c_int,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_attstatsslot(
                arg_sslot: *mut AttStatsSlot,
                arg_statstuple: HeapTuple,
                arg_reqkind: ::std::os::raw::c_int,
                arg_reqop: Oid,
                arg_flags: ::std::os::raw::c_int,
            ) -> bool;
        }
        get_attstatsslot(arg_sslot, arg_statstuple, arg_reqkind, arg_reqop, arg_flags)
    })
}
pub unsafe fn free_attstatsslot(arg_sslot: *mut AttStatsSlot) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn free_attstatsslot(arg_sslot: *mut AttStatsSlot);
        }
        free_attstatsslot(arg_sslot)
    })
}
pub unsafe fn get_namespace_name(arg_nspid: Oid) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_namespace_name(arg_nspid: Oid) -> *mut ::std::os::raw::c_char;
        }
        get_namespace_name(arg_nspid)
    })
}
pub unsafe fn get_namespace_name_or_temp(arg_nspid: Oid) -> *mut ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_namespace_name_or_temp(arg_nspid: Oid) -> *mut ::std::os::raw::c_char;
        }
        get_namespace_name_or_temp(arg_nspid)
    })
}
pub unsafe fn get_range_subtype(arg_rangeOid: Oid) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_range_subtype(arg_rangeOid: Oid) -> Oid;
        }
        get_range_subtype(arg_rangeOid)
    })
}
pub unsafe fn get_range_collation(arg_rangeOid: Oid) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_range_collation(arg_rangeOid: Oid) -> Oid;
        }
        get_range_collation(arg_rangeOid)
    })
}
pub unsafe fn get_index_column_opclass(
    arg_index_oid: Oid,
    arg_attno: ::std::os::raw::c_int,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_index_column_opclass(
                arg_index_oid: Oid,
                arg_attno: ::std::os::raw::c_int,
            ) -> Oid;
        }
        get_index_column_opclass(arg_index_oid, arg_attno)
    })
}
pub unsafe fn get_index_isreplident(arg_index_oid: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_index_isreplident(arg_index_oid: Oid) -> bool;
        }
        get_index_isreplident(arg_index_oid)
    })
}
pub unsafe fn get_index_isvalid(arg_index_oid: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_index_isvalid(arg_index_oid: Oid) -> bool;
        }
        get_index_isvalid(arg_index_oid)
    })
}
pub unsafe fn get_index_isclustered(arg_index_oid: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_index_isclustered(arg_index_oid: Oid) -> bool;
        }
        get_index_isclustered(arg_index_oid)
    })
}
pub type SamplerRandomState = [::std::os::raw::c_ushort; 3usize];
pub unsafe fn sampler_random_init_state(
    arg_seed: ::std::os::raw::c_long,
    arg_randstate: *mut ::std::os::raw::c_ushort,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sampler_random_init_state(
                arg_seed: ::std::os::raw::c_long,
                arg_randstate: *mut ::std::os::raw::c_ushort,
            );
        }
        sampler_random_init_state(arg_seed, arg_randstate)
    })
}
pub unsafe fn sampler_random_fract(arg_randstate: *mut ::std::os::raw::c_ushort) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn sampler_random_fract(arg_randstate: *mut ::std::os::raw::c_ushort) -> f64;
        }
        sampler_random_fract(arg_randstate)
    })
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct BlockSamplerData {
    pub N: BlockNumber,
    pub n: ::std::os::raw::c_int,
    pub t: BlockNumber,
    pub m: ::std::os::raw::c_int,
    pub randstate: SamplerRandomState,
}
pub type BlockSampler = *mut BlockSamplerData;
pub unsafe fn BlockSampler_Init(
    arg_bs: BlockSampler,
    arg_nblocks: BlockNumber,
    arg_samplesize: ::std::os::raw::c_int,
    arg_randseed: ::std::os::raw::c_long,
) -> BlockNumber {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BlockSampler_Init(
                arg_bs: BlockSampler,
                arg_nblocks: BlockNumber,
                arg_samplesize: ::std::os::raw::c_int,
                arg_randseed: ::std::os::raw::c_long,
            ) -> BlockNumber;
        }
        BlockSampler_Init(arg_bs, arg_nblocks, arg_samplesize, arg_randseed)
    })
}
pub unsafe fn BlockSampler_HasMore(arg_bs: BlockSampler) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BlockSampler_HasMore(arg_bs: BlockSampler) -> bool;
        }
        BlockSampler_HasMore(arg_bs)
    })
}
pub unsafe fn BlockSampler_Next(arg_bs: BlockSampler) -> BlockNumber {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn BlockSampler_Next(arg_bs: BlockSampler) -> BlockNumber;
        }
        BlockSampler_Next(arg_bs)
    })
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ReservoirStateData {
    pub W: f64,
    pub randstate: SamplerRandomState,
}
pub type ReservoirState = *mut ReservoirStateData;
pub unsafe fn reservoir_init_selection_state(arg_rs: ReservoirState, arg_n: ::std::os::raw::c_int) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn reservoir_init_selection_state(arg_rs: ReservoirState, arg_n: ::std::os::raw::c_int);
        }
        reservoir_init_selection_state(arg_rs, arg_n)
    })
}
pub unsafe fn reservoir_get_next_S(
    arg_rs: ReservoirState,
    arg_t: f64,
    arg_n: ::std::os::raw::c_int,
) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn reservoir_get_next_S(
                arg_rs: ReservoirState,
                arg_t: f64,
                arg_n: ::std::os::raw::c_int,
            ) -> f64;
        }
        reservoir_get_next_S(arg_rs, arg_t, arg_n)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VariableStatData {
    pub var: *mut Node,
    pub rel: *mut RelOptInfo,
    pub statsTuple: HeapTuple,
    pub freefunc: ::std::option::Option<unsafe extern "C" fn(tuple: HeapTuple)>,
    pub vartype: Oid,
    pub atttype: Oid,
    pub atttypmod: int32,
    pub isunique: bool,
    pub acl_ok: bool,
}
impl Default for VariableStatData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GenericCosts {
    pub indexStartupCost: Cost,
    pub indexTotalCost: Cost,
    pub indexSelectivity: Selectivity,
    pub indexCorrelation: f64,
    pub numIndexPages: f64,
    pub numIndexTuples: f64,
    pub spc_random_page_cost: f64,
    pub num_sa_scans: f64,
}
pub type get_relation_stats_hook_type = ::std::option::Option<
    unsafe extern "C" fn(
        root: *mut PlannerInfo,
        rte: *mut RangeTblEntry,
        attnum: AttrNumber,
        vardata: *mut VariableStatData,
    ) -> bool,
>;
extern "C" {
    pub static mut get_relation_stats_hook: get_relation_stats_hook_type;
}
pub type get_index_stats_hook_type = ::std::option::Option<
    unsafe extern "C" fn(
        root: *mut PlannerInfo,
        indexOid: Oid,
        indexattnum: AttrNumber,
        vardata: *mut VariableStatData,
    ) -> bool,
>;
extern "C" {
    pub static mut get_index_stats_hook: get_index_stats_hook_type;
}
pub unsafe fn examine_variable(
    arg_root: *mut PlannerInfo,
    arg_node: *mut Node,
    arg_varRelid: ::std::os::raw::c_int,
    arg_vardata: *mut VariableStatData,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn examine_variable(
                arg_root: *mut PlannerInfo,
                arg_node: *mut Node,
                arg_varRelid: ::std::os::raw::c_int,
                arg_vardata: *mut VariableStatData,
            );
        }
        examine_variable(arg_root, arg_node, arg_varRelid, arg_vardata)
    })
}
pub unsafe fn statistic_proc_security_check(
    arg_vardata: *mut VariableStatData,
    arg_func_oid: Oid,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn statistic_proc_security_check(
                arg_vardata: *mut VariableStatData,
                arg_func_oid: Oid,
            ) -> bool;
        }
        statistic_proc_security_check(arg_vardata, arg_func_oid)
    })
}
pub unsafe fn get_restriction_variable(
    arg_root: *mut PlannerInfo,
    arg_args: *mut List,
    arg_varRelid: ::std::os::raw::c_int,
    arg_vardata: *mut VariableStatData,
    arg_other: *mut *mut Node,
    arg_varonleft: *mut bool,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_restriction_variable(
                arg_root: *mut PlannerInfo,
                arg_args: *mut List,
                arg_varRelid: ::std::os::raw::c_int,
                arg_vardata: *mut VariableStatData,
                arg_other: *mut *mut Node,
                arg_varonleft: *mut bool,
            ) -> bool;
        }
        get_restriction_variable(
            arg_root,
            arg_args,
            arg_varRelid,
            arg_vardata,
            arg_other,
            arg_varonleft,
        )
    })
}
pub unsafe fn get_join_variables(
    arg_root: *mut PlannerInfo,
    arg_args: *mut List,
    arg_sjinfo: *mut SpecialJoinInfo,
    arg_vardata1: *mut VariableStatData,
    arg_vardata2: *mut VariableStatData,
    arg_join_is_reversed: *mut bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_join_variables(
                arg_root: *mut PlannerInfo,
                arg_args: *mut List,
                arg_sjinfo: *mut SpecialJoinInfo,
                arg_vardata1: *mut VariableStatData,
                arg_vardata2: *mut VariableStatData,
                arg_join_is_reversed: *mut bool,
            );
        }
        get_join_variables(
            arg_root,
            arg_args,
            arg_sjinfo,
            arg_vardata1,
            arg_vardata2,
            arg_join_is_reversed,
        )
    })
}
pub unsafe fn get_variable_numdistinct(
    arg_vardata: *mut VariableStatData,
    arg_isdefault: *mut bool,
) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_variable_numdistinct(
                arg_vardata: *mut VariableStatData,
                arg_isdefault: *mut bool,
            ) -> f64;
        }
        get_variable_numdistinct(arg_vardata, arg_isdefault)
    })
}
pub unsafe fn mcv_selectivity(
    arg_vardata: *mut VariableStatData,
    arg_opproc: *mut FmgrInfo,
    arg_collation: Oid,
    arg_constval: Datum,
    arg_varonleft: bool,
    arg_sumcommonp: *mut f64,
) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn mcv_selectivity(
                arg_vardata: *mut VariableStatData,
                arg_opproc: *mut FmgrInfo,
                arg_collation: Oid,
                arg_constval: Datum,
                arg_varonleft: bool,
                arg_sumcommonp: *mut f64,
            ) -> f64;
        }
        mcv_selectivity(
            arg_vardata,
            arg_opproc,
            arg_collation,
            arg_constval,
            arg_varonleft,
            arg_sumcommonp,
        )
    })
}
pub unsafe fn histogram_selectivity(
    arg_vardata: *mut VariableStatData,
    arg_opproc: *mut FmgrInfo,
    arg_collation: Oid,
    arg_constval: Datum,
    arg_varonleft: bool,
    arg_min_hist_size: ::std::os::raw::c_int,
    arg_n_skip: ::std::os::raw::c_int,
    arg_hist_size: *mut ::std::os::raw::c_int,
) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn histogram_selectivity(
                arg_vardata: *mut VariableStatData,
                arg_opproc: *mut FmgrInfo,
                arg_collation: Oid,
                arg_constval: Datum,
                arg_varonleft: bool,
                arg_min_hist_size: ::std::os::raw::c_int,
                arg_n_skip: ::std::os::raw::c_int,
                arg_hist_size: *mut ::std::os::raw::c_int,
            ) -> f64;
        }
        histogram_selectivity(
            arg_vardata,
            arg_opproc,
            arg_collation,
            arg_constval,
            arg_varonleft,
            arg_min_hist_size,
            arg_n_skip,
            arg_hist_size,
        )
    })
}
pub unsafe fn generic_restriction_selectivity(
    arg_root: *mut PlannerInfo,
    arg_oproid: Oid,
    arg_collation: Oid,
    arg_args: *mut List,
    arg_varRelid: ::std::os::raw::c_int,
    arg_default_selectivity: f64,
) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn generic_restriction_selectivity(
                arg_root: *mut PlannerInfo,
                arg_oproid: Oid,
                arg_collation: Oid,
                arg_args: *mut List,
                arg_varRelid: ::std::os::raw::c_int,
                arg_default_selectivity: f64,
            ) -> f64;
        }
        generic_restriction_selectivity(
            arg_root,
            arg_oproid,
            arg_collation,
            arg_args,
            arg_varRelid,
            arg_default_selectivity,
        )
    })
}
pub unsafe fn ineq_histogram_selectivity(
    arg_root: *mut PlannerInfo,
    arg_vardata: *mut VariableStatData,
    arg_opoid: Oid,
    arg_opproc: *mut FmgrInfo,
    arg_isgt: bool,
    arg_iseq: bool,
    arg_collation: Oid,
    arg_constval: Datum,
    arg_consttype: Oid,
) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ineq_histogram_selectivity(
                arg_root: *mut PlannerInfo,
                arg_vardata: *mut VariableStatData,
                arg_opoid: Oid,
                arg_opproc: *mut FmgrInfo,
                arg_isgt: bool,
                arg_iseq: bool,
                arg_collation: Oid,
                arg_constval: Datum,
                arg_consttype: Oid,
            ) -> f64;
        }
        ineq_histogram_selectivity(
            arg_root,
            arg_vardata,
            arg_opoid,
            arg_opproc,
            arg_isgt,
            arg_iseq,
            arg_collation,
            arg_constval,
            arg_consttype,
        )
    })
}
pub unsafe fn var_eq_const(
    arg_vardata: *mut VariableStatData,
    arg_oproid: Oid,
    arg_collation: Oid,
    arg_constval: Datum,
    arg_constisnull: bool,
    arg_varonleft: bool,
    arg_negate: bool,
) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn var_eq_const(
                arg_vardata: *mut VariableStatData,
                arg_oproid: Oid,
                arg_collation: Oid,
                arg_constval: Datum,
                arg_constisnull: bool,
                arg_varonleft: bool,
                arg_negate: bool,
            ) -> f64;
        }
        var_eq_const(
            arg_vardata,
            arg_oproid,
            arg_collation,
            arg_constval,
            arg_constisnull,
            arg_varonleft,
            arg_negate,
        )
    })
}
pub unsafe fn var_eq_non_const(
    arg_vardata: *mut VariableStatData,
    arg_oproid: Oid,
    arg_collation: Oid,
    arg_other: *mut Node,
    arg_varonleft: bool,
    arg_negate: bool,
) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn var_eq_non_const(
                arg_vardata: *mut VariableStatData,
                arg_oproid: Oid,
                arg_collation: Oid,
                arg_other: *mut Node,
                arg_varonleft: bool,
                arg_negate: bool,
            ) -> f64;
        }
        var_eq_non_const(
            arg_vardata,
            arg_oproid,
            arg_collation,
            arg_other,
            arg_varonleft,
            arg_negate,
        )
    })
}
pub unsafe fn boolvarsel(
    arg_root: *mut PlannerInfo,
    arg_arg: *mut Node,
    arg_varRelid: ::std::os::raw::c_int,
) -> Selectivity {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn boolvarsel(
                arg_root: *mut PlannerInfo,
                arg_arg: *mut Node,
                arg_varRelid: ::std::os::raw::c_int,
            ) -> Selectivity;
        }
        boolvarsel(arg_root, arg_arg, arg_varRelid)
    })
}
pub unsafe fn booltestsel(
    arg_root: *mut PlannerInfo,
    arg_booltesttype: BoolTestType,
    arg_arg: *mut Node,
    arg_varRelid: ::std::os::raw::c_int,
    arg_jointype: JoinType,
    arg_sjinfo: *mut SpecialJoinInfo,
) -> Selectivity {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn booltestsel(
                arg_root: *mut PlannerInfo,
                arg_booltesttype: BoolTestType,
                arg_arg: *mut Node,
                arg_varRelid: ::std::os::raw::c_int,
                arg_jointype: JoinType,
                arg_sjinfo: *mut SpecialJoinInfo,
            ) -> Selectivity;
        }
        booltestsel(arg_root, arg_booltesttype, arg_arg, arg_varRelid, arg_jointype, arg_sjinfo)
    })
}
pub unsafe fn nulltestsel(
    arg_root: *mut PlannerInfo,
    arg_nulltesttype: NullTestType,
    arg_arg: *mut Node,
    arg_varRelid: ::std::os::raw::c_int,
    arg_jointype: JoinType,
    arg_sjinfo: *mut SpecialJoinInfo,
) -> Selectivity {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn nulltestsel(
                arg_root: *mut PlannerInfo,
                arg_nulltesttype: NullTestType,
                arg_arg: *mut Node,
                arg_varRelid: ::std::os::raw::c_int,
                arg_jointype: JoinType,
                arg_sjinfo: *mut SpecialJoinInfo,
            ) -> Selectivity;
        }
        nulltestsel(arg_root, arg_nulltesttype, arg_arg, arg_varRelid, arg_jointype, arg_sjinfo)
    })
}
pub unsafe fn scalararraysel(
    arg_root: *mut PlannerInfo,
    arg_clause: *mut ScalarArrayOpExpr,
    arg_is_join_clause: bool,
    arg_varRelid: ::std::os::raw::c_int,
    arg_jointype: JoinType,
    arg_sjinfo: *mut SpecialJoinInfo,
) -> Selectivity {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn scalararraysel(
                arg_root: *mut PlannerInfo,
                arg_clause: *mut ScalarArrayOpExpr,
                arg_is_join_clause: bool,
                arg_varRelid: ::std::os::raw::c_int,
                arg_jointype: JoinType,
                arg_sjinfo: *mut SpecialJoinInfo,
            ) -> Selectivity;
        }
        scalararraysel(
            arg_root,
            arg_clause,
            arg_is_join_clause,
            arg_varRelid,
            arg_jointype,
            arg_sjinfo,
        )
    })
}
pub unsafe fn estimate_array_length(arg_arrayexpr: *mut Node) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn estimate_array_length(arg_arrayexpr: *mut Node) -> ::std::os::raw::c_int;
        }
        estimate_array_length(arg_arrayexpr)
    })
}
pub unsafe fn rowcomparesel(
    arg_root: *mut PlannerInfo,
    arg_clause: *mut RowCompareExpr,
    arg_varRelid: ::std::os::raw::c_int,
    arg_jointype: JoinType,
    arg_sjinfo: *mut SpecialJoinInfo,
) -> Selectivity {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn rowcomparesel(
                arg_root: *mut PlannerInfo,
                arg_clause: *mut RowCompareExpr,
                arg_varRelid: ::std::os::raw::c_int,
                arg_jointype: JoinType,
                arg_sjinfo: *mut SpecialJoinInfo,
            ) -> Selectivity;
        }
        rowcomparesel(arg_root, arg_clause, arg_varRelid, arg_jointype, arg_sjinfo)
    })
}
pub unsafe fn mergejoinscansel(
    arg_root: *mut PlannerInfo,
    arg_clause: *mut Node,
    arg_opfamily: Oid,
    arg_strategy: ::std::os::raw::c_int,
    arg_nulls_first: bool,
    arg_leftstart: *mut Selectivity,
    arg_leftend: *mut Selectivity,
    arg_rightstart: *mut Selectivity,
    arg_rightend: *mut Selectivity,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn mergejoinscansel(
                arg_root: *mut PlannerInfo,
                arg_clause: *mut Node,
                arg_opfamily: Oid,
                arg_strategy: ::std::os::raw::c_int,
                arg_nulls_first: bool,
                arg_leftstart: *mut Selectivity,
                arg_leftend: *mut Selectivity,
                arg_rightstart: *mut Selectivity,
                arg_rightend: *mut Selectivity,
            );
        }
        mergejoinscansel(
            arg_root,
            arg_clause,
            arg_opfamily,
            arg_strategy,
            arg_nulls_first,
            arg_leftstart,
            arg_leftend,
            arg_rightstart,
            arg_rightend,
        )
    })
}
pub unsafe fn estimate_num_groups(
    arg_root: *mut PlannerInfo,
    arg_groupExprs: *mut List,
    arg_input_rows: f64,
    arg_pgset: *mut *mut List,
) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn estimate_num_groups(
                arg_root: *mut PlannerInfo,
                arg_groupExprs: *mut List,
                arg_input_rows: f64,
                arg_pgset: *mut *mut List,
            ) -> f64;
        }
        estimate_num_groups(arg_root, arg_groupExprs, arg_input_rows, arg_pgset)
    })
}
pub unsafe fn estimate_hash_bucket_stats(
    arg_root: *mut PlannerInfo,
    arg_hashkey: *mut Node,
    arg_nbuckets: f64,
    arg_mcv_freq: *mut Selectivity,
    arg_bucketsize_frac: *mut Selectivity,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn estimate_hash_bucket_stats(
                arg_root: *mut PlannerInfo,
                arg_hashkey: *mut Node,
                arg_nbuckets: f64,
                arg_mcv_freq: *mut Selectivity,
                arg_bucketsize_frac: *mut Selectivity,
            );
        }
        estimate_hash_bucket_stats(
            arg_root,
            arg_hashkey,
            arg_nbuckets,
            arg_mcv_freq,
            arg_bucketsize_frac,
        )
    })
}
pub unsafe fn estimate_hashagg_tablesize(
    arg_path: *mut Path,
    arg_agg_costs: *const AggClauseCosts,
    arg_dNumGroups: f64,
) -> f64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn estimate_hashagg_tablesize(
                arg_path: *mut Path,
                arg_agg_costs: *const AggClauseCosts,
                arg_dNumGroups: f64,
            ) -> f64;
        }
        estimate_hashagg_tablesize(arg_path, arg_agg_costs, arg_dNumGroups)
    })
}
pub unsafe fn get_quals_from_indexclauses(arg_indexclauses: *mut List) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn get_quals_from_indexclauses(arg_indexclauses: *mut List) -> *mut List;
        }
        get_quals_from_indexclauses(arg_indexclauses)
    })
}
pub unsafe fn index_other_operands_eval_cost(
    arg_root: *mut PlannerInfo,
    arg_indexquals: *mut List,
) -> Cost {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn index_other_operands_eval_cost(
                arg_root: *mut PlannerInfo,
                arg_indexquals: *mut List,
            ) -> Cost;
        }
        index_other_operands_eval_cost(arg_root, arg_indexquals)
    })
}
pub unsafe fn add_predicate_to_index_quals(
    arg_index: *mut IndexOptInfo,
    arg_indexQuals: *mut List,
) -> *mut List {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn add_predicate_to_index_quals(
                arg_index: *mut IndexOptInfo,
                arg_indexQuals: *mut List,
            ) -> *mut List;
        }
        add_predicate_to_index_quals(arg_index, arg_indexQuals)
    })
}
pub unsafe fn genericcostestimate(
    arg_root: *mut PlannerInfo,
    arg_path: *mut IndexPath,
    arg_loop_count: f64,
    arg_costs: *mut GenericCosts,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn genericcostestimate(
                arg_root: *mut PlannerInfo,
                arg_path: *mut IndexPath,
                arg_loop_count: f64,
                arg_costs: *mut GenericCosts,
            );
        }
        genericcostestimate(arg_root, arg_path, arg_loop_count, arg_costs)
    })
}
pub unsafe fn scalararraysel_containment(
    arg_root: *mut PlannerInfo,
    arg_leftop: *mut Node,
    arg_rightop: *mut Node,
    arg_elemtype: Oid,
    arg_isEquality: bool,
    arg_useOr: bool,
    arg_varRelid: ::std::os::raw::c_int,
) -> Selectivity {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn scalararraysel_containment(
                arg_root: *mut PlannerInfo,
                arg_leftop: *mut Node,
                arg_rightop: *mut Node,
                arg_elemtype: Oid,
                arg_isEquality: bool,
                arg_useOr: bool,
                arg_varRelid: ::std::os::raw::c_int,
            ) -> Selectivity;
        }
        scalararraysel_containment(
            arg_root,
            arg_leftop,
            arg_rightop,
            arg_elemtype,
            arg_isEquality,
            arg_useOr,
            arg_varRelid,
        )
    })
}
pub const SysCacheIdentifier_AGGFNOID: SysCacheIdentifier = 0;
pub const SysCacheIdentifier_AMNAME: SysCacheIdentifier = 1;
pub const SysCacheIdentifier_AMOID: SysCacheIdentifier = 2;
pub const SysCacheIdentifier_AMOPOPID: SysCacheIdentifier = 3;
pub const SysCacheIdentifier_AMOPSTRATEGY: SysCacheIdentifier = 4;
pub const SysCacheIdentifier_AMPROCNUM: SysCacheIdentifier = 5;
pub const SysCacheIdentifier_ATTNAME: SysCacheIdentifier = 6;
pub const SysCacheIdentifier_ATTNUM: SysCacheIdentifier = 7;
pub const SysCacheIdentifier_AUTHMEMMEMROLE: SysCacheIdentifier = 8;
pub const SysCacheIdentifier_AUTHMEMROLEMEM: SysCacheIdentifier = 9;
pub const SysCacheIdentifier_AUTHNAME: SysCacheIdentifier = 10;
pub const SysCacheIdentifier_AUTHOID: SysCacheIdentifier = 11;
pub const SysCacheIdentifier_CASTSOURCETARGET: SysCacheIdentifier = 12;
pub const SysCacheIdentifier_CLAAMNAMENSP: SysCacheIdentifier = 13;
pub const SysCacheIdentifier_CLAOID: SysCacheIdentifier = 14;
pub const SysCacheIdentifier_COLLNAMEENCNSP: SysCacheIdentifier = 15;
pub const SysCacheIdentifier_COLLOID: SysCacheIdentifier = 16;
pub const SysCacheIdentifier_CONDEFAULT: SysCacheIdentifier = 17;
pub const SysCacheIdentifier_CONNAMENSP: SysCacheIdentifier = 18;
pub const SysCacheIdentifier_CONSTROID: SysCacheIdentifier = 19;
pub const SysCacheIdentifier_CONVOID: SysCacheIdentifier = 20;
pub const SysCacheIdentifier_DATABASEOID: SysCacheIdentifier = 21;
pub const SysCacheIdentifier_DEFACLROLENSPOBJ: SysCacheIdentifier = 22;
pub const SysCacheIdentifier_ENUMOID: SysCacheIdentifier = 23;
pub const SysCacheIdentifier_ENUMTYPOIDNAME: SysCacheIdentifier = 24;
pub const SysCacheIdentifier_EVENTTRIGGERNAME: SysCacheIdentifier = 25;
pub const SysCacheIdentifier_EVENTTRIGGEROID: SysCacheIdentifier = 26;
pub const SysCacheIdentifier_FOREIGNDATAWRAPPERNAME: SysCacheIdentifier = 27;
pub const SysCacheIdentifier_FOREIGNDATAWRAPPEROID: SysCacheIdentifier = 28;
pub const SysCacheIdentifier_FOREIGNSERVERNAME: SysCacheIdentifier = 29;
pub const SysCacheIdentifier_FOREIGNSERVEROID: SysCacheIdentifier = 30;
pub const SysCacheIdentifier_FOREIGNTABLEREL: SysCacheIdentifier = 31;
pub const SysCacheIdentifier_INDEXRELID: SysCacheIdentifier = 32;
pub const SysCacheIdentifier_LANGNAME: SysCacheIdentifier = 33;
pub const SysCacheIdentifier_LANGOID: SysCacheIdentifier = 34;
pub const SysCacheIdentifier_NAMESPACENAME: SysCacheIdentifier = 35;
pub const SysCacheIdentifier_NAMESPACEOID: SysCacheIdentifier = 36;
pub const SysCacheIdentifier_OPERNAMENSP: SysCacheIdentifier = 37;
pub const SysCacheIdentifier_OPEROID: SysCacheIdentifier = 38;
pub const SysCacheIdentifier_OPFAMILYAMNAMENSP: SysCacheIdentifier = 39;
pub const SysCacheIdentifier_OPFAMILYOID: SysCacheIdentifier = 40;
pub const SysCacheIdentifier_PARTRELID: SysCacheIdentifier = 41;
pub const SysCacheIdentifier_PROCNAMEARGSNSP: SysCacheIdentifier = 42;
pub const SysCacheIdentifier_PROCOID: SysCacheIdentifier = 43;
pub const SysCacheIdentifier_PUBLICATIONNAME: SysCacheIdentifier = 44;
pub const SysCacheIdentifier_PUBLICATIONOID: SysCacheIdentifier = 45;
pub const SysCacheIdentifier_PUBLICATIONREL: SysCacheIdentifier = 46;
pub const SysCacheIdentifier_PUBLICATIONRELMAP: SysCacheIdentifier = 47;
pub const SysCacheIdentifier_RANGETYPE: SysCacheIdentifier = 48;
pub const SysCacheIdentifier_RELNAMENSP: SysCacheIdentifier = 49;
pub const SysCacheIdentifier_RELOID: SysCacheIdentifier = 50;
pub const SysCacheIdentifier_REPLORIGIDENT: SysCacheIdentifier = 51;
pub const SysCacheIdentifier_REPLORIGNAME: SysCacheIdentifier = 52;
pub const SysCacheIdentifier_RULERELNAME: SysCacheIdentifier = 53;
pub const SysCacheIdentifier_SEQRELID: SysCacheIdentifier = 54;
pub const SysCacheIdentifier_STATEXTDATASTXOID: SysCacheIdentifier = 55;
pub const SysCacheIdentifier_STATEXTNAMENSP: SysCacheIdentifier = 56;
pub const SysCacheIdentifier_STATEXTOID: SysCacheIdentifier = 57;
pub const SysCacheIdentifier_STATRELATTINH: SysCacheIdentifier = 58;
pub const SysCacheIdentifier_SUBSCRIPTIONNAME: SysCacheIdentifier = 59;
pub const SysCacheIdentifier_SUBSCRIPTIONOID: SysCacheIdentifier = 60;
pub const SysCacheIdentifier_SUBSCRIPTIONRELMAP: SysCacheIdentifier = 61;
pub const SysCacheIdentifier_TABLESPACEOID: SysCacheIdentifier = 62;
pub const SysCacheIdentifier_TRFOID: SysCacheIdentifier = 63;
pub const SysCacheIdentifier_TRFTYPELANG: SysCacheIdentifier = 64;
pub const SysCacheIdentifier_TSCONFIGMAP: SysCacheIdentifier = 65;
pub const SysCacheIdentifier_TSCONFIGNAMENSP: SysCacheIdentifier = 66;
pub const SysCacheIdentifier_TSCONFIGOID: SysCacheIdentifier = 67;
pub const SysCacheIdentifier_TSDICTNAMENSP: SysCacheIdentifier = 68;
pub const SysCacheIdentifier_TSDICTOID: SysCacheIdentifier = 69;
pub const SysCacheIdentifier_TSPARSERNAMENSP: SysCacheIdentifier = 70;
pub const SysCacheIdentifier_TSPARSEROID: SysCacheIdentifier = 71;
pub const SysCacheIdentifier_TSTEMPLATENAMENSP: SysCacheIdentifier = 72;
pub const SysCacheIdentifier_TSTEMPLATEOID: SysCacheIdentifier = 73;
pub const SysCacheIdentifier_TYPENAMENSP: SysCacheIdentifier = 74;
pub const SysCacheIdentifier_TYPEOID: SysCacheIdentifier = 75;
pub const SysCacheIdentifier_USERMAPPINGOID: SysCacheIdentifier = 76;
pub const SysCacheIdentifier_USERMAPPINGUSERSERVER: SysCacheIdentifier = 77;
pub type SysCacheIdentifier = ::std::os::raw::c_uint;
pub unsafe fn InitCatalogCache() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitCatalogCache();
        }
        InitCatalogCache()
    })
}
pub unsafe fn InitCatalogCachePhase2() {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitCatalogCachePhase2();
        }
        InitCatalogCachePhase2()
    })
}
pub unsafe fn SearchSysCache(
    arg_cacheId: ::std::os::raw::c_int,
    arg_key1: Datum,
    arg_key2: Datum,
    arg_key3: Datum,
    arg_key4: Datum,
) -> HeapTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SearchSysCache(
                arg_cacheId: ::std::os::raw::c_int,
                arg_key1: Datum,
                arg_key2: Datum,
                arg_key3: Datum,
                arg_key4: Datum,
            ) -> HeapTuple;
        }
        SearchSysCache(arg_cacheId, arg_key1, arg_key2, arg_key3, arg_key4)
    })
}
pub unsafe fn SearchSysCache1(arg_cacheId: ::std::os::raw::c_int, arg_key1: Datum) -> HeapTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SearchSysCache1(arg_cacheId: ::std::os::raw::c_int, arg_key1: Datum) -> HeapTuple;
        }
        SearchSysCache1(arg_cacheId, arg_key1)
    })
}
pub unsafe fn SearchSysCache2(
    arg_cacheId: ::std::os::raw::c_int,
    arg_key1: Datum,
    arg_key2: Datum,
) -> HeapTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SearchSysCache2(
                arg_cacheId: ::std::os::raw::c_int,
                arg_key1: Datum,
                arg_key2: Datum,
            ) -> HeapTuple;
        }
        SearchSysCache2(arg_cacheId, arg_key1, arg_key2)
    })
}
pub unsafe fn SearchSysCache3(
    arg_cacheId: ::std::os::raw::c_int,
    arg_key1: Datum,
    arg_key2: Datum,
    arg_key3: Datum,
) -> HeapTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SearchSysCache3(
                arg_cacheId: ::std::os::raw::c_int,
                arg_key1: Datum,
                arg_key2: Datum,
                arg_key3: Datum,
            ) -> HeapTuple;
        }
        SearchSysCache3(arg_cacheId, arg_key1, arg_key2, arg_key3)
    })
}
pub unsafe fn SearchSysCache4(
    arg_cacheId: ::std::os::raw::c_int,
    arg_key1: Datum,
    arg_key2: Datum,
    arg_key3: Datum,
    arg_key4: Datum,
) -> HeapTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SearchSysCache4(
                arg_cacheId: ::std::os::raw::c_int,
                arg_key1: Datum,
                arg_key2: Datum,
                arg_key3: Datum,
                arg_key4: Datum,
            ) -> HeapTuple;
        }
        SearchSysCache4(arg_cacheId, arg_key1, arg_key2, arg_key3, arg_key4)
    })
}
pub unsafe fn ReleaseSysCache(arg_tuple: HeapTuple) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn ReleaseSysCache(arg_tuple: HeapTuple);
        }
        ReleaseSysCache(arg_tuple)
    })
}
pub unsafe fn SearchSysCacheCopy(
    arg_cacheId: ::std::os::raw::c_int,
    arg_key1: Datum,
    arg_key2: Datum,
    arg_key3: Datum,
    arg_key4: Datum,
) -> HeapTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SearchSysCacheCopy(
                arg_cacheId: ::std::os::raw::c_int,
                arg_key1: Datum,
                arg_key2: Datum,
                arg_key3: Datum,
                arg_key4: Datum,
            ) -> HeapTuple;
        }
        SearchSysCacheCopy(arg_cacheId, arg_key1, arg_key2, arg_key3, arg_key4)
    })
}
pub unsafe fn SearchSysCacheExists(
    arg_cacheId: ::std::os::raw::c_int,
    arg_key1: Datum,
    arg_key2: Datum,
    arg_key3: Datum,
    arg_key4: Datum,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SearchSysCacheExists(
                arg_cacheId: ::std::os::raw::c_int,
                arg_key1: Datum,
                arg_key2: Datum,
                arg_key3: Datum,
                arg_key4: Datum,
            ) -> bool;
        }
        SearchSysCacheExists(arg_cacheId, arg_key1, arg_key2, arg_key3, arg_key4)
    })
}
pub unsafe fn GetSysCacheOid(
    arg_cacheId: ::std::os::raw::c_int,
    arg_oidcol: AttrNumber,
    arg_key1: Datum,
    arg_key2: Datum,
    arg_key3: Datum,
    arg_key4: Datum,
) -> Oid {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetSysCacheOid(
                arg_cacheId: ::std::os::raw::c_int,
                arg_oidcol: AttrNumber,
                arg_key1: Datum,
                arg_key2: Datum,
                arg_key3: Datum,
                arg_key4: Datum,
            ) -> Oid;
        }
        GetSysCacheOid(arg_cacheId, arg_oidcol, arg_key1, arg_key2, arg_key3, arg_key4)
    })
}
pub unsafe fn SearchSysCacheAttName(
    arg_relid: Oid,
    arg_attname: *const ::std::os::raw::c_char,
) -> HeapTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SearchSysCacheAttName(
                arg_relid: Oid,
                arg_attname: *const ::std::os::raw::c_char,
            ) -> HeapTuple;
        }
        SearchSysCacheAttName(arg_relid, arg_attname)
    })
}
pub unsafe fn SearchSysCacheCopyAttName(
    arg_relid: Oid,
    arg_attname: *const ::std::os::raw::c_char,
) -> HeapTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SearchSysCacheCopyAttName(
                arg_relid: Oid,
                arg_attname: *const ::std::os::raw::c_char,
            ) -> HeapTuple;
        }
        SearchSysCacheCopyAttName(arg_relid, arg_attname)
    })
}
pub unsafe fn SearchSysCacheExistsAttName(
    arg_relid: Oid,
    arg_attname: *const ::std::os::raw::c_char,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SearchSysCacheExistsAttName(
                arg_relid: Oid,
                arg_attname: *const ::std::os::raw::c_char,
            ) -> bool;
        }
        SearchSysCacheExistsAttName(arg_relid, arg_attname)
    })
}
pub unsafe fn SearchSysCacheAttNum(arg_relid: Oid, arg_attnum: int16) -> HeapTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SearchSysCacheAttNum(arg_relid: Oid, arg_attnum: int16) -> HeapTuple;
        }
        SearchSysCacheAttNum(arg_relid, arg_attnum)
    })
}
pub unsafe fn SearchSysCacheCopyAttNum(arg_relid: Oid, arg_attnum: int16) -> HeapTuple {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SearchSysCacheCopyAttNum(arg_relid: Oid, arg_attnum: int16) -> HeapTuple;
        }
        SearchSysCacheCopyAttNum(arg_relid, arg_attnum)
    })
}
pub unsafe fn SysCacheGetAttr(
    arg_cacheId: ::std::os::raw::c_int,
    arg_tup: HeapTuple,
    arg_attributeNumber: AttrNumber,
    arg_isNull: *mut bool,
) -> Datum {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SysCacheGetAttr(
                arg_cacheId: ::std::os::raw::c_int,
                arg_tup: HeapTuple,
                arg_attributeNumber: AttrNumber,
                arg_isNull: *mut bool,
            ) -> Datum;
        }
        SysCacheGetAttr(arg_cacheId, arg_tup, arg_attributeNumber, arg_isNull)
    })
}
pub unsafe fn GetSysCacheHashValue(
    arg_cacheId: ::std::os::raw::c_int,
    arg_key1: Datum,
    arg_key2: Datum,
    arg_key3: Datum,
    arg_key4: Datum,
) -> uint32 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn GetSysCacheHashValue(
                arg_cacheId: ::std::os::raw::c_int,
                arg_key1: Datum,
                arg_key2: Datum,
                arg_key3: Datum,
                arg_key4: Datum,
            ) -> uint32;
        }
        GetSysCacheHashValue(arg_cacheId, arg_key1, arg_key2, arg_key3, arg_key4)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct catclist {
    _unused: [u8; 0],
}
pub unsafe fn SearchSysCacheList(
    arg_cacheId: ::std::os::raw::c_int,
    arg_nkeys: ::std::os::raw::c_int,
    arg_key1: Datum,
    arg_key2: Datum,
    arg_key3: Datum,
) -> *mut catclist {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SearchSysCacheList(
                arg_cacheId: ::std::os::raw::c_int,
                arg_nkeys: ::std::os::raw::c_int,
                arg_key1: Datum,
                arg_key2: Datum,
                arg_key3: Datum,
            ) -> *mut catclist;
        }
        SearchSysCacheList(arg_cacheId, arg_nkeys, arg_key1, arg_key2, arg_key3)
    })
}
pub unsafe fn SysCacheInvalidate(arg_cacheId: ::std::os::raw::c_int, arg_hashValue: uint32) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SysCacheInvalidate(arg_cacheId: ::std::os::raw::c_int, arg_hashValue: uint32);
        }
        SysCacheInvalidate(arg_cacheId, arg_hashValue)
    })
}
pub unsafe fn RelationInvalidatesSnapshotsOnly(arg_relid: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationInvalidatesSnapshotsOnly(arg_relid: Oid) -> bool;
        }
        RelationInvalidatesSnapshotsOnly(arg_relid)
    })
}
pub unsafe fn RelationHasSysCache(arg_relid: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationHasSysCache(arg_relid: Oid) -> bool;
        }
        RelationHasSysCache(arg_relid)
    })
}
pub unsafe fn RelationSupportsSysCache(arg_relid: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn RelationSupportsSysCache(arg_relid: Oid) -> bool;
        }
        RelationSupportsSysCache(arg_relid)
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DomainConstraintCache {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TypeCacheEnumData {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TypeCacheEntry {
    pub type_id: Oid,
    pub type_id_hash: uint32,
    pub typlen: int16,
    pub typbyval: bool,
    pub typalign: ::std::os::raw::c_char,
    pub typstorage: ::std::os::raw::c_char,
    pub typtype: ::std::os::raw::c_char,
    pub typrelid: Oid,
    pub typelem: Oid,
    pub typcollation: Oid,
    pub btree_opf: Oid,
    pub btree_opintype: Oid,
    pub hash_opf: Oid,
    pub hash_opintype: Oid,
    pub eq_opr: Oid,
    pub lt_opr: Oid,
    pub gt_opr: Oid,
    pub cmp_proc: Oid,
    pub hash_proc: Oid,
    pub hash_extended_proc: Oid,
    pub eq_opr_finfo: FmgrInfo,
    pub cmp_proc_finfo: FmgrInfo,
    pub hash_proc_finfo: FmgrInfo,
    pub hash_extended_proc_finfo: FmgrInfo,
    pub tupDesc: TupleDesc,
    pub tupDesc_identifier: uint64,
    pub rngelemtype: *mut TypeCacheEntry,
    pub rng_collation: Oid,
    pub rng_cmp_proc_finfo: FmgrInfo,
    pub rng_canonical_finfo: FmgrInfo,
    pub rng_subdiff_finfo: FmgrInfo,
    pub domainBaseType: Oid,
    pub domainBaseTypmod: int32,
    pub domainData: *mut DomainConstraintCache,
    pub flags: ::std::os::raw::c_int,
    pub enumData: *mut TypeCacheEnumData,
    pub nextDomain: *mut TypeCacheEntry,
}
impl Default for TypeCacheEntry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DomainConstraintRef {
    pub constraints: *mut List,
    pub refctx: MemoryContext,
    pub tcache: *mut TypeCacheEntry,
    pub need_exprstate: bool,
    pub dcc: *mut DomainConstraintCache,
    pub callback: MemoryContextCallback,
}
impl Default for DomainConstraintRef {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SharedRecordTypmodRegistry {
    _unused: [u8; 0],
}
pub unsafe fn lookup_type_cache(
    arg_type_id: Oid,
    arg_flags: ::std::os::raw::c_int,
) -> *mut TypeCacheEntry {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lookup_type_cache(
                arg_type_id: Oid,
                arg_flags: ::std::os::raw::c_int,
            ) -> *mut TypeCacheEntry;
        }
        lookup_type_cache(arg_type_id, arg_flags)
    })
}
pub unsafe fn InitDomainConstraintRef(
    arg_type_id: Oid,
    arg_ref_: *mut DomainConstraintRef,
    arg_refctx: MemoryContext,
    arg_need_exprstate: bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn InitDomainConstraintRef(
                arg_type_id: Oid,
                arg_ref_: *mut DomainConstraintRef,
                arg_refctx: MemoryContext,
                arg_need_exprstate: bool,
            );
        }
        InitDomainConstraintRef(arg_type_id, arg_ref_, arg_refctx, arg_need_exprstate)
    })
}
pub unsafe fn UpdateDomainConstraintRef(arg_ref_: *mut DomainConstraintRef) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn UpdateDomainConstraintRef(arg_ref_: *mut DomainConstraintRef);
        }
        UpdateDomainConstraintRef(arg_ref_)
    })
}
pub unsafe fn DomainHasConstraints(arg_type_id: Oid) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn DomainHasConstraints(arg_type_id: Oid) -> bool;
        }
        DomainHasConstraints(arg_type_id)
    })
}
pub unsafe fn lookup_rowtype_tupdesc(arg_type_id: Oid, arg_typmod: int32) -> TupleDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lookup_rowtype_tupdesc(arg_type_id: Oid, arg_typmod: int32) -> TupleDesc;
        }
        lookup_rowtype_tupdesc(arg_type_id, arg_typmod)
    })
}
pub unsafe fn lookup_rowtype_tupdesc_noerror(
    arg_type_id: Oid,
    arg_typmod: int32,
    arg_noError: bool,
) -> TupleDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lookup_rowtype_tupdesc_noerror(
                arg_type_id: Oid,
                arg_typmod: int32,
                arg_noError: bool,
            ) -> TupleDesc;
        }
        lookup_rowtype_tupdesc_noerror(arg_type_id, arg_typmod, arg_noError)
    })
}
pub unsafe fn lookup_rowtype_tupdesc_copy(arg_type_id: Oid, arg_typmod: int32) -> TupleDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lookup_rowtype_tupdesc_copy(arg_type_id: Oid, arg_typmod: int32) -> TupleDesc;
        }
        lookup_rowtype_tupdesc_copy(arg_type_id, arg_typmod)
    })
}
pub unsafe fn lookup_rowtype_tupdesc_domain(
    arg_type_id: Oid,
    arg_typmod: int32,
    arg_noError: bool,
) -> TupleDesc {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn lookup_rowtype_tupdesc_domain(
                arg_type_id: Oid,
                arg_typmod: int32,
                arg_noError: bool,
            ) -> TupleDesc;
        }
        lookup_rowtype_tupdesc_domain(arg_type_id, arg_typmod, arg_noError)
    })
}
pub unsafe fn assign_record_type_typmod(arg_tupDesc: TupleDesc) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn assign_record_type_typmod(arg_tupDesc: TupleDesc);
        }
        assign_record_type_typmod(arg_tupDesc)
    })
}
pub unsafe fn assign_record_type_identifier(arg_type_id: Oid, arg_typmod: int32) -> uint64 {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn assign_record_type_identifier(arg_type_id: Oid, arg_typmod: int32) -> uint64;
        }
        assign_record_type_identifier(arg_type_id, arg_typmod)
    })
}
pub unsafe fn compare_values_of_enum(
    arg_tcache: *mut TypeCacheEntry,
    arg_arg1: Oid,
    arg_arg2: Oid,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn compare_values_of_enum(
                arg_tcache: *mut TypeCacheEntry,
                arg_arg1: Oid,
                arg_arg2: Oid,
            ) -> ::std::os::raw::c_int;
        }
        compare_values_of_enum(arg_tcache, arg_arg1, arg_arg2)
    })
}
pub unsafe fn SharedRecordTypmodRegistryEstimate() -> usize {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SharedRecordTypmodRegistryEstimate() -> usize;
        }
        SharedRecordTypmodRegistryEstimate()
    })
}
pub unsafe fn SharedRecordTypmodRegistryInit(
    arg_arg1: *mut SharedRecordTypmodRegistry,
    arg_segment: *mut dsm_segment,
    arg_area: *mut dsa_area,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SharedRecordTypmodRegistryInit(
                arg_arg1: *mut SharedRecordTypmodRegistry,
                arg_segment: *mut dsm_segment,
                arg_area: *mut dsa_area,
            );
        }
        SharedRecordTypmodRegistryInit(arg_arg1, arg_segment, arg_area)
    })
}
pub unsafe fn SharedRecordTypmodRegistryAttach(arg_arg1: *mut SharedRecordTypmodRegistry) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn SharedRecordTypmodRegistryAttach(arg_arg1: *mut SharedRecordTypmodRegistry);
        }
        SharedRecordTypmodRegistryAttach(arg_arg1)
    })
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RangeType {
    pub vl_len_: int32,
    pub rangetypid: Oid,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RangeBound {
    pub val: Datum,
    pub infinite: bool,
    pub inclusive: bool,
    pub lower: bool,
}
impl Default for RangeBound {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub unsafe fn range_contains_elem_internal(
    arg_typcache: *mut TypeCacheEntry,
    arg_r: *const RangeType,
    arg_val: Datum,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_contains_elem_internal(
                arg_typcache: *mut TypeCacheEntry,
                arg_r: *const RangeType,
                arg_val: Datum,
            ) -> bool;
        }
        range_contains_elem_internal(arg_typcache, arg_r, arg_val)
    })
}
pub unsafe fn range_eq_internal(
    arg_typcache: *mut TypeCacheEntry,
    arg_r1: *const RangeType,
    arg_r2: *const RangeType,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_eq_internal(
                arg_typcache: *mut TypeCacheEntry,
                arg_r1: *const RangeType,
                arg_r2: *const RangeType,
            ) -> bool;
        }
        range_eq_internal(arg_typcache, arg_r1, arg_r2)
    })
}
pub unsafe fn range_ne_internal(
    arg_typcache: *mut TypeCacheEntry,
    arg_r1: *const RangeType,
    arg_r2: *const RangeType,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_ne_internal(
                arg_typcache: *mut TypeCacheEntry,
                arg_r1: *const RangeType,
                arg_r2: *const RangeType,
            ) -> bool;
        }
        range_ne_internal(arg_typcache, arg_r1, arg_r2)
    })
}
pub unsafe fn range_contains_internal(
    arg_typcache: *mut TypeCacheEntry,
    arg_r1: *const RangeType,
    arg_r2: *const RangeType,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_contains_internal(
                arg_typcache: *mut TypeCacheEntry,
                arg_r1: *const RangeType,
                arg_r2: *const RangeType,
            ) -> bool;
        }
        range_contains_internal(arg_typcache, arg_r1, arg_r2)
    })
}
pub unsafe fn range_contained_by_internal(
    arg_typcache: *mut TypeCacheEntry,
    arg_r1: *const RangeType,
    arg_r2: *const RangeType,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_contained_by_internal(
                arg_typcache: *mut TypeCacheEntry,
                arg_r1: *const RangeType,
                arg_r2: *const RangeType,
            ) -> bool;
        }
        range_contained_by_internal(arg_typcache, arg_r1, arg_r2)
    })
}
pub unsafe fn range_before_internal(
    arg_typcache: *mut TypeCacheEntry,
    arg_r1: *const RangeType,
    arg_r2: *const RangeType,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_before_internal(
                arg_typcache: *mut TypeCacheEntry,
                arg_r1: *const RangeType,
                arg_r2: *const RangeType,
            ) -> bool;
        }
        range_before_internal(arg_typcache, arg_r1, arg_r2)
    })
}
pub unsafe fn range_after_internal(
    arg_typcache: *mut TypeCacheEntry,
    arg_r1: *const RangeType,
    arg_r2: *const RangeType,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_after_internal(
                arg_typcache: *mut TypeCacheEntry,
                arg_r1: *const RangeType,
                arg_r2: *const RangeType,
            ) -> bool;
        }
        range_after_internal(arg_typcache, arg_r1, arg_r2)
    })
}
pub unsafe fn range_adjacent_internal(
    arg_typcache: *mut TypeCacheEntry,
    arg_r1: *const RangeType,
    arg_r2: *const RangeType,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_adjacent_internal(
                arg_typcache: *mut TypeCacheEntry,
                arg_r1: *const RangeType,
                arg_r2: *const RangeType,
            ) -> bool;
        }
        range_adjacent_internal(arg_typcache, arg_r1, arg_r2)
    })
}
pub unsafe fn range_overlaps_internal(
    arg_typcache: *mut TypeCacheEntry,
    arg_r1: *const RangeType,
    arg_r2: *const RangeType,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_overlaps_internal(
                arg_typcache: *mut TypeCacheEntry,
                arg_r1: *const RangeType,
                arg_r2: *const RangeType,
            ) -> bool;
        }
        range_overlaps_internal(arg_typcache, arg_r1, arg_r2)
    })
}
pub unsafe fn range_overleft_internal(
    arg_typcache: *mut TypeCacheEntry,
    arg_r1: *const RangeType,
    arg_r2: *const RangeType,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_overleft_internal(
                arg_typcache: *mut TypeCacheEntry,
                arg_r1: *const RangeType,
                arg_r2: *const RangeType,
            ) -> bool;
        }
        range_overleft_internal(arg_typcache, arg_r1, arg_r2)
    })
}
pub unsafe fn range_overright_internal(
    arg_typcache: *mut TypeCacheEntry,
    arg_r1: *const RangeType,
    arg_r2: *const RangeType,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_overright_internal(
                arg_typcache: *mut TypeCacheEntry,
                arg_r1: *const RangeType,
                arg_r2: *const RangeType,
            ) -> bool;
        }
        range_overright_internal(arg_typcache, arg_r1, arg_r2)
    })
}
pub unsafe fn range_get_typcache(
    arg_fcinfo: FunctionCallInfo,
    arg_rngtypid: Oid,
) -> *mut TypeCacheEntry {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_get_typcache(
                arg_fcinfo: FunctionCallInfo,
                arg_rngtypid: Oid,
            ) -> *mut TypeCacheEntry;
        }
        range_get_typcache(arg_fcinfo, arg_rngtypid)
    })
}
pub unsafe fn range_serialize(
    arg_typcache: *mut TypeCacheEntry,
    arg_lower: *mut RangeBound,
    arg_upper: *mut RangeBound,
    arg_empty: bool,
) -> *mut RangeType {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_serialize(
                arg_typcache: *mut TypeCacheEntry,
                arg_lower: *mut RangeBound,
                arg_upper: *mut RangeBound,
                arg_empty: bool,
            ) -> *mut RangeType;
        }
        range_serialize(arg_typcache, arg_lower, arg_upper, arg_empty)
    })
}
pub unsafe fn range_deserialize(
    arg_typcache: *mut TypeCacheEntry,
    arg_range: *const RangeType,
    arg_lower: *mut RangeBound,
    arg_upper: *mut RangeBound,
    arg_empty: *mut bool,
) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_deserialize(
                arg_typcache: *mut TypeCacheEntry,
                arg_range: *const RangeType,
                arg_lower: *mut RangeBound,
                arg_upper: *mut RangeBound,
                arg_empty: *mut bool,
            );
        }
        range_deserialize(arg_typcache, arg_range, arg_lower, arg_upper, arg_empty)
    })
}
pub unsafe fn range_get_flags(arg_range: *const RangeType) -> ::std::os::raw::c_char {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_get_flags(arg_range: *const RangeType) -> ::std::os::raw::c_char;
        }
        range_get_flags(arg_range)
    })
}
pub unsafe fn range_set_contain_empty(arg_range: *mut RangeType) {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_set_contain_empty(arg_range: *mut RangeType);
        }
        range_set_contain_empty(arg_range)
    })
}
pub unsafe fn make_range(
    arg_typcache: *mut TypeCacheEntry,
    arg_lower: *mut RangeBound,
    arg_upper: *mut RangeBound,
    arg_empty: bool,
) -> *mut RangeType {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_range(
                arg_typcache: *mut TypeCacheEntry,
                arg_lower: *mut RangeBound,
                arg_upper: *mut RangeBound,
                arg_empty: bool,
            ) -> *mut RangeType;
        }
        make_range(arg_typcache, arg_lower, arg_upper, arg_empty)
    })
}
pub unsafe fn range_cmp_bounds(
    arg_typcache: *mut TypeCacheEntry,
    arg_b1: *const RangeBound,
    arg_b2: *const RangeBound,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_cmp_bounds(
                arg_typcache: *mut TypeCacheEntry,
                arg_b1: *const RangeBound,
                arg_b2: *const RangeBound,
            ) -> ::std::os::raw::c_int;
        }
        range_cmp_bounds(arg_typcache, arg_b1, arg_b2)
    })
}
pub unsafe fn range_cmp_bound_values(
    arg_typcache: *mut TypeCacheEntry,
    arg_b1: *const RangeBound,
    arg_b2: *const RangeBound,
) -> ::std::os::raw::c_int {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn range_cmp_bound_values(
                arg_typcache: *mut TypeCacheEntry,
                arg_b1: *const RangeBound,
                arg_b2: *const RangeBound,
            ) -> ::std::os::raw::c_int;
        }
        range_cmp_bound_values(arg_typcache, arg_b1, arg_b2)
    })
}
pub unsafe fn bounds_adjacent(
    arg_typcache: *mut TypeCacheEntry,
    arg_bound1: RangeBound,
    arg_bound2: RangeBound,
) -> bool {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn bounds_adjacent(
                arg_typcache: *mut TypeCacheEntry,
                arg_bound1: RangeBound,
                arg_bound2: RangeBound,
            ) -> bool;
        }
        bounds_adjacent(arg_typcache, arg_bound1, arg_bound2)
    })
}
pub unsafe fn make_empty_range(arg_typcache: *mut TypeCacheEntry) -> *mut RangeType {
    crate::submodules::setjmp::pg_guard_ffi_boundary(move || {
        extern "C" {
            fn make_empty_range(arg_typcache: *mut TypeCacheEntry) -> *mut RangeType;
        }
        make_empty_range(arg_typcache)
    })
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
pub type __uint128_t = u128;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AttrMissing {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct JitContext {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct JitInstrumentation {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SharedJitInstrumentation {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PartitionTupleRouting {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct binaryheap {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TsmRoutine {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TableFuncRoutine {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HashTapeInfo {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HashAggSpill {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WindowObjectData {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ParallelExecutorInfo {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TupleQueueReader {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ResourceOwnerData {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RowSecurityDesc {
    pub _address: u8,
}
impl pg_sys::PgNode for A_ArrayExpr {}
impl std::fmt::Display for A_ArrayExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for A_Const {}
impl std::fmt::Display for A_Const {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for A_Expr {}
impl std::fmt::Display for A_Expr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for A_Indices {}
impl std::fmt::Display for A_Indices {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for A_Indirection {}
impl std::fmt::Display for A_Indirection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for A_Star {}
impl std::fmt::Display for A_Star {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AccessPriv {}
impl std::fmt::Display for AccessPriv {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for Agg {}
impl std::fmt::Display for Agg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AggPath {}
impl std::fmt::Display for AggPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AggState {}
impl std::fmt::Display for AggState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for Aggref {}
impl std::fmt::Display for Aggref {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AggrefExprState {}
impl std::fmt::Display for AggrefExprState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for Alias {}
impl std::fmt::Display for Alias {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlterCollationStmt {}
impl std::fmt::Display for AlterCollationStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlterDatabaseSetStmt {}
impl std::fmt::Display for AlterDatabaseSetStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlterDatabaseStmt {}
impl std::fmt::Display for AlterDatabaseStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlterDefaultPrivilegesStmt {}
impl std::fmt::Display for AlterDefaultPrivilegesStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlterDomainStmt {}
impl std::fmt::Display for AlterDomainStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlterEnumStmt {}
impl std::fmt::Display for AlterEnumStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlterEventTrigStmt {}
impl std::fmt::Display for AlterEventTrigStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlterExtensionContentsStmt {}
impl std::fmt::Display for AlterExtensionContentsStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlterExtensionStmt {}
impl std::fmt::Display for AlterExtensionStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlterFdwStmt {}
impl std::fmt::Display for AlterFdwStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlterForeignServerStmt {}
impl std::fmt::Display for AlterForeignServerStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlterFunctionStmt {}
impl std::fmt::Display for AlterFunctionStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlterObjectDependsStmt {}
impl std::fmt::Display for AlterObjectDependsStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlterObjectSchemaStmt {}
impl std::fmt::Display for AlterObjectSchemaStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlterOpFamilyStmt {}
impl std::fmt::Display for AlterOpFamilyStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlterOperatorStmt {}
impl std::fmt::Display for AlterOperatorStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlterOwnerStmt {}
impl std::fmt::Display for AlterOwnerStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlterPolicyStmt {}
impl std::fmt::Display for AlterPolicyStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlterPublicationStmt {}
impl std::fmt::Display for AlterPublicationStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlterRoleSetStmt {}
impl std::fmt::Display for AlterRoleSetStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlterRoleStmt {}
impl std::fmt::Display for AlterRoleStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlterSeqStmt {}
impl std::fmt::Display for AlterSeqStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlterStatsStmt {}
impl std::fmt::Display for AlterStatsStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlterSubscriptionStmt {}
impl std::fmt::Display for AlterSubscriptionStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlterSystemStmt {}
impl std::fmt::Display for AlterSystemStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlterTSConfigurationStmt {}
impl std::fmt::Display for AlterTSConfigurationStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlterTSDictionaryStmt {}
impl std::fmt::Display for AlterTSDictionaryStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlterTableCmd {}
impl std::fmt::Display for AlterTableCmd {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlterTableMoveAllStmt {}
impl std::fmt::Display for AlterTableMoveAllStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlterTableSpaceOptionsStmt {}
impl std::fmt::Display for AlterTableSpaceOptionsStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlterTableStmt {}
impl std::fmt::Display for AlterTableStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlterTypeStmt {}
impl std::fmt::Display for AlterTypeStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlterUserMappingStmt {}
impl std::fmt::Display for AlterUserMappingStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlternativeSubPlan {}
impl std::fmt::Display for AlternativeSubPlan {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AlternativeSubPlanState {}
impl std::fmt::Display for AlternativeSubPlanState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for Append {}
impl std::fmt::Display for Append {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AppendPath {}
impl std::fmt::Display for AppendPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AppendRelInfo {}
impl std::fmt::Display for AppendRelInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for AppendState {}
impl std::fmt::Display for AppendState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ArrayCoerceExpr {}
impl std::fmt::Display for ArrayCoerceExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ArrayExpr {}
impl std::fmt::Display for ArrayExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for BaseBackupCmd {}
impl std::fmt::Display for BaseBackupCmd {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for BitmapAnd {}
impl std::fmt::Display for BitmapAnd {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for BitmapAndPath {}
impl std::fmt::Display for BitmapAndPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for BitmapAndState {}
impl std::fmt::Display for BitmapAndState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for BitmapHeapPath {}
impl std::fmt::Display for BitmapHeapPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for BitmapHeapScan {}
impl std::fmt::Display for BitmapHeapScan {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for BitmapHeapScanState {}
impl std::fmt::Display for BitmapHeapScanState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for BitmapIndexScan {}
impl std::fmt::Display for BitmapIndexScan {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for BitmapIndexScanState {}
impl std::fmt::Display for BitmapIndexScanState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for BitmapOr {}
impl std::fmt::Display for BitmapOr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for BitmapOrPath {}
impl std::fmt::Display for BitmapOrPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for BitmapOrState {}
impl std::fmt::Display for BitmapOrState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for BoolExpr {}
impl std::fmt::Display for BoolExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for BooleanTest {}
impl std::fmt::Display for BooleanTest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for BufferHeapTupleTableSlot {}
impl std::fmt::Display for BufferHeapTupleTableSlot {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CallContext {}
impl std::fmt::Display for CallContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CallStmt {}
impl std::fmt::Display for CallStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CaseExpr {}
impl std::fmt::Display for CaseExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CaseTestExpr {}
impl std::fmt::Display for CaseTestExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CaseWhen {}
impl std::fmt::Display for CaseWhen {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CheckPointStmt {}
impl std::fmt::Display for CheckPointStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ClosePortalStmt {}
impl std::fmt::Display for ClosePortalStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ClusterStmt {}
impl std::fmt::Display for ClusterStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CoalesceExpr {}
impl std::fmt::Display for CoalesceExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CoerceToDomain {}
impl std::fmt::Display for CoerceToDomain {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CoerceToDomainValue {}
impl std::fmt::Display for CoerceToDomainValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CoerceViaIO {}
impl std::fmt::Display for CoerceViaIO {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CollateClause {}
impl std::fmt::Display for CollateClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CollateExpr {}
impl std::fmt::Display for CollateExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ColumnDef {}
impl std::fmt::Display for ColumnDef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ColumnRef {}
impl std::fmt::Display for ColumnRef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CommentStmt {}
impl std::fmt::Display for CommentStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CommonTableExpr {}
impl std::fmt::Display for CommonTableExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CompositeTypeStmt {}
impl std::fmt::Display for CompositeTypeStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for Const {}
impl std::fmt::Display for Const {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for Constraint {}
impl std::fmt::Display for Constraint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ConstraintsSetStmt {}
impl std::fmt::Display for ConstraintsSetStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ConvertRowtypeExpr {}
impl std::fmt::Display for ConvertRowtypeExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CopyStmt {}
impl std::fmt::Display for CopyStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CreateAmStmt {}
impl std::fmt::Display for CreateAmStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CreateCastStmt {}
impl std::fmt::Display for CreateCastStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CreateConversionStmt {}
impl std::fmt::Display for CreateConversionStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CreateDomainStmt {}
impl std::fmt::Display for CreateDomainStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CreateEnumStmt {}
impl std::fmt::Display for CreateEnumStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CreateEventTrigStmt {}
impl std::fmt::Display for CreateEventTrigStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CreateExtensionStmt {}
impl std::fmt::Display for CreateExtensionStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CreateFdwStmt {}
impl std::fmt::Display for CreateFdwStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CreateForeignServerStmt {}
impl std::fmt::Display for CreateForeignServerStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CreateForeignTableStmt {}
impl std::fmt::Display for CreateForeignTableStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CreateFunctionStmt {}
impl std::fmt::Display for CreateFunctionStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CreateOpClassItem {}
impl std::fmt::Display for CreateOpClassItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CreateOpClassStmt {}
impl std::fmt::Display for CreateOpClassStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CreateOpFamilyStmt {}
impl std::fmt::Display for CreateOpFamilyStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CreatePLangStmt {}
impl std::fmt::Display for CreatePLangStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CreatePolicyStmt {}
impl std::fmt::Display for CreatePolicyStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CreatePublicationStmt {}
impl std::fmt::Display for CreatePublicationStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CreateRangeStmt {}
impl std::fmt::Display for CreateRangeStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CreateReplicationSlotCmd {}
impl std::fmt::Display for CreateReplicationSlotCmd {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CreateRoleStmt {}
impl std::fmt::Display for CreateRoleStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CreateSchemaStmt {}
impl std::fmt::Display for CreateSchemaStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CreateSeqStmt {}
impl std::fmt::Display for CreateSeqStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CreateStatsStmt {}
impl std::fmt::Display for CreateStatsStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CreateStmt {}
impl std::fmt::Display for CreateStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CreateSubscriptionStmt {}
impl std::fmt::Display for CreateSubscriptionStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CreateTableAsStmt {}
impl std::fmt::Display for CreateTableAsStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CreateTableSpaceStmt {}
impl std::fmt::Display for CreateTableSpaceStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CreateTransformStmt {}
impl std::fmt::Display for CreateTransformStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CreateTrigStmt {}
impl std::fmt::Display for CreateTrigStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CreateUserMappingStmt {}
impl std::fmt::Display for CreateUserMappingStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CreatedbStmt {}
impl std::fmt::Display for CreatedbStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CteScan {}
impl std::fmt::Display for CteScan {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CteScanState {}
impl std::fmt::Display for CteScanState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CurrentOfExpr {}
impl std::fmt::Display for CurrentOfExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CustomPath {}
impl std::fmt::Display for CustomPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CustomScan {}
impl std::fmt::Display for CustomScan {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for CustomScanState {}
impl std::fmt::Display for CustomScanState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for DeallocateStmt {}
impl std::fmt::Display for DeallocateStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for DeclareCursorStmt {}
impl std::fmt::Display for DeclareCursorStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for DefElem {}
impl std::fmt::Display for DefElem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for DefineStmt {}
impl std::fmt::Display for DefineStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for DeleteStmt {}
impl std::fmt::Display for DeleteStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for DiscardStmt {}
impl std::fmt::Display for DiscardStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for DoStmt {}
impl std::fmt::Display for DoStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for DomainConstraintState {}
impl std::fmt::Display for DomainConstraintState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for DropOwnedStmt {}
impl std::fmt::Display for DropOwnedStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for DropReplicationSlotCmd {}
impl std::fmt::Display for DropReplicationSlotCmd {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for DropRoleStmt {}
impl std::fmt::Display for DropRoleStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for DropStmt {}
impl std::fmt::Display for DropStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for DropSubscriptionStmt {}
impl std::fmt::Display for DropSubscriptionStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for DropTableSpaceStmt {}
impl std::fmt::Display for DropTableSpaceStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for DropUserMappingStmt {}
impl std::fmt::Display for DropUserMappingStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for DropdbStmt {}
impl std::fmt::Display for DropdbStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for EState {}
impl std::fmt::Display for EState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for EquivalenceClass {}
impl std::fmt::Display for EquivalenceClass {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for EquivalenceMember {}
impl std::fmt::Display for EquivalenceMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for EventTriggerData {}
impl std::fmt::Display for EventTriggerData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ExecuteStmt {}
impl std::fmt::Display for ExecuteStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ExplainStmt {}
impl std::fmt::Display for ExplainStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for Expr {}
impl std::fmt::Display for Expr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ExprContext {}
impl std::fmt::Display for ExprContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ExprState {}
impl std::fmt::Display for ExprState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ExtensibleNode {}
impl std::fmt::Display for ExtensibleNode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for FdwRoutine {}
impl std::fmt::Display for FdwRoutine {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for FetchStmt {}
impl std::fmt::Display for FetchStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for FieldSelect {}
impl std::fmt::Display for FieldSelect {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for FieldStore {}
impl std::fmt::Display for FieldStore {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ForeignKeyCacheInfo {}
impl std::fmt::Display for ForeignKeyCacheInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ForeignKeyOptInfo {}
impl std::fmt::Display for ForeignKeyOptInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ForeignPath {}
impl std::fmt::Display for ForeignPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ForeignScan {}
impl std::fmt::Display for ForeignScan {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ForeignScanState {}
impl std::fmt::Display for ForeignScanState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for FromExpr {}
impl std::fmt::Display for FromExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for FuncCall {}
impl std::fmt::Display for FuncCall {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for FuncExpr {}
impl std::fmt::Display for FuncExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for FunctionParameter {}
impl std::fmt::Display for FunctionParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for FunctionScan {}
impl std::fmt::Display for FunctionScan {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for FunctionScanState {}
impl std::fmt::Display for FunctionScanState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for Gather {}
impl std::fmt::Display for Gather {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for GatherMerge {}
impl std::fmt::Display for GatherMerge {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for GatherMergePath {}
impl std::fmt::Display for GatherMergePath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for GatherMergeState {}
impl std::fmt::Display for GatherMergeState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for GatherPath {}
impl std::fmt::Display for GatherPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for GatherState {}
impl std::fmt::Display for GatherState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for GrantRoleStmt {}
impl std::fmt::Display for GrantRoleStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for GrantStmt {}
impl std::fmt::Display for GrantStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for Group {}
impl std::fmt::Display for Group {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for GroupPath {}
impl std::fmt::Display for GroupPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for GroupResultPath {}
impl std::fmt::Display for GroupResultPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for GroupState {}
impl std::fmt::Display for GroupState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for GroupingFunc {}
impl std::fmt::Display for GroupingFunc {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for GroupingSet {}
impl std::fmt::Display for GroupingSet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for GroupingSetData {}
impl std::fmt::Display for GroupingSetData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for GroupingSetsPath {}
impl std::fmt::Display for GroupingSetsPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for Hash {}
impl std::fmt::Display for Hash {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for HashJoin {}
impl std::fmt::Display for HashJoin {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for HashJoinState {}
impl std::fmt::Display for HashJoinState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for HashPath {}
impl std::fmt::Display for HashPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for HashState {}
impl std::fmt::Display for HashState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for HeapTupleTableSlot {}
impl std::fmt::Display for HeapTupleTableSlot {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for IdentifySystemCmd {}
impl std::fmt::Display for IdentifySystemCmd {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ImportForeignSchemaStmt {}
impl std::fmt::Display for ImportForeignSchemaStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for IncrementalSort {}
impl std::fmt::Display for IncrementalSort {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for IncrementalSortPath {}
impl std::fmt::Display for IncrementalSortPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for IncrementalSortState {}
impl std::fmt::Display for IncrementalSortState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for IndexAmRoutine {}
impl std::fmt::Display for IndexAmRoutine {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for IndexClause {}
impl std::fmt::Display for IndexClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for IndexElem {}
impl std::fmt::Display for IndexElem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for IndexInfo {}
impl std::fmt::Display for IndexInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for IndexOnlyScan {}
impl std::fmt::Display for IndexOnlyScan {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for IndexOnlyScanState {}
impl std::fmt::Display for IndexOnlyScanState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for IndexOptInfo {}
impl std::fmt::Display for IndexOptInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for IndexPath {}
impl std::fmt::Display for IndexPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for IndexScan {}
impl std::fmt::Display for IndexScan {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for IndexScanState {}
impl std::fmt::Display for IndexScanState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for IndexStmt {}
impl std::fmt::Display for IndexStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for InferClause {}
impl std::fmt::Display for InferClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for InferenceElem {}
impl std::fmt::Display for InferenceElem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for InlineCodeBlock {}
impl std::fmt::Display for InlineCodeBlock {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for InsertStmt {}
impl std::fmt::Display for InsertStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for IntoClause {}
impl std::fmt::Display for IntoClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for Join {}
impl std::fmt::Display for Join {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for JoinExpr {}
impl std::fmt::Display for JoinExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for JoinPath {}
impl std::fmt::Display for JoinPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for JoinState {}
impl std::fmt::Display for JoinState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for JunkFilter {}
impl std::fmt::Display for JunkFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for Limit {}
impl std::fmt::Display for Limit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for LimitPath {}
impl std::fmt::Display for LimitPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for LimitState {}
impl std::fmt::Display for LimitState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for List {}
impl std::fmt::Display for List {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ListenStmt {}
impl std::fmt::Display for ListenStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for LoadStmt {}
impl std::fmt::Display for LoadStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for LockRows {}
impl std::fmt::Display for LockRows {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for LockRowsPath {}
impl std::fmt::Display for LockRowsPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for LockRowsState {}
impl std::fmt::Display for LockRowsState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for LockStmt {}
impl std::fmt::Display for LockStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for LockingClause {}
impl std::fmt::Display for LockingClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for Material {}
impl std::fmt::Display for Material {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for MaterialPath {}
impl std::fmt::Display for MaterialPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for MaterialState {}
impl std::fmt::Display for MaterialState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for MemoryContextData {}
impl std::fmt::Display for MemoryContextData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for MergeAppend {}
impl std::fmt::Display for MergeAppend {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for MergeAppendPath {}
impl std::fmt::Display for MergeAppendPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for MergeAppendState {}
impl std::fmt::Display for MergeAppendState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for MergeJoin {}
impl std::fmt::Display for MergeJoin {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for MergeJoinState {}
impl std::fmt::Display for MergeJoinState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for MergePath {}
impl std::fmt::Display for MergePath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for MinMaxAggInfo {}
impl std::fmt::Display for MinMaxAggInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for MinMaxAggPath {}
impl std::fmt::Display for MinMaxAggPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for MinMaxExpr {}
impl std::fmt::Display for MinMaxExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for MinimalTupleTableSlot {}
impl std::fmt::Display for MinimalTupleTableSlot {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ModifyTable {}
impl std::fmt::Display for ModifyTable {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ModifyTablePath {}
impl std::fmt::Display for ModifyTablePath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ModifyTableState {}
impl std::fmt::Display for ModifyTableState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for MultiAssignRef {}
impl std::fmt::Display for MultiAssignRef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for NamedArgExpr {}
impl std::fmt::Display for NamedArgExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for NamedTuplestoreScan {}
impl std::fmt::Display for NamedTuplestoreScan {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for NamedTuplestoreScanState {}
impl std::fmt::Display for NamedTuplestoreScanState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for NestLoop {}
impl std::fmt::Display for NestLoop {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for NestLoopParam {}
impl std::fmt::Display for NestLoopParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for NestLoopState {}
impl std::fmt::Display for NestLoopState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for NextValueExpr {}
impl std::fmt::Display for NextValueExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for Node {}
impl std::fmt::Display for Node {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for NotifyStmt {}
impl std::fmt::Display for NotifyStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for NullTest {}
impl std::fmt::Display for NullTest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ObjectWithArgs {}
impl std::fmt::Display for ObjectWithArgs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for OnConflictClause {}
impl std::fmt::Display for OnConflictClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for OnConflictExpr {}
impl std::fmt::Display for OnConflictExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for OnConflictSetState {}
impl std::fmt::Display for OnConflictSetState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for OpExpr {}
impl std::fmt::Display for OpExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for Param {}
impl std::fmt::Display for Param {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ParamPathInfo {}
impl std::fmt::Display for ParamPathInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ParamRef {}
impl std::fmt::Display for ParamRef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for PartitionBoundSpec {}
impl std::fmt::Display for PartitionBoundSpec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for PartitionCmd {}
impl std::fmt::Display for PartitionCmd {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for PartitionElem {}
impl std::fmt::Display for PartitionElem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for PartitionPruneInfo {}
impl std::fmt::Display for PartitionPruneInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for PartitionPruneStep {}
impl std::fmt::Display for PartitionPruneStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for PartitionPruneStepCombine {}
impl std::fmt::Display for PartitionPruneStepCombine {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for PartitionPruneStepOp {}
impl std::fmt::Display for PartitionPruneStepOp {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for PartitionRangeDatum {}
impl std::fmt::Display for PartitionRangeDatum {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for PartitionSpec {}
impl std::fmt::Display for PartitionSpec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for PartitionedRelPruneInfo {}
impl std::fmt::Display for PartitionedRelPruneInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for Path {}
impl std::fmt::Display for Path {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for PathKey {}
impl std::fmt::Display for PathKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for PathTarget {}
impl std::fmt::Display for PathTarget {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for PlaceHolderInfo {}
impl std::fmt::Display for PlaceHolderInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for PlaceHolderVar {}
impl std::fmt::Display for PlaceHolderVar {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for Plan {}
impl std::fmt::Display for Plan {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for PlanInvalItem {}
impl std::fmt::Display for PlanInvalItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for PlanRowMark {}
impl std::fmt::Display for PlanRowMark {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for PlanState {}
impl std::fmt::Display for PlanState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for PlannedStmt {}
impl std::fmt::Display for PlannedStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for PlannerGlobal {}
impl std::fmt::Display for PlannerGlobal {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for PlannerInfo {}
impl std::fmt::Display for PlannerInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for PlannerParamItem {}
impl std::fmt::Display for PlannerParamItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for PrepareStmt {}
impl std::fmt::Display for PrepareStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ProjectSet {}
impl std::fmt::Display for ProjectSet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ProjectSetPath {}
impl std::fmt::Display for ProjectSetPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ProjectSetState {}
impl std::fmt::Display for ProjectSetState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ProjectionInfo {}
impl std::fmt::Display for ProjectionInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ProjectionPath {}
impl std::fmt::Display for ProjectionPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for Query {}
impl std::fmt::Display for Query {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for RangeFunction {}
impl std::fmt::Display for RangeFunction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for RangeSubselect {}
impl std::fmt::Display for RangeSubselect {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for RangeTableFunc {}
impl std::fmt::Display for RangeTableFunc {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for RangeTableFuncCol {}
impl std::fmt::Display for RangeTableFuncCol {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for RangeTableSample {}
impl std::fmt::Display for RangeTableSample {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for RangeTblEntry {}
impl std::fmt::Display for RangeTblEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for RangeTblFunction {}
impl std::fmt::Display for RangeTblFunction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for RangeTblRef {}
impl std::fmt::Display for RangeTblRef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for RangeVar {}
impl std::fmt::Display for RangeVar {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for RawStmt {}
impl std::fmt::Display for RawStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ReassignOwnedStmt {}
impl std::fmt::Display for ReassignOwnedStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for RecursiveUnion {}
impl std::fmt::Display for RecursiveUnion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for RecursiveUnionPath {}
impl std::fmt::Display for RecursiveUnionPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for RecursiveUnionState {}
impl std::fmt::Display for RecursiveUnionState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for RefreshMatViewStmt {}
impl std::fmt::Display for RefreshMatViewStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ReindexStmt {}
impl std::fmt::Display for ReindexStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for RelOptInfo {}
impl std::fmt::Display for RelOptInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for RelabelType {}
impl std::fmt::Display for RelabelType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for RenameStmt {}
impl std::fmt::Display for RenameStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ReplicaIdentityStmt {}
impl std::fmt::Display for ReplicaIdentityStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ResTarget {}
impl std::fmt::Display for ResTarget {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for RestrictInfo {}
impl std::fmt::Display for RestrictInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for Result {}
impl std::fmt::Display for Result {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ResultRelInfo {}
impl std::fmt::Display for ResultRelInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ResultState {}
impl std::fmt::Display for ResultState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ReturnSetInfo {}
impl std::fmt::Display for ReturnSetInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for RoleSpec {}
impl std::fmt::Display for RoleSpec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for RollupData {}
impl std::fmt::Display for RollupData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for RowCompareExpr {}
impl std::fmt::Display for RowCompareExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for RowExpr {}
impl std::fmt::Display for RowExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for RowMarkClause {}
impl std::fmt::Display for RowMarkClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for RuleStmt {}
impl std::fmt::Display for RuleStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for SQLCmd {}
impl std::fmt::Display for SQLCmd {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for SQLValueFunction {}
impl std::fmt::Display for SQLValueFunction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for SampleScan {}
impl std::fmt::Display for SampleScan {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for SampleScanState {}
impl std::fmt::Display for SampleScanState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ScalarArrayOpExpr {}
impl std::fmt::Display for ScalarArrayOpExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for Scan {}
impl std::fmt::Display for Scan {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ScanState {}
impl std::fmt::Display for ScanState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for SecLabelStmt {}
impl std::fmt::Display for SecLabelStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for SelectStmt {}
impl std::fmt::Display for SelectStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for SeqScanState {}
impl std::fmt::Display for SeqScanState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for SetExprState {}
impl std::fmt::Display for SetExprState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for SetOp {}
impl std::fmt::Display for SetOp {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for SetOpPath {}
impl std::fmt::Display for SetOpPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for SetOpState {}
impl std::fmt::Display for SetOpState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for SetOperationStmt {}
impl std::fmt::Display for SetOperationStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for SetToDefault {}
impl std::fmt::Display for SetToDefault {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for Sort {}
impl std::fmt::Display for Sort {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for SortBy {}
impl std::fmt::Display for SortBy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for SortGroupClause {}
impl std::fmt::Display for SortGroupClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for SortPath {}
impl std::fmt::Display for SortPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for SortState {}
impl std::fmt::Display for SortState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for SpecialJoinInfo {}
impl std::fmt::Display for SpecialJoinInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for StartReplicationCmd {}
impl std::fmt::Display for StartReplicationCmd {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for StatisticExtInfo {}
impl std::fmt::Display for StatisticExtInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for SubLink {}
impl std::fmt::Display for SubLink {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for SubPlan {}
impl std::fmt::Display for SubPlan {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for SubPlanState {}
impl std::fmt::Display for SubPlanState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for SubqueryScan {}
impl std::fmt::Display for SubqueryScan {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for SubqueryScanPath {}
impl std::fmt::Display for SubqueryScanPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for SubqueryScanState {}
impl std::fmt::Display for SubqueryScanState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for SubscriptingRef {}
impl std::fmt::Display for SubscriptingRef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for SupportRequestCost {}
impl std::fmt::Display for SupportRequestCost {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for SupportRequestIndexCondition {}
impl std::fmt::Display for SupportRequestIndexCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for SupportRequestRows {}
impl std::fmt::Display for SupportRequestRows {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for SupportRequestSelectivity {}
impl std::fmt::Display for SupportRequestSelectivity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for SupportRequestSimplify {}
impl std::fmt::Display for SupportRequestSimplify {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for TableAmRoutine {}
impl std::fmt::Display for TableAmRoutine {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for TableFunc {}
impl std::fmt::Display for TableFunc {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for TableFuncScan {}
impl std::fmt::Display for TableFuncScan {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for TableFuncScanState {}
impl std::fmt::Display for TableFuncScanState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for TableLikeClause {}
impl std::fmt::Display for TableLikeClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for TableSampleClause {}
impl std::fmt::Display for TableSampleClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for TargetEntry {}
impl std::fmt::Display for TargetEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for TidPath {}
impl std::fmt::Display for TidPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for TidScan {}
impl std::fmt::Display for TidScan {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for TidScanState {}
impl std::fmt::Display for TidScanState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for TimeLineHistoryCmd {}
impl std::fmt::Display for TimeLineHistoryCmd {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for TransactionStmt {}
impl std::fmt::Display for TransactionStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for TriggerData {}
impl std::fmt::Display for TriggerData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for TriggerTransition {}
impl std::fmt::Display for TriggerTransition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for TruncateStmt {}
impl std::fmt::Display for TruncateStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for TupleTableSlot {}
impl std::fmt::Display for TupleTableSlot {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for TypeCast {}
impl std::fmt::Display for TypeCast {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for TypeName {}
impl std::fmt::Display for TypeName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for Unique {}
impl std::fmt::Display for Unique {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for UniquePath {}
impl std::fmt::Display for UniquePath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for UniqueState {}
impl std::fmt::Display for UniqueState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for UnlistenStmt {}
impl std::fmt::Display for UnlistenStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for UpdateStmt {}
impl std::fmt::Display for UpdateStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for UpperUniquePath {}
impl std::fmt::Display for UpperUniquePath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for VacuumRelation {}
impl std::fmt::Display for VacuumRelation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for VacuumStmt {}
impl std::fmt::Display for VacuumStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for Value {}
impl std::fmt::Display for Value {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ValuesScan {}
impl std::fmt::Display for ValuesScan {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ValuesScanState {}
impl std::fmt::Display for ValuesScanState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for Var {}
impl std::fmt::Display for Var {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for VariableSetStmt {}
impl std::fmt::Display for VariableSetStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for VariableShowStmt {}
impl std::fmt::Display for VariableShowStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for ViewStmt {}
impl std::fmt::Display for ViewStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for VirtualTupleTableSlot {}
impl std::fmt::Display for VirtualTupleTableSlot {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for WindowAgg {}
impl std::fmt::Display for WindowAgg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for WindowAggPath {}
impl std::fmt::Display for WindowAggPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for WindowAggState {}
impl std::fmt::Display for WindowAggState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for WindowClause {}
impl std::fmt::Display for WindowClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for WindowDef {}
impl std::fmt::Display for WindowDef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for WindowFunc {}
impl std::fmt::Display for WindowFunc {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for WindowFuncExprState {}
impl std::fmt::Display for WindowFuncExprState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for WithCheckOption {}
impl std::fmt::Display for WithCheckOption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for WithClause {}
impl std::fmt::Display for WithClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for WorkTableScan {}
impl std::fmt::Display for WorkTableScan {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for WorkTableScanState {}
impl std::fmt::Display for WorkTableScanState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for XmlExpr {}
impl std::fmt::Display for XmlExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
impl pg_sys::PgNode for XmlSerialize {}
impl std::fmt::Display for XmlSerialize {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.display_node())
    }
}
